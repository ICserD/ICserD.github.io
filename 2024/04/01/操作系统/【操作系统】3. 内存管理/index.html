<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内存管理 | nullptr</title><meta name="author" content="Icserm"><meta name="copyright" content="Icserm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存的基本概念  存储单元：存储数据的基本单元。要看内存是如何编址的，如果是按字节，则为1B&#x3D;8Bit，如果是按字的话，就要看具体PC的字长是多少。  指令的工作原理 区分逻辑地址和物理地址！ 程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址； 观察下面的例子，第一条指令是往地址79号存储单元写入10，但是由于系统给他分配的物理地址是从100开始的，">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="http://example.com/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:description" content="内存的基本概念  存储单元：存储数据的基本单元。要看内存是如何编址的，如果是按字节，则为1B&#x3D;8Bit，如果是按字的话，就要看具体PC的字长是多少。  指令的工作原理 区分逻辑地址和物理地址！ 程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址），即：相对于进程的起始地址而言的地址； 观察下面的例子，第一条指令是往地址79号存储单元写入10，但是由于系统给他分配的物理地址是从100开始的，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/self_img/head_img.jpg">
<meta property="article:published_time" content="2024-04-01T04:00:00.000Z">
<meta property="article:modified_time" content="2024-04-01T04:00:00.000Z">
<meta property="article:author" content="Icserm">
<meta property="article:tag" content="课程学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/self_img/head_img.jpg"><link rel="shortcut icon" href="/self_img/bollon.png"><link rel="canonical" href="http://example.com/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 12:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="onerror=null;src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/self_img/11c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="nullptr"><span class="site-name">nullptr</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-01T04:00:00.000Z" title="发表于 2024-04-01 12:00:00">2024-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-01T04:00:00.000Z" title="更新于 2024-04-01 12:00:00">2024-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>内存的基本概念</h1>
<ol>
<li>存储单元：存储数据的基本单元。要看内存是如何编址的，如果是按字节，则为1B=8Bit，如果是按字的话，就要看具体PC的字长是多少。</li>
</ol>
<h2 id="指令的工作原理">指令的工作原理</h2>
<p>区分逻辑地址和物理地址！<br>
<strong>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址）</strong>，即：相对于进程的起始地址而言的地址；<br>
观察下面的例子，第一条指令是往地址79号存储单元写入10，但是由于系统给他分配的物理地址是从100开始的，如果写入前面的79，则很有可能会写入其他进程的内存空间。这是很危险的行为。<br>
而实际上，指令中的地址是逻辑地址，相对于进程的起始地址100偏移79个的存储单元写入10，所以会在物理地址179号寄存器写入数据。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417160405.png" alt="Pasted image 20240417160405"></p>
<h3 id="如何将指令中的逻辑地址转换为物理地址">如何将指令中的逻辑地址转换为物理地址</h3>
<h4 id="绝对装入">绝对装入</h4>
<p>在编译时，如果知道程序将放入内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br>
就如前面的例子，如果在可执行文件装入内存中之前，就知道该可执行程序装入内存的地址为100，则在装入之前就可以把逻辑地址转换为绝对地址装入。<br>
<strong>绝对装入只适用于单道程序</strong></p>
<h4 id="可重定位装入">可重定位装入</h4>
<p>又称可重定位装入。编译、链接后装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的合适为止，<strong>装入时对地址进行“重定位”</strong>， 将逻辑地址转变为物理地址（地址变换是在装入时一次完成的）<br>
<strong>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。在运行期间就不能再移动。</strong></p>
<h4 id="动态重定位">动态重定位</h4>
<p>动态运行时装入。编译、链接后的装入模块地址都是从0开始的。装入程序把装入模块装入内存之后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行的时候才进行</strong>。因此装入内存后的所有地址依然是逻辑地址。<br>
这种方式需要一个<strong>重定位寄存器</strong>来支持。<br>
比如下图，重定位寄存器存放装入模块的起始地址；当程序直行到指令0的时候，需要往逻辑地址79号存储单元写入数据10；则这时候才进行逻辑地址到物理地址的转换，即79+100=179，然后往物理地址179号存储单元写入数据10。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417161642.png" alt="Pasted image 20240417161642"><br>
优点（学完虚拟内存之后可能会更加清楚）：</p>
<ol>
<li>允许程序在内存中发生移动（修改重定位寄存器的值就行）；</li>
<li>可以将程序分配到不连续的存储区中，在程序运行前只需要装入它的部分代码即可投入运行， 然后在程序运行期间，根据需要动态申请分配内存；</li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大的多的地址空间；</li>
</ol>
<h3 id="从写程序到程序运行的流程">从写程序到程序运行的流程</h3>
<p>装入模块中存放的是完整的逻辑地址，存放到内存里之后，按照上面提到的三种装入策略装入，最后执行的时候访问的还是物理地址。</p>
<ul>
<li>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译成机器语言的过程）</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块</li>
<li>装载/装入：由装入程序将装入模块装入内存运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">subgraph *.c</span><br><span class="line">	direction TB</span><br><span class="line">	1[&quot;源代码文件1&quot;] &amp; 2[&quot;源代码文件2&quot;] &amp; 3[&quot;源代码文件3&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph *.o</span><br><span class="line">	direction TB</span><br><span class="line">	4[&quot;目标模块1&quot;] &amp; 5[&quot;目标模块2&quot;] &amp; 6[&quot;目标模块3&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph *.exe</span><br><span class="line">	direction TB</span><br><span class="line">	7[&quot;装入模块&quot;]</span><br><span class="line">end</span><br><span class="line">程序员 --编辑--&gt; *.c --编译--&gt; *.o  --链接--&gt; *.exe --装入--&gt; 8[&quot;内存&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="链接的三种方式">链接的三种方式</h3>
<h4 id="静态链接">静态链接</h4>
<p>在程序运行之前，先将各个目标模块以及他们所需要的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。<br>
也就是说，在形成装入模块之后，逻辑地址已经形成，不再改变。</p>
<h4 id="装入时动态链接">装入时动态链接</h4>
<p><strong>将各个目标模块装入内存时</strong>，边装入边链接的方式；<br>
这种方式的完整的逻辑地址是一边装入，一边形成的。</p>
<h4 id="运行时动态链接">运行时动态链接</h4>
<p><strong>在程序执行中需要该目标模块时</strong>，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。<br>
用不到的模块不用装入内存。<br>
这种方式内存利用率高，而且更灵活。</p>
<h1>内存管理的概念</h1>
<p>操作系统作为系统资源的管理者，需要对内存进行管理，需要进行管理什么呢？</p>
<ol>
<li>操作系统负责内存空间的分配与回收</li>
<li>需要提供某种技术，从逻辑上对内存空间进行扩充</li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换（3种装入方式）</li>
<li>操作系统需要提供内存保护功能。保证各个进程在各自存储空间内运行，互不干扰<br>
内存保护的两种方法：
<ol>
<li>采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址，<strong>界地址寄存器中存放的是最大逻辑地址</strong>；</li>
<li>在CPU中设置一对上下限寄存器，存放进程的上限、下限地址。进程指令要访问某个地址时，CPU检查是否越界；<br>
区别：<br>
方法一：在进程想要访问某一内存单元时，CPU先将进程的逻辑地址与界地址寄存器的逻辑地址进行对比，如果不超过界地址寄存器的逻辑地址，则与基地址寄存器的地址进行相加得到物理地址，允许进程访问相应的内存空间；<br>
方法二：在进程想要访问某一内存单元时，CPU会将进程的内存单元的逻辑地址先转换成物理地址，检查该物理地址是否在上下限地址寄存器之间，如果在上下限地址寄存器存放的物理地址之间，那么才允许进程访问内存空间；</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存管理的概念 --&gt; 内存的分配与回收 &amp; 内存空间的扩充 &amp; 地址转换 &amp; 存储保护</span><br><span class="line">内存的分配与回收 --&gt; 连续分配管理方式 &amp; 非连续分配管理方式</span><br><span class="line">内存空间的扩充 --&gt; 覆盖技术 &amp; 交换技术 &amp; 虚拟存储技术</span><br></pre></td></tr></table></figure>
<h2 id="内存的分配与回收">内存的分配与回收</h2>
<p>连续分配与非连续分配的区别是：是否为用户进程分配一段连续的内存空间；</p>
<h3 id="连续分配管理方式">连续分配管理方式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">连续分配管理方式 --&gt; 单一连续分配 &amp; 固定连续分配 &amp; 动态连续分配</span><br></pre></td></tr></table></figure>
<h4 id="单一连续分配">单一连续分配</h4>
<p>在单一连续分配方式中，内存被分为系统区和用户区。<br>
系统区通常位于内存的地地址部分，用于存放操作系统的相关数据；用户区用于存放用户进程相关数据。<br>
内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502171744.png" alt="Pasted image 20240502171744"></p>
<h4 id="固定分区分配">固定分区分配</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">固定分区分配 --&gt; 分区大小相同 &amp; 分区大小不同</span><br></pre></td></tr></table></figure>
<p>为了同时载入多道程序，后续发展出了固定分区分配的内存分配方式；<br>
即把内存的用户区分层若干个固定的分区，根据分区大小是否相同又衍生出分区大小相同的固定分区分配方式和分区大小不同的固定分区分配方式；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502173400.png" alt="Pasted image 20240502173400"><br>
分区大小相同：</p>
<ul>
<li>缺乏灵活性</li>
<li>适用于<strong>一个计算机控制多个相同的对象的场合</strong><br>
分区大小不同：</li>
<li>增加灵活性</li>
<li>满足不同大小进程的需求</li>
</ul>
<h4 id="分区大小不同的内存管理">分区大小不同的内存管理</h4>
<p>建立一个分区说明表，记录不同分区大小的起始地址、终止地址、是否被分配等信息，便于操作系统对某一个进程进行载入时选择合适的分区进行载入；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502173643.png" alt="Pasted image 20240502173643"></p>
<h4 id="动态分区分配">动态分区分配</h4>
<p>这种分配方式不会预先把用户区内存分块，而是在进程需要载入的时候根据进程的大小为进程分配一块大小刚好合适的内存空间；<br>
<strong>动态分区分的内存管理</strong>：需要建立一个空闲分区表/空闲分区链，记录每一块空闲区的信息（分区号、起始地址、内存大小、分配状态等）来管理空闲区；<br>
<strong>内存分配方法</strong>：当多个空闲区都能满足进程的大小时，系统通过动态分区分配算法决定选择哪一块空闲区进行内存分配；<br>
<strong>分区的分配与回收操作</strong>：物理上执行分配，逻辑上在对应的空闲分配区/表记录新的空闲区的内容；</p>
<h4 id="碎片的概念">碎片的概念</h4>
<ol>
<li>内部碎片：<br>
分配给某个进程的内存区域内，该进程并不需要用到这么多内存，所以这部分多出的内存没有被利用但是被分配给了该进程；这部分没被进程利用的内存称为内部碎片；</li>
<li>外部碎片：<br>
内存中某些空闲区由于太小而难以利用；<br>
有时可以通过紧凑的方式，将已经使用的内存区合并，增大空闲区的连续空间大小；</li>
</ol>
<h2 id="动态分区分配算法">动态分区分配算法</h2>
<p>在动态分区分配方式中，当有很多个空闲区满足进程的内存分配要求时，操作系统应该如何选择空闲区进行内存分配？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">动态分区分配算法 --&gt; 1(&quot;`首次适应算法（First Fit）`&quot;) &amp; 2(&quot;`最佳适应算法（Best Fit）`&quot;) &amp; 3(&quot;`最坏适应算法（Worst Fit）`&quot;) &amp; 4(&quot;`邻近适应算法（Next Fit）`&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="不同分配算法的对比介绍">不同分配算法的对比介绍</h4>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>首次适应算法</td>
<td>每次从低地址开始查找空闲区，一旦找到合适的空闲区，则把该空闲区分配给进程；</td>
<td>以<strong>地址</strong>递增的次序排列</td>
<td>综合性能最好，<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区进行重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应算法</td>
<td>将所有空闲分区按从小到大排序，每次分配从头到尾查找匹配的空闲区，遇到<strong>能够满足进程空间的最小空闲区</strong>就进行分配；（<strong>优先使用更小的分区，以保留更大的分区</strong>）</td>
<td>按照<strong>空闲区容量</strong>从小到大排序</td>
<td>会有更大的空闲区被保留下来，能够满足大进程的需求</td>
<td>1. 算法开销大；<br>2. <strong>会产生很多太小的、难以利用的空间</strong></td>
</tr>
<tr>
<td>最坏适应算法</td>
<td>将所有空闲分区从大到小排序，每次分配从最大的空闲区开始分配，这样能避免产生<strong>外部碎片</strong>；</td>
<td>按照空闲区容量从大到校排序</td>
<td>减少外部碎片的产生</td>
<td>1. 算法开销大；<br>2. 会导致大分区很快被利用完，不利于大进程；</td>
</tr>
<tr>
<td>邻近适应算法</td>
<td>由首次适应算法演变而来，每次从上次查找结束为止开始查找；</td>
<td>以地址递增的次序排列（可以排列成循环链表）</td>
<td>算法开销小；<br>不用每次都从低地址空间开始检索；</td>
<td>会使高地址的大分区也会被用完；</td>
</tr>
</tbody>
</table>
<h2 id="非连续分配管理方式">非连续分配管理方式</h2>
<p>与连续分配方式不同的是，非连续分配方式为用户进程分配的是分散的内存空间；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">非连续分配管理方式 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 段页式存储管理</span><br></pre></td></tr></table></figure>
<h3 id="基本分页存储管理">基本分页存储管理</h3>
<h4 id="分页存储">分页存储</h4>
<p>把内存分成一个个大小相等的分区（比如每个分区4KB），每个分区就是一个页框(Page Frame)（页框=页帧=内存块=物理块=物理页面）；<br>
系统会将内存的每一个物理区域分成一个个大小相等的页框，每个页框有一个编号，也称为“页框号”（页框号=页帧号=内存块号=物理页号）；页框号从0开始；<br>
<strong>如何基于这样的内存存储结构对一个用户进程进行内存分配？</strong><br>
在每一个用户进程创建时，在PCB（进程控制块）中建立一个页表；<br>
在页表中，对用户进程所需要的空间（逻辑地址空间）按照页框大小进行分组，假设分为n块，每一块称为一个页面/页，每个页/页面都有一个页号/页面号，页表中记录0~n-1个页面号到页框号的映射关系；<br>
由于用户进程的逻辑地址在每一个组中都是连续存放的，所以页面号是隐含的，所以每一个页表项实际上就是记录页框号；<br>
<strong>例子</strong>：假设有4GB的内存，页框大小为4KB，则每个页表项至少应该是多少个字节？<br>
解：$$\displaylines{\because 页框=4KB\<br>
\therefore 内存块数n=4GB/4KB=2^{32}B/2^{12}B=2^{20}个 \<br>
\therefore 内存块编号范围/页框号范围:0-2^{20}-1 \<br>
\because 每一个页表项只用存放的是页框号，页号隐含 \<br>
\therefore 每一个页表项至少为20个比特，至少需要3个字节，也就是3B \<br>
\therefore 进一步地，该页表需要3*(n+1)B来存放<br>
}$$<br>
<strong>例子进阶</strong>：如何找到每一个页表项对应的页号？<br>
解：$$\displaylines{首先我们需要知道页表项的第一项页框号是什么（由于在页内是连续存放的）\<br>
假设页表项第一项的页框号是X，则X对应的是0页号;\<br>
于是页号i对应的页框号为X+3*i}$$<br>
<strong>注意：</strong></p>
<ol>
<li>页表中存放的是页框号J，而不是页框的物理起始地址adr；</li>
<li>要计算该页框号对应的物理起始地址，应该为adr = J*页框大小</li>
</ol>
<h4 id="确定进程逻辑地址到内存物理地址的转换">确定进程逻辑地址到内存物理地址的转换</h4>
<p><strong>例题</strong>：某计算机系统中，页面大小是50B，某进程逻辑地址空间大小为200B，则逻辑地址110对应的页号、页内偏移量是多少？内存地址起始地址是多少？内存实际地址是多少？<br>
解：$$\displaylines{依据题意，页号范围为0-200B/50B，即0-4，每一个页号存一个页框号\<br>
\therefore 逻辑地址为110的页号为110/50=2（取整，因为页号从0开始）\<br>
页内偏移量为110%50=10 \<br>
\therefore 可以根据页号3查询对应的页框号，根据页框号计算该页框的内存起始地址\<br>
然后再加上页内偏移量，即可算出该逻辑地址对应的内存物理地址\<br>
\therefore 物理地址=页框号对应的内存起始地址+页内偏移地址}$$<br>
<strong>小结</strong>：</p>
<ol>
<li>页号=逻辑地址/页面长度（取整）</li>
<li>页内偏移量=逻辑地址%页面长度</li>
<li>如果页面大小设计为2的整数幂，则可以快速把逻辑地址拆成页号和页内偏移量
<ul>
<li>如果每个页面大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则用二进制表示逻辑地址，低k位表示页内偏移量，其余位数表示页号；</li>
<li>页表中记录的页号与页内偏移量进行二进制拼接即可得到物理地址，不需要再页号*页面大小来得到起始地址，因为刚好一致；（看下面第二个例子）<br>
具体看下面两个例子：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502235407.png" alt="Pasted image 20240502235407"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240503000409.png" alt="Pasted image 20240503000409"></li>
</ul>
</li>
</ol>
<h4 id="基本地址变换机构">基本地址变换机构</h4>
<p>在基本分页存储管理的内存分配方式中，通过基本地址变换机构来实现逻辑地址到物理地址的转换；<br>
基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构；<br>
<strong>工作原理</strong>：<br>
回顾程序的从编辑到执行的过程，程序写好后会被编译、链接，形成机器指令，机器指令中所涉及到的地址（比如将某个常数写入某个内存地址）都是逻辑地址；<br>
所以程序需要执行的时候，会对该程序建立一个进程载入内存（进程由程序段、数据段和PCB组成），在进程的程序段中，所涉及到的机器指令是逻辑地址，所以当程序执行到某个机器指令时，需要把其中涉及到的逻辑地址转换成物理地址进行访存操作；</p>
<ol>
<li>从进程中获取待访问的内存的逻辑地址；（进程在内存中，所以这一步操作是访问内存的）</li>
<li>根据进程中记录的逻辑地址，计算出页号和页内偏移量；</li>
<li>在进程的PCB中，有一个页表寄存器（PTR），记录该进程的页表的起始地址（第一个存放的内存块号）以及页表长度；</li>
<li>根据页号与页表长度进行对比，如果页号小于或者等于<strong>页表长度-1</strong>（页表长度从1开始），则没有越界，否则发生越界中断；</li>
<li>根据页表始址和页号，计算页表中该页号存放的页框号（内存块号）；<br>
计算公式：页框号=页表始址+页号*页框大小</li>
<li>根据页框号*页框大小+页内偏移量得到对应的内存物理地址；<br>
<strong>注意</strong>：</li>
</ol>
<ul>
<li>页式管理中，地址是一维的，只要给出一个逻辑地址，就能计算出页号和页内偏移量；</li>
<li>页内偏移量占多少位，等价于页框大小占多少位</li>
</ul>
<h4 id="具有快表的地址变换机构">具有快表的地址变换机构</h4>
<p>快表，又称联想寄存器（TLB，translation lookaside buffer），是一种访问速度比内存块很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加快地址变换的速度。与此对应，内存中的页表常称为慢表。<br>
<strong>快表的作用</strong>：<br>
基于<strong>局部性原理</strong>，将最近在内存中访问的内存块号（页框号）存入缓存区的快表中；提高快表命中要访问的内存块号的概率，一般来说快表的命中率可以达到90%以上；<br>
快表的访问要比访问内存要快很多，这样就可以使得平均访存速度大大提升！<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240503191123.png" alt="Pasted image 20240503191123"><br>
<strong>引入快表后地址变换过程</strong>：</p>
<ol>
<li>CPU给出逻辑地址，由某个硬件计算出页号、页内偏移量，根据页表寄存器中的页表长度与页号对比，检查是否越界，越界则产生越界中断；</li>
<li>没有越界则将页号与快表中所有页号进行比较查找；如果找到匹配的页号，说明要访问的页表项在快表中有副本，直接从快表中取出内存块号，再将内存块号和页内偏移量拼接成物理地址，然后根据物理地址对内存进行访问；（<strong>这个过程只需要一次内存访问</strong>）</li>
<li>如果没有找到匹配的页号，则说明快表中没有存放要访问的页号的副本；于是需要访问存储在该进程PCB中的页表（在内存中），找到对应的页号取出内存块号，拼接计算出物理地址再进行访存；（<strong>这个过程需要两次内存访问</strong>）<br>
<strong>注意</strong>：在找到页表项之后，应该同时将页表项的副本载入快表中，以便后续可能再次访问该页表项；若快表已满，则需要按照一定的算法对快表中的页表项进行替换；</li>
</ol>
<h4 id="局部性原理">局部性原理</h4>
<p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久后该数据很有可能再次被访问。（因为程序中存在大量的循环）<br>
<strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p>
<h3 id="两级页表">两级页表</h3>
<h4 id="单级页表存在的问题">单级页表存在的问题</h4>
<p>假设某计算机系统按字节寻址，支持32位逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B；试分析如果采用单级页表存储会有什么不足之处？<br>
分析：$$\displaylines{因为页面大小是4KB，所以页内偏移地址是12位的\<br>
因为内存是2^{32}大小的，所以一个页表最多有2^{32}/2^{12}=2^{20}个页面\<br>
也就是会有2^{20}个页表项\<br>
所以一个页表的存储空间为4B*2^{20}=2^{22}B的连续内存空间存放\<br>
由于内存空间是分页存储，一个页框大小为4KB \<br>
所以一个页表需要占用连续的2^{22}B/2^{12}=2^{10}个页框<br>
}$$<br>
由上述分析可见，采用<strong>单级页表的两个问题</strong>：</p>
<ol>
<li>一个进程的创建，光页表就需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个连续的页框存放，这意味着系统需要提供很多个连续的页框以满足多个进程的需要，这显然已经丧失了离散式存储管理的优点；（多级页表解决）</li>
<li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没必要让整个页表都常驻内存；（虚拟存储技术解决）<br>
<strong>注意</strong>：<br>
页表项的长度为什么是4B？<br>
分析：$$\displaylines{4B是4个字节的意思\<br>
页表项需要存储页框号，页框号的个数决定了页表项的长度\<br>
由上面分析可知页框号的个数是2^{20}个，所以需要20位的数据来表示\<br>
所以页表项长度应该是20位比特，但是由于该计算机按照字节编址\<br>
1字节=8位，所以至少需要3个字节来存储，所以页表项长度最小为3B\<br>
为了计算机计算方便，我们应该把页表项表示为2的整数幂大小\<br>
所以设置页表项长度为4个字节<br>
}$$</li>
</ol>
<h4 id="多级页表">多级页表</h4>
<p>参照解决连续型存储管理的思路，我们也将页表进行分组，使得每一个内存块刚好可以放入一个分组；（这里对比单级页表，每一个页表项存储的是内存块号而不是内存块）<br>
比如：<br>
按照上面的例子，一个页表有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个页表项（每个页表项存储的是内存块号），一个页面/内存块/页框大小/页内偏移量/页面大小是4KB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{12}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，一个页表项大小是4B，所以一个页面存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页表项；(页面号是隐含的)<br>
我们将页表按照页面大小分组（每一个页面刚好能放下一个内存块），然后将每一个分组离散地存储在内存中即可，这样就避免了页表过大的问题；<br>
为了实现页表逻辑上的连续，为离散分配的页面再建立一张页表，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>/<strong>顶层页表</strong>；<br>
我们每一个页面建立一个二级页表，离散的存放在内存中，二级页表中存放对应的内存块号；<br>
分组之后，一个<strong>页目录表</strong>存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个<strong>二级页表所存放的内存号</strong>（页面号隐含），相比于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>就大大减少了对连续空间的需求；</p>
<h4 id="多级页表的地址结构">多级页表的地址结构</h4>
<p>由于在多级页表中，页表结构发生变化，所以页表地址结构也相应发生变化；<br>
比如上面的例子：<br>
二级页表（页面页表）需要记录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页表项（内存块号），所以需要10位的地址；<br>
顶层页表（一级页表）需要记录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个二级页表存放的内存块号，所以需要10位地址；<br>
每一个内存块被分为4KB，也就是页框大小为4KB，需要12位地址；<br>
于是在32位机中，地址结构如下：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504000908.png" alt="Pasted image 20240504000908"></p>
<h4 id="多级页表的地址变换">多级页表的地址变换</h4>
<p>例题：将逻辑地址（0000000000, 0000000001, 111111111111）转换为物理地址（十进制表示）</p>
<ol>
<li>按照地址结构将逻辑地址拆分为三部分；</li>
<li>第一部分（一级页号）：0，表示二级页表存放在内存块号0的地方；<br>
于是从内存块号0访问出相应的二级页表；</li>
<li>第二部分（二级页号）：1，表示二级页表中的1号页表项，于是得到二级页表的1号页表项存放的内存块号；</li>
<li>第三部分（页内偏移量）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{12}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，根据二级页表的内存块号，以及页内偏移量，拼接成相应的内存的物理地址，然后根据该物理地址在内存中访问存储的数据；</li>
</ol>
<h4 id="需要注意的细节">需要注意的细节</h4>
<ol>
<li>若采用多级页表机制，则各级页表的大小不能超过一个页面：<br>
<strong>例题：</strong> 若某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则需要采用多少级页表？页内偏移量是多少？<br>
分析： $$\displaylines{由于一个页面大小为4KB，所以页内偏移量为2^{12}个，即12位\<br>
由于是40位逻辑地址，低12位用于表示页内偏移量，所以剩余28位可以用于表示页号\<br>
\because 各级页表大小不能超过一个页面  \<br>
在这个例子中，一个页面大小为2^{12}B/2^2B=2^{10} \<br>
\therefore 一个页面为10位，各级页表最多为10位 \<br>
\therefore 40位的逻辑地址，可以分为：1级页号8位，2级页号10位，3级页号10位\<br>
剩余12位为页内偏移量<br>
}$$</li>
<li>两级页表的访存次数分析（假设没有快表机制）：
<ul>
<li>第一次访存：访问内存中的页目录表</li>
<li>第二次访存：访问内存中的二级页表</li>
<li>第三次访存：访问目标内存单元</li>
</ul>
</li>
</ol>
<h3 id="基本分段存储管理方式">基本分段存储管理方式</h3>
<p>基本分段存储管理方式，是按照程序自身的逻辑将逻辑地址划分为若干个连续的地址，对应不同的连续的内存空间；每个段都有一个段名（低级语言中，程序员使用段名来编程），每段从0开始编址。<br>
<strong>内存分配原则</strong>：以段为单位进行分配，每个段在内存中占据着连续的空间，但各个段之间可以不相邻；<br>
<strong>分段优点</strong>：按照程序的逻辑功能划分，用户编程更加方便，程序可读性更高；</p>
<h4 id="分段系统的逻辑地址结构">分段系统的逻辑地址结构</h4>
<p>段号的位数决定了每个进程最多分几个段，段内地址的位数决定了每个段的最大长度是多少；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504182127.png" alt="Pasted image 20240504182127"></p>
<h4 id="段表">段表</h4>
<p>进程如何访问各个段实现程序逻辑上的连续？和页式存储的方式一致，建立一个段表。段表记录了每一个段的段号（隐含），以及每一个<strong>段在内存中的起始地址</strong>，并且还需要记录每一个<strong>段的长度</strong>（因为段长不固定）；<br>
由于每一个段表项使用相同大小的内存空间存储，所以段号隐含，只需要知道段表存放在内存中的起始地址M以及段号K，就可以计算出对应的段表项地址：M+K*size，其中size指的是存储一个段表项所用的大小；<br>
<strong>如何计算size</strong>：<br>
继续上面的例子，假设段内地址16位，则16位可以表示最大段长；物理内存大小为4GB，即32位；<br>
所以要用段表记录整个内存空间，则需要16+32位来唯一标识一个内存空间；也就是48位的数据，所以一个段表项的大小的6B；也就是size=6B；</p>
<h4 id="分段存储管理地址变换过程">分段存储管理地址变换过程</h4>
<p>当进程要上处理机运行之前，进程切换的相关程序负责恢复进程的运行环境，其中就包括恢复进程PCB中的段表寄存器的值，段表寄存器记录了段表的起始地址和段表长度；</p>
<ol>
<li>当进程环境恢复之后，进行开始运行，在进程运行的过程中可能要访问一些逻辑地址；</li>
<li>当进程要访问一个逻辑地址adr的时候，逻辑地址首先被分为两部分，包括段号S和段内偏移量/段内地址W；</li>
<li>段号和返表长度进行对比检查越界，如果段号大于段表长度，则发生越界中断（内中断，程序执行过程中产生的中断）；</li>
<li>如果没有越界，则根据段表起始地址访问内存找到段表，并结合段号计算出段表项内存位置访问对应的段表项（段表项存储段长度和段起始地址）；<strong>计算公式：段表项地址=段表起始地址+段号*段表项大小</strong></li>
<li>于是<strong>再一次进行越界检查</strong>，对比段长度和段内地址，如果段内地址大于段长度则发生越界中断；</li>
<li>段内地址不大于段长度，则继续进行地址转换；</li>
<li>通过段起始地址和段长度，访问内存中相应的物理内存空间，即访问目标内存块；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504202417.png" alt="Pasted image 20240504202417"></li>
</ol>
<h4 id="分段、分页管理的对比">分段、分页管理的对比</h4>
<p>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的；<br>
段时信息的逻辑单位，分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名；<br>
页的大小固定且有系统决定，段的长度却不固定，决定于用户编写的程序；<br>
分页的用户进程地址空间是1维的，而分段的用户进程地址空间是二维的；</p>
<h4 id="分段存储管理的优缺点分析">分段存储管理的优缺点分析</h4>
<p>分段比分页更容易实现信息的共享和保护；</p>
<ol>
<li>信息的共享<br>
对于不能被修改的代码称为纯代码或可重入代码（不属于临界资源，可以并发访问），这样的代码段是可以共享的；<br>
可修改的代码是不能共享的，比如一个代码段中有多个变量，各个进程并发地执行可能会导致变量数据的不一致错误；</li>
<li>信息的保护<br>
可以很轻松地给每一个代码段标记为是否可访问，即可实现对于各个段的保护；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504203544.png" alt="Pasted image 20240504203544"><br>
<strong>由于分页存储管理并不是按照逻辑来对代码进行划分，所以可能导致某一个页框存储多个逻辑的代码，这将难以对某一个页框进行信息保护（比如标记为是否可访问）</strong></li>
</ol>
<p><strong>访问内存的次数</strong>：<br>
分段管理中，访问内存的次数也是2次；<br>
分段管理也可以通过快表提高内存分配效率；</p>
<h3 id="段页式存储管理方式">段页式存储管理方式</h3>
<p>段页式管理是结合段式管理和页式管理对内存进行管理的方式，结合了两种管理方式的优点；</p>
<h4 id="分页、分段管理的优缺点分析">分页、分段管理的优缺点分析</h4>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分页管理</td>
<td>内存空间利用率高，不会产生外部碎片，只会有少量的内部碎片</td>
<td>不方便按照逻辑模块实现信息的共享与保护</td>
</tr>
<tr>
<td>分段管理</td>
<td>很方便地按照逻辑模块实现信息的共享与保护</td>
<td>如果段长过大，为其分配连续的内存空间会很大；<br>段式管理会产生外部碎片；</td>
</tr>
</tbody>
</table>
<h4 id="段页式管理的逻辑地址结构">段页式管理的逻辑地址结构</h4>
<p>段页式系统的逻辑地址结构由段号、页号、页内偏移量构成；实际上就是段式管理结构中对每一个段的存储采用页式管理的方式来管理；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504220234.png" alt="Pasted image 20240504220234"></p>
<ul>
<li>段号位数决定了一个进程最多可以分为几个段</li>
<li>页号的位数决定了每个段可以有多少个页</li>
<li>页内偏移量决定了页面大小，也就是内存块大小</li>
</ul>
<h4 id="段表、页表">段表、页表</h4>
<p>系统会为每一个进程建立一个段表，每个段表项记录着页表所在内存块，每个页表记录目标内存单元所在内存块；</p>
<h4 id="段页式管理的地址变换">段页式管理的地址变换</h4>
<p>当进程进入处理机时，相关的内核会恢复进行的运行环境，其中包括在PCB的段表寄存器记录该进程的段表始址F和段表长度M；<br>
进程执行过程中，会遇到要访问逻辑地址的需求；</p>
<ol>
<li>假设需要访问逻辑地址adr，首先将adr分为3段，分别是段号S、页号P、页内偏移量W；</li>
<li>然后段号与段表寄存器的段表长度M进行比较，如果越界产生越界中断，如果没越界则继续执行；</li>
<li>根据段表始址F和段号S，找到段表项存储的信息，首先对比段表项中存储的页表大小与页号，如果页号大于页面大小，则发生越界中断；如果没有发生越界中断，则通过公式：页表内存块地址Padr=F+S*size计算得到段表中该段号存储的页表地址，并进行访问；</li>
<li>根据前面的公式找到页表存放的内存块，访问对应的页表，对应页号存储的内存块号，然后结合逻辑地址中的页内偏移量W得到目标内存单元的物理地址并进行访问；<br>
整个过程进行了3次访存。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504222312.png" alt="Pasted image 20240504222312"></li>
</ol>
<h2 id="内存空间的扩充">内存空间的扩充</h2>
<p>在传统的存储管理方式上引入交换技术、覆盖技术、虚拟存储技术，可以在逻辑上实现对内存空间的扩充，提高内存的利用效率；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存空间的扩充 --&gt; 覆盖技术 &amp; 交换技术 &amp; 虚拟存储技术</span><br></pre></td></tr></table></figure>
<h3 id="交换与覆盖">交换与覆盖</h3>
<h4 id="覆盖技术">覆盖技术</h4>
<p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要的时候才需要调入内存。内存中分为一个“固定区”和若干个“覆盖区”；<br>
需要常驻内存的段放在“固定区”中，调入之后就不在调出（除非运行结束）<br>
不常用的段放在“覆盖区”，需要用的时候调入内存，用不到的时候调出内存；<br>
缺点：对用户不透明，增加了程序员的编程负担。因为要提前编程指明需要常驻内存的代码段之类的信息；</p>
<h4 id="交换技术">交换技术</h4>
<p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存（保留PCB），把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）；</p>
<h5 id="在外存的什么位置保存被换出的进程？">在外存的什么位置保存被换出的进程？</h5>
<p>在具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；<br>
对换区空间只占用磁盘小部分空间，被换出的进程数据存放在对换区，由于对换速度直接影响系统的整体速度，因此对换区空间管理主要<strong>追求换出换入速度</strong>，因此对换区采用连续分配方式；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417173330.png" alt="Pasted image 20240417173330"></p>
<h4 id="什么时候交换？">什么时候交换？</h4>
<p>交换通常在需要进程运行且内存吃紧的时候进行，而系统符合降低就暂停。例如：在发现许多进程运行时进程发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p>
<h4 id="应该换出什么进程？">应该换出什么进程？</h4>
<p>优先换出阻塞进程；<br>
可换出优先级低的进程；<br>
<strong>PCB需要常驻内存，不会被换出</strong></p>
<h3 id="虚拟存储">虚拟存储</h3>
<h4 id="传统存储管理的缺点">传统存储管理的缺点</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">传统存储管理 --&gt; 连续分配 &amp; 非连续分配</span><br><span class="line">连续分配 --&gt; 单一连续分配 &amp; 固定分区连续分配 &amp; 动态分区连续分配</span><br><span class="line">非连续分配 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 基本段页式存储管理</span><br></pre></td></tr></table></figure>
<ol>
<li>一次性：作业必须一次性全部装入内存后才能开始运行，这将会导致大作业无法运行；当大量作业要求运行时，由于内存无法同时容纳那么多作业，导致系统作业运行的并发度下降；</li>
<li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，可是实际上每个作业只有一小部分数据即可正常运行，这就导致内存中会驻留许多暂时用不到的数据，浪费了宝贵的内存空间；<br>
虚拟存储管理实际上是基于<strong>局部性原理</strong>而产生的：<br>
<strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久后该数据很有可能再次被访问。（因为程序中存在大量的循环）<br>
<strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</li>
</ol>
<h4 id="虚拟内存的定义和特征">虚拟内存的定义和特征</h4>
<p>基于不局限原理，程序在装入时，可以将程序中很快会用到的部分装入内存，暂时不用的部分暂时留在外存，就可以让程序开始执行；<br>
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需的信息从外存调入内存，然后继续执行程序；<br>
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出外存；<br>
在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>；</p>
<p><strong>特征</strong>：</p>
<ol>
<li>多次性：允许一个作业分多次调入内存；</li>
<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中将作业换入换出；</li>
<li>从逻辑上扩充了内存的容量，使得用户看到的内存容量，远大于实际的内存容量；</li>
</ol>
<h4 id="实现虚拟存储技术">实现虚拟存储技术</h4>
<p>虚拟内存技术，允许一个作业分多次调入内存；如果采用连续的分配方式，当下一次调入该作业的其他部分数据时还要与上一部分的数据保持连续，造成极大的不便；<br>
所以虚拟内存技术是建立在非连续性存储管理之上的；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">传统非连续性存储管理 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 基本段页式存储管理</span><br><span class="line">虚拟内存的实现 --&gt; 请求分页存储管理 &amp; 请求分段存储管理 &amp; 请求段页式存储管理</span><br></pre></td></tr></table></figure>
<p>虚拟内存管理和传统非连续性存储管理的区别：</p>
<ol>
<li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需要的信息调入内存；</li>
<li>当内存空间不够时，由操作系统负责将内存中暂时用不到的信息调出到外存；</li>
</ol>
<h4 id="请求分页管理方式">请求分页管理方式</h4>
<h5 id="页表机制">页表机制</h5>
<p><strong>需求分析</strong>：</p>
<ul>
<li>与基本的页表机制相比，请求分页管理方式中需要知道某个页面是否被调入内存；</li>
<li>当内存空间不够的时候，需要知道将哪一个页面调出内存；由于操作系统需要根据一些额外的信息来决策选择将哪个页面放入外存，所以页表机制中应该记录这些信息来帮助操作系统来决策；（比如某个页面在内存中停留的时间）<br>
基于上述需求，可以将页表设计如下：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240505134633.png" alt="Pasted image 20240505134633"><br>
<strong>修改位的意义</strong>：<br>
如果某个页面没被修改过，则该页面无需在外存重写，因为外存中的数据和内存中数据一致；<br>
如果某个页面被修改过，则该页面调出外存时需要覆盖重写原外存数据；</li>
</ul>
<h5 id="缺页中断机构">缺页中断机构</h5>
<p>为了实现请求调页功能，系统需要引入缺页中断机构，当检查到需要访问的页面不存在于内存中时引发中断，同时该缺页的进程进入阻塞态，放入阻塞队列，由操作系统在缺页中断函数中实现调页到内存，调页完成后再次将该进程唤醒，放回就绪队列；</p>
<h5 id="地址变换过程">地址变换过程</h5>
<ol>
<li>当进程执行过程中，要访问某个逻辑地址adr，首先将逻辑地址分为页号和页内偏移量；</li>
<li>然后页号和页表寄存器的页表长度进行比较，检查是否发生越界，如果发生越界则产生缺页中断；</li>
<li>如果未发生越界则去快表查询是否有该页号，如果有则直接访问快表对应的页表项，与页内偏移量相加计算出目标内存单元的物理地址并访问；</li>
<li>如果快表中没有对应的页号则根据页表寄存器的页表始址访问内存中的页表，查询对应页表中的页号的状态位，<strong>检查该内存单元是否被调入内存，如果状态显示未调入内存则发生缺页中断</strong>；等待系统调页，然后往页表写入该页面调入的内存块号并将状态为置1；</li>
<li>访问该页号对应的内存块号，结合页内偏移量计算出目标内存单元的物理地址，访问目标内存单元；<br>
<strong>注意</strong>：快表中有的页面一定是在内存中的，若某个页面调出外存，则快表中相应的页面也要删除；<br>
<strong>细节</strong>：</li>
<li>只有“写指令”才需要修改页表项的“修改位”；<br>
一般来说，只需要修改快表中的表项，只有当快表中的表项将要被删除时，才将快表项的修改写会慢表，减少访存次数；</li>
<li>和普通中断处理程序一样，缺页中断也需要保存CPU现场；</li>
<li>需要采用某种“页面置换算法”来决定一个换出页面</li>
<li>换入换出页面都需要访问外存，访问外存的速度是很慢的，需要尽量避免换入换出；</li>
<li>页面调入内存后需要修改慢表，同时也需要将表项复制到快表中；</li>
</ol>
<h4 id="页面置换算法">页面置换算法</h4>
<p>在请求分页存储管理中，当需要调页进入内存但内存空间已经满的时候，需要进行页面置换，即把内存中暂时用不到的信息换出外存；<br>
由于页面的换入换出需要磁盘IO操作，会有较大的时间开销，所以我们的页面置换算法应该追求更少的<strong>缺页率</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">页面置换算法 --&gt; 1(&quot;`最佳置换算法（OPT）`&quot;) &amp; 2(&quot;`先进先出置换算法（FIFO）`&quot;) &amp; 3(&quot;`最近最久未使用置换算法(LRU)`&quot;) &amp; 4(&quot;`时钟置换算法(CLOCK)`&quot;) &amp; 5(&quot;`改进型的时钟置换算法`&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="最佳置换算法">最佳置换算法</h5>
<p>每次选择淘汰的页面将是以后永不使用，或者是在最长时间内不再被访问的页面，这样可以保证最低的缺页率；<br>
先检查目前每个内存块存放的页面号，然后向后搜索将要访问的页面号，在后续访问的页面号中，最后一个被访问到的已存在于当前内存块的页面将是后续最长时间内不被访问的页面，因此需要被换掉；<br>
<strong>注意</strong>：</p>
<ol>
<li>缺页中断是指需要访问的页面没有被调入内存中；</li>
<li>页面置换是指内存已经满了，如果需要调入页面进入内存，需要将内存中暂时不需要用到的页面换出；</li>
<li>缺页中断并不一定会引发页面置换，因为当内存有空闲区域时，可以直接将页面调入内存而无需发生页面置换；<br>
<strong>缺页率</strong>：<br>
缺页率 = 缺页中断发生的次数/总共访问内存的次数<br>
<strong>缺点</strong>：</li>
<li>最佳置换算法需要知道后续需要访问什么页面；</li>
<li>但实际上操作系统无法提前预判需要访问的页面序列，只有在进程执行到相应过程才能实现，所以最佳置换算法在实际应用中无法实现，只是一种理想的算法；</li>
<li>但是最佳置换算法可以作为衡量其他置换算法效率的参考；</li>
</ol>
<h5 id="先进先出置换算法（FIFO）">先进先出置换算法（FIFO）</h5>
<p>每次选择淘汰的页面是最早进入内存的页面；<br>
实现方法：将进入内存的页面根据调入的先后顺序组织成一个队列，每次需要发生页面置换的时候，只需要把队头的页面换出即可；<br>
FIFO算法虽然实现简单，但是该算法与进程的实际运行规律不使用，因为先进入页面的也有可能进程被访问，因此有可能产生Belady异常，算法效率低；<br>
<strong>Belady异常</strong>：<br>
当进程分配的物理块数增大时，缺页次数不减反增的现象称为Belady异常；</p>
<h5 id="最近最久未使用算法（LRU）">最近最久未使用算法（LRU）</h5>
<p>最近最久未使用置换算法（Least recently used）：每次淘汰的页面是最近最久未使用的页面；<br>
实现方法：在页表中增加一个访问字段，该字段记录某个页面自上次访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t最大的置换出去即可；<br>
<strong>缺点</strong>：该算法需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大；<br>
<strong>优点</strong>：性能好，最接近最佳置换算法；</p>
<h5 id="时钟置换算法（CLOCK）">时钟置换算法（CLOCK）</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">时钟置换算法 --&gt; 简单时钟置换算法 &amp; 改进时钟置换算法</span><br></pre></td></tr></table></figure>
<p>时钟置换算法是一种性能和开销比较均衡的算法，又称CLOCK算法，或最近未用算法。（NRU，Not Recently Used）</p>
<p><strong>简单时钟算法实现方式</strong>：<br>
为每个页面设置一个访问位，将内存中的页面组织成一个循环队列；<br>
每次需要置换时，从当前队列位置开始扫描，检查页面的标志位是否为0，如果为1则将该页面标志位置0，然后扫描下一个，碰到第一个标志位为0的页面即可将该页面换出；（因为该页面最先被访问过，所以是最近未被用）<br>
如果第一轮扫描没有发现标志位为0的页面，进行第二轮扫描，由于第一轮扫描会将所有标志位为1的页面置0，所以第二轮扫描一定会找到标志位为0的页面；<br>
<strong>因此，简单时钟算法最多扫描两次</strong></p>
<h5 id="改进的时钟置换算法">改进的时钟置换算法</h5>
<p>简单的时钟置换算法仅考虑到一个页面最近是否被访问，但是没有考虑该页面是否被修改；如果一个页面没有被修改过，该页面应该优先调出，因为未修改过的数据调出外存不需要进行IO操作写回外存；<strong>只有被修改过的页面被淘汰，才会进行IO读写。</strong><br>
所以，当两个页面其他条件都相同时，未被修改过的页面应该优先被置换，避免IO操作；</p>
<p><strong>改进的时钟置换算法实现方式</strong>：</p>
<ol>
<li>给每个页面增加一个访问位和一个修改位；访问位为1表示访问过，修改位为1表示修改过；</li>
<li>优先级：<br>
（0，0）未访问且未修改<br>
（0，1）未访问但被修改<br>
（1，0）访问但未被修改<br>
（1，1）访问且被修改</li>
<li>将所有的页面组织成一个循环队列；</li>
<li>第一次扫描：扫描队列中所有（0，0）的页面，如果该页面不满足（0，0）不对页面状态作任何修改；如果第一轮扫描中找到（0，0）的页面，则将其置换；否则进行第二轮扫描；</li>
<li>第二次扫描：由于第一轮扫描未发现（0，0）的页面，所以当前内存中不存在即未被访问又未被修改的页面，所以第二轮扫描实际上要找出第二优先级的状态，即未被访问过但是被修改过的页面（0，1）；<br>
所以第二轮扫描中扫描所有（0，1），同时对不满足状态要求的页面的访问状态位置0；<br>
如果第二轮扫描中遇到（0，1）则将其置换；否则进行第三轮扫描；</li>
<li>第三次扫描：由于第二轮扫描也失败，所以当前内存中不存在未被访问过的页面，同时第二次扫描将所有页面的访问状态位置0；<br>
所以第三次扫描实际上需要找到访问过但是没有被修改过的页面（0，0）；本次扫描不修改任何标志位；</li>
<li>第四次扫描：由于第三轮扫描失败，证明该内存中仅存在被访问过也被修改过的页面；经过第二轮的修改和第三轮的排除，当前内存中所有页面的状态都为（0，1）；所以第四轮扫描则扫描（0，1）的页面即可，且一定能找到对应页面；<br>
<strong>改进的时钟置换算法最多扫描4次</strong></li>
</ol>
<h5 id="例题">例题</h5>
<h6 id="简单时钟置换算法">简单时钟置换算法</h6>
<p>要点：</p>
<ul>
<li>当一页装入内存，访问位置1</li>
<li>当页面在物理块中，且被访问，访问位置1</li>
<li>页面替换后，指针指向被替换页面的下一页</li>
<li>页面在物理块中，且被访问，指针指向被访问页的下一页
<ul>
<li>从指针处开始，遇到第一个访问位为0的，进行置换；遇到访问位为1的，将其访问位置0</li>
</ul>
</li>
</ul>
<iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=464060423&bvid=BV1sL411u7rn&cid=437950541&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640; height: 430px; max-width: 100%;"></iframe>
###### 改进时钟置换算法
<h4 id="页面分配策略">页面分配策略</h4>
<p>驻留集：指请求分页存储管理中给进程分配的物理块的集合；（采用虚拟存储技术的系统中，驻留集大小一般小于进程的总大小）<br>
<strong>固定分配</strong>：操作系统为每个进程分配统一固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变；<br>
<strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或者减少，即，驻留集大小可变；<br>
<strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换；<br>
<strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">页面分配策略 --&gt; 1(&quot;`固定分配，局部置换`&quot;) &amp; 2(&quot;`可变分配，局部置换`&quot;) &amp; 3(&quot;`可变分配，全局置换`&quot;)</span><br></pre></td></tr></table></figure>
<h5 id="固定分配，局部置换">固定分配，局部置换</h5>
<p>每个进程分配固定大小的物理内存块（即驻留集大小固定），当进程发生缺页时，只能从该进程的驻留集中分配内存空间调页，如果驻留集已满，则需要对驻留集采用页面置换算法调出暂时不用的页面；<br>
<strong>缺点</strong>：难以一开始就选择合适的驻留集大小；</p>
<h5 id="可变分配，全局置换">可变分配，全局置换</h5>
<p>刚开始为每个进程分配一定数量的物理块，操作系统会保持一个空闲的物理块队列；当进程发生缺页时，从空闲物理块取出一块分配给该进程；若已无空闲物理块，则可以选择系统中任意一个进程的任意一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程；<br>
<strong>锁定</strong>：操作系统会将进程中比较重要的页面进行锁定，比如一些内核数据；<br>
<strong>特点</strong>：每次发生缺页都会分配一块新的物理内存，仅当空闲物理块用完才会发生页面置换；被置换的页面可能是系统中任意一个进程的页面，因此这个被选中的进程的物理块会减少，缺页率可能会增加；</p>
<h5 id="可变分配，局部置换">可变分配，局部置换</h5>
<p>刚开始为每个进程分配一定数量的物理块，当某些进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存；<br>
如果一个进程频繁地缺页，系统则会为该进程分配多一些物理块，直到该进程缺页率趋于适当程度；反之，如果进程在运行时缺页率特别低，系统会适当减少该进程的物理块；</p>
<p><strong>可变分配全局置换</strong>：只要缺页就分配新的物理块<br>
<strong>可变分配局部置换</strong>：根据进程的缺页率来动态增加或减少进程物理块</p>
<h5 id="何时调入页面">何时调入页面</h5>
<p>什么时候调入页面进入内存，主要有两种方式：</p>
<ol>
<li>预调页策略：根据局部性原理，一次调入若干个相邻的页面进入内存；（主要应用与程序的首次调入，由程序员指出应该先调入哪些部分）</li>
<li>请求调页策略：进程在运行期间发现缺页才将所缺页面调入内存；（IO开销较大）</li>
</ol>
<h5 id="何处调入页面">何处调入页面</h5>
<p>页面一般是存储在外存的文件区的，所以一般是从外存调入页面；<br>
但是外存不仅分为文件区，还有对换区：</p>
<ul>
<li>对换区：连续分配方式，访问速度快</li>
<li>文件区：离散分配方式，访问速度慢</li>
</ul>
<ol>
<li>当系统有足够的对换区空间：页面的调入调出应该都在对换区于内存中进行，这样会加快页面调入调出速度；<br>
在程序运行前，需要将进程相关的数据从文件区复制到对换区；</li>
<li>若系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，因为这部分数据不会被修改，换出时不会被写回外存，直接覆盖，需要的时候再次从外存调入即可；<br>
对于需要被修改的数据，换出时需要写入对换区，下次需要的时候再从对换区调入；</li>
<li>UNIX文件系统：运行前将所有数据放入文件区，未使用过的页面都可以从文件区调用；若被使用的页面需要换出，则将页面调出到交换区，需要的时候再从交换区调入；</li>
</ol>
<h5 id="抖动-颠簸现象">抖动/颠簸现象</h5>
<p>刚刚换出的页面马上要换入内存，刚刚换入内存的页面又要换出外存；这种现象称为抖动/颠婆现象；<br>
出现这种现象的根本原因是：该进程工作时需要的页面数量大于系统分配给该进程的物理块数量；<br>
为了给每个进程分配合适数量的物理块，引入进程的<strong>工作集</strong>的概念；<br>
<strong>驻留集</strong>：操作系统为进程分配的内存块集合；<br>
<strong>工作集</strong>：在某段时间间隔里，进程实际访问页面的集合；</p>
<p>操作系统会根据“窗口尺寸”算出工作集；根据工作集的大小确定驻留集的大小，一般驻留集大小大于工作集大小；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240506164320.png" alt="Pasted image 20240506164320"></p>
<h4 id="内存映射文件">内存映射文件</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存映射文件 --&gt; 特性 &amp; 优点</span><br><span class="line">特性 --&gt; 1(&quot;`进程可以使用系统调用，请求操作系统将文件映射到虚拟地址空间（就是放到内存块中并通过编号的形式实现逻辑上的连续）`&quot;) &amp; 以访问内存的方式读写文件 &amp; 2(&quot;`进程关闭文件时，操作系统负责将文件数据写回磁盘并解除内存映射`&quot;) &amp; 3(&quot;`多个进程可以映射到同一个文件，方便共享（就是映射到同样的内存块）`&quot;)</span><br><span class="line"></span><br><span class="line">优点 --&gt; 4(&quot;`编程简单，只需要按照访问内存的方式读写`&quot;) &amp; 5(&quot;`文件数据的读写完全由操作系统负责，IO效率可以由操作系统负责优化`&quot;)</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Icserm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">http://example.com/2024/04/01/操作系统/【操作系统】3. 内存管理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">nullptr</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div class="post_share"><div class="social-share" data-image="/self_img/head_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%91CLIP%E6%A8%A1%E5%9E%8B/" title="CLIP模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CLIP模型</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="文件系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">文件系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/" title="操作系统概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-15</div><div class="title">操作系统概览</div></div></a></div><div><a href="/2024/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/" title="处理器管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-21</div><div class="title">处理器管理</div></div></a></div><div><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="文件系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">文件系统</div></div></a></div><div><a href="/2024/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="设备管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-29</div><div class="title">设备管理</div></div></a></div><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="基本概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">基本概念</div></div></a></div><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%912.%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/" title="关系代数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">关系代数</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="this.onerror=null;this.src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Icserm</div><div class="author-info__description">无为之心，做有为之事</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">108</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ICserD"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ICserD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2862081626@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_73546177" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">内存的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">指令的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">如何将指令中的逻辑地址转换为物理地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">绝对装入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A3%85%E5%85%A5"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">可重定位装入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">动态重定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%99%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">从写程序到程序运行的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">链接的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">装入时动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">运行时动态链接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">内存管理的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">2.1.</span> <span class="toc-text">内存的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">分区大小不同的内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">动态分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">碎片的概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">不同分配算法的对比介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">非连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">分页存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E8%BF%9B%E7%A8%8B%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%88%B0%E5%86%85%E5%AD%98%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">确定进程逻辑地址到内存物理地址的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">基本地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">局部性原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">两级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">单级页表存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">多级页表的地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">多级页表的地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">需要注意的细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.3.</span> <span class="toc-text">基本分段存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">分段系统的逻辑地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">分段存储管理地址变换过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E3%80%81%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">分段、分页管理的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">分段存储管理的优缺点分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">段页式存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E3%80%81%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">分页、分段管理的优缺点分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">段页式管理的逻辑地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">段表、页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">段页式管理的地址变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E6%89%A9%E5%85%85"><span class="toc-number">2.4.</span> <span class="toc-text">内存空间的扩充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%A6%86%E7%9B%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">交换与覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%A4%96%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%E4%BF%9D%E5%AD%98%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.4.1.2.1.</span> <span class="toc-text">在外存的什么位置保存被换出的进程？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BA%A4%E6%8D%A2%EF%BC%9F"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">什么时候交换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E6%8D%A2%E5%87%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">应该换出什么进程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">虚拟存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">传统存储管理的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">虚拟内存的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">实现虚拟存储技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">请求分页管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.2.4.1.</span> <span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">2.4.2.4.2.</span> <span class="toc-text">缺页中断机构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.2.4.3.</span> <span class="toc-text">地址变换过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.2.5.1.</span> <span class="toc-text">最佳置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">2.4.2.5.2.</span> <span class="toc-text">先进先出置换算法（FIFO）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%89"><span class="toc-number">2.4.2.5.3.</span> <span class="toc-text">最近最久未使用算法（LRU）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88CLOCK%EF%BC%89"><span class="toc-number">2.4.2.5.4.</span> <span class="toc-text">时钟置换算法（CLOCK）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.2.5.5.</span> <span class="toc-text">改进的时钟置换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.4.2.5.6.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.2.5.6.1.</span> <span class="toc-text">简单时钟置换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E9%85%8D%EF%BC%8C%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.6.1.</span> <span class="toc-text">固定分配，局部置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%EF%BC%8C%E5%85%A8%E5%B1%80%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.6.2.</span> <span class="toc-text">可变分配，全局置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E9%85%8D%EF%BC%8C%E5%B1%80%E9%83%A8%E7%BD%AE%E6%8D%A2"><span class="toc-number">2.4.2.6.3.</span> <span class="toc-text">可变分配，局部置换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.4.2.6.4.</span> <span class="toc-text">何时调入页面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.4.2.6.5.</span> <span class="toc-text">何处调入页面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8-%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="toc-number">2.4.2.6.6.</span> <span class="toc-text">抖动&#x2F;颠簸现象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.2.7.</span> <span class="toc-text">内存映射文件</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/21/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E3%80%90%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C%E3%80%91Ubuntu22%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E5%B9%B3%E6%9D%BF%E4%BD%9C%E4%B8%BA%E6%89%A9%E5%B1%95%E5%B1%8F/" title="Ubuntu22环境下配置安卓作为扩展屏">Ubuntu22环境下配置安卓作为扩展屏</a><time datetime="2024-09-21T03:08:59.000Z" title="发表于 2024-09-21 11:08:59">2024-09-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E3%80%912.%20%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/" title="文献检索方法">文献检索方法</a><time datetime="2024-09-08T16:00:00.000Z" title="发表于 2024-09-09 00:00:00">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/" title="结构化设计方法">结构化设计方法</a><time datetime="2024-08-23T16:00:00.000Z" title="发表于 2024-08-24 00:00:00">2024-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/" title="期末考点整理">期末考点整理</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="期末复习">期末复习</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/self_img/11c.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Icserm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>