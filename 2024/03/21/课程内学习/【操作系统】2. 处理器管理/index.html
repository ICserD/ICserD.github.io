<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【操作系统】2. 处理器管理 | 半栈日记</title><meta name="author" content="Cyrus"><meta name="copyright" content="Cyrus"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程的概念、组成、特征 感性认知 程序：是静态的，存放在硬盘里的可执行文件，就是一系列指令集合 进程：动态的，是程序的一次执行过程，同一个程序的多次执行会对应多个进程；当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证标识”——PID（Process ID） PCB 进程控制块 在创建进程后，操作系统要记录进程号PID，进程所属用户ID（UID），还要记录给该进程分配了什么资源、多">
<meta property="og:type" content="article">
<meta property="og:title" content="【操作系统】2. 处理器管理">
<meta property="og:url" content="http://example.com/2024/03/21/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="半栈日记">
<meta property="og:description" content="进程的概念、组成、特征 感性认知 程序：是静态的，存放在硬盘里的可执行文件，就是一系列指令集合 进程：动态的，是程序的一次执行过程，同一个程序的多次执行会对应多个进程；当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证标识”——PID（Process ID） PCB 进程控制块 在创建进程后，操作系统要记录进程号PID，进程所属用户ID（UID），还要记录给该进程分配了什么资源、多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/self_img/head_img.jpg">
<meta property="article:published_time" content="2024-03-21T04:00:00.000Z">
<meta property="article:modified_time" content="2024-03-21T04:00:00.000Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="课程学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/self_img/head_img.jpg"><link rel="shortcut icon" href="/self_img/bollon.png"><link rel="canonical" href="http://example.com/2024/03/21/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【操作系统】2. 处理器管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-21 12:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="onerror=null;src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/self_img/11c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="半栈日记"><span class="site-name">半栈日记</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【操作系统】2. 处理器管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-21T04:00:00.000Z" title="发表于 2024-03-21 12:00:00">2024-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-21T04:00:00.000Z" title="更新于 2024-03-21 12:00:00">2024-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【操作系统】2. 处理器管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>进程的概念、组成、特征</h1>
<h3 id="感性认知">感性认知</h3>
<p>程序：是静态的，存放在硬盘里的可执行文件，就是一系列指令集合<br>
进程：动态的，是程序的一次执行过程，同一个程序的多次执行会对应多个进程；当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证标识”——PID（Process ID）</p>
<h3 id="PCB-进程控制块">PCB 进程控制块</h3>
<p>在创建进程后，操作系统要记录进程号PID，进程所属用户ID（UID），还要记录给该进程分配了什么资源、多少资源，该进程的运行情况等等；<br>
这些记录的信息都被保存在一个数据结构<strong>PCB（Process Control Block）中，即进程控制块。<br>
操作系统需要对各个并发的进程进行管理，但凡管理时所需要的信息，都会被存放在PCB中</strong></p>
<p>概念：进程控制块是操作系统用于记录和描述进程状态以及有关信息的数据结构；<br>
一般而言，进程控制块应该包含四类信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程控制块 --&gt; 1[标识信息, PID] &amp; 2[说明信息，说明本进程的状况] &amp; 3[现场信息] &amp; 4[管理信息, 对进程的管理和调度]</span><br></pre></td></tr></table></figure>
<h3 id="进程的概念和组成">进程的概念和组成</h3>
<p>概念：进程是可并发执行的程序在一个数据集上的一次执行过程，它是系统进行资源分配的基本单位；<br>
程序段、数据段、PCB三部分组成了<strong>进程实体</strong>（进程映像/进程上下文）；<br>
<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的组成 --&gt; PCB &amp; 程序段 &amp; 数据段</span><br><span class="line">PCB --&gt; 进程描述信息 &amp; 进程控制和管理信息 &amp; 资源分配清单 &amp; 处理机相关信息</span><br><span class="line">程序段 --&gt; 程序代码</span><br><span class="line">数据段 --&gt; 运行过程中产生的各种数据</span><br></pre></td></tr></table></figure>
<h3 id="进程的特征">进程的特征</h3>
<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的特征 --&gt; A(动态性, 最基本的特征) &amp; B(并发性) &amp; C(独立性) &amp; D(异步性) &amp; E(结构性)</span><br><span class="line">A --&gt; F(进程是程序的一次执行过程&lt;/br&gt;是动态地产生、变化和消亡的)</span><br><span class="line">B --&gt; G(内存中有多个进程实体&lt;/br&gt;各进程可以并发执行)</span><br><span class="line">C --&gt; H(进程是能独立运行&lt;/br&gt;独立获得资源&lt;/br&gt;独立接受调度的基本单位)</span><br><span class="line">D --&gt; I(各进程按各自独立的、不可预知的速度向前推进&lt;/br&gt;操作系统要提供“进程同步机制”&lt;/br&gt;来解决异步问题)</span><br><span class="line">E --&gt; J(每个进程都会配置一个PCB&lt;/br&gt;结构上看，进程由程序段、数据段、&lt;/br&gt;PCB组成)</span><br></pre></td></tr></table></figure>
<h1>进程的状态与转换、进程的组织</h1>
<h2 id="进程的状态-——-创建态，就绪态，运行态，阻塞态，终止态">进程的状态 —— 创建态，就绪态，运行态，阻塞态，终止态</h2>
<h3 id="进程的状态">进程的状态</h3>
<p><strong>进程PCB中，会有一个变量state表示进程的当前状态。</strong> 如：1表示创建态、2表示就绪态…；为了对同一个状态下的各个进行进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">三种基本状态 --&gt; 运行态 &amp; 就绪态 &amp; 阻塞态</span><br><span class="line">运行态 --&gt; 占有CPU且在CPU上运行</span><br><span class="line">就绪态 --&gt; A(已经具备运行条件但由于&lt;/br&gt;没有空闲的CPU，暂时不能运行, 比如进行IO操作)</span><br><span class="line">阻塞态 --&gt; 因等待某一事件而暂时不能运行</span><br><span class="line"></span><br><span class="line">另外两种状态 --&gt; 创建态 &amp; 终止态</span><br><span class="line">创建态 --&gt; B(进程正在被创建，操作系统&lt;/br&gt;为进程分配资源、初始化PCB)</span><br><span class="line">终止态 --&gt; C(进程正在从系统撤销，操作系统&lt;/br&gt;回收进程拥有的资源、撤销PCB)</span><br></pre></td></tr></table></figure>
<h3 id="进程状态的转换">进程状态的转换</h3>
<p><strong>注意</strong>：不能直接由阻塞态转为运行态，也不能直接由就绪态直接转换成阻塞态；因为进入阻塞态是主动请求的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">	direction LR </span><br><span class="line">	创建态 --&gt; 就绪态 : 系统完成创&lt;/br&gt;建进程的&lt;/br&gt;一系列工作</span><br><span class="line">	就绪态 --&gt; 运行态 : 进程被调度</span><br><span class="line">	运行态 --&gt; 就绪态 : 时间片到&lt;/br&gt;或处理机被抢占</span><br><span class="line">	运行态 --&gt; 终止态 : 进程运行结束&lt;/br&gt;运行过程遇到&lt;/br&gt;不可修复错误</span><br><span class="line">	运行态 --&gt; 阻塞态 : 进程用“系统调用”的方式&lt;/br&gt;申请某种系统&lt;/br&gt;资源，或者请求&lt;/br&gt;等待某个事情发生</span><br><span class="line">	阻塞态 --&gt; 就绪态 : 申请的资源被分配&lt;/br&gt;等待的事件发生</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="进程的组织-——-链接方式，索引方式">进程的组织 —— 链接方式，索引方式</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的组织方式 --&gt; A(&quot;`链接方式(**主要方式**)`&quot;) &amp; 索引方式</span><br><span class="line">A --&gt; B[&quot;`按照**进程状态**将PCB分为多个队列`&quot;] &amp; 操作系统持有指向各个队列的指针</span><br><span class="line">索引方式 --&gt; 根据进程状态不同建立不同索引表 &amp; 操作系统持有指向各个索引表的指针</span><br></pre></td></tr></table></figure>
<p><strong>链接方式</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240321181331.png" alt="Pasted image 20240321181331"><br>
<strong>索引方式</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240321181402.png" alt="Pasted image 20240321181402"></p>
<h1>进程控制</h1>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<br>
本质上：进程控制就是要实现进程状态的转换</p>
<p><strong>如何实现进程控制（用原语实现）</strong><br>
原语是内核中的一种程序，它的执行具有原子性，运行必须一气呵成，不可被中断。<br>
<strong>如何实现原语的“原子性”</strong><br>
用“关中断指令”和“开中断指令”这两个特权指令实现原子性。CPU执行了关终端指令后，就不会再例行检查中断信号，直到执行开中断指令才会再次进行例行检查。<br>
原语的执行是屏蔽中断的；</p>
<h2 id="进程控制概览">进程控制概览</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程控制 --&gt; 相关概念 &amp; 相关原语</span><br><span class="line">相关概念 --&gt; B(进程控制就是要&lt;/br&gt;实现进程状态的转换) &amp; C(进程控制要&lt;/br&gt;用原语实现)</span><br><span class="line">C --&gt; A(&quot;`原语用**开/关**中断实现`&quot;) &amp; 原语是一种特殊的程序 &amp; 原语的执行必须一气呵成</span><br><span class="line">相关原语 --&gt; 进程创建 &amp; 进程终止 &amp; 进程阻塞 &amp; 进程唤醒 &amp; 进程切换</span><br><span class="line">进程阻塞 &amp; 进程唤醒 --&gt; 成对出现</span><br></pre></td></tr></table></figure>
<h2 id="进程控制原语">进程控制原语</h2>
<p>无论哪个进程控制的原语，要做的都无非是这三类事情：</p>
<ol>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ol>
<h1>进程通信</h1>
<p>进程间的通信（Inter-Process Communication, IPC）是指两个进程之间产生数据交互。<br>
进程是分配系统资源的单位（包括内存地址空间），因此个进程拥有的内存地址空间相互独立。<strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间。为了进程之间能够通信，必须由操作系统参与实现。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程通信方式 --&gt; 共享存储 &amp; 消息传递 &amp; 管道通信</span><br></pre></td></tr></table></figure>
<h2 id="共享存储">共享存储</h2>
<p>开辟一个共享存储空间，其他进程都可以对这片空间进行读写。<br>
但是为了避免出错，各个进程对共享空间的访问应该是互斥的，操作系统内核提供同步互斥工具（比如P，V操作）来实现互斥的访问。<br>
共享存储有两种方式：</p>
<ol>
<li>基于存储区的共享：操作系统在内存中画出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种方式速度快，是一种高级的通信方式。</li>
<li>基于数据结构的共享：比如共享空间只能放一个长度为10的数组，这种共享方式速度慢、限制多，是一种低级的通信方式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">共享存储 --&gt; 基于数据结构的共享 &amp; 基于存储区的共享</span><br></pre></td></tr></table></figure>
<h2 id="消息传递">消息传递</h2>
<p>进程间的数据交换以<strong>格式化的消息</strong>为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。<br>
消息传递也有两种方式：</p>
<ol>
<li>直接通信方式（直达）：需要指明接收消息的ID，接收消息的进程也需要指明发生消息的进程ID</li>
<li>间接通信方式（邮箱）</li>
</ol>
<h2 id="管道通信">管道通信</h2>
<p>从一端写入数据，另一端接收数据，且数据的流通是单向的。<br>
在操作系统中，“管道”是一个特殊的共享文件，又名pipe文件，其实就是在内存中开开辟一个<strong>大小固定的内存缓冲区</strong>，但是数据的读写是先进先出的（FIFO）。<br>
<strong>进程P只能写数据，进程Q只能读数据，先写的数据先被读出。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程P --&gt; 管道 --&gt; 进程Q</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ol>
<li>管道通信只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则需要设置两个管道。</li>
<li>各个进程要互斥地访问管道。</li>
<li><strong>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</strong></li>
<li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li>
<li>管道中的数据一旦被读出，就彻底消失，因此，当多个进程同时读写管道时，可能会出现错乱。<br>
对此，通常有两种解决方案：
<ul>
<li>一个管道允许多个写进程，一个读进程；</li>
<li>允许多个写进程，多个读进程，但是操作系统会让各个读进程轮流从管道读取数据（LINUX方案）</li>
</ul>
</li>
</ol>
<h1>线程</h1>
<h2 id="线程的概念">线程的概念</h2>
<p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，==线程是可以独立参与调度的基本单位==！<br>
引入线程之后，不仅使得进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发性，使得一个进程内部也可以并发处理各种任务（如QQ，视频，文字聊天等等）<br>
引入线程之后，进程只作为除了CPU之外的系统资源的分配单元。</p>
<ul>
<li>进程是资源分配的基本单位</li>
<li>线程是cpu调度的最小单位</li>
</ul>
<h3 id="引入线程之后的变化">引入线程之后的变化</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">变化 --&gt; A(资源分配) &amp; B(并发性) &amp; C(系统开销)</span><br><span class="line">A --&gt; D(传统进程机制中，进程是资源分配调度的基本单位) &amp; E(引入线程后，进程是资源分配&lt;/br&gt;的基本单位，线程是调度的基本单位)</span><br><span class="line">B --&gt; 1(传统进程机制中，只能进程间并发) &amp; 2(引入线程后，各线程间也能并发)</span><br><span class="line">C --&gt; 3(传统进程间的并发，需要切换进程的&lt;/br&gt;运行环境，系统开销很大) &amp; 4(线程并发，如果是同一进程内&lt;/br&gt;的线程切换，则不需要切换进程环境，系统开销小)</span><br></pre></td></tr></table></figure>
<h2 id="线程的实现方式和多线程模型">线程的实现方式和多线程模型</h2>
<h3 id="概览">概览</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">线程 --&gt; 实现方式 &amp; 多线程模型</span><br><span class="line">实现方式 --&gt; 用户级线程 &amp; 内核级线程</span><br><span class="line">多线程模型 --&gt; 一对一 &amp; 多对一 &amp; 多对多</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="用户级线程和内核级线程">用户级线程和内核级线程</h2>
<p>用户级线程下，操作系统并不能感知到线程的存在，还是以进程作为资源调度和分配的基本单位，只是程序员在程序中人为地设置不同进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">用户级线程 --&gt; 1(优点：线程在用户态切换，&lt;/br&gt;线程管理开销小，不需要切换到核心态) &amp; 2(缺点：当一个线程被阻塞，整个进程&lt;/br&gt;都会被阻塞，并发度不高)</span><br></pre></td></tr></table></figure>
<p>内核级线程是在操作系统层面的线程，内核级线程的管理工作由操作系统内核完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内核级线程 --&gt; 1(优点：并发能力强，一个线程阻塞，别的线程还能执&lt;/br&gt;行。多线程可以在多核处理机上执行) &amp; 2(一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成&lt;/br&gt;线程管理成本高，开销大)</span><br></pre></td></tr></table></figure>
<h2 id="多线程模型">多线程模型</h2>
<h3 id="一对一模型">一对一模型</h3>
<p>一个用户级线程映射到一个内核级线程。</p>
<h3 id="多对一模型">多对一模型</h3>
<p>多个用户级线程映射到一个内核级线程。</p>
<h3 id="多对多模型">多对多模型</h3>
<p>n用户级线程映射到m个内核级线程(n&gt;=m)。</p>
<h2 id="线程的状态与转换">线程的状态与转换</h2>
<p>线程的状态与转换和进程的逻辑基本一致。<br>
线程的组织与控制与进程的组织与控制也基本一致。<br>
进程由PCB保存关键信息，线程由TCB保存关键信息。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240325080217.png" alt="Pasted image 20240325080217"></p>
<h2 id="处理机调度">处理机调度</h2>
<p><strong>调度的基本概念：</strong><br>
当有一堆任务要处理，由于资源有限，这些事情无法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”要解决的问题。</p>
<h3 id="调度的三个层次">调度的三个层次</h3>
<ol>
<li>高级调度（作业调度）<br>
作业：一个具体的任务。</li>
<li>低级调度（进程调度/处理机调度）<br>
进程调度频率很高，一般几十毫秒一次。</li>
<li>中级调度（内存调度）<br>
内存不够时，可将某些进程的数据调出外村，等内存空闲或者进程需要运行时再重新调入内存。</li>
</ol>
<h2 id="进程调度的时机">进程调度的时机</h2>
<p>进程再操作系统<strong>内核程序临界区</strong>中不能进行调度与切换。<br>
临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源；<br>
临界区：访问临界资源的那段代码；<br>
内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<h2 id="作业（补充）">作业（补充）</h2>
<h3 id="相关概念">相关概念</h3>
<p>概念：用户在一次解题过程中要求计算机所做的工作的集合；<br>
作业运行的步骤：</p>
<ol>
<li>编辑：写源程序</li>
<li>编译：源程序被编译成机器指令，形成目标代码程序</li>
<li>链接装配：将目标代码以及调用的各种库代码链接装配成一个可执行程序</li>
<li>运行：可执行程序装入内存并提供程序运行时所需要的数据，运行程序并产生结果</li>
</ol>
<h1>调度算法</h1>
<h2 id="调度算法的评价指标">调度算法的评价指标</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法的平均指标 --&gt; CPU利用率 &amp; 3[&quot;系统吞吐量, 单位时间内让更多进程完成工作&lt;/br&gt;提高单位时间的处理能力&quot;] &amp; 周转时间 &amp; 等待时间 &amp; 响应时间</span><br><span class="line">周转时间 --&gt; 1(周转时间、平均周转时间) &amp; 2(带权周转时间、平均带权周转时间)</span><br></pre></td></tr></table></figure>
<ol>
<li>CPU利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">利用率=\frac{忙碌时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>系统吞吐量  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐量</mtext><mo>=</mo><mfrac><mtext>总共完成了多少道作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐量</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少道作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>周转时间：作业提交给系统开始，到作业完成为止。  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>作业周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">作业周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间=\frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间=\frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>等待时间  进程/作业处于等待处理机状态时间之和（在就绪态中的时间），等待时间越长，用户满意度越低；<br>
<strong>进程等待时间：</strong> 进程建立后等待被服务的时间之和；<br>
作业等待时间：不仅要考虑进程建立后的等待时间，还要作业在外存后备队列中等待的时间；</li>
<li>响应时间：用户提交请求到首次产生响应所用的时间；</li>
</ol>
<h2 id="早期批处理调度算法">早期批处理调度算法</h2>
<h3 id="知识总览">知识总览</h3>
<p>早期的批处理系统采用的调度算法，这些算法对“响应时间”这个指标并不关心，也不区分任务紧急程度。考虑的是系统整体的性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法 --&gt; 1(&quot;先来先服务(FCFS)&quot;) &amp; 2(&quot;短作业优先(SJF)&quot;) &amp; 3(&quot;高响应比优先(HRRN)&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="短作业优先">短作业优先</h3>
<p><strong>注意：</strong></p>
<ol>
<li>如果未特别说明，短作业优先算法都默认是“非抢占式”的；</li>
<li>所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转最少；或者说，在所有进程都几乎同时到达时，SJF调度算法的平均等待时间、平均周转时间最少；</li>
<li>抢占式的但作业/进程优先调度算法（SRNT）的平均等待时间、平均周转时间最少；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">短作业优先 --&gt; 1(&quot;非抢占式短作&lt;/br&gt;业优先(Shortest Job First)&quot;) &amp; 2(&quot;抢占式短作业&lt;/br&gt;优先，又称“最短剩余&lt;/br&gt;时间优先“&lt;/br&gt;算法(SRTN)&quot;)</span><br><span class="line">1 --&gt; 3(&quot;`算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程`&quot;)</span><br><span class="line">2 --&gt; 4(&quot;算法：每当有进程加入就&lt;/br&gt;绪队列改变时就需要调度&lt;/br&gt;如果新到达的进程剩余时间比当&lt;/br&gt;前运行的进程剩余时间更短&lt;/br&gt;则由新进程抢占处理机, 当&lt;/br&gt;前运行进程重新回到就绪队列&lt;/br&gt;另外, 当一个进程完成时也需要调度&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="高响应比优先算法">高响应比优先算法</h3>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">响应比 = \frac{等待时间+要求服务时间}{要求服务时间} \geq 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<ol>
<li><strong>非抢占式</strong>调度算法：<br>
只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进程调度，调度时<strong>计算所有就绪进程的响应比，选择响应比最高的</strong>进程上处理机。</li>
</ol>
<h2 id="调度算法">调度算法</h2>
<h3 id="知识总览-2">知识总览</h3>
<p>更关心&quot;响应时间&quot;，这几种算法更加适合交互式系统。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法 --&gt; 时间片轮转调度算法 &amp; 优先级调度算法 &amp; 多级反馈队列调度算法</span><br></pre></td></tr></table></figure>
<h3 id="时间片轮转">时间片轮转</h3>
<ol>
<li>算法思想：公平地、轮流地为各个进程服务，让每个进程再一定时间间隔内都可以得到响应；</li>
<li>算法规则：按照进程到达就绪队列的顺序，轮流地让各个进程执行一个时间片。若进程未再一个时间片执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。<br>
<strong>显然，这个是抢占式算法</strong><br>
<strong>注意：</strong></li>
</ol>
<ul>
<li>如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>
<li>时间片如果太小，由于进程切换过于频繁，会导致实际用于进程执行时间比例减少。</li>
<li>一般来说，设计时间片要让切换进程的开销占比不超过1%</li>
</ul>
<ol start="3">
<li>优缺点：</li>
</ol>
<ul>
<li>优点：
<ul>
<li>公平，响应快，适用于分时操作系统</li>
</ul>
</li>
<li>缺点：
<ul>
<li>不区分任务紧急程度；</li>
<li>高频率的进程切换，有一定的开销；</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法">优先级调度算法</h3>
<ol>
<li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序；</li>
<li>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
<li>用于作业/进程调度：既可以用于作业调度，也可以用于进程调度；</li>
<li>可抢占性：抢占式、非抢占式都有；区别在于非抢占式只在进程主动放弃处理机时进行调度，抢占式还需要再就绪队列变化时检查是否会发生抢占；</li>
</ol>
<h4 id="动态优先级-静态优先级调度">动态优先级/静态优先级调度</h4>
<p>根据优先级是否可以动态改编，可以将优先级分为静态优先级和动态优先级两种；</p>
<ol>
<li>如何合理地设置各类进程的优先级？
<ul>
<li>系统进程优先级   高于  用户进程</li>
<li>前台进程优先级   高于  后台进程</li>
<li>交互式进程优先级较高</li>
<li>批处理进程（比如AI训练模型，视频特效渲染）优先级较高</li>
<li>操作系统更偏好 <strong>IO型进程/IO繁忙型进程</strong>（与之相对的是  计算型进程，也称CPU繁忙型进程）</li>
</ul>
</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<p>优点：</p>
<ol>
<li>适用于实时操作系统，用优先级区分紧急程度、重要程度，可以灵活地调整对各种作业/进程的偏好程度。<br>
缺点：</li>
<li>若源源不断有高优先级的进程进入就绪队列，则可能导致饥饿。</li>
</ol>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<p>设置多级的就绪队列，各级队列的优先级从高到低，时间片从小到大；</p>
<ol>
<li>算法思想：对其他调度算法的这种权衡</li>
<li>算法规则：
<ul>
<li>设置多级就绪队列，各级就绪队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。若此时已经是在最下级队列，则重新放回该队列队尾</li>
<li>只有第k级队列为空时，才会为第k+1级队头的进程分配时间片</li>
</ul>
</li>
<li>抢占式算法</li>
<li>优缺点：
<ol>
<li>优点：
<ul>
<li>相对公平</li>
<li>新到达进程可以很快得到响应</li>
<li>短进程只用较少时间就可完成</li>
<li>不必事先估计进程运行时间（避免用户作假）</li>
<li>可以灵活调整各类进程的偏好程度</li>
</ul>
</li>
</ol>
</li>
<li>可能会导致饥饿</li>
</ol>
<h1>进程同步和进程互斥</h1>
<h2 id="进程互斥的四个原则">进程互斥的四个原则</h2>
<p>为了实现临界资源的互斥访问，保证系统整体性能，需要遵循以下原则：</p>
<ol>
<li>忙则等待<br>
临界区被进入的时候，就让其他进程在外面等着</li>
<li>空闲让进<br>
临界区空闲的时候，就让别人立即访问，别闲着</li>
<li>有限等待<br>
对请求访问临界的进程，应该保证能在有限的时间可以进入临界区（保证不会饥饿）</li>
<li>让权等待<br>
当进程被拒之门外，该进程不能一直等待，因为他占用着处理机资源，所以需要剥夺其cpu资源</li>
</ol>
<h2 id="进程同步">进程同步</h2>
<ol>
<li>进程异步性：进程具有异步性特征，异步性是指各并发执行的进程以各自独立的、不可预知的速度向前推进；</li>
<li>有时，各个进程的执行需要一定的顺序关系，这时需要操作系统提供“进程同步机制”来实现这种需求；</li>
</ol>
<h2 id="进程互斥">进程互斥</h2>
<ol>
<li>进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、打印机、摄像头等）</li>
<li>共享资源的两种方式：同时共享方式和互斥共享方式
<ul>
<li>互斥共享方式：一个时间段只允许一个进程访问该程序</li>
<li>同时共享方式：允许一个时间段由多个进程“同时”对它们进行访问</li>
<li>我们把 <strong>一个时间段内只允许一个进程使用</strong>的资源称为 <strong>临界资源</strong>。<br>
对临界资源的互斥访问逻辑：</li>
</ul>
</li>
</ol>
<ul>
<li>进入区：负责检查是否可以进入临界区，若可以进入，则应设置<strong>正在访问临界资源标志</strong>（可以理解为“上锁”），以阻止其他进程同时进入临界区；</li>
<li>临界区：访问临界资源的那段代码；</li>
<li>退出区：负责解除<strong>正在访问临界资源的标志</strong>（可以理解为“解锁”）</li>
<li>剩余区：做其他处理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"> entry section; <span class="comment">//进入区</span></span><br><span class="line"> critical section;  <span class="comment">//临界区</span></span><br><span class="line"> exit section;  <span class="comment">// 退出区</span></span><br><span class="line"> remainder section;  <span class="comment">// 剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程互斥的软件实现方法（了解即可）">进程互斥的软件实现方法（了解即可）</h2>
<h3 id="知识概览">知识概览</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程互斥的软件实现方法 --&gt; 单标志法 &amp; 双标志先检查 &amp; 双标志后检查 &amp; Peterson算法</span><br></pre></td></tr></table></figure>
<h3 id="单标志法">单标志法</h3>
<ol>
<li>算法思想：两个进程再访问完临界区后会把临界区的权限转交给另一个程序。也就是说，每个进程进入临界区的权限只能被另一个进程赋予。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<h3 id="双标志先检查法">双标志先检查法</h3>
<ol>
<li>算法思想：设置一个布尔数组flag[]， 数组中各个元素用于标记各进程进入临界区的意愿；比如<code>flag[0] = true</code>表示0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有无别的进程进入临界区，如果没有，则把自身对应的标志<code>flag[i] = true</code>，之后开始访问临界区。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);  <span class="comment">//  可以理解为上了锁</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>缺点：<br>
由于检查和上锁这两个处理在这里并不是一气呵成的，所以违反了“忙则等待”的原则；</li>
</ol>
<h3 id="双标志后检查法">双标志后检查法</h3>
<ol>
<li>算法思想：双标志检查法的改版，前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>缺点：<br>
违背了“空闲让进”和“有限等待”的原则，有可能会产生“饥饿”现象；</li>
</ol>
<h3 id="Peterson算法">Peterson算法</h3>
<ol>
<li>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>缺点：<br>
为遵循让权等待的原则；<br>
但是遵循了空闲让进，忙则等待，有限等待的原则，是这三种算法中最优的一个，当然还有更优的算法；</li>
</ol>
<h2 id="进程互斥的硬件实现方法（了解即可）">进程互斥的硬件实现方法（了解即可）</h2>
<h3 id="中断屏蔽方法">中断屏蔽方法</h3>
<p>利用“开/关中断指令”实现（与原语的实现思想相同）<br>
优点：简单、高效<br>
缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程</p>
<h3 id="TestAndSet指令">TestAndSet指令</h3>
<p>简称TS指令，也有地方称为TSL指令；<br>
TSL指令（Test-and-Set Lock）是用硬件实现的，执行过程不允许被中断，只能一气呵成；<br>
缺点：不满足让权等待原则；<br>
优点：适合多处理机环境；</p>
<h3 id="Swap指令">Swap指令</h3>
<p>也叫Exchange指令，或简称为XCHG指令。Swap指令是用硬件实现的，执行的过程不允许被中断。<br>
物理硬件实现上与TSL不同，但是逻辑基本相同，优缺点也相同；</p>
<h3 id="互斥锁">互斥锁</h3>
<ol>
<li>解决临界区最简单的工具就是互斥锁；互斥锁常用硬件机制实现；</li>
<li>互斥锁主要缺点：忙等待；</li>
<li>特性：等待期间不需要切换进程上下文，多处理器系统中，若上锁时间很短，则等待代价很低</li>
</ol>
<h1>信号量机制（重中之重）</h1>
<ol>
<li>信号量机制：用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li>
<li><strong>信号量其实就是一个变量</strong>（可以是一个整数，也可以是更加复杂的记录型变量），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>；</li>
<li><strong>一对原语：</strong> <strong>wait(S)和signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。<br>
wait、signal原语常简称为 P、V 操作（来自荷兰语）。因此，wait(S)和signal(S)两个操作分别写为<strong>P(S)和V(S)</strong>，它们是原语，有底层支持保证它们的执行不可中断。
<ul>
<li>P：proberen 测试（荷兰语）</li>
<li>V：verhogen 增加（荷兰语）</li>
<li>==S信号量只能由PV操作访问！==</li>
</ul>
</li>
<li>一般而言，S无特别说明，都是记录型信号量；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">信号量机制 --&gt; 整型信号量 &amp; 1[结构型信号量/记录型信号量]</span><br></pre></td></tr></table></figure>
<h3 id="整型信号量">整型信号量</h3>
<p>用一个整数型的变量作为信号量，用于表示系统中某种资源的数量。</p>
<ol>
<li>存在的问题：不满足“让权等待”原则，会发生忙等；</li>
</ol>
<h3 id="结构型信号量（重点）">结构型信号量（重点）</h3>
<p>结构型信号量有效解决了忙等的问题；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> value; <span class="comment">//剩余资源数</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">process</span> *L; <span class="comment">//等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait 原语申请*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S.value--;</span><br><span class="line">	<span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">block</span>(S.L); <span class="comment">//如果剩余资源数不够，则使用block原语使进程从运行态变成阻塞态，并将之挂到信号量S的等待/阻塞队列中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完成后，通过signal原语释放*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S.value++;</span><br><span class="line">	<span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">wakeup</span>(S.L); <span class="comment">//释放资源后，若还有别的程序在等待使用资源，则使用wakeup原语唤醒等待队列的进程；</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>优点：<br>
遵循了“让权等待”原则，不会出现忙等的现象；</li>
</ol>
<h2 id="信号量机制实现进程同步与互斥">信号量机制实现进程同步与互斥</h2>
<p>一个信号量对应了一种资源，信号量的值对应这种资源的剩余数量；</p>
<ul>
<li>P(S)，申请一个资源S，如果资源不够就阻塞等待</li>
<li>V(S)，释放一个资源S，如果有进程在等待，则<strong>唤醒一个进程</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">信号量机制实现 --&gt; 进程互斥 &amp; 进程同步 &amp; 进程的前驱关系</span><br></pre></td></tr></table></figure>
<h3 id="实现进程互斥">实现进程互斥</h3>
<p><strong>步骤</strong>：</p>
<ol>
<li>分析并发进程的关键活动</li>
<li>设置互斥信号量mutex，初值为1</li>
<li>在进入区 P 申请资源</li>
<li>在退出区 V 释放资源<br>
<strong>注意：</strong></li>
<li>对<strong>不同临界资源</strong>需要设置不同的互斥的信号量；</li>
<li>信号量的P，V操作必须成对出现；缺少P操作则不能保证临界资源的互斥访问，缺少V操作则会导致资源永不被释放，等待进程永不唤醒；</li>
</ol>
<h3 id="实现进程同步">实现进程同步</h3>
<p>进程同步：要让并发程序按要求有序地推进；（按照所需要的“顺序”并发执行）<br>
<strong>步骤：</strong></p>
<ol>
<li>分析什么地方需要实现“同步关系”，即找到必须保证“一前一后”执行的两个操作；</li>
<li>设置同步信号量S，初始值为0；</li>
<li>在“前操作”之后设置V(S)</li>
<li>在“后操作”之前设置P(S)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphora S = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">	code1;</span><br><span class="line">	code2;</span><br><span class="line">	<span class="built_in">V</span>(S);</span><br><span class="line">	code3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">	<span class="built_in">P</span>(S);</span><br><span class="line">	code4;</span><br><span class="line">	code5;</span><br><span class="line">	code6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现前驱关系">实现前驱关系</h3>
<p>假设S1，S2，S3…代码需要按照如下前驱关系执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">S1 --&gt; S2</span><br><span class="line">S2 --&gt; S4</span><br><span class="line">S2 --&gt; S5</span><br><span class="line">S1 --&gt; S3</span><br><span class="line">S4 --&gt; S6</span><br><span class="line">S5 --&gt; S6</span><br><span class="line">S3 --&gt; S6</span><br></pre></td></tr></table></figure>
<p>用信号量机制实现前驱关系思路步骤：<br>
其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），因此：</p>
<ol>
<li>要为每一对前驱关系各设置一个<strong>同步信号量</strong>；</li>
<li>前v后p</li>
</ol>
<h2 id="经典问题">经典问题</h2>
<h3 id="生产者——消费者问题">生产者——消费者问题</h3>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓存区，消费者进程每次从缓存区取出一个产品使用，初始时，生产者消费者共享一个初始为空，大小为n的缓存区；</p>
<ol>
<li>关系分析：找出题目中描述的各个进程，分析他们之间的同步互斥关系<br>
同步关系（一前一后）：<br>
只有缓存区没满时，生产者才可以放入产品；定义一种信号量资源empty=n<br>
只有缓存区不空时，消费者才可以消费产品；定义一种信号量资源full=0<br>
互斥关系：<br>
缓冲区时临界资源，各个进程对缓冲区的访问必须是互斥的；</li>
<li>根据各进程的操作流程确定P、V操作的大致顺序：<br>
生产者同步关系：在“放入产品”之前P empty，表示申请消耗一个empty资源；在“访入产品”之V full，表示已经生产一个full资源；<br>
消费者同步关系：在“取出产品”之前P full，表示申请消耗full资源；在“取出产品”之后V empty，表示已经产生一个empty资源；</li>
<li>设置信号量：<br>
互斥信号量初始值一般为1，同步信号量要看对应资源的初始值是多少；</li>
<li>代码实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥信号量</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">//同步信号量，表示产品数量</span></span><br><span class="line">semaphore empty = n; <span class="comment">//同步信号量，表示空闲缓冲区数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  生产一个产品;</span><br><span class="line">  <span class="built_in">P</span>(empty);<span class="comment">//空闲缓冲区-1</span></span><br><span class="line">  <span class="built_in">P</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  将产品放入缓冲区;</span><br><span class="line">  <span class="built_in">V</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">V</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">P</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line">  <span class="built_in">P</span>(mutex);</span><br><span class="line">  从缓冲区取出一个产品;</span><br><span class="line">  <span class="built_in">V</span>(mutex);</span><br><span class="line">  <span class="built_in">V</span>(empty);<span class="comment">//空闲缓冲区+1</span></span><br><span class="line">  消费一个产品;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="死锁">死锁</h4>
<p>思考一下上面的例子，如果先进行互斥资源的申请，再进行同步资源的申请会怎么样？<br>
假设此时缓冲区已经放满产品，则empty=0, full=n；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  生产一个产品;</span><br><span class="line">  <span class="built_in">P</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">P</span>(empty);<span class="comment">//空闲缓冲区-1</span></span><br><span class="line">  将产品放入缓冲区;</span><br><span class="line">  <span class="built_in">V</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">V</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">P</span>(mutex);</span><br><span class="line">  <span class="built_in">P</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line">  从缓冲区取出一个产品;</span><br><span class="line">  <span class="built_in">V</span>(mutex);</span><br><span class="line">  <span class="built_in">V</span>(empty);<span class="comment">//空闲缓冲区+1</span></span><br><span class="line">  消费一个产品;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，当进入生产者进程时，先申请临界区资源；然后申请empty资源，由于empty=0，即此时缓冲区已满而无法放产品，所以生产者进程由运行态转变为阻塞态；<br>
然后发生进程调度，进入消费者进程，消费者进程中，第一步申请临界区资源，由于临界区资源已经被生产者使用，mutex=0，此时消费者进程也由运行态转为阻塞态；<br>
于是发生了两个进程相互循环等待对方唤醒的情况！<br>
这种情况称为“死锁”。<br>
<strong>提醒：实现互斥的P操作一定要在实现同步的P操作之后。</strong></p>
<h3 id="多生产者—多消费者问题">多生产者—多消费者问题</h3>
<ol>
<li>关系分析：<br>
同步关系：
<ol>
<li>只有盘子为空时，爸爸才能往盘子里放苹果；</li>
<li>只有盘子为空时，妈妈才能往盘子里放橘子；</li>
<li>只有盘子里放苹果时，女儿才能拿走盘子里的苹果；</li>
<li>只有盘子里放橘子时，儿子才能拿走盘子里的橘子；<br>
互斥关系：</li>
<li>爸爸妈妈儿子女儿互斥访问盘子；</li>
</ol>
</li>
<li>确定P和V操作的大致顺序：<br>
前v后p</li>
<li>代码：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//空闲盘子数量，互斥资源</span></span><br><span class="line">semaphore empty = <span class="number">1</span>;<span class="comment">//空闲盘子数量，同步资源</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子里的苹果数量，同步资源</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子里的橘子数量，同步资源</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dad</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		削一个苹果;</span><br><span class="line">		<span class="built_in">P</span>(empty);</span><br><span class="line">		<span class="built_in">P</span>(mutex);</span><br><span class="line">		放一个苹果;</span><br><span class="line">		<span class="built_in">V</span>(mutex);</span><br><span class="line">		<span class="built_in">V</span>(apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mom</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		剥一个橘子;</span><br><span class="line">		<span class="built_in">P</span>(empty);</span><br><span class="line">		<span class="built_in">P</span>(mutex);</span><br><span class="line">		放一个橘子;</span><br><span class="line">		<span class="built_in">V</span>(mutex);</span><br><span class="line">		<span class="built_in">V</span>(orange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(apple);</span><br><span class="line">		<span class="comment">//P(mutex);</span></span><br><span class="line">		拿走一个苹果;</span><br><span class="line">		<span class="comment">//V(mutex);</span></span><br><span class="line">		<span class="built_in">V</span>(empty);</span><br><span class="line">		吃一个苹果;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">daughter</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(orange);</span><br><span class="line">		<span class="comment">//P(mutex);</span></span><br><span class="line">		拿走一个橘子;</span><br><span class="line">		<span class="comment">//V(mutex);</span></span><br><span class="line">		<span class="built_in">V</span>(empty);</span><br><span class="line">		吃一个橘子;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽烟者问题">抽烟者问题</h3>
<ol>
<li>关系分析：<br>
同步关系：
<ol>
<li>只有盘子上放的是纸和胶水的时候，1号抽烟者才能取走材料；</li>
<li>只有盘子上放的是烟草和胶水的时候，2号抽烟者才能取走材料；</li>
<li>只有盘子上放的是纸和烟草的时候，3号抽烟者才能取走材料；</li>
<li>只有其中一个抽烟者抽完烟通知生产者的时候，生产者才能放材料；<br>
互斥关系：</li>
<li>无，因为是单生产者</li>
</ol>
</li>
<li>确定P和V的大致操作</li>
<li>代码：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">//1号需要的资源信息量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">//2号需要的资源信息量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">//3号需要的资源信息量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//生产者需要的资源信息量</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现“轮流抽烟”</span></span><br><span class="line"><span class="built_in">provider</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">			放入offer1;</span><br><span class="line">			<span class="built_in">V</span>(offer1);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">			放入offer2;</span><br><span class="line">			<span class="built_in">V</span>(offer2);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">			放入offer3;</span><br><span class="line">			<span class="built_in">V</span>(offer3);</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		i = i%<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">P</span>(finish);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer1</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(offer1);</span><br><span class="line">		拿走offer1;</span><br><span class="line">		<span class="built_in">V</span>(finish);</span><br><span class="line">		消费offer1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer2</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(offer2);</span><br><span class="line">		拿走offer2;</span><br><span class="line">		<span class="built_in">V</span>(finish);</span><br><span class="line">		消费offer2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer3</span>()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">P</span>(offer3);</span><br><span class="line">		拿走offer3;</span><br><span class="line">		<span class="built_in">V</span>(finish);</span><br><span class="line">		消费offer3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者—写者问题">读者—写者问题</h3>
<h3 id="哲学家进餐问题">哲学家进餐问题</h3>
<h1>死锁</h1>
<h2 id="相关概念-2">相关概念</h2>
<h3 id="概念辨析">概念辨析</h3>
<ol>
<li>死锁：<br>
各进程互相等待对方手里的资源，导致各个进程都阻塞，无法向前推进的现象；<br>
如果产生死锁现象，至少有两个或两个以上的进程同时发生死锁；</li>
<li>饥饿：<br>
由于长期得不到想要的资源，某进程无法向前推进的现象；<br>
可能只有一个进程发生饥饿；</li>
<li>死循环：<br>
某程序执行过程中一直跳不出来某个循环的现象。有时是程序逻辑bug导致的；<br>
死循环的进程是可以上处理机运行的（可以是运行态），死循环是程序员的问题，不是操作系统的问题；</li>
</ol>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<ol>
<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</li>
<li>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但是又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
<li>循环等待条件：存在一种进程资源的循环等待链</li>
</ol>
<h3 id="死锁的处理策略">死锁的处理策略</h3>
<ol>
<li>预防死锁：破坏死锁产生的四个必要条件之一；</li>
<li><strong>避免死锁：用某种方法组织系统进入不安全状态，从而避免死锁（银行家算法）</strong>；</li>
<li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出思索的发生，然后采取某种措施解除死锁；</li>
</ol>
<h2 id="死锁处理的策略——预防死锁">死锁处理的策略——预防死锁</h2>
<ol>
<li>互斥条件——SPOOLing法逻辑上将互斥资源改为逻辑上共享资源</li>
<li>不可剥夺条件——</li>
<li>请求和保持条件——静态分配方法，即在运行前一次申请完它所需要的资源</li>
<li>循环等待条件——顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完</li>
</ol>
<h2 id="死锁处理的策略——避免死锁">死锁处理的策略——避免死锁</h2>
<h3 id="银行家算法（重点）">银行家算法（重点）</h3>
<ul>
<li>[ ] TODO，代码实现</li>
</ul>
<h2 id="死锁处理的策略——检测死锁">死锁处理的策略——检测死锁</h2>
<p>资源分配图是否可完全简化</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Cyrus</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/03/21/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/">http://example.com/2024/03/21/课程内学习/【操作系统】2. 处理器管理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">半栈日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div class="post_share"><div class="social-share" data-image="/self_img/head_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/" title="【数据库系统】2. 关系代数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【数据库系统】2. 关系代数</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/20/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%911.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/" title="【深度学习】1. 机器学习和深度学习综述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【深度学习】1. 机器学习和深度学习综述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="【数据库系统】1. 基本概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">【数据库系统】1. 基本概念</div></div></a></div><div><a href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%911.%20%E5%89%8D%E5%AF%BC/" title="【编译原理】1. 前导"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-08</div><div class="title">【编译原理】1. 前导</div></div></a></div><div><a href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%913.%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/" title="【编译原理】3. 有穷自动机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-08</div><div class="title">【编译原理】3. 有穷自动机</div></div></a></div><div><a href="/2024/03/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%914.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89/" title="【编译原理】4. 语言和文法的形式定义"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-29</div><div class="title">【编译原理】4. 语言和文法的形式定义</div></div></a></div><div><a href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%915.%20%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="【编译原理】5. 自顶而下的分析方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">【编译原理】5. 自顶而下的分析方法</div></div></a></div><div><a href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%916.%20%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="【编译原理】6. 自底向上的分析方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">【编译原理】6. 自底向上的分析方法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="this.onerror=null;this.src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cyrus</div><div class="author-info__description">保持好奇，持续输出</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ICserD"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ICserD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2862081626@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_73546177" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">进程的概念、组成、特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5"><span class="toc-number">1.0.1.</span> <span class="toc-text">感性认知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.0.2.</span> <span class="toc-text">PCB 进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%84%E6%88%90"><span class="toc-number">1.0.3.</span> <span class="toc-text">进程的概念和组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.0.4.</span> <span class="toc-text">进程的特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">进程的状态与转换、进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-%E2%80%94%E2%80%94-%E5%88%9B%E5%BB%BA%E6%80%81%EF%BC%8C%E5%B0%B1%E7%BB%AA%E6%80%81%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%80%81%EF%BC%8C%E9%98%BB%E5%A1%9E%E6%80%81%EF%BC%8C%E7%BB%88%E6%AD%A2%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">进程的状态 —— 创建态，就绪态，运行态，阻塞态，终止态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">进程状态的转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87-%E2%80%94%E2%80%94-%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">进程的组织 —— 链接方式，索引方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%A6%82%E8%A7%88"><span class="toc-number">3.1.</span> <span class="toc-text">进程控制概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.2.</span> <span class="toc-text">进程控制原语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">4.1.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">4.2.</span> <span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">4.3.</span> <span class="toc-text">管道通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">引入线程之后的变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">线程的实现方式和多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">5.2.1.</span> <span class="toc-text">概览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">用户级线程和内核级线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">多对多模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.5.</span> <span class="toc-text">线程的状态与转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">5.6.</span> <span class="toc-text">处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">5.6.1.</span> <span class="toc-text">调度的三个层次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">5.7.</span> <span class="toc-text">进程调度的时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">作业（补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.8.1.</span> <span class="toc-text">相关概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.</span> <span class="toc-text">调度算法的评价指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E6%89%B9%E5%A4%84%E7%90%86%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">早期批处理调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88"><span class="toc-number">6.2.1.</span> <span class="toc-text">知识总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-number">6.2.2.</span> <span class="toc-text">短作业优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">高响应比优先算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">知识总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC"><span class="toc-number">6.3.2.</span> <span class="toc-text">时间片轮转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.3.</span> <span class="toc-text">优先级调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7-%E9%9D%99%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">动态优先级&#x2F;静态优先级调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.4.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">进程同步和进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.</span> <span class="toc-text">进程互斥的四个原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">7.2.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">7.3.</span> <span class="toc-text">进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">进程互斥的软件实现方法（了解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E6%A6%82%E8%A7%88"><span class="toc-number">7.4.1.</span> <span class="toc-text">知识概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">7.4.2.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">7.4.3.</span> <span class="toc-text">双标志先检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">7.4.4.</span> <span class="toc-text">双标志后检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">7.4.5.</span> <span class="toc-text">Peterson算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">进程互斥的硬件实现方法（了解即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.1.</span> <span class="toc-text">中断屏蔽方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestAndSet%E6%8C%87%E4%BB%A4"><span class="toc-number">7.5.2.</span> <span class="toc-text">TestAndSet指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap%E6%8C%87%E4%BB%A4"><span class="toc-number">7.5.3.</span> <span class="toc-text">Swap指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">7.5.4.</span> <span class="toc-text">互斥锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">信号量机制（重中之重）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">8.0.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">8.0.2.</span> <span class="toc-text">结构型信号量（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">8.1.</span> <span class="toc-text">信号量机制实现进程同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">8.1.1.</span> <span class="toc-text">实现进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">8.1.2.</span> <span class="toc-text">实现进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.3.</span> <span class="toc-text">实现前驱关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text">经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.1.</span> <span class="toc-text">生产者——消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.2.</span> <span class="toc-text">多生产者—多消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.3.</span> <span class="toc-text">抽烟者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.4.</span> <span class="toc-text">读者—写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.5.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5-2"><span class="toc-number">9.1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="toc-number">9.1.1.</span> <span class="toc-text">概念辨析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">9.1.2.</span> <span class="toc-text">死锁产生的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">9.1.3.</span> <span class="toc-text">死锁的处理策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%9A%84%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">9.2.</span> <span class="toc-text">死锁处理的策略——预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%9A%84%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">9.3.</span> <span class="toc-text">死锁处理的策略——避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">9.3.1.</span> <span class="toc-text">银行家算法（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%9A%84%E7%AD%96%E7%95%A5%E2%80%94%E2%80%94%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81"><span class="toc-number">9.4.</span> <span class="toc-text">死锁处理的策略——检测死锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/08/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91%E9%85%8D%E7%BD%AE%20python%20%E7%8E%AF%E5%A2%83/" title="0 基础配置 Python 环境">0 基础配置 Python 环境</a><time datetime="2025-11-08T07:00:00.000Z" title="发表于 2025-11-08 15:00:00">2025-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%914.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/" title="【深度学习】4. 深度学习计算">【深度学习】4. 深度学习计算</a><time datetime="2024-11-16T07:00:00.000Z" title="发表于 2024-11-16 15:00:00">2024-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%915.%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="【深度学习】5. 卷积神经网络（CNN）">【深度学习】5. 卷积神经网络（CNN）</a><time datetime="2024-10-18T07:00:00.000Z" title="发表于 2024-10-18 15:00:00">2024-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%913.%20%E5%A4%9A%E5%B1%82%E6%AC%A1%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="【深度学习】3. 多层次感知机">【深度学习】3. 多层次感知机</a><time datetime="2024-10-16T07:00:00.000Z" title="发表于 2024-10-16 15:00:00">2024-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%912.%20%E7%BA%BF%E6%80%A7%E7%BD%91%E7%BB%9C/" title="【深度学习】2. 线性网络">【深度学习】2. 线性网络</a><time datetime="2024-10-16T07:00:00.000Z" title="发表于 2024-10-16 15:00:00">2024-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/self_img/11c.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Cyrus</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>