<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【数据库系统】7. 期末考点整理 | 半栈日记</title><meta name="author" content="Cyrus"><meta name="copyright" content="Cyrus"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章——数据库系统概述 1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？ 数据：用以描述事务性质的符号 数据库：一个相互联合的数据的集合 数据的重要特点：数据是相互联系的 数据库管理系统：  广义的数据库管理系统包括：相互联系的数据集合以及存取和管理这些数据的一套程序，即数据库和数据库管理系统软件 一般的数据库管理系统：仅指数据库管理系">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据库系统】7. 期末考点整理">
<meta property="og:url" content="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="半栈日记">
<meta property="og:description" content="第一章——数据库系统概述 1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？ 数据：用以描述事务性质的符号 数据库：一个相互联合的数据的集合 数据的重要特点：数据是相互联系的 数据库管理系统：  广义的数据库管理系统包括：相互联系的数据集合以及存取和管理这些数据的一套程序，即数据库和数据库管理系统软件 一般的数据库管理系统：仅指数据库管理系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/self_img/head_img.jpg">
<meta property="article:published_time" content="2024-06-29T00:00:00.000Z">
<meta property="article:modified_time" content="2024-06-29T00:50:00.000Z">
<meta property="article:author" content="Cyrus">
<meta property="article:tag" content="课程学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/self_img/head_img.jpg"><link rel="shortcut icon" href="/self_img/bollon.png"><link rel="canonical" href="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【数据库系统】7. 期末考点整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-29 08:50:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="onerror=null;src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/self_img/11c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="半栈日记"><span class="site-name">半栈日记</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【数据库系统】7. 期末考点整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-29T00:50:00.000Z" title="更新于 2024-06-29 08:50:00">2024-06-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【数据库系统】7. 期末考点整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第一章——数据库系统概述">第一章——数据库系统概述</h2>
<h3 id="1、四个概念：什么是数据-什么是数据库-什么是数据库管理系统（DBMS）？什么是数据库系统-DBS-？">1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？</h3>
<p><strong>数据</strong>：用以描述事务性质的符号<br>
<strong>数据库</strong>：一个相互联合的数据的集合<br>
数据的重要特点：数据是相互联系的<br>
<strong>数据库管理系统</strong>：</p>
<ul>
<li>广义的数据库管理系统包括：相互联系的数据集合以及存取和管理这些数据的一套程序，即<strong>数据库</strong>和<strong>数据库管理系统软件</strong></li>
<li>一般的数据库管理系统：仅指数据库管理系统软件<br>
<strong>数据库系统</strong>：是指以<strong>数据库</strong>为核心的整个计算机系统。其目的是向用户提供方便、高效、可靠的存取数据的功能。</li>
</ul>
<p>DBMS的功能：</p>
<ol>
<li>数据组织定义</li>
<li>数据操作与查询优化</li>
<li>数据管理以及维护</li>
<li>事务管理和运行控制</li>
<li>对外提供多种接口（实用工具）</li>
</ol>
<h3 id="2、熟记数据库系统的组成。">2、熟记数据库系统的组成。</h3>
<p><strong>数据库系统的组成</strong>：</p>
<ol>
<li>数据库</li>
<li>硬件：CPU、内存…</li>
<li>软件：DBMS，操作系统，数据库应用程序…</li>
<li>人员：数据库管理人员DBA，应用程序员，用户</li>
</ol>
<h3 id="3、理解DBA是对数据库进行集中控制和管理的最重要人员。">3、理解DBA是对数据库进行集中控制和管理的最重要人员。</h3>
<p>数据库管理员（DBA）是整个数据库系统进行集中控制和管理的人员，是系统中最重要的人员。<br>
<strong>数据库管理员的具体职责</strong>：</p>
<ol>
<li>数据库设计：决定数据库中的信息结构和内容</li>
<li>数据库维护：维护数据的安全性、完整性，以及<strong>并发控制、故障恢复</strong>等等</li>
<li>改善系统性能：监视系统性能变化，在性能下降时找出瓶颈所在，并解决问题</li>
</ol>
<h3 id="4、实例和模式的对比（内容-状态-vs-结构，变化-vs-稳定）">4、实例和模式的对比（内容/状态 vs 结构，变化 vs 稳定）</h3>
<p><strong>数据模式</strong>：数据库/表的结构（比如表中有什么字段，关系有什么属性）<br>
<strong>实例</strong>：数据库/表在特定时刻的内容<br>
<strong>区别：</strong></p>
<ol>
<li>对于一个数据库/表，由于记录不断地插入/删除/更新，所以它的实例（内容）是变化的，但模式（结构）是稳定的</li>
</ol>
<h3 id="5、熟记5和6全部内容三级模式的名称和定义（注意物理模式又称内模式，逻辑模式又称模式，子模式又称外模式）。三级模式的数量：一个数据库有几个物理模式，逻辑模式和子模式？-三级模式间的两极映射？由谁（DMBS）来完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——">5、熟记5和6全部内容三级模式的名称和定义（注意物理模式又称内模式，逻辑模式又称模式，子模式又称外模式）。三级模式的数量：一个数据库有几个物理模式，逻辑模式和子模式？ 三级模式间的两极映射？由谁（DMBS）来完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——</h3>
<h4 id="三级模式结构">三级模式结构</h4>
<p>三级模式结构主要是指数据抽象分为内模式、模式、外模式三级结构。<br>
<strong>一、内模式</strong>（又称物理模式、存储模式）<br>
<strong>定义</strong>：整体数据库的物理/存储结构，描述全体数据在硬盘等介质上如何存储。<br>
==一个数据库只有一个内模式==</p>
<p><strong>二、模式</strong>（又称逻辑模式）<br>
<strong>定义</strong>：整体数据库的逻辑结构，描述所有数据的结构和数据间的联系，向下屏蔽了物理模式，即不需要知道数据的物理存储结构。<br>
==一个数据库只有一个模式==</p>
<p><strong>三、外模式</strong>（也称子模式、用户模式）<br>
<strong>定义</strong>：</p>
<ul>
<li>外模式是一部分数据库的逻辑结构，即特定用户能看到的部分，描述这部分数据的结构和彼此间的关系；</li>
<li>向下屏蔽了逻辑模式，即不需要知道其他的数据结构和联系；</li>
<li>外模式等同于用户模式，实际上是逻辑模式的子集，逻辑模式是所有外模式之和<br>
==一个数据库可以有多个外模式，外模式是保障数据安全性的一个有力措施==</li>
</ul>
<h4 id="三级模式结构的两级映射">三级模式结构的两级映射</h4>
<p><strong>DBMS</strong>内部在这三种模式之间提供两级映射功能，以实现上下模式间的联系和转换，分别是<strong>模式/内模式映射</strong>和<strong>外模式/模式映射</strong>。<br>
==DBMS数据库管理系统来完成这种映射==</p>
<h4 id="两级映射的优点">两级映射的优点</h4>
<ol>
<li>保证了数据的物理独立性：<br>
当数据库的物理存储结构发生改变时（如存储位置发生改变），应用程序不发生变化。<br>
<strong>原因</strong>：当内模式改变时，（DBA手动或者DBMS自动地修改模式/内模式映像，最终使）模式保持不变；</li>
<li>保证了数据逻辑的独立性：<strong>外模式/概念模式映射就是逻辑独立性的关键</strong><br>
当数据库整体逻辑结构改变时（如字段的增减，字段名的修改），应用程序不一定要改变。<br>
<strong>原因</strong>：当模式改变时，（DBA手动或DBMS自动地修改外模式/模式映像，最终使）外模式<strong>可能</strong>保持不变；</li>
</ol>
<h3 id="6、什么是逻辑数据独立性？什么是物理数据独立性？这两种数据独立性，分别是怎么实现的？（用到的A模式-B模式映射搞清楚，当…变…不变的过程也搞清楚）">6、什么是逻辑数据独立性？什么是物理数据独立性？这两种数据独立性，分别是怎么实现的？（用到的A模式/B模式映射搞清楚，当…变…不变的过程也搞清楚）</h3>
<h4 id="逻辑独立性和物理独立性的概念">逻辑独立性和物理独立性的概念</h4>
<ol>
<li>物理逻辑独立性：<br>
当数据库的物理存储结构发生改变时（如存储位置发生改变），应用程序不发生变化。<br>
<strong>原因</strong>：当内模式改变时，（DBA手动或者DBMS自动地修改模式/内模式映像，最终使）模式保持不变；</li>
<li>逻辑数据的独立性：<strong>外模式/概念模式映射就是逻辑独立性的关键</strong><br>
当数据库整体逻辑结构改变时（如字段的增减，字段名的修改），应用程序不一定要改变。<br>
<strong>原因</strong>：当模式改变时，（DBA手动或DBMS自动地修改外模式/模式映像，最终使）外模式可能保持不变；<br>
==数据库系统（DBMS）通过两个子系统：DBCS（Data Controlling System）和DBSS（Data Storage System）来实现三级模式的结构和两级映射的功能。==</li>
</ol>
<h3 id="7、用户或者应用程序面向的到底是哪一级数据库模式？">7、用户或者应用程序面向的到底是哪一级数据库模式？</h3>
<p>用户或者应用程序面向的是外模式。</p>
<h3 id="8、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。">8、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。</h3>
<h4 id="模型的基本概念">模型的基本概念</h4>
<p>模型是对现实世界某些事物和特征的模拟和抽象，数据模型用于描述数据结构、数据联系、数据语义和数据约束的一套工具和方法。</p>
<h4 id="区分数据模型、数据模式、数据实例">区分数据模型、数据模式、数据实例</h4>
<table>
<thead>
<tr>
<th></th>
<th>数据模型</th>
<th>数据模式</th>
<th>数据实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>描述数据结构与联系的方法</td>
<td>某一数据库的结构与联系(用数据模型描述的结果)</td>
<td>遵循以上结构的数据库，在某一时点的内容/状态<br></td>
</tr>
<tr>
<td>对比理解</td>
<td>程序语言(例如, PHP)</td>
<td>开发的一套程序(例如, 新闻网站)</td>
<td>程序运行到某一时点(例如, 今日的新闻网站)</td>
</tr>
</tbody>
</table>
<h4 id="数据模型的层次分类">数据模型的层次分类</h4>
<p><strong>一、概念数据模型</strong>（概念模型、信息模型）</p>
<ul>
<li>概念数据模型是对现实世界的建模，与具体的数据库/DBMS无关</li>
<li>用于数据库设计，是设计人员与用户交流的基本工具<br>
<strong>最常见的例子</strong>：<strong>ER图</strong></li>
</ul>
<p><strong>二、逻辑数据模型</strong>（结构数据模型）</p>
<ul>
<li>对数据库里的数据（的逻辑结构）建模，与具体的DBMS有关，每种DBMS至少支持一种特定的逻辑数据结构模型</li>
<li>通过适当的方法，可以将概念数据模型转化为逻辑数据模型<br>
<strong>最常见的例子</strong>：<strong>关系模型</strong><br>
==如无特别说明，以后讲到数据库模型，专指逻辑数据模型==</li>
</ul>
<p><strong>三、物理数据模型</strong></p>
<ul>
<li>对数据在物理介质的存储方法和组织结构建模，不仅与具体的DBMS有关，还与具体硬件和操作系统有关</li>
<li>DBMS能够自动完成大部分物理数据模型的工作，即自动将逻辑数据模型映射为物理数据模型。</li>
</ul>
<h4 id="（逻辑）数据模型的三要素">（逻辑）数据模型的三要素</h4>
<ol>
<li>数据结构
<ul>
<li>数据的<strong>组织方式和相互联系</strong></li>
<li>系统的静态特性</li>
</ul>
</li>
<li>数据操作
<ul>
<li>对各种数据对象所允许执行的操作以及有关的操作规则</li>
<li>系统的动态特性</li>
</ul>
</li>
<li>数据完整性约束
<ul>
<li>一组约束条件的集合</li>
<li>强制约束数据的状态以及状态变化符合这些约束条件，以保证数据的正确、有效、相容</li>
</ul>
</li>
</ol>
<h4 id="常见的数据模型">常见的数据模型</h4>
<ol>
<li>格式化模型：
<ul>
<li>层次模型</li>
<li>网状模型</li>
</ul>
</li>
<li>经典数据模型：
<ul>
<li>关系模型</li>
</ul>
</li>
<li>新型数据模型：
<ul>
<li>对象数据模型</li>
<li>对象关系模型</li>
</ul>
</li>
</ol>
<h2 id="第二章">第二章</h2>
<h3 id="1、数据模型的三要素？关系模型的三要素？">1、数据模型的三要素？关系模型的三要素？</h3>
<h4 id="数据模型三要素">数据模型三要素</h4>
<ol>
<li>数据结构</li>
<li>数据操作</li>
<li>数据完整性约束</li>
</ol>
<h4 id="关系模型三要素">关系模型三要素</h4>
<ol>
<li>关系（关系的数据结构）</li>
<li>关系操作（关系的数据操作）</li>
<li>关系完整性约束（关系的数据完整性约束）</li>
</ol>
<h4 id="关系模型的相关概念">关系模型的相关概念</h4>
<p>关系模型是一种常见的（逻辑）数据模型，<strong>数据结构为二维表（关系）</strong>，可以表示任意实体以及实体间的联系。<br>
一、关系模型的数据结构</p>
<ul>
<li>在关系模型中，数据结构是若干二维表，二维表又称关系，由行（元组）和列（关系）组成</li>
<li>关系既可以表示实体，又可以表示实体间的联系</li>
</ul>
<p>二、关系模型的数据操作<br>
关系模型的数据数据操作包括：</p>
<ul>
<li>查询</li>
<li>插入</li>
<li>删除</li>
<li>更新<br>
数据操作的对象和结构都是关系，所以是<strong>集合操作</strong>（关系=许多元组的集合）<br>
<strong>存取路径对用户透明</strong>，用户只要指出“做什么”，不需要说明或知道“怎么做”的过程和细节（<strong>非过程化</strong>）</li>
</ul>
<p>三、关系模型的完整性约束</p>
<ul>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义完整性</li>
</ul>
<h4 id="关系模型的优缺点">关系模型的优缺点</h4>
<ol>
<li>优点：
<ul>
<li>建立在严格的数学基础上</li>
<li>概念单一，实体和各类联系都用关系表示、对数据的检索结果也是关系</li>
<li>关系模型的存取路径对用户透明，具有更高的数据独立性，更好的安全保密性；简化了程序员的工作和数据库开发建立的工作</li>
</ul>
</li>
<li>缺点：
<ul>
<li>存取路径对用户透明导致<strong>查询效率</strong>往往不如非关系数据模型</li>
<li>为了提高性能，必须对用户的<strong>查询请求</strong>进行<strong>优化</strong>，增加了开发DBMS的难度</li>
</ul>
</li>
</ol>
<h3 id="2、关系的组成：什么是属性？什么是元组？什么是分量？">2、关系的组成：什么是属性？什么是元组？什么是分量？</h3>
<h4 id="关系的相关概念">关系的相关概念</h4>
<h4 id="关系的组成">关系的组成</h4>
<p>关系是一个命名的二维表，由以下部分组成：</p>
<ul>
<li>关系有名字，即关系名</li>
<li>关系的一列是<strong>属性</strong>，属性有名字（属性名）</li>
<li>关系的一行是<strong>元组</strong></li>
<li><strong>分量</strong>是行和列的交叉，或者说，分量是某个元组的某个属性值</li>
</ul>
<p>注意其他概念：</p>
<ul>
<li>关系的度：属性的个数</li>
<li>关系的基数：元组的个数</li>
<li>（属性的）域：该属性的取值集合（范围）</li>
</ul>
<h3 id="3、理解关系有哪些基本性质？">3、理解关系有哪些基本性质？</h3>
<h4 id="关系的性质（关系必须满足的条件）">关系的性质（关系必须满足的条件）</h4>
<ol>
<li>列的同质性：同一列中的分量（值）必须具有相同的类型，因为它们来自同一个域</li>
<li>异列同域性：不同列可以来自同一个域，但属性名不能相同</li>
<li>元组相异性：关系里的任意两行不能相同，因为关系是一个元组集合（数学上严格禁止，但是实际数据库里面可以容忍重复）</li>
<li>行列无序性：关系的行或列是顺序无关的。即改变行或列的次序（例如交换两行或者两列），关系不会变</li>
<li>属性值原子性：每一个属性值(分量)都必须是原子的(不可分)，不允许出现组合数据，更不允许“表中有表”。满足该条件的关系称作第一范式</li>
</ol>
<h3 id="4、关系有哪四种码？数量（一或多个）？并能根据定义判定！外部码从E-R图的什么概念转化而来？外部码的属性名可以和所对应的主码不同，外部码可以指向同一个关系的主码。例如：学生（学号，姓名，班长学号…）。">4、关系有哪四种码？数量（一或多个）？并能根据定义判定！外部码从E-R图的什么概念转化而来？外部码的属性名可以和所对应的主码不同，外部码可以指向同一个关系的主码。例如：学生（学号，姓名，班长学号…）。</h3>
<h4 id="关系的码">关系的码</h4>
<ol>
<li>超码：关系中能够唯一标识每个元组的属性或者属性组</li>
<li>候选码：最小的超码（一个超码可能含有多余的属性）</li>
<li>主码：虽然在一个关系中里可能存在几个候选码，但是只<strong>选出一个作为主码</strong></li>
<li>外部码：关系R1中的属性或属性组，对应关系R2的主码，R1称为参照关系，R2称为被参照关系
<ul>
<li>外部码的属性名，和对应主码的属性名不一定要相同<br>
（外部码参照对应的主码，是属性值的参照，不是属性名的参照）</li>
<li>外部码的<strong>取值（范围）</strong>，就是对应主码的取值（范围），<strong>以此判断外部码</strong></li>
<li><strong>外部码反映联系</strong>，一个元组的外部码，说明了它是和另外的哪一个（主码）元组相联系的</li>
</ul>
</li>
</ol>
<h4 id="外部码与E-R图的关系">外部码与E-R图的关系</h4>
<p>外部码是从E-R图的联系的概念中转化而来</p>
<h4 id="外部码的判别依据">外部码的判别依据</h4>
<ol>
<li>该属性是不是某个关系的主码（能唯一决定该关系的一个元组的最小的候选码之一）</li>
<li>该属性与对应关系的域是否相同（值的范围是否一致）<br>
满足以上两个条件即可判别是否为外部码</li>
</ol>
<h3 id="5、关系模式和关系实例的对比。">5、关系模式和关系实例的对比。</h3>
<h4 id="关系模式的定义">关系模式的定义</h4>
<p>一、关系模式是关系的逻辑设计（数据结构、数据关系的设计）<br>
二、关系模式的完整定义：<br>
<code>R(U, D, dom, F)</code></p>
<ul>
<li>R: 关系名</li>
<li>U: 关系的属性的集合</li>
<li>D: 域的集合</li>
<li>dom: 属性到域的映射（每个属性属于什么域）</li>
<li>F: 属性间依赖关系的集合<br>
简记为：<code>R(A1,A2,...)</code>，其中A为关系中的所有属性</li>
</ul>
<h4 id="关系实例的定义">关系实例的定义</h4>
<ul>
<li>关系实例是关系在某一特定时刻的状态，强调具体的关系内容</li>
<li>我们提到的关系有时指关系实例，有时指关系模式</li>
</ul>
<h4 id="关系模式与关系实例的对比">关系模式与关系实例的对比</h4>
<ul>
<li>关系模式比较稳定，关系实例随时间变化</li>
</ul>
<h3 id="6、关系操作分为查询和更新操作。表示关系操作的语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。">6、关系操作分为查询和更新操作。表示关系操作的语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。</h3>
<h4 id="关系操作的类型">关系操作的类型</h4>
<p>一、查询操作</p>
<ul>
<li>查询操作是静态操作，在一个关系内或多个关系间检索/定位数据，但不改变原有数据<br>
二、修改操作</li>
<li>动态操作，改变一个关系的数据<br>
三、两类操作的关系</li>
<li>查询操作是修改操作的基础，修改操作实际是对查询操作定位后的结果进行修改</li>
</ul>
<h4 id="关系操作的表示——查询语言">关系操作的表示——查询语言</h4>
<p>一、关系操作是通过某一种查询语言来表示的，比如关系代数、关系演算</p>
<ul>
<li>关系代数：用一组对关系的运算来表示查询和修改</li>
<li><strong>关系演算：用谓词演算来表示查询和修改，根据谓词的不同，又分为元组演算和域演算</strong><br>
二、查询语言的分类</li>
<li>过程化：
<ol>
<li>用户要指定查询什么</li>
<li>怎么查询，用什么方法</li>
</ol>
</li>
<li>非过程化：
<ol>
<li>用户只需要指定要查询什么</li>
<li>系统自动返回查询的内容<br>
查询优化：寻找（近似）最优的查询方法就是查询优化<br>
<strong>关系代数是过程化的，而SQL和关系演算是非过程化的</strong></li>
</ol>
</li>
</ul>
<h3 id="7、过程化和非过程化语言的区分和理解——看课件。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。">7、过程化和非过程化语言的区分和理解——看课件。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。</h3>
<h3 id="8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？可以替代的运算，是怎么用其它运算的组合式子来替代的？">8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？可以替代的运算，是怎么用其它运算的组合式子来替代的？</h3>
<h4 id="关系代数概述">关系代数概述</h4>
<p>一、代数系统</p>
<ul>
<li>代数系统包括运算对象和基于对象的一组运算</li>
<li>特点：运算封闭性<br>
二、关系代数<br>
关系代数也是一个代数系统，关系代数的运算对象是关系，并且关系代数是封闭的，任何关系运算的结果还是一个关系</li>
</ul>
<h4 id="关系运算的分类">关系运算的分类</h4>
<ol>
<li>基本运算
<ul>
<li>选择: 输出无名字的关系，保留输入关系的全部属性，但只包含哪些满足条件的元组</li>
<li>投影: 从输入关系r产生一个仅包含r中某些属性的新关系，并<strong>消去重复元素</strong></li>
<li>笛卡尔积、集合并、集合差、更名</li>
</ul>
</li>
<li>附加运算：非基本的、可替代的运算，可以用基本运算组合来替换
<ul>
<li><strong>集合交</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \cap S = R - (R-S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></li>
<li><strong>自然连接</strong>: 一种特殊的连接运算，连接条件是（两边元组的）同名属性相等，并且在连接结果中<strong>去掉重复的同名属性</strong>（其他连接运算没有去重这一点）<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo>⋈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∏</mo><mrow><mi>A</mi><mo separator="true">,</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo separator="true">,</mo><mi>E</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>R</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>∧</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi><mi>D</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A, B, C, D) \Join S(B, D, E) = \prod_{A, R.B, C, R.D, E}(\sigma_{R.B=S.B\wedge R.D=S.D}(R \times S))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">∧</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">))</span></span></span></span></li>
<li><strong>除</strong>: 是笛卡尔积的逆运算</li>
<li><strong>赋值</strong></li>
</ul>
</li>
<li>扩展运算: 前两种基础上对运算能力进行扩展和增强
<ul>
<li>广义投影: 对投影运算的扩展，在属性列表中允许使用表达式构造新属性</li>
<li><strong>外连接</strong>: 外连接是对自然连接的扩展</li>
<li>聚集运算</li>
</ul>
</li>
<li>一元运算
<ul>
<li>输入为一个关系</li>
</ul>
</li>
<li>二元运算
<ul>
<li>输入为两个关系</li>
</ul>
</li>
</ol>
<h4 id="外连接？">外连接？</h4>
<p>一、为什么要扩展自然连接，产生外连接？<br>
自然连接可能会造成信息的丢失。造成信息丢失的根本原因在于自然连接只会保留关系在相同属性上有相同值的元组。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809094059.png" alt="Pasted image 20240809094059"><br>
二、外连接的基本内容</p>
<ul>
<li>外连接：
<ul>
<li>因为自然连接运算的结果不包括那些失配的元组，造成信息丢失</li>
<li>为了避免这种情况，把失配的元组连接上一个空元组（所有属性值为NULL），添加到结果关系中去，这就是外连接运算</li>
</ul>
</li>
<li>外连接的三种类型：
<ul>
<li>左外连接 = 自然连接 + 左侧失配元组（与空元组连接）</li>
<li>右外连接 = 自然连接 + 右侧失配元组</li>
<li>全外连接 = 自然连接 + 两侧失配元组</li>
</ul>
</li>
<li>计算外连接的方法：
<ol>
<li>计算自然连接</li>
<li>加上失配元组</li>
</ol>
</li>
</ul>
<h4 id="聚集函数">聚集函数</h4>
<p>一、聚集函数的基本概念</p>
<ol>
<li>输入：一个值的“集合”，因为相同值可以出现多次，这样的“集合”称为多重集</li>
<li>输出：单一值，如：<br>
sum<br>
count<br>
avg<br>
max<br>
min</li>
<li>如果希望在计算中忽略重复值，则应该在函数名后面加上 -distinct，比如count-distinct就表示计算多重集中的不同值的个数<br>
二、聚集运算<br>
<strong>聚集运算的形式</strong>通常如下：</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow></mrow><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>F</mi><mi>m</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{G_1,G_2,...,G_n}\mathcal{G}_{F_1(A_1),F_2(A_2),...,F_m(A_m)}(E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中，E是关系代数表达式，也可以理解为一个未命名的关系，实际上也是元组集合；<br>
F是聚集函数，A是E的属性；<br>
G是用于分组的一系列属性；</p>
<p><strong>该运算的计算过程</strong>：<br>
先分组：</p>
<ul>
<li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的值相同的元组，分为同一组；</li>
<li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的值不同的元组，分为不同组；<br>
再统计：<br>
各组属性可以由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值唯一标识；<br>
对于每一个组来说，其结果都有且仅有一个结果（因为聚集函数接受一个元组集合，返回一个值）元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>g</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>m</mi></msub><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（g_1,g_2,g_3,...g_n,a_1,a_2,...,a_m）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span> ，其中每个a都是由聚集函数F作用于该组所有元素在A属性上的结果；<br>
<strong>聚集运算的结果</strong>：</li>
<li>一个新关系，属性有m + n个，前 n 个属性来自左下标的分组属性，后 m 个来自右下标的聚集函数（新属性无属性名，或用 as 命名）</li>
<li>（第二步中）原来关系被分成多少组，最后结果关系中就有多少个元组。因为每一个分组被统计为结果中的一个元组。</li>
</ul>
<p><strong>举例说明</strong>：求出每个系的平均工资<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{dept\_name}\mathcal{G}_{avg(salary)}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">pt</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">vg</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span></span></span></span><br>
上面的例子中，对instructor教师表，按照dept_name属性分成每个系的教书组，然后对每个系的教师求平均工资；</p>
<p><strong>计算方法</strong>：</p>
<ol>
<li>确定关系的属性（m + n）</li>
<li>根据分组属性划分组</li>
<li>为每个分好的组，在结果关系内添加一个元组t：前n个属性值等于该分组在n个分组属性（左下标）上的值，后m个属性等于在该分组上统计m个聚集函数（右下标）的结果<br>
PPT讲的很精彩，可以看看。</li>
</ol>
<h3 id="9、除运算不要求。">9、除运算不要求。</h3>
<p>一、关于除运算需要掌握的基础</p>
<ul>
<li>除运算是笛卡尔积的逆运算</li>
<li>更一般地，两个关系 T, R 相除<br>
T ÷ R = S, S 是满足 R × S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span> T ( 不超过 T) 的最大关系</li>
<li>T ÷ R 合法有效的充要条件：T 包含 R 的全部属性，并额外含有不在 R 中的属性——这些属性将会出现在除的结果中</li>
<li><strong>除运算的输出</strong>:  T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">÷</span></span></span></span> R
<ol>
<li>输出的属性Z：T的属性-R的属性</li>
<li>输出的元组必须同时满足以下条件：
<ul>
<li>是T元组在Z投影下的子集</li>
<li>与R的所有元组的连接都出现在关系T中（所以从这一点也可以看出它是笛卡尔积的逆运算）<br>
二、除运算的应用场景<br>
一般涉及到“全部”的时候考虑使用除运算。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>三、除运算与其他运算的等价<br>
除运算通用可以表示为其他运算的组合，所以也是附加运算。<br>
例如，关系 T 的属性集为 X ，关系 R 的属性集为<br>
Y 。 Z = X － Y ，则 T ÷ R 可重写为：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>÷</mo><mi>R</mi><mo>=</mo><msub><mo>∏</mo><mi>Z</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mo>∏</mo><mi>Z</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>×</mo><mi>R</mi><mo>−</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \div R = \prod_Z(T) - \prod_Z((T)\times R - T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p>
<p>10、查询优化不要求。</p>
<h2 id="第三章-——-关系数据库语言SQL">第三章 —— 关系数据库语言SQL</h2>
<h3 id="1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点。">1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点。</h3>
<p>一、SQL简介</p>
<ul>
<li>SQL是Sructured Query Language(结构化查询语言)的缩写</li>
<li>SQL是一种数据库语言 —— 为使用关系数据库提供了<strong>数据结构的定义(DDL)</strong>、<strong>数据内容的操纵(DML)</strong>(查询和修改)、和<strong>日常运行控制(DCL)</strong> 等功能。</li>
</ul>
<p><strong>二、SQL的特点</strong>：</p>
<ol>
<li>综合统一性：<br>
功能统一，都提供数据定义、数据操作、数据控制等功能；<br>
操作过程统一，都是针对关系的操作，包括操作对象和操作结果；</li>
<li>高度非过程化</li>
<li>面向集合的操作方式：<br>
每条操作语句的对象和结果都是关系（记录集合）；</li>
<li>两种使用方式，统一的语法结构：<br>
自含式SQL：数据库管理系统自带，供用户与数据库联机使用，又称为联机式<br>
嵌入式SQL：嵌入到高级语言里面，供程序员用这些高级语言开发数据库应用程序时使用（JDBC等）</li>
</ol>
<h3 id="2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？">2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？</h3>
<p>一、SQL的四种功能</p>
<ol>
<li>数据定义，用数据定义语言实现（DDL, Data Defined Language）</li>
<li>数据查询，用数据操作语言实现</li>
<li>数据修改，用数据操作语言实现（DML，Data Manipulate Language）</li>
<li>数据控制，用数据控制语言实现（DCL，Data Control Language）</li>
</ol>
<p>二、四种功能以及对应的SQL操作语句</p>
<table>
<thead>
<tr>
<th>SQL功能</th>
<th>操作语句</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据定义</td>
<td>CREATE、ALTER、DROP</td>
<td>可定义的对象包括数据库、表、索引、视图等…</td>
</tr>
<tr>
<td>数据操作</td>
<td>SELECT</td>
<td>又称数据查询</td>
</tr>
<tr>
<td></td>
<td>INSERT、DELETE、UPDATE</td>
<td>又称数据修改</td>
</tr>
<tr>
<td>数据控制</td>
<td>GRANT、REVOKE、…</td>
<td>包括事务控制、安全性控制等…</td>
</tr>
</tbody>
</table>
<h3 id="3、SQL对数据库三级模式的规定：每级模式由什么组成？">3、SQL对数据库三级模式的规定：每级模式由什么组成？</h3>
<p>一、数据库的三级模式</p>
<ol>
<li>物理模式
<ul>
<li>整体数据库的物理结构</li>
<li>描述所有数据是如何在硬盘等介质上存储的</li>
</ul>
</li>
<li>逻辑模式
<ul>
<li>整体数据库的逻辑结构</li>
<li>描述所有数据的结构以及所有数据间的联系</li>
</ul>
</li>
<li>子模式
<ul>
<li>部分数据库的逻辑结构</li>
<li>描述某个特定用户能看到的那一部分数据的结构以及他们之间的联系</li>
</ul>
</li>
</ol>
<h3 id="4、理解SQL中的系统数据类型，char-varchar-numeric等。">4、理解SQL中的系统数据类型，char/varchar/numeric等。</h3>
<p>补充知识：SQL的数据类型<br>
SQL-92标准中的部分数据类型如下：</p>
<ul>
<li>char(n) : 长度固定为n的字符串</li>
<li>varchar(n): 长度可变，最大长度为n的字符串</li>
<li>int: 整数</li>
<li>smallint: 短整数</li>
<li>numeric(p, q): 总共位数不多于p，小数点右边不多于q位的定点数</li>
<li>real: 浮点数</li>
<li>float(n): 精度至少为n位的浮点数</li>
<li>date: 日期(年, 月, 日)</li>
<li>time: 时间(时, 分, 秒)</li>
</ul>
<h3 id="5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。">5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。</h3>
<p>一、数据定义的对象</p>
<ul>
<li>数据库</li>
<li>关系（基本表）</li>
<li>视图</li>
<li>索引</li>
<li>用户域（数据类型）<br>
二、数据定义功能语句</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>创建</th>
<th>修改</th>
<th>销毁</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>CREATE DATABASE</td>
<td>——</td>
<td>DROP DATABASE</td>
</tr>
<tr>
<td>关系</td>
<td>CREATE TABLE</td>
<td>ALTER TABLE</td>
<td>DROP TABLE</td>
</tr>
<tr>
<td>视图</td>
<td>CREATE VIEW</td>
<td>——</td>
<td>DROP VIEW</td>
</tr>
<tr>
<td>索引</td>
<td>CREATE INDEX</td>
<td>——</td>
<td>DROP INDEX</td>
</tr>
<tr>
<td>域</td>
<td>CREATE DOMAIN</td>
<td>——</td>
<td>DROP DOMAIN</td>
</tr>
<tr>
<td>三、SQL语法</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>基本表/关系的定义<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809162656.png" alt="Pasted image 20240809162656"></li>
<li>修改表/关系<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809162832.png" alt="Pasted image 20240809162832"></li>
<li>销毁关系   drop table 关系名<br>
<strong>注意</strong>：销毁关系后，关系的结构（属性/字段）和内容（元组/记录）都不再存在。依赖于这个关系的索引、视图也被销毁</li>
<li>新建索引<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809163303.png" alt="Pasted image 20240809163303"></li>
<li>销毁索引   DROP INDEX 索引名</li>
</ol>
<p>四、索引的有关概念<br>
索引的基本概念：</p>
<ul>
<li>索引是一种常用的物理存储结构，作用包括：加快查询速度、保证某一列或几列的唯一性等</li>
<li>例如，在学生表的“年龄”字段上建立索引，可能加快带一类“年龄=？ 年龄&gt;? 年龄&lt; ?”条件的查询</li>
</ul>
<h3 id="6、掌握SQL的Select数据查询语句。掌握Like运算符的使用。">6、掌握SQL的Select数据查询语句。掌握Like运算符的使用。</h3>
<h4 id="一、基本语法结构">一、基本语法结构</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, A3,..., An</span><br><span class="line"><span class="keyword">FROM</span> R1, R2, R3, ..., Rn</span><br><span class="line">[<span class="keyword">WHERE</span> P]</span><br></pre></td></tr></table></figure>
<ul>
<li>SELECT相当于关系代数中的投影</li>
<li>FROM相当于关系代数中的笛卡尔积</li>
<li>WHERE相当于关系代数中的选择</li>
<li>执行顺序：FROM -&gt; WHERE -&gt; SELECT</li>
</ul>
<p><strong>细节</strong>：<br>
SELECT后面，属性列表前面，可以加上关键字<strong>ALL或者DISTINCT</strong></p>
<ul>
<li>DISTINCT  表明结果中消去重复行</li>
<li>==ALL  表明结果中不去重==</li>
<li>默认为ALL</li>
</ul>
<p><strong>WHERE子句中可能出现的运算符号：</strong></p>
<ol>
<li>比较运算符：
<ul>
<li>
<blockquote></blockquote>
</li>
<li>&lt;</li>
<li>=</li>
<li>
<blockquote>
<p>=</p>
</blockquote>
</li>
<li>&lt;=</li>
<li>&lt;&gt;</li>
</ul>
</li>
<li>逻辑运算符：
<ul>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
</li>
<li>范围运算符
<ul>
<li>between 下界 and 上界</li>
</ul>
</li>
<li>集合运算：
<ul>
<li>in  集合；  例如： 姓名  in {‘小陈’, ‘小李’}</li>
<li>not in  集合</li>
</ul>
</li>
<li>匹配运算：
<ul>
<li>like 匹配串（一个可能含有特殊字符的字符串）</li>
<li>%，通配符，匹配0个或多个字符串</li>
<li>_ ，通配符，匹配任意一个字符串</li>
<li>\\，转义字符</li>
</ul>
</li>
</ol>
<h4 id="二、汇合多个SELECT的查询语句（集合运算）">二、汇合多个SELECT的查询语句（<strong>集合运算</strong>）</h4>
<p>基本的集合运算：</p>
<ul>
<li>Union：并运算</li>
<li>Intersect：交运算</li>
<li>Except：差运算</li>
<li>all关键字表示不去重<br>
集合运算要点：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">union</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">intersect</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">except</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">union</span> B</span><br><span class="line">A <span class="keyword">intersect</span> B</span><br><span class="line">A <span class="keyword">except</span> B</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>虽然 SQL 标准中支持 Intersect 和 Except ，许多实际的 DBMS 产品如 SQL Server 2000 及以前的版本， ACCESS 等，并不提供这两种运算符。</li>
<li>在这些 DBMS 实现中差运算或者交运算，应使用exist/in 和 not exist/not in 形式的嵌套子查询。</li>
</ul>
<h4 id="三、扩展基本结构">三、扩展基本结构</h4>
<ol>
<li>Group By子句<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809175842.png" alt="Pasted image 20240809175842"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180057.png" alt="Pasted image 20240809180057"><br>
小结：</li>
</ol>
<ul>
<li>出现统计词（平均、最高,…）等问题，就需要考虑Group By
<ul>
<li>如果还有“每…”，那么Group By   相应的属性</li>
<li>如果没有，那么Group By  无属性</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Having子句<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180257.png" alt="Pasted image 20240809180257"></li>
<li>Order By子句<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180846.png" alt="Pasted image 20240809180846"></li>
</ol>
<p><strong>SELECT语句执行次序</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, A3, ...</span><br><span class="line"><span class="keyword">FROM</span> R1, R2, R3, ...</span><br><span class="line">[<span class="keyword">WHERE</span> P]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> A1, A2, A3, ...</span><br><span class="line">	<span class="keyword">HAVING</span> P</span><br><span class="line">]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> A1 [<span class="keyword">DESC</span> <span class="operator">|</span> <span class="keyword">ASC</span>]</span><br><span class="line">		  A2 [<span class="keyword">DESC</span> <span class="operator">|</span> <span class="keyword">ASC</span>]</span><br><span class="line">		  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>执行次序：<br>
From(笛卡尔积)-&gt;WHERE(选择)-&gt;GROUP BY(分组)-&gt;HAVING(筛选分组)-&gt;SELECT(投影)-&gt;ORDER BY(对结果进行排序)</p>
<h4 id="嵌套子查询">嵌套子查询</h4>
<ol>
<li>格式</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ..., (<span class="keyword">SELECT</span> 子查询) (<span class="keyword">AS</span>) 关系名...,</span><br><span class="line"><span class="keyword">FROM</span> ..., (<span class="keyword">SELECT</span> 子查询) (<span class="keyword">AS</span>) 关系名(属性<span class="number">1</span>, 属性<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure>
<ul>
<li>新关系必须重命名，其属性也可以重命名</li>
</ul>
<ol start="2">
<li>WHERE子句中用子查询构造条件
<ul>
<li>条件1：判定一个值（比如属性值）是否在查询结果中   A [not in] (子查询)<br>
意义：A是否出现在子查询的结果（多个值）之中？如果出现则为真，否则为假<br>
要求：<strong>A往往是一个属性或表达式的值</strong>，此时子查询要相当于一个值的集合。即<strong>子查询可以有多个元组，但==只能有一个属性==</strong></li>
<li>条件2：将一个值（比如属性值）与查询结果作比较<br>
A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>(比较运算 &gt;, &lt;, =, …)some|all(子查询)<br>
意义：
<ul>
<li>some : A与子查询的结果中的一个值满足比较条件时为真</li>
<li>all：A与子查询的结果中的所有值满足比较条件时为真<br>
要求：A是一个值，而子查询的结果是一个值的集合。子查询可以有多个元组，但是只能有一个属性</li>
</ul>
</li>
<li>条件3：判定子查询的结果是否存在（至少一条）记录<br>
格式（exist运算符）<br>
[not] exists (子查询)<br>
意义：子查询结果存在（至少一条）记录<br>
要点：
<ol>
<li>子查询的结果关系，不要求只有一个属性，可以有多个属性（exists是对记录数的判断，和属性无关）</li>
<li>子查询可引用付查询关系的属性（此时最好标明关系前缀），作为子查询的“参数”。这一点对于其他类型（in, some, all）的子查询也是使用的</li>
</ol>
</li>
</ul>
</li>
<li>子查询的注意事项：
<ul>
<li>子查询会降低执行速度：
<ul>
<li>同一个问题，用子查询，和不用子查询相比，速度可能更慢，甚至慢若干数量级，最好的情况是两者相等。即使考虑到必要的查询优化，这个结论也是成立的。</li>
<li>如果子查询带参数，情况会更糟糕</li>
</ul>
</li>
<li>慎用子查询，特别是带参数子查询，<strong>大多数的子查询都可以用复杂的连接条件等价表示</strong>，但是少数情况下，比如DBMS不支持的交、差运算，只能用子查询</li>
</ul>
</li>
</ol>
<h4 id="连接关系">连接关系</h4>
<p>一、连接的基本概念<br>
在From子句中的两个相邻关系之间，可以是一个逗号——表示进行笛卡尔积运算（无条件链接）；也可以是一个连接运算 —— 表示按照指定条件进行连接。</p>
<p>二、连接运算的类型<br>
内连接：</p>
<ul>
<li>格式： A [inner] join B on 条件</li>
<li>内连接的结果不包含失配元组<br>
左外连接：</li>
<li>格式：A left [outer] join B on 条件</li>
<li>左外连接的结果包含左边关系的失配元组<br>
右外连接：</li>
<li>格式：A right [outer] join B on 条件</li>
<li>右外连接的结果包含右边关系的失配元组<br>
全外连接：</li>
<li>格式：A full [outer] join B on 条件</li>
<li>全外连接的结果包含两边关系的失配元组</li>
</ul>
<p>三、多个表的连接<br>
格式：<br>
A [left | right] join B on 条件1<br>
[left | right] join C on 条件2<br>
[left | right] join D on 条件3<br>
[left | right] join E on 条件4<br>
…<br>
关系A和关系B按照条件1连接后，得到结果关系，再和关系C作连接，但是系统在具体执行时，可能会为了优化而改变连接顺序，但是最终结果是一样的！<br>
注意：<br>
所以条件 1 应该是关系 A 、 B 的属性比较，条件 2 则可能是 A+B 的属性与关系 C 的属性比较 ( 上一步 A, B已经连接成一个关系了 )</p>
<h4 id="7、掌握SQL的各个数据修改语句：-Insert-Update-Delete。">7、掌握SQL的各个数据修改语句： Insert, Update, Delete。</h4>
<p>一、基本概念<br>
SQL的数据修改功能，指对表的元组（记录）进行修改。又分为以下三个操作：</p>
<ol>
<li>插入元组，用insert语句实现</li>
<li>删除元组，用delete语句实现</li>
<li>更新元组（的属性值），用update语句实现<br>
<strong>注意</strong>：如果是针对属性进行修改，请用alter table语句</li>
</ol>
<p>二、插入操作语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条新纪录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...)] <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多条新纪录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...)] <span class="keyword">select</span> 字段s1, 字段s2, ...</span><br><span class="line"><span class="comment">-- 新纪录的个数和值来自select的查询结果</span></span><br></pre></td></tr></table></figure>
<p>三、删除操作语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> 关系 [<span class="keyword">WHERE</span> 条件]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>从表中删除符合条件的元组。如果不写where条件，则删除全部元组（<strong>但表的结构如字段、主码等保留</strong>）</li>
<li>一次只能删除一个关系中的元组</li>
<li>找到全部符合条件的记录后再一起删除<br>
四、更新操作语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line">	<span class="keyword">Set</span> 字段<span class="number">1</span> <span class="operator">=</span> 表达式<span class="number">1</span></span><br><span class="line">		[, 字段<span class="number">2</span> <span class="operator">=</span> 表达式<span class="number">2</span>]</span><br><span class="line">		......</span><br><span class="line">[<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>在表中找到满足where条件的记录（如果没有where条件，就默认是全部记录），然后更新。</li>
<li>set子句说明怎么更新记录：更新哪些字段、以及更新后的值（表达式的结果）</li>
<li>同样是全部找到符合条件的记录后再一起更新</li>
</ul>
<h3 id="8、空值的意义。空值的判定方法（IS-NULL）。掌握空值的运算规则（包括聚集函数忽略空值等），能计算一个包含空值式子的结果。">8、空值的意义。空值的判定方法（IS NULL）。掌握空值的运算规则（包括聚集函数忽略空值等），能计算一个包含空值式子的结果。</h3>
<p>一、空值的意义<br>
空值表示两种情况：</p>
<ol>
<li>值不存在</li>
<li>值未知</li>
</ol>
<p>二、空值的计算<br>
空值参与各种运算，被当做一个未知的值。</p>
<ul>
<li>算数运算出现空值，结果一定是null</li>
<li>比较运算出现空值，结果一定是unknown</li>
<li>布尔运算中出现空值，把空值替换为unknown再计算（结果为true/false/unknown）<br>
<strong>对于一个表达式，如果最后一步计算得到的结果是unknown，那么就替换为false</strong><br>
下面这里例子中，比较运算null &lt; 20返回unknown，所以最终结果为false，所以不会选择王小明<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809213320.png" alt="Pasted image 20240809213320"></li>
</ul>
<p>三、聚集函数与空值的关系</p>
<ul>
<li>聚集函数除了count(*)以外都忽略空值</li>
<li>count(*)会统计<strong>记录</strong>的个数，也会把空值算在内</li>
</ul>
<p>四、空值的判定<br>
格式： A is null<br>
其中A是属性值或表达式<br>
<strong>不能用=null判断空值</strong></p>
<h3 id="9、熟记视图的优点。并理解！！！">9、熟记视图的优点。并理解！！！</h3>
<p>一、视图的基本概念<br>
视图的定义：</p>
<ul>
<li>视图是一个命名，是用查询从基本表中导出的基本表</li>
<li>==视图的本质：命名查询==。真正存在、存储在数据库里的是视图的名字和对应的查询（视图的定义）</li>
<li>视图的表象：虚拟表。<br>
逻辑上，对用户而言视图与基本表无差别，都可以查询/修改；<br>
物理上，表中的数据/记录平时并没有存储在数据库里，而是用到的时候才执行查询算出来；</li>
</ul>
<p>对视图的理解：</p>
<ol>
<li><strong>每次访问视图都要重新计算一次“查询”</strong>，<strong>以获取最新的内容</strong>。所以当（查询）相关基本表发生改变后，我们再去访问视图，看到的虚拟表也会相应的变化。</li>
<li>用户对视图的查询（编写的Select语句），系统在执行时必须转化为对相关基本表的查询——用户不知道视图这个“表”不存在，但系统是知道的。</li>
<li>用户对视图的修改（Insert、Update、Delete），系统在执行时必须转化为对相关基本表的修改。</li>
</ol>
<p>物化视图：<br>
概念：在某些数据库系统中，允许视图某一时刻的内容（当时的查询结果关系）真正存储起来，这样的“快照”称为物化视图。<br>
优点：</p>
<ul>
<li>访问快，避免了每次计算查询结果的过程<br>
缺点：</li>
<li>只反映基本表当时的查询结果，所以基本表变化后要考虑<strong>同步的问题</strong><br>
适用场合：读多于写</li>
</ul>
<p>==二、视图的优点==</p>
<ol>
<li>简化用户操作（比如，物理老师有专门的物理成绩单，不需要每次编写对选修表的查询才查询到物理成绩单）</li>
<li>个性化服务<br>
为不同用户量身打造不同的数据（视图）</li>
<li>安全性<br>
限制用户访问的数据范围为他所需要的数据</li>
<li>逻辑独立性<br>
提供了从模式（基本表）到子模式（视图）的映像<br>
视图往往只抽取基本表的一部分数据。所以如果不相关的基本表数据的结构发生了变化（模式改变），不会影响到视图（子模式不变）和面向此视图的应用程序（应用程序也不变），即逻辑独立性</li>
</ol>
<h3 id="10、掌握定义视图的语句。什么是视图的嵌套定义？">10、掌握定义视图的语句。什么是视图的嵌套定义？</h3>
<p>一、视图定义语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 新建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 [(属性名&#123;,属性名&#125;)] <span class="keyword">as</span> (<span class="keyword">Select</span>查询) [<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>视图的属性可以显示命名，也可以缺省查询结果中的属性名（推荐这个，要更名在select查询中更名）</li>
<li>with check option：当对视图进行插入、更新时，要检查新元组是否满足视图对应查询的条件（出现在哪个子句），否则拒绝</li>
</ul>
<p>==二、视图的嵌套定义==</p>
<ul>
<li>定义视图A时，可以在对应查询中<strong>使用其他已有的视图</strong>，比如B、C。此时我们说视图A是定义在视图B、C上的</li>
<li>这又称视图的嵌套定义</li>
</ul>
<h3 id="11、理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：执行时展开视图——替换视图为它所对应的查询。视图的修改：执行时转化为对基本表的修改，这种转化可能因为哪些原因失败，从而无法修改-修改受限）。所以，视图是不可能提高查询效率的，但可以简化查询的书写（把整个查询或者其中固定的部分预先做成一个视图）">11、理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：执行时展开视图——替换视图为它所对应的查询。视图的修改：执行时转化为对基本表的修改，这种转化可能因为哪些原因失败，从而无法修改/修改受限）。所以，视图是不可能提高查询效率的，但可以简化查询的书写（把整个查询或者其中固定的部分预先做成一个视图）</h3>
<p>一、视图的操作</p>
<ol>
<li>视图的查询<br>
用户可以像基本表一样（写SQL语句）查询视图；
<ul>
<li>系统收到这样的SELECT查询后，必须转化成对基本表的查询，方法是展开视图——用定义中的查询取代视图本身；</li>
<li>如果展开一个视图后，（它定义中的）查询又还出现了其他视图，那么继续展开，直到没有任何视图为止；</li>
</ul>
</li>
<li>视图的修改<br>
用户可以向基本表一样（写Insert、Delete、Update语句）修改视图
<ul>
<li>系统收到这样的修改后，必须转化为对基本表的修改；</li>
<li>这种转化有时能成功——视图可修改，有时失败——视图不可修改，因此<strong>我们对视图的修改是受限的</strong></li>
</ul>
</li>
</ol>
<p>二、什么样的视图可以被修改？</p>
<ul>
<li>用查询从单个基本表（From子句只有一个表）抽取一部分元组（Where子句）和一部分属性（Select子句）所构造的视图，称为行列子集视图。<strong>且这一部分属性包含了候选码，没包含的其它属性上没有not null等约束</strong></li>
<li>原因：修改这样视图的一个记录，可以在基本表找到对应的一条源记录然后进行修改（<strong>逆映射</strong>）。方法为按视图记录中包含的候选码值进行查找。</li>
</ul>
<p>三、什么样的视图不能被修改？<br>
不能被修改的根本原因：</p>
<ol>
<li>无法逆映射（字段名找不到、不能唯一确定一个元组）</li>
<li>视图中一个元组，基本表中多个满足条件的元组（无法确定修改哪一个以及修改多少个）<br>
不能被修改的情况：</li>
<li>Select子句中选出的属性不包含候选码（无法逆映射）</li>
<li>Select子句中使用distinct关键字（基本表中有多条记录，但是视图中只有一条记录）</li>
<li>有group by子句或出现聚集函数（基本表中多条记录，但是视图中一条记录）</li>
<li>包含用表达式构造的新属性（无法进行逆映射，找不到对应字段）</li>
<li>From中列出多个关系（无法进行逆映射，找不到对应元组）</li>
</ol>
<p>12、嵌入式SQL不要求。<br>
13、应用题型（必考！！！参考作业）：用SQL表达查询问题（看查询习题课件）。用SQL建表，建视图等定义语句。第二、三章的应用题型（查询表达等）占30分。</p>
<h2 id="第七章-数据库设计和E-R模型">第七章 数据库设计和E-R模型</h2>
<h3 id="1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。">1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。</h3>
<p>一、E-R模型<br>
E-R模型的建模思想：现实世界可以建模为具有属性的实体的集合以及这些实体间的联系<br>
建模可以理解为：用…描述</p>
<p>E-R模型的基本元素：</p>
<ul>
<li>实体：客观存在的并可以与其他相<strong>区分</strong>的某一物体<br>
实体集是实体的集合(×)<br>
实体集是同类型实体的集合(√)</li>
<li>属性：实体区分于其他实体所具有的属性；实体集中每个实体都拥有的，起描述作用的性质<br>
特殊类型的属性：<br>
1. 复合属性：可以划分为其他更小的属性（成分属性），比如Parents就是一个复合属性<br>
2. 多值属性：可以分解为不止一个值的属性，分解后的个数不确定，比如Phone-numbers属性是多值的，因为可以有多个<br>
3. 派生属性：可以从其他属性（基属性）计算得来，例如tax = salary * 0.05</li>
<li>联系：联系是实体间的相互关联<br>
联系集：联系集是相同类型的联系的集合。<br>
相同类型：这些联系涉及相同数量的实体，且来自同一序列的实体集<br>
<strong>联系可能发生在同类型实体之间，即一个实体集内部彼此之间有联系</strong>（同类实体参与联系时，发挥的作用/角色可能不同，比如雇佣关系）<br>
联系集的属性：联系集也可以有其描述作用的属性<br>
例如：borrow联系集可以用borrow-date属性<br>
联系的度：参与联系集的实体集的个数（次数），比如borrow联系集涉及到customer和loan，度为2，称为二元联系集；三元及以上的联系集较少</li>
</ul>
<p>其他相关元素：</p>
<ul>
<li>参与：参与是指实体集与联系集之间的关联。如果联系集R涉及到实体集E1，E2，…,En，那么等于说实体集E1，E2，…,参与了联系集R。（例如：实体集customer和loan参与联系集borrower）<br>
<strong>注意</strong>：一个实体集能两次参与同一个联系集吗？<br>
例子：work-for = customer : customer 这一联系集<br>
参与的类型：<br>
1. 完全参与：如果E中全部实体都参与R中的联系，那么E对R的参与就是完全的<br>
2. 部分参与：如果实体集E中的某些实体不参与联系集R中的任何联系，那么这种参与就是部分的</li>
<li>角色：实体集参与联系集时发挥的作用。
<ul>
<li>如果实体集仅参与联系集一次，那么它只有一个角色且隐含在名字中，不用特别注明</li>
<li>如果实体集参与联系集两次或以上，那么相应地，它有两个或以上的角色。这是单靠实体的名字无法区分这些角色，需要单独说明每次以什么角色参与</li>
</ul>
</li>
<li>映射基数：表示某一实体通过联系集能够和几个其他实体关联（1对1，1对多，多对多）</li>
<li>码</li>
</ul>
<h3 id="2、三种特殊类型的属性，并能够判断。">2、三种特殊类型的属性，并能够判断。</h3>
<p>特殊类型的属性：</p>
<ol>
<li>复合属性：可以划分为其他更小的属性（成分属性），比如Parents就是一个复合属性</li>
<li>多值属性：可以分解为不止一个值的属性，分解后的个数不确定，比如Phone-numbers属性是多值的，因为可以有多个</li>
<li>派生属性：可以从其他属性（基属性）计算得来，例如tax = salary * 0.05</li>
</ol>
<h3 id="3、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。">3、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。</h3>
<p>一、映射基数</p>
<ul>
<li>
<p>映射基数表示某一实体集通过联系集能够和几个其他实体集关联，在描述二元联系集时特别有用。</p>
</li>
<li>
<p>假设在实体集A和B之间有二元联系集R，它的映射基数必是以下之一：</p>
<ol>
<li>一对一联系（丈夫：妻子）
<ul>
<li>A的每个实体，最多和B的一个实体相联系（可以是1个，也可以是0个）</li>
<li>B的每个实体，最多和A的一个实体相联系</li>
</ul>
</li>
<li>一对多联系（公司：部门）
<ul>
<li>A的每个实体，和B的任意多个实体相联系（可以是0， 1， 2，…个）</li>
<li>B的每个实体，最多和A的一个实体相联系</li>
</ul>
</li>
<li>多对一联系（院系：学校）
<ul>
<li>一对多反过来就是多对一</li>
</ul>
</li>
<li>多对多联系（学生：课程）
<ul>
<li>A的每个实体，可以和B的任意多个实体联系</li>
<li>B的每个实体，可以和A的任意多个实体联系</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>二、在E-R图中如何表示映射基数</p>
<ul>
<li>从联系集到“一”方实体集，画一条有向线，箭头指向“一”方实体集</li>
<li>从联系集到“多”放实体集，画一条无向线</li>
<li>巧记：箭头所指的方向是“一”方实体集</li>
</ul>
<p>三、补充：判断多元联系的映射基数<br>
多元联系：E1 : E2 : E3 : … = ? : ? : ? : …</p>
<ul>
<li>Ei是“一”方的条件：对于每个非Ei的实体集Ej，Ej的每个实体最多对应Ei的一个实体</li>
<li>Ei是“多”方的条件：对于每个非Ei的实体集Ej，Ej的每个实体可对应Ei的任意多个实体</li>
</ul>
<p>四、实体的码</p>
<ol>
<li>超码：特殊的单个属性或属性集合，它的值可以唯一标识实体集里的每个实体</li>
<li>候选码：最小的超码</li>
<li>主码：虽然在一个实体集里可能存在几个候选码，但是只选出一个作为主码</li>
</ol>
<h3 id="4、能将E-R图转化为关系模型。注意：多值属性的处理（如果有n个多值属性，n个分开来处理）；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。">4、能将E-R图转化为关系模型。注意：多值属性的处理（如果有n个多值属性，n个分开来处理）；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。</h3>
<p>一、用户需求转化为E-R图<br>
基本过程：</p>
<ol>
<li>找出实体集：实体集的属性、主码</li>
<li>找出联系集：参与、角色、映射基数</li>
<li>画出E-R图</li>
</ol>
<p>二、E-R模型转化为关系模型（in 逻辑设计）</p>
<ul>
<li>E-R模型的基本元素：实体、联系、属性</li>
<li>关系模型基本元素：关系、属性</li>
<li>E-R模型到关系模型：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810102757.png" alt="Pasted image 20240810102757"></li>
<li><strong>方法</strong>：
<ol>
<li>实体 —&gt; 关系，属性 —&gt; 属性：<br>
每个实体转化为一个关系，实体属性转化为该关系的属性，实体的主码转化为该关系的主码；<br>
<strong>消除多值属性，否则违反第一范式：多值属性移出去形成一个新关系，这个新关系包含原来的主码（新关系的主码为这两者之和）</strong></li>
<li>联系 —&gt; 关系/属性：<br>
<strong>一对一联系</strong>：转化为新属性，方法是将某“一”方关系的主码，与联系自身属性一起，添加到另一个“一”方关系里面（属性可以更名）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810104914.png" alt="Pasted image 20240810104914"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810104942.png" alt="Pasted image 20240810104942"><br>
<strong>一对多联系/多对一联系</strong>：转化为新属性，方法是将“一”方关系的主码与联系自身的属性加到“多”方关系中（属性可更名）<br>
<strong>多对多联系</strong>：转化为一个新关系，新关系的属性包括两个“多”方的主码，以及联系自身的属性<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810105224.png" alt="Pasted image 20240810105224"><br>
<strong>三元及以上的联系</strong>：转化为一个新关系，其属性包括<strong>各个设计实体的主码</strong>和联系自身的属性</li>
</ol>
</li>
</ul>
<h3 id="5、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？">5、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？</h3>
<p>一、数据库设计过程<br>
第一阶段：用户需求分析</p>
<ul>
<li>与应用领域专家、数据库用户广泛地交流，获得用户预期的数据和功能需求</li>
<li>结果：得到用户需求说明书<br>
第二阶段：概念设计</li>
<li>将用户需求转化为选定的某种概念模型（常见的是E-R模型）</li>
<li>结果：得到数据库概念模式（常见的是E-R模型表示的概念模式）<br>
第三阶段：逻辑设计</li>
<li>将概念模型转化为选定的某种数据模型（常见的是关系型模型）</li>
<li>结果：得到（以关系模型表示的）数据库逻辑模式<br>
第四阶段：物理设计</li>
<li>在上阶段得到逻辑模式的基础上，补充定义数据库的物理特征。比如索引、内部存储结构、文件组织方式等</li>
<li>结果：得到数据库的物理模式<br>
<strong>注意</strong>：<br>
在设计数据库时，要尽量避免两个方面的问题：</li>
</ul>
<ol>
<li>冗余</li>
<li>表达不完整：某些特定的信息无法存储。比如，如果我们选择在选修表中保存课程的全部或大部分信息，那一门没人选的课将无法插入到数据库</li>
</ol>
<p>6、应用题型（必考！！！参考作业）：<br>
a)给出用户需求，画E-R图（概念设计）。<br>
b)将E-R图转化为关系模型（逻辑设计）。</p>
<h2 id="第八章-关系数据库模式设计">第八章  关系数据库模式设计</h2>
<h3 id="1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。">1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。</h3>
<p>一、坏的关系模式可能出现的四种问题</p>
<ol>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<br>
产生问题的原因：不良的数据依赖。</li>
</ol>
<h3 id="2、理解函数依赖X→Y的含义。掌握判定函数依赖的方法（以课件的“排课”关系为例）。">2、理解函数依赖X→Y的含义。掌握判定函数依赖的方法（以课件的“排课”关系为例）。</h3>
<p>一、数据依赖的基本概念</p>
<ul>
<li>数据依赖是一种数学工具，刻画了（同一关系内）属性间的联系</li>
<li>最常见的数据依赖：函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，其中X，Y是属性值
<ul>
<li>一个X对应一个Y</li>
<li>X值相等则Y也相等</li>
</ul>
</li>
<li>其他类型的数据依赖：多值依赖、连接依赖等等</li>
</ul>
<p>二、函数依赖的定义</p>
<ol>
<li>相关符号：
<ul>
<li>r：一个关系模式</li>
<li>R：r的全部属性，此时r又可以写作r®</li>
<li>X，Y：R的子集</li>
</ul>
</li>
<li>定义：<br>
关系模式r上存在以下函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，读作：X函数确定Y/Y函数依赖X/X是Y的决定元素<br>
条件：当且仅当两个元组如果在属性集X上相等，则它们在属性集Y上也相等（同一个X值只对应一个Y值）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>⇒</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mo>→</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t_1[X]=t_2[X] \Rightarrow t_1[Y] \to t_2[Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>，这对r在任何时间的任何实例上都成立</li>
</ol>
<h3 id="3、三对特殊类型的函数依赖：平凡-非平凡，部分-完全，传递-非传递。根据定义去理解和判定它们。">3、三对特殊类型的函数依赖：平凡/非平凡，部分/完全，传递/非传递。根据定义去理解和判定它们。</h3>
<p>一、平凡/非平凡的函数依赖</p>
<ol>
<li>平凡的函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \to Y, Y \subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，（右边的属性，每个都在左边出现）<br>
平凡的函数依赖的定义决定了它必然成立</li>
<li>非平凡的函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \to Y, Y\nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>
非平凡的函数依赖不一定成立</li>
</ol>
<p>二、部分/完全的函数依赖</p>
<ol>
<li>部分的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>：存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X` \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X` \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>成立
<ul>
<li>理解：左边的一部分就能决定右边</li>
</ul>
</li>
<li>完全的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>：不存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X` \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X` \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>成立
<ul>
<li>理解：不存在左边的一部分可以决定右边，一定要左边的全部才能</li>
</ul>
</li>
</ol>
<p>三、特殊类型的函数依赖：传递、非传递</p>
<ol>
<li>函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是传递的，当
<ul>
<li>存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Z, Z \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>同时成立，<strong>但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Z \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>不成立（Z不是X的等价因素）</strong></li>
<li>理解：左边和右边是间接的决定关系，存在中间元素</li>
</ul>
</li>
<li>函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是非传递的，当
<ul>
<li>不存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Z, Z \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>同时成立，<strong>但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Z \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>不成立（Z不是X的等价因素）</strong></li>
<li>理解：左边和右边是直接的决定关系，不存在中间元素</li>
</ul>
</li>
<li>证明：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是部分函数依赖，那么它也是传递的</li>
</ol>
<h3 id="4、用函数依赖判断一个属性集是否超码，或者是否候选码的方法。">4、用函数依赖判断一个属性集是否超码，或者是否候选码的方法。</h3>
<p>一、码和函数依赖<br>
<strong>超码</strong><br>
在关系r®中：</p>
<ol>
<li>属性（组）K是一个超码，当且仅当：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><br>
<strong>候选码</strong></li>
<li>属性（组）K是一个候选码，当且仅当：
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>且任何K的真子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>都不满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K`\to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li>
</ul>
</li>
</ol>
<p>二、坏的函数依赖——对候选码的部分/传递依赖</p>
<ol>
<li>对候选码的部分函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
<ul>
<li>存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K` \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>无唯一性，会引起冗余</li>
</ul>
</li>
<li>对候选码K的传递函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>
<ul>
<li>存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>Z</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to Z \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">Z \to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>不成立</li>
<li>Z不是超码（否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">Z \to R \to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>成立），这种情况也会产生冗余</li>
</ul>
</li>
</ol>
<h3 id="5、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。">5、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。</h3>
<p>一、函数依赖集的闭包</p>
<ul>
<li>r®：一个关系模式，R为全部属性</li>
<li>F：r满足的（若干个）函数依赖的集合</li>
<li>从F推出（又称逻辑蕴含）其他函数依赖</li>
<li>从一个函数依赖集F推出的全部函数依赖（包括F自身）的全集，就是F的闭包，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><br>
二、计算函数依赖集的闭包——Armstrong公理<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240811100631.png" alt="Pasted image 20240811100631"><br>
<strong>实际上</strong>，找到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中的所有函数依赖是非常复杂的工作，意义也不大。<br>
更常见和重要的是给出一些函数依赖（F），判断另一个函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是否成立（在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中）</li>
</ul>
<p>三、属性集的闭包<br>
r®： 一个关系模式<br>
F：r所满足的函数依赖集合<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>：r中一个或多个属性的集合</p>
<p>属性集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的闭包：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>能决定的全部属性的全集，包括<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>自身。记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>α</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">\alpha_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>A</mi><mo>⇒</mo><mi>A</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mtext> </mtext><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \to A \Rightarrow A\ is\ in\ \alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal">in</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是否成立，等价的方法是判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是否在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中</strong></p>
<h3 id="6、最小函数依赖集不要求。4-3这一节不要求。">6、最小函数依赖集不要求。4.3这一节不要求。</h3>
<p>一、函数依赖集的等价和覆盖<br>
函数依赖集的关系——等价和覆盖</p>
<ol>
<li>函数依赖集的覆盖<br>
当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>⊆</mo><msup><mi>G</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+ \subseteq G^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9073em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>时，称G覆盖F<br>
简言之，F能推导出（逻辑蕴含）的，也能被G推导出，G的表达能力强于F</li>
<li>函数依赖集的等价<br>
当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>=</mo><msup><mi>G</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+=G^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，称G和F等价<br>
简言之，F、G能相互推导出，它们的表达能力一样</li>
<li><strong>最小函数依赖集</strong>（==最小覆盖就是最小函数依赖集==）<br>
函数依赖集F的最小覆盖，是与F等价、且满足以下条件的函数依赖集，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>单属性化：F中任意函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，右边A必是单属性</li>
<li>无冗余化：F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，使得F与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>−</mo><mo stretchy="false">{</mo><mi>x</mi><mo>→</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F-\{x\to A\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span></span></span></span>等价(即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>多余)</li>
<li>既约化：F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，X重写为真子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">X`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span></span></span></span>后，变化后的F与原来等价<br>
任何一个给定的函数依赖集F，必定存在最小覆盖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（可通过方法找到），但可能会有多个</li>
</ul>
</li>
</ol>
<p>二、求最小函数依赖集</p>
<ol>
<li>逐一检查 F 中各函数依赖 : X→Y ，若 Y=A1A2 …Ak，则替换为 X→A1 ， X→A2 ，…， X→Ak—— 单属性化：右边多个属性的，拆分成单个属性 ( 左边不变 )</li>
<li>逐一检查 F 中各函数依赖： X→A ，若去掉 X→A 后，仍有 A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">X^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> ，则删去该函数依赖—— 去冗余化：检查是否有函数依赖多余，即可从其它导出</li>
<li>逐一检查 F 中各函数依赖： X→A ，若 X=B1B2…Bm ， 考虑左边能否用 X-Bi (i=1,2,…,m) 取代 X ，即 A 是否在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><msub><mi>B</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">(X-B_i)^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><br>
—— 既约化：每个函数依赖，看减少左边的某个属性后，是否仍成立。</li>
</ol>
<p>三、正则覆盖<br>
对 F 的最小函数依赖集，其中左半部相同的函数依赖（右半部）作合并，即得到 F 的正则覆盖。</p>
<h3 id="7、掌握1NF、2NF、3NF、BCNF的定义-要求，并能依此进行判定。">7、掌握1NF、2NF、3NF、BCNF的定义/要求，并能依此进行判定。</h3>
<p>一、范式的基本概念</p>
<ol>
<li>为什么要使用范式<br>
范式能够帮助我们判断一个关系模式的好坏，是否有不良的数据依赖，越高级的范式表示越好的关系，不良数据依赖越少</li>
<li>范式的概念：范式是数据依赖满足一定要求的所有关系模式的全集</li>
<li>不同范式之间的联系：高级范式是低级范式的真子集<br>
范式从从低到高，要求也从低到高，满足高要求的关系（属于高级范式），肯定也满足低要求（属于低级范式）</li>
</ol>
<p>二、相关术语</p>
<ol>
<li>码属性（主属性）<br>
一个属性出现在某个候选码中，码特指候选码</li>
<li>非码属性（非主属性）<br>
一个属性，不出现在任何候选码中</li>
<li>码的一部分：候选码的真子集</li>
<li>超码：具有唯一性的属性组，从超码中去掉多余属性可得到候选码</li>
</ol>
<p>三、第一范式（1NF）</p>
<ol>
<li>要求：关系模式的每个属性都是原子的</li>
<li>判断方法：逐个属性分析，如果遇到多值属性则不满足1NF</li>
</ol>
<p>四、第二范式（2NF）</p>
<ol>
<li>要求：关系模式在1NF中<br>
每一个非码属性完全函数依赖于码</li>
<li>判断：检查码以外的每个属性A所依赖的X（即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>），若X是候选码的一部分，违反2NF</li>
</ol>
<p>五、第三范式（3NF）</p>
<ol>
<li>要求：关系模式在1NF中<br>
每一个非码属性非传递函数依赖于码</li>
<li>判断：检查码以外的每个属性A所依赖的X（即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>），若X不包含码（不是超码），违反3NF<br>
推导：码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>X</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>A</mi><mo separator="true">,</mo><mi>X</mi><mo>↛</mo><mi>K</mi><mo separator="true">,</mo><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K\to X, X\to A, X \nrightarrow K, K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，所以A传递函数依赖于K</li>
</ol>
<p>六、BC范式</p>
<ol>
<li>要求：关系在1NF中<br>
每一个属性（码属性，非码属性）不传递函数依赖于码（也没有任何属性部分函数依赖于码，因为非传递函数依赖一定能推到出非部分函数依赖）<br>
充要条件：每一个非平凡函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，无论Y是什么，X必含码<br>
证明：若X不含码，码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>X</mi><mtext>且</mtext><mi>X</mi><mo>↛</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K\to X且X \nrightarrow K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，又有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，所以存在传递函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">K\to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></li>
</ol>
<p>七、三种范式的比较以及判定</p>
<ol>
<li>三种范式的比较<br>
2NF保证函数依赖：如果右边非码属性，则左边不会是码的一部分<br>
3NF保证函数依赖：如果右边非码属性，则左边含有码（或&gt;=码）<br>
BCNF保证函数依赖：右边不论是码属性还是非码属性，左边必含有码</li>
</ol>
<ul>
<li>到了BCNF，任何有意义、非平凡的函数依赖都是好的，右边无论是什么，左边都具有唯一性（超码含码）</li>
<li>但是，虽然BCNF中所有函数依赖都是好的，可能还有不好的其他依赖，比如多值依赖…因此BCNF不是最高级的范式，往上还有4NF…</li>
</ul>
<p>八、认识</p>
<ul>
<li>低级范式肯定有问题，高级范式问题相对较少，但仍然可能有问题。</li>
<li>我们往往不期望完美的关系模式——最高范式、没有任何问题；<br>
而是期望“足够好”的关系模式，到达足够高级别的范式、是问题在容忍范围内最少</li>
</ul>
<h3 id="8、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。">8、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。</h3>
<p>一、关系模式规范化（如何让关系达到更高的范式？）<br>
方法：分解</p>
<ul>
<li>把个属于低级范式的坏关系，分解成几个属于高级范式的好关系</li>
<li>但是某些情况下分解会带来信的问题，比如信息丢失，这样的分解是不正确的（无损连接…）<br>
确保分解方案的正确性：</li>
<li>无损连接分解（不丢失信息）</li>
<li>不丢失函数依赖的分解，但某些场合允许丢失<br>
规范化：将一个属于低级范式的“坏”关系，分解为多个属于高级范式的“好”关系，且无信息丢失的过程</li>
</ul>
<p>二、无损连接分解的判断<br>
判定“一分为二”是否为无损连接分解的充分必要条件：</p>
<ul>
<li>将关系r分解为r1和r2，这种分解是无损的条件是以下两个函数之一能够成立：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mn>1</mn><mo>∩</mo><mi>r</mi><mn>2</mn><mo>→</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">r1 \cap r2 \to r1 - r2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mn>1</mn><mo>∩</mo><mi>r</mi><mn>2</mn><mo>→</mo><mi>r</mi><mn>2</mn><mo>−</mo><mi>r</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">r1 \cap r2 \to r2 - r1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span></span></span></span></li>
</ul>
<p>三、规范化到1NF<br>
方法：将关系中每个非原子的属性转化为原子的<br>
<strong>复合属性</strong>的处理：转化为若干个（成员）原子属性<br>
<strong>多值属性</strong>的处理：移出去形成一个新的关系，同时包含原来的主码，==新关系的主码为这两者之和==</p>
<p>四、规范化到3NF<br>
方法步骤：</p>
<ol>
<li><strong>先求出最小函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">F_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></li>
<li>求候选码<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603002339.png" alt="Pasted image 20240603002339"></li>
</ol>
<p>五、规范化到BCNF<br>
分解成BCNF并且无损连接的算法<br>
给定关系模式R&lt;U , F&gt; ，<br>
⒈令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> = {R&lt;U , F&gt;}<br>
⒉检查<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中各关系模式是否属于BCNF，若是，则算法终止。<br>
⒊设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中Ri&lt;Ui , Fi&gt;不属于BCNF，<br>
则存在函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi><mo>∈</mo><msubsup><mi>F</mi><mi>i</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X\to A \in F_i^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4231em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span></span>，且X不是Ri的码，<br>
XA是Ri的真子集，将Ri分解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>={S1，S2}，<br>
其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>S</mi><mn>1</mn></mrow></msub><mo>=</mo><mi>X</mi><mi>A</mi><mtext>，</mtext><msub><mi>U</mi><mrow><mi>S</mi><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>U</mi><mi>i</mi></msub><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U_{S1}  = XA， U_{S2}  = U_i - {A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span><br>
以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>代替Ri ，返回到⒉</p>
<p>证明无损连接性：</p>
<p>\displaylines{\because U_{S1} = XA,\ \ U_{S2} = U_i - {A} \\ 
\therefore U_{S1} \cap U_{S2} = X \\
U_{S1} - U_{S2} = A \\
\therefore U_{S1} \cap U_{S2} \to U_{S1} - U_{S2} \\得证
}</p>
<p>例题：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603091647.png" alt="Pasted image 20240603091647"></p>
<p>9、多值依赖不要求。</p>
<p>10、应用题型（必考！！！参考作业）：给出关系和函数依赖<br>
a)找出候选码，并证明。<br>
b)判断某个函数依赖是否成立，给出证明。<br>
c)判断关系所属的最高范式，给出证明。<br>
d)将关系规范化到3NF，或者BCNF<br>
e)判断一个分解是否无损依赖，给出证明</p>
<h2 id="补充-数据库安全性与完整性">补充  数据库安全性与完整性</h2>
<h3 id="1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户及合法操作产生的。">1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户及合法操作产生的。</h3>
<p>一、安全性和完整性辨析：</p>
<ol>
<li>非法用户：安全性（未授权用户进入了数据库系统）</li>
<li>非法操作：安全性（已授权的用户执行了超出其权限的范围的操作）</li>
<li>非法数据：合法用户的合法操作，也可能产生错误的数据，例如负的年龄</li>
</ol>
<p>二、安全保护技术</p>
<ol>
<li>基于视图的技术<br>
为不同需求的用户打造不同的视图</li>
<li>基于访问控制的技术
<ul>
<li>控制每一个用户对数据库的访问，都在事先允许的范围内</li>
<li>实现方法：
<ol>
<li>用户身份鉴别</li>
<li>用户权限管理</li>
<li>用户权限验证</li>
</ol>
</li>
</ul>
</li>
<li>审计追踪技术
<ul>
<li>记录用户访问数据库的全过程</li>
</ul>
</li>
</ol>
<h3 id="2、掌握用SQL授予权限和回收、禁止权限的语句-grant-revoke-deny-。with-grant-option子句的作用。">2、掌握用SQL授予权限和回收、禁止权限的语句(grant, revoke, deny)。with grant option子句的作用。</h3>
<p>一、SQL授权机制</p>
<ol>
<li>授权命令格式</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限[,...n] <span class="keyword">on</span> 对象名 <span class="keyword">to</span> 用户[,...n] <span class="operator">|</span> public [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">to</span> 教务员王 <span class="keyword">with</span> <span class="keyword">grant</span> opetion</span><br><span class="line"><span class="comment">--教务员王有对选修表的查询、更新权限，并且可以转授</span></span><br></pre></td></tr></table></figure>
<ul>
<li>public代表所有用户</li>
<li>with grant option代表用户可以把获得的权限转授</li>
</ul>
<ol start="2">
<li>
<p>权限类型</p>
<ul>
<li>CREATE</li>
<li>SELECT</li>
<li>INSERT</li>
<li>DELETE</li>
<li>UDATE</li>
<li>REFERENCE：针对表，表示可以引用该表的主码来定义其他表的外部码</li>
<li>ALL：对象上的所有权限</li>
</ul>
</li>
<li>
<p>数据对象的类型</p>
<ul>
<li><strong>SCHEMA：数据库模式</strong></li>
<li>TABLE：基本表</li>
<li>VIEW：视图</li>
<li>ATTRIBUTE：属性</li>
</ul>
</li>
</ol>
<p>二、回收权限</p>
<ol>
<li>命令格式</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限[,...n] <span class="keyword">on</span> 对象名 <span class="keyword">from</span> 用户[,...n] <span class="operator">|</span> public [CASCADE <span class="operator">|</span> RESTRICT]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">from</span> 教务员王 cascade</span><br></pre></td></tr></table></figure>
<ul>
<li>CASCADE：级联式收回权限（若干用户已将权限转授给其他用户，则一并收回）</li>
<li>RESTRICT：不存在级联时收回权限成功，存在级联时（用户已把授权转授出去）则命令失败</li>
</ul>
<p>三、禁止权限</p>
<ol>
<li>命令格式</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny ... <span class="keyword">to</span> 用户</span><br></pre></td></tr></table></figure>
<ul>
<li>禁止权限：使用户以后绝对不可以做相应操作</li>
</ul>
<p>四、对比三种权限<br>
grant … to 用户</p>
<ul>
<li>授予正权限：使用户可以做相应的操作</li>
<li>特殊情况：A，B授予同一个用户同一个权限X，即该用户的权限有两个来源；此时该用户有两个X，当A收回该权限，此用户对应X消失，但他还拥有B给他的X，所以他仍然有权限；</li>
</ul>
<p>deny … to 用户</p>
<ul>
<li><strong>禁用（授予负）权限：使用户以后绝对不可以做相应的操作</strong></li>
<li>比如上面的例子，C禁止该用户的X权限，即给了用户一个-X，那么用户无法再做此权限的操作，即使之前A，B授予了“正权限X”；</li>
<li><strong>所以负权限大于正权限，只要有一个负权限，无论得到多少正权限都无法获得权限</strong></li>
</ul>
<p>revoke … from 用户</p>
<ul>
<li>收回，相当于取消此前授予的（正、负）权限；注意：取消禁止权限，也是通过revoke</li>
<li><strong>思考</strong>：如果B收回授予用户的正权限X，有什么效果？接下来C取消他授予的负权限（禁止权限）呢？<br>
现在用户有两个X和一个-X，B收回后，用户有一个X和一个-X，仍然无法使用权限；<br>
C撤销负权限后，用户有一个X，无-X，则拥有权限；</li>
</ul>
<p><strong>小结：一个用户无法使用权限的情况：1. 无权限；2. 被授予负权限；</strong></p>
<p>五、角色机制<br>
“角色”出现的必要性：<br>
如果有一组用户，他们的权限相同或非常相近，那么设置一个角色代表这组用户，同意给角色授权，可以大大减少工作量；</p>
<p>角色的概念：</p>
<ol>
<li>角色就是一个用户集合</li>
<li>角色也是一个权限集合</li>
</ol>
<p>例子：<br>
辅导员小王、小李、…想访问数据库里面的学生表；但只能允许他们查询和更新某些字段，比如年龄、宿舍。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="comment">--创建角色</span></span><br><span class="line"><span class="keyword">grant</span> 角色名 <span class="keyword">to</span> 用户 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--把用户拉入角色</span></span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">to</span> 角色名 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--集合中每个用户以及以后得新用户都具有该权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--角色即可以出现在to前面，又可以出现在to后面，所以它即是权限集合，又是用户集合</span></span><br></pre></td></tr></table></figure>
<p><strong>角色即可以出现在to前面，又可以出现在to后面，所以==它即是权限集合，又是用户集合==</strong></p>
<p>思考：<br>
如果所有辅导员权限不完全一致，比如某一个辅导员比其他辅导员权限<strong>多一点</strong>或<strong>少一点</strong>，那还可以应用角色吗？怎么处理？<br>
多一点：按照用户赋给额外的权限<br>
少一点：deny掉该用户的权限</p>
<h3 id="3、理解常见权限的含义。（例如-insert-on-table-S-update-on-view-A等">3、理解常见权限的含义。（例如 insert on (table) S, update on (view) A等)</h3>
<h3 id="4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。">4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。</h3>
<p>一、完整性的概念</p>
<ol>
<li>定义：完整性指的是数据的正确性、有效性、相容性</li>
<li>完整性规则：完整性规则是为了保证完整性，数据所必须满足的约束条件，又称完整性约束/完整性约束条件<br>
可分为两类：
<ul>
<li>静态约束：数据取值条件</li>
<li>动态约束：数据变化/修改数据的条件(新旧值比较)</li>
</ul>
</li>
<li>完整性控制：在数据库系统中，保证数据的完整性，这一工作由DBMS完整性子系统完成<br>
完整性控制围绕完整性规则进行，包括：
<ul>
<li>定义完整性规则（check…）</li>
<li>检查完整性并做处理（在用户发出操作（update、insert…）、修改数据后检查是否仍然满足完整性规则，如果不满足则进行处理）</li>
</ul>
</li>
</ol>
<h3 id="5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？">5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？</h3>
<p>一、关系模型三要素</p>
<ol>
<li>关系</li>
<li>关系操作</li>
<li>关系完整性
<ul>
<li>实体完整性：元组主码唯一且非空</li>
<li>参照完整性：外部码要么为空，要么取一个存在的对应主码值</li>
<li>用户定义完整性：用户根据具体的应用环境定义</li>
</ul>
</li>
</ol>
<p>思考：创建表时，外部码中的属性应该设为什么类型？<br>
<strong>外部码的属性类型要严格等于主码字段类型</strong></p>
<p>二、什么会破坏这些完整性规则</p>
<ul>
<li>显然查询操作不会破坏完整性，只有改变数据的修改操作才可能；</li>
<li>只有删除操作不会破坏实体完整性，其他修改数据的操作都会破坏三种完整性；<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603185945.png" alt="Pasted image 20240603185945"></li>
</ul>
<h3 id="6、掌握用SQL定义主码约束、外码约束、非空-not-null-约束、唯一-unique-约束、域约束、检查-check-约束的语句？以及这些约束的含义、作用。">6、掌握用SQL定义主码约束、外码约束、非空(not null)约束、唯一(unique)约束、域约束、检查(check)约束的语句？以及这些约束的含义、作用。</h3>
<p>一、关系数据库里的完整性约束</p>
<ol>
<li>主码约束</li>
<li>外部码约束</li>
<li>非空约束</li>
<li>检查约束</li>
<li>唯一约束</li>
<li>断言</li>
<li>触发器</li>
</ol>
<p>二、各种约束<br>
主码约束</p>
<ol>
<li>规则：主码值不允许为空，也不允许重复</li>
<li>定义：创建/修改表的语句中，用<strong>PRIMARY KEY</strong>声明主码的同时定义一个主码约束；</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">	书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	读者编号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	借阅日期 <span class="type">date</span></span><br><span class="line">	<span class="keyword">primary</span> key (书号, 借阅日期)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部码约束</p>
<ol>
<li>规则：外部码要求取值要么空值要么取对应的主码值</li>
<li>定义：创建/修改表的语句中，用FOREIGN KEY声明外部码的同时，即定义一个外部码约束</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">foreign</span> key (外部码属性)</span><br><span class="line">		refernce 被参照表名(主码属性) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="operator">&lt;</span>参照动作<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>参照动作</strong>：说明当（被参照关系的）某个主码值被删除/更新时，如何处理自己表中对应的外部码值<br>
RESTRCT方式（for server: no action）：仅当没有任何对应外部码值时才能删除/更新这个主码值，否则系统拒绝执行此操作<br>
CASCADE方式：连带所有对应的外部码值一起删除/更新<br>
SET NULL方式：将所有外部码值设为空<br>
SET DEFALUT方式：将所有对应外部码值设置为默认值</li>
</ol>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Libroary</span><br><span class="line">&#123;</span><br><span class="line">	书号 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	数名 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">primary</span> key(书号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">	书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	读者编号 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	借阅日期 <span class="type">date</span></span><br><span class="line">	<span class="keyword">primary</span> key (...),</span><br><span class="line">	<span class="keyword">foreign</span> key (书号)</span><br><span class="line">		<span class="keyword">references</span> 图书表(书号)</span><br><span class="line">			<span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line">			<span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非空约束<br>
规则：属性值不允许取空值<br>
定义：创建/修改表的语句中，声明某个属性NOT NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">	读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	姓名 <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值约束<br>
规则：插入记录时，没有指定数据的属性值取默认值<br>
定义：创建/修改表的语句中，声明某个属性时，用DEFAULT关键字引出其默认值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">	读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一约束<br>
规则：制定属性或属性组，不能取重复值<br>
定义：创建/修改表的语句中，<strong>用Unique关键字声明</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">	读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">	e<span class="operator">-</span>mail <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">unique</span>(e<span class="operator">-</span>mail)</span><br><span class="line">	<span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查约束<br>
规则：每个元组内部一个或多个属性值，必须满足用户指定的条件<br>
定义：创建/修改表的语句中，check关键字后说明条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">	读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">primary</span> key (读者号)</span><br><span class="line">	<span class="keyword">check</span>(性别 <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">or</span> 性别 <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> 性别 <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>域约束<br>
规则：域（数据类型）中的值要满足用户指定的条件<br>
目的：间接地约束属性。因为如果把某个属性声明为这个域（数据类型），则该属性的取值也连带要满足这一条件。<br>
定义：在创建域的语句中，在constraint关键字后面说明约束的名称和条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式</span></span><br><span class="line"><span class="keyword">create</span> domain 用于域名 系统预定义域 [<span class="keyword">constraint</span> 约束名 <span class="keyword">check</span>(条件)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> domain 性别类型 <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">constraint</span> 约束名 <span class="keyword">check</span>(<span class="keyword">value</span> <span class="keyword">in</span> (<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="keyword">Null</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">	读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">	性别 性别类型 <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7、在定义外部码约束时，有哪几种参照动作？代表什么意义？">7、在定义外部码约束时，有哪几种参照动作？代表什么意义？</h3>
<p><strong>参照动作</strong>：说明当（被参照关系的）某个主码值被删除/更新时，如何处理自己表中对应的外部码值<br>
RESTRCT方式（for server: no action）：仅当没有任何对应外部码值时才能删除/更新这个主码值，否则系统拒绝执行此操作<br>
CASCADE方式：连带所有对应的外部码值一起删除/更新<br>
SET NULL方式：将所有外部码值设为空<br>
SET DEFALUT方式：将所有对应外部码值设置为默认值</p>
<h3 id="8、断言不作要求">8、断言不作要求</h3>
<h3 id="9、熟记以下全部-触发器的概念。触发器有哪些作用？触发器-ECA规则构成的三个方面，包括英文单词。哪些事件会激活（INSERT-UPDATE-DELETE操作）。">9、熟记以下全部 触发器的概念。触发器有哪些作用？触发器/ECA规则构成的三个方面，包括英文单词。哪些事件会激活（INSERT,UPDATE,DELETE操作）。</h3>
<p>一、触发器基本概念<br>
概念：自动执行的过程</p>
<ul>
<li>传统过程是用户调用才手动执行，否则不执行</li>
<li>在系统检测到某些事情发生时才会去主动执行相应（预先跟这些时间绑定的）触发器<br>
构成：</li>
<li>Event ： 发生什么是？</li>
<li>Condition ： 检查什么条件？</li>
<li>Action：再执行什么动作（条件成立）？</li>
</ul>
<p>==二、触发器作用==</p>
<ol>
<li>保证数据完整性，例如在增删改记录时，验证一些复杂的条件是否满足</li>
<li>审计（例如把一个用户对数据库的操作和时间都记录下来）</li>
<li>满足特定条件自动执行某项任务（例如，商品库存不足时，自动生成一张订单）</li>
</ol>
<p>例子：当职工工资增幅超过10%，放弃修改（改回原值）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 触发器模板</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="keyword">trigger</span><span class="operator">-</span>name</span><br><span class="line">	[before <span class="operator">|</span> after] <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">delete</span><span class="operator">/</span><span class="keyword">update</span> [<span class="keyword">of</span> <span class="keyword">column</span><span class="operator">-</span>name] <span class="keyword">on</span> <span class="keyword">table</span><span class="operator">-</span>name</span><br><span class="line">	<span class="keyword">referencing</span> <span class="keyword">old</span> <span class="keyword">as</span> ?</span><br><span class="line">				<span class="keyword">new</span> <span class="keyword">as</span> ?</span><br><span class="line">	<span class="keyword">when</span>(<span class="keyword">search</span><span class="operator">-</span><span class="keyword">condition</span>)</span><br><span class="line">		<span class="keyword">begin</span> [<span class="keyword">atomic</span>]</span><br><span class="line">		 triggered<span class="operator">-</span><span class="keyword">SQL</span><span class="operator">-</span>statement</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trig_SALARY_LIMIT</span><br><span class="line">	after <span class="keyword">update</span> <span class="keyword">of</span> 工资 <span class="keyword">on</span> 职工表</span><br><span class="line">	<span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">as</span> newrow </span><br><span class="line">				<span class="keyword">old</span> <span class="keyword">as</span> <span class="keyword">old</span> <span class="type">row</span></span><br><span class="line">	<span class="keyword">when</span> (newrow.工资 <span class="operator">&gt;</span> <span class="number">1.1</span><span class="operator">*</span>oldrow.工资)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">update</span> 职工表</span><br><span class="line">		<span class="keyword">set</span> 工资 <span class="operator">=</span> oldrow.工资</span><br><span class="line">		<span class="keyword">where</span> 员工号 <span class="operator">=</span> oldrow.员工号</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="第十二章——事务管理">第十二章——事务管理</h2>
<h3 id="1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、保障机制）。">1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、保障机制）。</h3>
<p><strong>事务的概念</strong>：事务的DBMS的<strong>基本执行单位</strong>，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。事务是恢复和并发控制的基本单位！</p>
<p><strong>事务的性质</strong>（ACID）：</p>
<ol>
<li>原子性（Atomicity）：事务中包含的所有操作（特指修改操作）要么全做，要么全不做。<br>
保障机制：恢复机制</li>
<li>一致性（Consistency）：单独执行一个事务（无其他事务同时并发执行）的结果必须保证数据的一致性，即事务开始之前数据满足一致性要求；事务结束之后，数据可能被修改了，但仍然满足一致性要求。<br>
保障机制：完整性机制</li>
<li>隔离性（Isolation）：多个事务在并发执行的时候不会相互影响，好像他们是隔离开来的；并发执行的最后结果与顺序执行这些事务的结果一致；<strong>隔离性要求一个事务不会看到另一个事务的中间结果</strong><br>
保障机制：并发控制机制</li>
<li>持久性（Durability）：事务一旦提交，它对数据库的影响就是永久性的，无论发生什么事都无法取消这种影响。<br>
保障机制：恢复机制</li>
</ol>
<h3 id="2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。不能提交的事务结局只能是回滚。">2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。不能提交的事务结局只能是回滚。</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生人数</span></span><br><span class="line">IF (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students) <span class="operator">&gt;</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 如果学生人数大于100，提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 如果学生人数不大于100，回滚事务</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、事务调度分串行调度和并发调度，并发调度的效率高，但也有问题：破坏数据一致性，产生错误。">3、事务调度分串行调度和并发调度，并发调度的效率高，但也有问题：破坏数据一致性，产生错误。</h3>
<h3 id="4、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。">4、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。</h3>
<ol>
<li>
<p>并发调度会带来三种数据不一致问题，分别是：丢失修改、不可重复读以及读取脏数据。</p>
</li>
<li>
<p>丢失修改：多个事务从数据库中读取同一数据，分别仅修改并提交，会产生修改覆盖的现象，从而丢失修改。</p>
</li>
<li>
<p>不可重复度：事务T1读取某个数据后，事务T2对该数据进行了修改并提交，事务T1第二次读取该数据会和第一次有不同的结果（出现幻影现象）</p>
</li>
<li>
<p>读取脏数据：事务T1读取某个数据后，事务T2对该数据进行了修改但还未提交，此时事务T1被称为读取了脏数据；脏数据是指被修改但是未提交的数据。</p>
</li>
</ol>
<h3 id="5、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。">5、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。</h3>
<h3 id="6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。各个锁的含义（例如排他锁是读-写，共享是读），相容-排斥关系？">6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。各个锁的含义（例如排他锁是读+写，共享是读），相容/排斥关系？</h3>
<p><strong>锁</strong>：一个事务在对某个数据对象（表、元组、关系等）进行操作前，可以向系统申请对该<strong>数据对象</strong>加锁。==数据库上锁的数据对象是内存中的数据，不是磁盘中的数据）来自于励儒云的习题==</p>
<p><strong>X锁</strong>：又称为写锁/排他锁（Exclusive Lock）</p>
<ul>
<li>一个事务对数据A进行修改（写）操作前，给它加上X锁。获得X锁后，事务可以对数据A进行写，也可以对数据A进行读</li>
<li>==其他事务不能对A再加任何锁，直到X锁被释放为止！==<br>
<strong>S锁</strong>：又称为读锁/共享锁（Shared Lock）</li>
<li>一个事务对数据A进行读取操作前，给它加上S锁，获得S锁后，该事物<strong>可以读，但不可以写</strong></li>
<li>其他事务可以对A加更多的锁（除了X锁）</li>
</ul>
<h3 id="7、意向锁不要求。更新锁不要求。">7、意向锁不要求。更新锁不要求。</h3>
<h3 id="8、有哪几种封锁协议？规则是什么？它们的作用（各自解决了哪些数据不一致性问题）？两段封锁协议是可串行化调度的充分非必要条件。">8、有哪几种封锁协议？规则是什么？它们的作用（各自解决了哪些数据不一致性问题）？两段封锁协议是可串行化调度的充分非必要条件。</h3>
<p><strong>封锁协议</strong>：封锁协议是事务对数据对象加锁时需要遵守的规则</p>
<h4 id="一级封锁协议">一级封锁协议</h4>
<p><strong>规则</strong>：数据对象D如果是修改/写操作，在第一次read/write之前需要加X锁，事务结束（commit/rollback）后才释放X锁<br>
<strong>规则的简洁表述</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放（事务的结束有两种状态，正常结束commit和非正常结束rollback）<br>
<strong>特点</strong>：仅对写操作加锁，==对读操作无要求！==<br>
<strong>作用</strong>：一级封锁协议可以解决==丢失修改==的问题，并保证了事务T是可恢复的（原因：没有事务能够修改其他事务正在修改，还未提交的数据）</p>
<h4 id="二级封锁协议">二级封锁协议</h4>
<p><strong>规则</strong>：满足一级封锁协议的基础上，若要读取数据R，事务T必须先对其加S锁，读取完后，可以在任意时候释放S锁（瞬间S锁）<br>
<strong>特点</strong>：不仅对数据的读有要求，而且对数据的写有要求<br>
<strong>作用</strong>：可以解决<strong>读取脏数据</strong>的问题（原因：没有事务可以读取其他事务正在修改但是未提交的数据）</p>
<h4 id="三级封锁协议">三级封锁协议</h4>
<p><strong>规则</strong>：一级封锁协议的基础上，若要读取数据R，事务T必须在第一次读取R之前加上S锁，直到事务结束之后才释放S锁<br>
<strong>作用</strong>：解决<strong>不可重复读</strong>的问题（原因：在同一事务的两次读数据中间，没有其他事务能够修改该数据）</p>
<h4 id="两段封锁协议">两段封锁协议</h4>
<p><strong>规则</strong>：</p>
<ul>
<li>事务对数据加S/X锁后，才能读写数据；释放锁后不能再读写该数据</li>
<li>事务分为两个阶段：
<ol>
<li>生长阶段：（一直在）获得锁，不能释放锁</li>
<li>收缩阶段：（一直在）释放锁，不能申请锁<br>
<strong>首次释放掉一个锁后，即由生长阶段转为收缩阶段</strong><br>
==注意：符合三级封锁协议的事务一定也符合两段封锁协议，因为三级封锁协议保证了每个数据都在加锁和释放锁之间==</li>
</ol>
</li>
</ul>
<h4 id="两段封锁协议是可串行化的充分非必要条件">两段封锁协议是可串行化的充分非必要条件</h4>
<p>若所有事物均遵从两段封锁协议，则对这些事务的并发调度一定是可串行化的！<br>
反之，在一个可串行化的调度中，不一定所有事务都满足两段封锁协议！<br>
因此，<strong>所有事务都遵从两段封锁协议是可串行化的充分非必要条件</strong>！</p>
<h4 id="小结">小结</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002402.png" alt="Pasted image 20240618002402"></p>
<h3 id="9、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。">9、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。</h3>
<p>数据库恢复的基本原理：<strong>冗余</strong><br>
在故障发生、数据出错后，用存储在其他地方的数据副本（冗余数据）来重建正确的数据。<br>
平时<strong>建立数据冗余</strong>的方法：</p>
<ul>
<li>数据备份（周期），也称数据转储</li>
<li>登记日志文件（实时）</li>
</ul>
<h3 id="10、静态备份-vs-动态备份（有否一致性；是否允许用户运行事务来操作数据库）。">10、静态备份 vs 动态备份（有否一致性；是否允许用户运行事务来操作数据库）。</h3>
<p><strong>数据备份定义</strong>：有数据库系统定期将数据进行复制，得到后备副本并保存在外部存储空间上的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0[&quot;</span><br><span class="line">数</span><br><span class="line">据</span><br><span class="line">备</span><br><span class="line">份&quot;] --&gt; 静态备份 &amp; 动态备份</span><br><span class="line">静态备份 --&gt; 1[&quot;备份期间，系统不能有事务运行&quot;] &amp; 2[&quot;优点: 实现简单，得到的数据库副本有一致性&lt;/br&gt;缺点: 备份时，数据库不可用&quot;]</span><br><span class="line">动态备份 --&gt; 3[&quot;备份期间，允许事务运行（存取数据）&quot;] &amp; 4[&quot;优点: 备份时，数据库可用&lt;/br&gt;缺点: 实现复杂，不能保证数据库副本的一致性&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="11、日志文件的定义：是用来记录事务对数据库进行更新操作的文件">11、日志文件的定义：是用来记录事务对数据库进行更新操作的文件</h3>
<h3 id="12、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记更新操作的日志记录时，更新前后的旧值与新值都要保存到日志记录中。">12、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记更新操作的日志记录时，更新前后的旧值与新值都要保存到日志记录中。</h3>
<p><strong>日志文件的记录单位</strong>：<br>
日志文件的记录对象/单位有两种，分别为：记录、数据块</p>
<p><strong>一个事务登记到日志文件的内容</strong>：</p>
<ol>
<li>事务的开始标志（Begin Transaction）<br>
每个事务都有一条标志开始的日志记录</li>
<li>事务的结束标志（commit/rollback）</li>
<li>事务的所有修改操作<br>
每个事务有多个修改操作，但凡修改一个单位（记录或者数据块），就需要产生一条日志记录，记录下修改的单位编号，<strong>修改前的旧值、修改后的新值</strong></li>
</ol>
<p><strong>一条日志记录的数据结构（假设以记录为单位）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;一条</span><br><span class="line">日志</span><br><span class="line">记录&quot;] --&gt; 2[&quot;事务标识（事务编号）&quot;] &amp; 3[&quot;操作类型（事务开始、事务结束、添加、删除、更新）&quot;] &amp; 4[&quot;操作对象的标识(记录的内部编号)&quot;] &amp; 5[&quot;修改前的旧值，如果是插入操作则为空&quot;] &amp; 6[&quot;修改后的新值，如果是删除操作则为空&quot;]</span><br></pre></td></tr></table></figure>
<p>**日志文件的原则：</p>
<ol>
<li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li>
<li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li>
</ol>
<p><strong>事务提交</strong>：</p>
<ul>
<li>事务提交，意味着事务的所有操作（包括commit）都已经记录进入日志，并且日志也存入外存中</li>
</ul>
<h3 id="13、什么是运行记录优先（先写日志）原则？">13、什么是运行记录优先（先写日志）原则？</h3>
<p>**日志文件的原则：</p>
<ol>
<li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li>
<li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li>
</ol>
<h3 id="14、熟记以下全部不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），及由谁完成（系统自动-or-用户干预？）">14、熟记以下全部不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），及由谁完成（系统自动 or 用户干预？）</h3>
<p>一、事务故障<br>
<strong>定义</strong>：事务在运行至正常终止点前被终止<br>
比如溢出、除0操作、死锁等等<br>
<strong>影响范围</strong>：事务故障属于小型故障，影响范围仅限于一个事务，不会影响其他事务的正常运行。<br>
<strong>恢复方法</strong>：</p>
<ol>
<li>反向扫描日志文件，找到属于该事务的修改操作，不断执行撤销操作直到读到此事务的开始标记，则事务故障就恢复完成</li>
<li>撤销操作，将日志记录中的“修改前的值”写入磁盘</li>
<li>事务故障的恢复由==系统==自动完成，对==用户透明==</li>
</ol>
<p>二、系统故障<br>
<strong>定义</strong>：因某种原因，造成数据库管理系统（DBMS）停止运行<br>
比如硬件故障（cpu故障…），软件故障(os异常)，外部因素（停电…）<br>
<strong>影响范围/性质</strong>：中型故障，DBMS故障会导致多个工作的事务被异常终止，系统需要重新启动；重启后，内存缓冲区中的数据丢失，但磁盘介质上数据依然完好<br>
<strong>系统故障造成数据库不一致状态的原因</strong>：</p>
<ul>
<li>未完成的事务对数据库的更新可能已经写入数据库</li>
<li>已提交的事务对数据库的更新可能还留在缓冲区没来得及写<br>
<strong>恢复方法</strong>：<br>
DBMS在重新启动后自动完成，不需要用户的干预，对用户透明</li>
</ul>
<ol>
<li>Undo故障发生时未完成的事务</li>
<li>Redo已经发生的事务<br>
<strong>恢复步骤</strong>：</li>
<li>正向扫描日志文件，找到已提交的事务（有begin transaction和commit），将其事务标志放入redo队列；<br>
找到未提交的事务（有begin transaction无commit）放入undo队列</li>
<li>反向扫描日志文件，找到找到属于撤销队列的事务的修改操作并执行撤销操作，即将修改前的旧值写入磁盘</li>
<li>正向扫描日志文件，找到属于重做队列中的事务的修改操作并执行重做操作，即将修改后的新值写入磁盘<br>
<strong>小结恢复步骤</strong>：<br>
系统故障的恢复需要三次扫描日志文件<br>
第一次扫描建立undo和redo队列；<br>
第二次反向扫描日志文件，对需要undo的事件的修改操作进行undo操作；<br>
第三次正向扫描日志文件，对需要redo的事件的修改操作进行redo操作；</li>
</ol>
<p>三、介质故障<br>
<strong>定义</strong>：因某种原因，磁盘上的物理数据部分或完全丢失<br>
<strong>原因</strong>：硬件损坏、计算机病毒、黑客…<br>
<strong>影响范围/性质</strong>：属于大型故障，不仅DBMS中止，内存数据丢失，并且磁盘上的数据也会丢失和异常<br>
<strong>恢复方法</strong>：<br>
需要人工干预，需要数据库管理人员DBA来完成（唯一需要人工介入的故障）<br>
恢复过程：</p>
<ol>
<li>装入最近一次<strong>备份的数据库副本</strong>，即恢复数据库到最近的一次备份时的状态</li>
<li>装入备份后到故障发生时的<strong>日志文件或副本</strong>，然后把未提交的事务撤销，已提交的事务重做</li>
</ol>
<h3 id="15、检查点不要求">15、检查点不要求</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Cyrus</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/">http://example.com/2024/06/29/课程内学习/【数据库系统】7. 期末考点整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">半栈日记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div class="post_share"><div class="social-share" data-image="/self_img/head_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/" title="【软件工程】4. 结构化设计方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【软件工程】4. 结构化设计方法</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="【编译原理】8. 期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【编译原理】8. 期末复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="【数据库系统】1. 基本概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">【数据库系统】1. 基本概念</div></div></a></div><div><a href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%911.%20%E5%89%8D%E5%AF%BC/" title="【编译原理】1. 前导"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-08</div><div class="title">【编译原理】1. 前导</div></div></a></div><div><a href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%913.%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/" title="【编译原理】3. 有穷自动机"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-08</div><div class="title">【编译原理】3. 有穷自动机</div></div></a></div><div><a href="/2024/03/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%914.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89/" title="【编译原理】4. 语言和文法的形式定义"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-29</div><div class="title">【编译原理】4. 语言和文法的形式定义</div></div></a></div><div><a href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%915.%20%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="【编译原理】5. 自顶而下的分析方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">【编译原理】5. 自顶而下的分析方法</div></div></a></div><div><a href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%916.%20%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" title="【编译原理】6. 自底向上的分析方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">【编译原理】6. 自底向上的分析方法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="this.onerror=null;this.src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cyrus</div><div class="author-info__description">保持好奇，持续输出</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ICserD"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ICserD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2862081626@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_73546177" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章——数据库系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9B%9B%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88DBMS%EF%BC%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-DBS-%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%86%9F%E8%AE%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E3%80%82"><span class="toc-number">1.2.</span> <span class="toc-text">2、熟记数据库系统的组成。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%90%86%E8%A7%A3DBA%E6%98%AF%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E9%9B%86%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E6%9C%80%E9%87%8D%E8%A6%81%E4%BA%BA%E5%91%98%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">3、理解DBA是对数据库进行集中控制和管理的最重要人员。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%9E%E4%BE%8B%E5%92%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E5%86%85%E5%AE%B9-%E7%8A%B6%E6%80%81-vs-%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8F%98%E5%8C%96-vs-%E7%A8%B3%E5%AE%9A%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4、实例和模式的对比（内容&#x2F;状态 vs 结构，变化 vs 稳定）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%86%9F%E8%AE%B05%E5%92%8C6%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%AE%9A%E4%B9%89%EF%BC%88%E6%B3%A8%E6%84%8F%E7%89%A9%E7%90%86%E6%A8%A1%E5%BC%8F%E5%8F%88%E7%A7%B0%E5%86%85%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%BB%E8%BE%91%E6%A8%A1%E5%BC%8F%E5%8F%88%E7%A7%B0%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%AD%90%E6%A8%A1%E5%BC%8F%E5%8F%88%E7%A7%B0%E5%A4%96%E6%A8%A1%E5%BC%8F%EF%BC%89%E3%80%82%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%87%A0%E4%B8%AA%E7%89%A9%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%BB%E8%BE%91%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AD%90%E6%A8%A1%E5%BC%8F%EF%BC%9F-%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E9%97%B4%E7%9A%84%E4%B8%A4%E6%9E%81%E6%98%A0%E5%B0%84%EF%BC%9F%E7%94%B1%E8%B0%81%EF%BC%88DMBS%EF%BC%89%E6%9D%A5%E5%AE%8C%E6%88%90%E8%BF%99%E7%A7%8D%E6%98%A0%E5%B0%84%E5%8A%9F%E8%83%BD%E7%9A%84%EF%BC%9F%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%89%E6%98%AF%E5%B8%A6%E6%9D%A5%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7%E2%80%94%E2%80%94"><span class="toc-number">1.5.</span> <span class="toc-text">5、熟记5和6全部内容三级模式的名称和定义（注意物理模式又称内模式，逻辑模式又称模式，子模式又称外模式）。三级模式的数量：一个数据库有几个物理模式，逻辑模式和子模式？ 三级模式间的两极映射？由谁（DMBS）来完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">三级模式结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">三级模式结构的两级映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E6%98%A0%E5%B0%84%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">两级映射的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E7%94%A8%E5%88%B0%E7%9A%84A%E6%A8%A1%E5%BC%8F-B%E6%A8%A1%E5%BC%8F%E6%98%A0%E5%B0%84%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%8C%E5%BD%93%E2%80%A6%E5%8F%98%E2%80%A6%E4%B8%8D%E5%8F%98%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B9%9F%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">6、什么是逻辑数据独立性？什么是物理数据独立性？这两种数据独立性，分别是怎么实现的？（用到的A模式&#x2F;B模式映射搞清楚，当…变…不变的过程也搞清楚）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%8B%AC%E7%AB%8B%E6%80%A7%E5%92%8C%E7%89%A9%E7%90%86%E7%8B%AC%E7%AB%8B%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">逻辑独立性和物理独立性的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%94%A8%E6%88%B7%E6%88%96%E8%80%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%9D%A2%E5%90%91%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E5%93%AA%E4%B8%80%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7、用户或者应用程序面向的到底是哪一级数据库模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%A6%82%E5%BF%B5%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%98%AF%E5%AF%B9%E5%AE%A2%E8%A7%82%E4%B8%96%E7%95%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B1%82%E6%8A%BD%E8%B1%A1%E3%80%82%E5%B8%B8%E8%A7%81%E4%BE%8B%E5%AD%90%E6%98%AFE-R%E6%A8%A1%E5%9E%8B%E3%80%82"><span class="toc-number">1.8.</span> <span class="toc-text">8、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">模型的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E3%80%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F%E3%80%81%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">区分数据模型、数据模式、数据实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E5%88%86%E7%B1%BB"><span class="toc-number">1.8.3.</span> <span class="toc-text">数据模型的层次分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E9%80%BB%E8%BE%91%EF%BC%89%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.8.4.</span> <span class="toc-text">（逻辑）数据模型的三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.8.5.</span> <span class="toc-text">常见的数据模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1、数据模型的三要素？关系模型的三要素？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">数据模型三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">关系模型三要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.3.</span> <span class="toc-text">关系模型的相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">关系模型的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%9E%E6%80%A7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BB%84%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%87%8F%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2、关系的组成：什么是属性？什么是元组？什么是分量？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">关系的相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">关系的组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%90%86%E8%A7%A3%E5%85%B3%E7%B3%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">3、理解关系有哪些基本性质？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%88%E5%85%B3%E7%B3%BB%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">关系的性质（关系必须满足的条件）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E7%B3%BB%E6%9C%89%E5%93%AA%E5%9B%9B%E7%A7%8D%E7%A0%81%EF%BC%9F%E6%95%B0%E9%87%8F%EF%BC%88%E4%B8%80%E6%88%96%E5%A4%9A%E4%B8%AA%EF%BC%89%EF%BC%9F%E5%B9%B6%E8%83%BD%E6%A0%B9%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%88%A4%E5%AE%9A%EF%BC%81%E5%A4%96%E9%83%A8%E7%A0%81%E4%BB%8EE-R%E5%9B%BE%E7%9A%84%E4%BB%80%E4%B9%88%E6%A6%82%E5%BF%B5%E8%BD%AC%E5%8C%96%E8%80%8C%E6%9D%A5%EF%BC%9F%E5%A4%96%E9%83%A8%E7%A0%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%8F%AF%E4%BB%A5%E5%92%8C%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%BB%E7%A0%81%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A4%96%E9%83%A8%E7%A0%81%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%BB%E7%A0%81%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%9A%E5%AD%A6%E7%94%9F%EF%BC%88%E5%AD%A6%E5%8F%B7%EF%BC%8C%E5%A7%93%E5%90%8D%EF%BC%8C%E7%8F%AD%E9%95%BF%E5%AD%A6%E5%8F%B7%E2%80%A6%EF%BC%89%E3%80%82"><span class="toc-number">2.4.</span> <span class="toc-text">4、关系有哪四种码？数量（一或多个）？并能根据定义判定！外部码从E-R图的什么概念转化而来？外部码的属性名可以和所对应的主码不同，外部码可以指向同一个关系的主码。例如：学生（学号，姓名，班长学号…）。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E7%A0%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">关系的码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A0%81%E4%B8%8EE-R%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.4.2.</span> <span class="toc-text">外部码与E-R图的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E7%A0%81%E7%9A%84%E5%88%A4%E5%88%AB%E4%BE%9D%E6%8D%AE"><span class="toc-number">2.4.3.</span> <span class="toc-text">外部码的判别依据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AF%B9%E6%AF%94%E3%80%82"><span class="toc-number">2.5.</span> <span class="toc-text">5、关系模式和关系实例的对比。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">关系模式的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">关系实例的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.3.</span> <span class="toc-text">关系模式与关系实例的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E5%88%86%E4%B8%BA%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E3%80%82%E8%A1%A8%E7%A4%BA%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%EF%BC%8C%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97%EF%BC%88%E5%8F%88%E5%88%86%E4%B8%BA%E5%85%83%E7%BB%84%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97%E5%92%8C%E5%9F%9F%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97%EF%BC%89%E3%80%82"><span class="toc-number">2.6.</span> <span class="toc-text">6、关系操作分为查询和更新操作。表示关系操作的语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">关系操作的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A1%A8%E7%A4%BA%E2%80%94%E2%80%94%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">2.6.2.</span> <span class="toc-text">关系操作的表示——查询语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E8%BF%87%E7%A8%8B%E5%8C%96%E5%92%8C%E9%9D%9E%E8%BF%87%E7%A8%8B%E5%8C%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%86%E5%92%8C%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E7%9C%8B%E8%AF%BE%E4%BB%B6%E3%80%82%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E6%98%AF%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%EF%BC%8C%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97%E6%98%AF%E9%9D%9E%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%E3%80%82%E5%90%8E%E9%9D%A2%E8%AE%B2%E5%88%B0%E7%9A%84SQL%E6%98%AF%E9%9D%9E%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%E3%80%82"><span class="toc-number">2.7.</span> <span class="toc-text">7、过程化和非过程化语言的区分和理解——看课件。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%8E%8C%E6%8F%A1%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E7%9A%84%E5%90%84%E7%A7%8D%E8%BF%90%E7%AE%97%EF%BC%88%E5%8C%85%E6%8B%AC%E7%AC%A6%E5%8F%B7%EF%BC%89%E3%80%82%E5%85%B6%E4%B8%AD%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%88%E4%B8%8D%E5%8F%AF%E6%9B%BF%E4%BB%A3%EF%BC%89%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8F%AF%E4%BB%A5%E6%9B%BF%E4%BB%A3%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%8C%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E5%85%B6%E5%AE%83%E8%BF%90%E7%AE%97%E7%9A%84%E7%BB%84%E5%90%88%E5%BC%8F%E5%AD%90%E6%9D%A5%E6%9B%BF%E4%BB%A3%E7%9A%84%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？可以替代的运算，是怎么用其它运算的组合式子来替代的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">关系代数概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.8.2.</span> <span class="toc-text">关系运算的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">2.8.3.</span> <span class="toc-text">外连接？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.4.</span> <span class="toc-text">聚集函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E9%99%A4%E8%BF%90%E7%AE%97%E4%B8%8D%E8%A6%81%E6%B1%82%E3%80%82"><span class="toc-number">2.9.</span> <span class="toc-text">9、除运算不要求。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E2%80%94%E2%80%94-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80SQL"><span class="toc-number">3.</span> <span class="toc-text">第三章 —— 关系数据库语言SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81SQL%E7%9A%84%E5%85%A8%E5%90%8D%EF%BC%88%E4%B8%AD%E8%8B%B1%E6%96%87%EF%BC%89%E3%80%82SQL%E6%98%AF%E9%9D%9E%E8%BF%87%E7%A8%8B%E5%8C%96%E7%9A%84%E8%AF%AD%E8%A8%80%E3%80%82%E7%90%86%E8%A7%A3SQL%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%86%9F%E8%AE%B0SQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%8A%9F%E8%83%BD%E3%80%82%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E5%88%86%E5%88%AB%E7%94%B1%E5%93%AA%E4%BA%9B%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%8A%A8%E8%AF%8D%EF%BC%89%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81SQL%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%A7%84%E5%AE%9A%EF%BC%9A%E6%AF%8F%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%94%B1%E4%BB%80%E4%B9%88%E7%BB%84%E6%88%90%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3、SQL对数据库三级模式的规定：每级模式由什么组成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%90%86%E8%A7%A3SQL%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8Cchar-varchar-numeric%E7%AD%89%E3%80%82"><span class="toc-number">3.4.</span> <span class="toc-text">4、理解SQL中的系统数据类型，char&#x2F;varchar&#x2F;numeric等。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8E%8C%E6%8F%A1SQL%E7%9A%84%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5%EF%BC%88%E7%89%B9%E5%88%AB%E6%98%AF%E6%96%B0%E5%BB%BA%E8%A1%A8%EF%BC%8C%E5%BB%BA%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%BF%AE%E6%94%B9%E8%A1%A8%EF%BC%8C%E5%88%A0%E9%99%A4%E8%A1%A8%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%89%E3%80%82"><span class="toc-number">3.5.</span> <span class="toc-text">5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%8E%8C%E6%8F%A1SQL%E7%9A%84Select%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E3%80%82%E6%8E%8C%E6%8F%A1Like%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">3.6.</span> <span class="toc-text">6、掌握SQL的Select数据查询语句。掌握Like运算符的使用。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.1.</span> <span class="toc-text">一、基本语法结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B1%87%E5%90%88%E5%A4%9A%E4%B8%AASELECT%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%88%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">3.6.2.</span> <span class="toc-text">二、汇合多个SELECT的查询语句（集合运算）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%A9%E5%B1%95%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.3.</span> <span class="toc-text">三、扩展基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.6.4.</span> <span class="toc-text">嵌套子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.5.</span> <span class="toc-text">连接关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%8E%8C%E6%8F%A1SQL%E7%9A%84%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5%EF%BC%9A-Insert-Update-Delete%E3%80%82"><span class="toc-number">3.6.6.</span> <span class="toc-text">7、掌握SQL的各个数据修改语句： Insert, Update, Delete。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%A9%BA%E5%80%BC%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%82%E7%A9%BA%E5%80%BC%E7%9A%84%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%88IS-NULL%EF%BC%89%E3%80%82%E6%8E%8C%E6%8F%A1%E7%A9%BA%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99%EF%BC%88%E5%8C%85%E6%8B%AC%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E5%BF%BD%E7%95%A5%E7%A9%BA%E5%80%BC%E7%AD%89%EF%BC%89%EF%BC%8C%E8%83%BD%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E7%A9%BA%E5%80%BC%E5%BC%8F%E5%AD%90%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82"><span class="toc-number">3.7.</span> <span class="toc-text">8、空值的意义。空值的判定方法（IS NULL）。掌握空值的运算规则（包括聚集函数忽略空值等），能计算一个包含空值式子的结果。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%86%9F%E8%AE%B0%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BC%98%E7%82%B9%E3%80%82%E5%B9%B6%E7%90%86%E8%A7%A3%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">3.8.</span> <span class="toc-text">9、熟记视图的优点。并理解！！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E6%8E%8C%E6%8F%A1%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%E7%9A%84%E8%AF%AD%E5%8F%A5%E3%80%82%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">10、掌握定义视图的语句。什么是视图的嵌套定义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E7%90%86%E8%A7%A3%E5%AF%B9%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%98%AF%E6%80%8E%E6%A0%B7%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%88%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9F%A5%E8%AF%A2%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%97%B6%E5%B1%95%E5%BC%80%E8%A7%86%E5%9B%BE%E2%80%94%E2%80%94%E6%9B%BF%E6%8D%A2%E8%A7%86%E5%9B%BE%E4%B8%BA%E5%AE%83%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%82%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%97%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AF%B9%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%8C%E8%BF%99%E7%A7%8D%E8%BD%AC%E5%8C%96%E5%8F%AF%E8%83%BD%E5%9B%A0%E4%B8%BA%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9-%E4%BF%AE%E6%94%B9%E5%8F%97%E9%99%90%EF%BC%89%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%8C%E8%A7%86%E5%9B%BE%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E7%9A%84%EF%BC%8C%E4%BD%86%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B9%A6%E5%86%99%EF%BC%88%E6%8A%8A%E6%95%B4%E4%B8%AA%E6%9F%A5%E8%AF%A2%E6%88%96%E8%80%85%E5%85%B6%E4%B8%AD%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%83%A8%E5%88%86%E9%A2%84%E5%85%88%E5%81%9A%E6%88%90%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">11、理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：执行时展开视图——替换视图为它所对应的查询。视图的修改：执行时转化为对基本表的修改，这种转化可能因为哪些原因失败，从而无法修改&#x2F;修改受限）。所以，视图是不可能提高查询效率的，但可以简化查询的书写（把整个查询或者其中固定的部分预先做成一个视图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE-R%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">第七章 数据库设计和E-R模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%90%86%E8%A7%A3E-R%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9A%E5%AE%9E%E4%BD%93%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E8%81%94%E7%B3%BB%E3%80%82%E4%BB%A5%E5%8F%8A%E5%9C%A8E-R%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E3%80%82"><span class="toc-number">4.1.</span> <span class="toc-text">1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%A4%9F%E5%88%A4%E6%96%AD%E3%80%82"><span class="toc-number">4.2.</span> <span class="toc-text">2、三种特殊类型的属性，并能够判断。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%83%BD%E5%88%A4%E6%96%AD%E4%BA%8C%E5%85%83%E8%81%94%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%E3%80%82%E4%BB%A5%E5%8F%8A%E5%9C%A8E-R%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA%E3%80%82"><span class="toc-number">4.3.</span> <span class="toc-text">3、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%83%BD%E5%B0%86E-R%E5%9B%BE%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%A4%9A%E5%80%BC%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%88%E5%A6%82%E6%9E%9C%E6%9C%89n%E4%B8%AA%E5%A4%9A%E5%80%BC%E5%B1%9E%E6%80%A7%EF%BC%8Cn%E4%B8%AA%E5%88%86%E5%BC%80%E6%9D%A5%E5%A4%84%E7%90%86%EF%BC%89%EF%BC%9B1%E5%AF%B91%EF%BC%8C1%E5%AF%B9%E5%A4%9A%EF%BC%8C%E5%A4%9A%E5%AF%B91%EF%BC%8C%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%8C%E4%B8%89%E5%85%83%E4%BB%A5%E4%B8%8A%E8%81%94%E7%B3%BB%E5%90%84%E8%87%AA%E7%9A%84%E8%BD%AC%E5%8C%96%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94%E4%B8%8D%E8%A6%81%E5%BC%A0%E5%86%A0%E6%9D%8E%E6%88%B4%E3%80%82"><span class="toc-number">4.4.</span> <span class="toc-text">4、能将E-R图转化为关系模型。注意：多值属性的处理（如果有n个多值属性，n个分开来处理）；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%86%9F%E8%AE%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%9C%A8%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5%E5%88%86%E5%88%AB%E8%A6%81%E5%81%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">5、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">第八章  关系数据库模式设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%86%9F%E8%AE%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8D%E5%BD%93%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%97%AE%E9%A2%98%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99%E5%92%8C%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">5.1.</span> <span class="toc-text">1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96X%E2%86%92Y%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%82%E6%8E%8C%E6%8F%A1%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E4%BB%A5%E8%AF%BE%E4%BB%B6%E7%9A%84%E2%80%9C%E6%8E%92%E8%AF%BE%E2%80%9D%E5%85%B3%E7%B3%BB%E4%B8%BA%E4%BE%8B%EF%BC%89%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">2、理解函数依赖X→Y的含义。掌握判定函数依赖的方法（以课件的“排课”关系为例）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%89%E5%AF%B9%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%EF%BC%9A%E5%B9%B3%E5%87%A1-%E9%9D%9E%E5%B9%B3%E5%87%A1%EF%BC%8C%E9%83%A8%E5%88%86-%E5%AE%8C%E5%85%A8%EF%BC%8C%E4%BC%A0%E9%80%92-%E9%9D%9E%E4%BC%A0%E9%80%92%E3%80%82%E6%A0%B9%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%8E%BB%E7%90%86%E8%A7%A3%E5%92%8C%E5%88%A4%E5%AE%9A%E5%AE%83%E4%BB%AC%E3%80%82"><span class="toc-number">5.3.</span> <span class="toc-text">3、三对特殊类型的函数依赖：平凡&#x2F;非平凡，部分&#x2F;完全，传递&#x2F;非传递。根据定义去理解和判定它们。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E9%9B%86%E6%98%AF%E5%90%A6%E8%B6%85%E7%A0%81%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E5%90%A6%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">5.4.</span> <span class="toc-text">4、用函数依赖判断一个属性集是否超码，或者是否候选码的方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%8E%8C%E6%8F%A1%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E9%9B%86%E9%97%AD%E5%8C%85%E7%9A%84%E7%AE%97%E6%B3%95%E3%80%82%E4%BB%A5%E5%8F%8A%E7%94%B1%E6%AD%A4%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%98%AF%E5%90%A6%E6%88%90%E7%AB%8B%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">5.5.</span> <span class="toc-text">5、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E4%B8%8D%E8%A6%81%E6%B1%82%E3%80%824-3%E8%BF%99%E4%B8%80%E8%8A%82%E4%B8%8D%E8%A6%81%E6%B1%82%E3%80%82"><span class="toc-number">5.6.</span> <span class="toc-text">6、最小函数依赖集不要求。4.3这一节不要求。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%8E%8C%E6%8F%A11NF%E3%80%812NF%E3%80%813NF%E3%80%81BCNF%E7%9A%84%E5%AE%9A%E4%B9%89-%E8%A6%81%E6%B1%82%EF%BC%8C%E5%B9%B6%E8%83%BD%E4%BE%9D%E6%AD%A4%E8%BF%9B%E8%A1%8C%E5%88%A4%E5%AE%9A%E3%80%82"><span class="toc-number">5.7.</span> <span class="toc-text">7、掌握1NF、2NF、3NF、BCNF的定义&#x2F;要求，并能依此进行判定。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%8E%8C%E6%8F%A1%E8%A7%84%E8%8C%83%E5%8C%96%E5%88%B01NF%EF%BC%8C3NF%EF%BC%8CBCNF%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E3%80%82%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E5%BA%94%E8%AF%A5%E8%87%B3%E5%B0%91%E8%A7%84%E8%8C%83%E5%8C%96%E5%88%B03NF%E3%80%82%E8%A7%84%E8%8C%83%E5%8C%96%E5%88%B03NF%E5%92%8C%E8%A7%84%E8%8C%83%E5%8C%96%E5%88%B0BCNF%E7%9B%B8%E6%AF%94%EF%BC%8C%E5%90%8E%E8%80%85%E5%BE%97%E5%88%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E5%B1%9E%E4%BA%8E%E6%9B%B4%E9%AB%98%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E3%80%82"><span class="toc-number">5.8.</span> <span class="toc-text">8、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">补充  数据库安全性与完整性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E6%98%AF%E9%98%B2%E6%AD%A2%E9%9D%9E%E6%B3%95%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%90%88%E6%B3%95%E7%94%A8%E6%88%B7%E8%BF%9B%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8E%E5%81%9A%E4%BA%86%EF%BC%88%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9A%84%EF%BC%89%E9%9D%9E%E6%B3%95%E6%93%8D%E4%BD%9C%E3%80%82%E5%AE%8C%E6%95%B4%E6%80%A7%E6%98%AF%E9%98%B2%E6%AD%A2%E9%9D%9E%E6%B3%95%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%98%AF%E5%90%88%E6%B3%95%E7%94%A8%E6%88%B7%E5%8F%8A%E5%90%88%E6%B3%95%E6%93%8D%E4%BD%9C%E4%BA%A7%E7%94%9F%E7%9A%84%E3%80%82"><span class="toc-number">6.1.</span> <span class="toc-text">1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户及合法操作产生的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8E%8C%E6%8F%A1%E7%94%A8SQL%E6%8E%88%E4%BA%88%E6%9D%83%E9%99%90%E5%92%8C%E5%9B%9E%E6%94%B6%E3%80%81%E7%A6%81%E6%AD%A2%E6%9D%83%E9%99%90%E7%9A%84%E8%AF%AD%E5%8F%A5-grant-revoke-deny-%E3%80%82with-grant-option%E5%AD%90%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">6.2.</span> <span class="toc-text">2、掌握用SQL授予权限和回收、禁止权限的语句(grant, revoke, deny)。with grant option子句的作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%90%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E6%9D%83%E9%99%90%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%82%EF%BC%88%E4%BE%8B%E5%A6%82-insert-on-table-S-update-on-view-A%E7%AD%89"><span class="toc-number">6.3.</span> <span class="toc-text">3、理解常见权限的含义。（例如 insert on (table) S, update on (view) A等)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%90%86%E8%A7%A3%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9A%E6%AD%A3%E7%A1%AE%E3%80%81%E6%9C%89%E6%95%88%E3%80%81%E7%9B%B8%E5%AE%B9%E3%80%82%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%EF%BC%88%E8%A7%84%E5%88%99%EF%BC%89%E6%98%AF%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7%E6%89%80%E5%BF%85%E9%A1%BB%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%82"><span class="toc-number">6.4.</span> <span class="toc-text">4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%86%9F%E8%AE%B0%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E7%B1%BB%E5%AE%8C%E6%95%B4%E6%80%A7%E8%A7%84%E5%88%99%E3%80%82%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%EF%BC%9F%E7%90%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%88%E4%BF%AE%E6%94%B9%EF%BC%89%E6%93%8D%E4%BD%9C%E4%BC%9A%E7%A0%B4%E5%9D%8F%E8%BF%99%E4%BA%9B%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%8E%8C%E6%8F%A1%E7%94%A8SQL%E5%AE%9A%E4%B9%89%E4%B8%BB%E7%A0%81%E7%BA%A6%E6%9D%9F%E3%80%81%E5%A4%96%E7%A0%81%E7%BA%A6%E6%9D%9F%E3%80%81%E9%9D%9E%E7%A9%BA-not-null-%E7%BA%A6%E6%9D%9F%E3%80%81%E5%94%AF%E4%B8%80-unique-%E7%BA%A6%E6%9D%9F%E3%80%81%E5%9F%9F%E7%BA%A6%E6%9D%9F%E3%80%81%E6%A3%80%E6%9F%A5-check-%E7%BA%A6%E6%9D%9F%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%9F%E4%BB%A5%E5%8F%8A%E8%BF%99%E4%BA%9B%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%90%AB%E4%B9%89%E3%80%81%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">6.6.</span> <span class="toc-text">6、掌握用SQL定义主码约束、外码约束、非空(not null)约束、唯一(unique)约束、域约束、检查(check)约束的语句？以及这些约束的含义、作用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%9C%A8%E5%AE%9A%E4%B9%89%E5%A4%96%E9%83%A8%E7%A0%81%E7%BA%A6%E6%9D%9F%E6%97%B6%EF%BC%8C%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%8F%82%E7%85%A7%E5%8A%A8%E4%BD%9C%EF%BC%9F%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">7、在定义外部码约束时，有哪几种参照动作？代表什么意义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%96%AD%E8%A8%80%E4%B8%8D%E4%BD%9C%E8%A6%81%E6%B1%82"><span class="toc-number">6.8.</span> <span class="toc-text">8、断言不作要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%86%9F%E8%AE%B0%E4%BB%A5%E4%B8%8B%E5%85%A8%E9%83%A8-%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F%E8%A7%A6%E5%8F%91%E5%99%A8-ECA%E8%A7%84%E5%88%99%E6%9E%84%E6%88%90%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E9%9D%A2%EF%BC%8C%E5%8C%85%E6%8B%AC%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E3%80%82%E5%93%AA%E4%BA%9B%E4%BA%8B%E4%BB%B6%E4%BC%9A%E6%BF%80%E6%B4%BB%EF%BC%88INSERT-UPDATE-DELETE%E6%93%8D%E4%BD%9C%EF%BC%89%E3%80%82"><span class="toc-number">6.9.</span> <span class="toc-text">9、熟记以下全部 触发器的概念。触发器有哪些作用？触发器&#x2F;ECA规则构成的三个方面，包括英文单词。哪些事件会激活（INSERT,UPDATE,DELETE操作）。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">第十二章——事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%82%E7%86%9F%E8%AE%B0%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%80%A7%E8%B4%A8%EF%BC%88%E5%8C%85%E6%8B%AC%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D%E3%80%81%E8%A7%A3%E9%87%8A%E3%80%81%E4%BF%9D%E9%9A%9C%E6%9C%BA%E5%88%B6%EF%BC%89%E3%80%82"><span class="toc-number">7.1.</span> <span class="toc-text">1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、保障机制）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8E%8C%E6%8F%A1%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E7%9A%84%E5%A4%9A%E4%B8%AASQL%E8%AF%AD%E5%8F%A5%E3%80%82%E4%B8%A4%E7%A7%8D%E7%BB%93%E6%9D%9F%E6%96%B9%E5%BC%8F%EF%BC%88%E6%8F%90%E4%BA%A4%E6%88%96%E5%9B%9E%E6%BB%9A%EF%BC%89%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E5%8C%BA%E5%88%AB%E3%80%82%E4%B8%8D%E8%83%BD%E6%8F%90%E4%BA%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%BB%93%E5%B1%80%E5%8F%AA%E8%83%BD%E6%98%AF%E5%9B%9E%E6%BB%9A%E3%80%82"><span class="toc-number">7.2.</span> <span class="toc-text">2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。不能提交的事务结局只能是回滚。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%88%86%E4%B8%B2%E8%A1%8C%E8%B0%83%E5%BA%A6%E5%92%8C%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%EF%BC%8C%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%8C%E4%BD%86%E4%B9%9F%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%9A%E7%A0%B4%E5%9D%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%8C%E4%BA%A7%E7%94%9F%E9%94%99%E8%AF%AF%E3%80%82"><span class="toc-number">7.3.</span> <span class="toc-text">3、事务调度分串行调度和并发调度，并发调度的效率高，但也有问题：破坏数据一致性，产生错误。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%86%9F%E8%AE%B0%E5%B9%B6%E5%8F%91%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%89%E7%B1%BB%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%88%E8%BF%87%E7%A8%8B%EF%BC%9F%EF%BC%89%E3%80%82%E4%BA%A7%E7%94%9F%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BA%8B%E5%8A%A1%E5%9C%A8%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%88%E8%B0%83%E5%BA%A6%EF%BC%89%E6%97%B6%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%BF%9D%E8%AF%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%82"><span class="toc-number">7.4.</span> <span class="toc-text">4、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%EF%BC%88%E8%B0%83%E5%BA%A6%EF%BC%89%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E5%87%86%E5%88%99%EF%BC%9A%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E2%80%94%E2%80%94%E6%95%88%E6%9E%9C%E7%AD%89%E4%BB%B7%E4%BA%8E%E4%B8%80%E4%B8%AA%E4%B8%B2%E8%A1%8C%E8%B0%83%E5%BA%A6%E3%80%82"><span class="toc-number">7.5.</span> <span class="toc-text">5、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%B0%81%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88%E5%86%99%E9%94%81%E3%80%81X%E9%94%81%EF%BC%89%E3%80%81%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%88%E8%AF%BB%E9%94%81%E3%80%81S%E9%94%81%EF%BC%89%E3%80%82%E5%90%84%E4%B8%AA%E9%94%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%88%E4%BE%8B%E5%A6%82%E6%8E%92%E4%BB%96%E9%94%81%E6%98%AF%E8%AF%BB-%E5%86%99%EF%BC%8C%E5%85%B1%E4%BA%AB%E6%98%AF%E8%AF%BB%EF%BC%89%EF%BC%8C%E7%9B%B8%E5%AE%B9-%E6%8E%92%E6%96%A5%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。各个锁的含义（例如排他锁是读+写，共享是读），相容&#x2F;排斥关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%84%8F%E5%90%91%E9%94%81%E4%B8%8D%E8%A6%81%E6%B1%82%E3%80%82%E6%9B%B4%E6%96%B0%E9%94%81%E4%B8%8D%E8%A6%81%E6%B1%82%E3%80%82"><span class="toc-number">7.7.</span> <span class="toc-text">7、意向锁不要求。更新锁不要求。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%EF%BC%9F%E8%A7%84%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%88%E5%90%84%E8%87%AA%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%89%EF%BC%9F%E4%B8%A4%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%85%E5%88%86%E9%9D%9E%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E3%80%82"><span class="toc-number">7.8.</span> <span class="toc-text">8、有哪几种封锁协议？规则是什么？它们的作用（各自解决了哪些数据不一致性问题）？两段封锁协议是可串行化调度的充分非必要条件。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.8.1.</span> <span class="toc-text">一级封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.8.2.</span> <span class="toc-text">二级封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.8.3.</span> <span class="toc-text">三级封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.8.4.</span> <span class="toc-text">两段封锁协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E7%9A%84%E5%85%85%E5%88%86%E9%9D%9E%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.8.5.</span> <span class="toc-text">两段封锁协议是可串行化的充分非必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">7.8.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%EF%BC%9A%E5%86%97%E4%BD%99%E3%80%82%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%92%8C%E7%99%BB%E8%AE%B0%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">7.9.</span> <span class="toc-text">9、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E9%9D%99%E6%80%81%E5%A4%87%E4%BB%BD-vs-%E5%8A%A8%E6%80%81%E5%A4%87%E4%BB%BD%EF%BC%88%E6%9C%89%E5%90%A6%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9B%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E8%BF%90%E8%A1%8C%E4%BA%8B%E5%8A%A1%E6%9D%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89%E3%80%82"><span class="toc-number">7.10.</span> <span class="toc-text">10、静态备份 vs 动态备份（有否一致性；是否允许用户运行事务来操作数据库）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A%E6%98%AF%E7%94%A8%E6%9D%A5%E8%AE%B0%E5%BD%95%E4%BA%8B%E5%8A%A1%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">7.11.</span> <span class="toc-text">11、日志文件的定义：是用来记录事务对数据库进行更新操作的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B%E4%B8%80%E6%9D%A1%EF%BC%9B%E4%BA%8B%E5%8A%A1%E7%BB%93%E6%9D%9F%E4%B8%80%E6%9D%A1%EF%BC%9B%E4%BA%8B%E5%8A%A1%E8%8B%A5%E5%B9%B2%E6%AC%A1%E6%9B%B4%E6%96%B0%E8%8B%A5%E5%B9%B2%E6%9D%A1%EF%BC%89%E3%80%82%E5%9C%A8%E7%99%BB%E8%AE%B0%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E6%97%B6%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%89%8D%E5%90%8E%E7%9A%84%E6%97%A7%E5%80%BC%E4%B8%8E%E6%96%B0%E5%80%BC%E9%83%BD%E8%A6%81%E4%BF%9D%E5%AD%98%E5%88%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E4%B8%AD%E3%80%82"><span class="toc-number">7.12.</span> <span class="toc-text">12、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记更新操作的日志记录时，更新前后的旧值与新值都要保存到日志记录中。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E8%A1%8C%E8%AE%B0%E5%BD%95%E4%BC%98%E5%85%88%EF%BC%88%E5%85%88%E5%86%99%E6%97%A5%E5%BF%97%EF%BC%89%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">7.13.</span> <span class="toc-text">13、什么是运行记录优先（先写日志）原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E7%86%9F%E8%AE%B0%E4%BB%A5%E4%B8%8B%E5%85%A8%E9%83%A8%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%85%E9%9A%9C%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%AE%83%E4%BB%AC%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E6%95%85%E9%9A%9C%E7%9A%84%E8%B5%B7%E5%9B%A0%EF%BC%88%E4%BE%8B%E5%A6%82%E6%AD%BB%E9%94%81%E5%BC%95%E8%B5%B7%E4%BA%8B%E5%8A%A1%E6%95%85%E9%9A%9C%EF%BC%8C%E5%81%9C%E7%94%B5%E5%BC%95%E8%B5%B7%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%EF%BC%8C%E7%A1%AC%E7%9B%98%E5%9D%8F%E9%81%93%E5%BC%95%E8%B5%B7%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C%E7%AD%89%E7%AD%89%E2%80%A6%EF%BC%89%EF%BC%8C%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4%EF%BC%88%E4%BA%8B%E5%8A%A1%E6%9C%AC%E8%BA%AB%EF%BC%9FDBMS%E7%B3%BB%E7%BB%9F%EF%BC%9F%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F%E7%A3%81%E7%9B%98%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F%EF%BC%89%E3%80%81%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5%EF%BC%88%E6%96%B9%E6%B3%95%E8%BF%87%E7%A8%8B%EF%BC%89%EF%BC%8C%E5%8F%8A%E7%94%B1%E8%B0%81%E5%AE%8C%E6%88%90%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8-or-%E7%94%A8%E6%88%B7%E5%B9%B2%E9%A2%84%EF%BC%9F%EF%BC%89"><span class="toc-number">7.14.</span> <span class="toc-text">14、熟记以下全部不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），及由谁完成（系统自动 or 用户干预？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E6%A3%80%E6%9F%A5%E7%82%B9%E4%B8%8D%E8%A6%81%E6%B1%82"><span class="toc-number">7.15.</span> <span class="toc-text">15、检查点不要求</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/08/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91%E9%85%8D%E7%BD%AE%20python%20%E7%8E%AF%E5%A2%83/" title="0 基础配置 Python 环境">0 基础配置 Python 环境</a><time datetime="2025-11-08T07:00:00.000Z" title="发表于 2025-11-08 15:00:00">2025-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%914.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/" title="【深度学习】4. 深度学习计算">【深度学习】4. 深度学习计算</a><time datetime="2024-11-16T07:00:00.000Z" title="发表于 2024-11-16 15:00:00">2024-11-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%915.%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="【深度学习】5. 卷积神经网络（CNN）">【深度学习】5. 卷积神经网络（CNN）</a><time datetime="2024-10-18T07:00:00.000Z" title="发表于 2024-10-18 15:00:00">2024-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%913.%20%E5%A4%9A%E5%B1%82%E6%AC%A1%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="【深度学习】3. 多层次感知机">【深度学习】3. 多层次感知机</a><time datetime="2024-10-16T07:00:00.000Z" title="发表于 2024-10-16 15:00:00">2024-10-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%912.%20%E7%BA%BF%E6%80%A7%E7%BD%91%E7%BB%9C/" title="【深度学习】2. 线性网络">【深度学习】2. 线性网络</a><time datetime="2024-10-16T07:00:00.000Z" title="发表于 2024-10-16 15:00:00">2024-10-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/self_img/11c.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Cyrus</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>