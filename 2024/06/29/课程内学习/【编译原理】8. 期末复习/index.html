<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>期末复习 | nullptr</title><meta name="author" content="Icserm"><meta name="copyright" content="Icserm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="期末复习 第一章 程序语言的分类 程序语言分为两种，高级语言和低级语言。 其中低级语言可以直接控制硬件，如汇编语言、机器语言 高级语言接近人类自热语言，如C++、Python、Java 程序翻译的方式有哪些？有何不同？ 程序翻译的方式有两种，分别是编译程序、解释程序。 编译程序借助编译器生成目标程序，目标程序收到输入数据和运行库后执行得到结果，优势是效率高，劣势是不跨平台 解释程序直接将输入的数据">
<meta property="og:type" content="article">
<meta property="og:title" content="期末复习">
<meta property="og:url" content="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:description" content="期末复习 第一章 程序语言的分类 程序语言分为两种，高级语言和低级语言。 其中低级语言可以直接控制硬件，如汇编语言、机器语言 高级语言接近人类自热语言，如C++、Python、Java 程序翻译的方式有哪些？有何不同？ 程序翻译的方式有两种，分别是编译程序、解释程序。 编译程序借助编译器生成目标程序，目标程序收到输入数据和运行库后执行得到结果，优势是效率高，劣势是不跨平台 解释程序直接将输入的数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/self_img/head_img.jpg">
<meta property="article:published_time" content="2024-06-29T00:00:00.000Z">
<meta property="article:modified_time" content="2024-06-29T00:50:00.000Z">
<meta property="article:author" content="Icserm">
<meta property="article:tag" content="课程学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/self_img/head_img.jpg"><link rel="shortcut icon" href="/self_img/bollon.png"><link rel="canonical" href="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-29 08:50:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="onerror=null;src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/self_img/11c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="nullptr"><span class="site-name">nullptr</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-29T00:50:00.000Z" title="更新于 2024-06-29 08:50:00">2024-06-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>期末复习</h1>
<h2 id="第一章">第一章</h2>
<h3 id="程序语言的分类">程序语言的分类</h3>
<p>程序语言分为两种，高级语言和低级语言。<br>
其中低级语言可以直接控制硬件，如汇编语言、机器语言<br>
高级语言接近人类自热语言，如C++、Python、Java</p>
<h3 id="程序翻译的方式有哪些？有何不同？">程序翻译的方式有哪些？有何不同？</h3>
<p>程序翻译的方式有两种，分别是编译程序、解释程序。<br>
编译程序借助编译器生成目标程序，目标程序收到输入数据和运行库后执行得到结果，优势是效率高，劣势是不跨平台<br>
解释程序直接将输入的数据和源程序进行解释并执行得到结果，优势是跨平台，劣势是暴露源码</p>
<h3 id="编译程序包含多少个阶段、各阶段的功能是什么？">编译程序包含多少个阶段、各阶段的功能是什么？</h3>
<p>程序编译的过程包含6个阶段，分别是：扫描程序、语法分析程序、语义分析程序、源代码优化程序、代码生成器、目标代码优化程序。</p>
<ol>
<li>扫描程序：功能是词法分析，将源程序进行分词</li>
<li>语法分析程序：功能是定义程序的符号元素以及元素之间的关系</li>
<li>语义分析程序：功能是理解程序的意思，并进行声明和类型检查</li>
<li>源代码优化程序：对代码进行改进或优化</li>
<li>代码生成器：得到中间代码（逆波兰、三元组、四元组），并将其生成目标代码</li>
<li>目标代码优化程序：与机器有关的优化，利用机器指令的特征对目标代码进行优化</li>
</ol>
<h2 id="第二章（重点）——词法分析">第二章（重点）——词法分析</h2>
<h3 id="正则表达式运算及其构建方法">正则表达式运算及其构建方法</h3>
<h3 id="正则表达式-toNFA-toDFA-toDFA最小化">正则表达式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>NFA<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>DFA<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>DFA最小化</h3>
<h4 id="确定化有穷自动机DFA的定义">确定化有穷自动机DFA的定义</h4>
<h4 id="非确定化有穷自动机NFA的定义">非确定化有穷自动机NFA的定义</h4>
<h4 id="DFA和NFA的区别">DFA和NFA的区别</h4>
<h4 id="NFA转化为DFA的方法">NFA转化为DFA的方法</h4>
<h5 id="epsilon闭包的定义"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包的定义</h5>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包是指可由一个或多个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\epsilon-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">−</span></span></span></span>转换从某个状态或某些状态达到的所有状态的集合。<br>
算法实现：深度优先或者广度优先，从初态出发，经过每一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>得到的状态都添加到该初态的集合上去。</p>
<h5 id="注意判别终态以及ERROR状态">注意判别终态以及ERROR状态</h5>
<p>如果某个状态集合中包含原来的终态，该状态集合为终态，对终态求非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包如果是空集，得到接受状态ACC，在状态转换表中不用写；<br>
如果某个状态集合为非终态（不包含原来的终态），对该集合求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>非</mtext><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">非\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">非</span><span class="mord mathnormal">ϵ</span></span></span></span>闭包如果是空集，则得到出错状态ERROR，在状态转换表中不用写；</p>
<h4 id="DFA最小化">DFA最小化</h4>
<h3 id="词法分析程序的生成方法">词法分析程序的生成方法</h3>
<h4 id="代码实现有穷自动机（两种方法）">代码实现有穷自动机（两种方法）</h4>
<h5 id="方法一：状态转换方法">方法一：状态转换方法</h5>
<ol>
<li>利用一个变量保持当前状态，并将转换写成一个双层嵌套的case语句而不是一个循环</li>
<li>其中第一个case语句测试当前的状态，嵌套着的第二层测试输入字符以及所给状态</li>
</ol>
<h5 id="方法二：转换表——二维数组">方法二：转换表——二维数组</h5>
<ol>
<li>通过表示转换函数T值的状态和输入字符来索引（构建查表的方法）</li>
</ol>
<h3 id="实验一与实验二">实验一与实验二</h3>
<h3 id="总结习题">总结习题</h3>
<p>==注意的问题：经常忘记画自环！！！==<br>
<strong>PPT习题</strong>：<br>
一、构建正则表达式习题<br>
chapter2的P37-38页</p>
<ol>
<li>例2.1：在仅由字母表中的3个字符组成的简单 字母表={a,b,c}中，考虑在这个字母表上的 仅包括一个b的所有串的集合</li>
<li>例2.2：在与上面相同的字母表中，如果集合是包 括了最多一个b的所有串</li>
<li>标识符的正则表达式的写法（必须由一个字母开头并且只包含字母和数字）</li>
<li>整数正则表达式（可以带正号、负号或者不带）</li>
<li>十进制数可以是整数、浮点数、或带有指数的 数(由e或E表示)的序列。如：123 3.14 -4.5 2.71E-2</li>
<li>注释的正则表达式：
<ul>
<li>pascal语言的注释，如{ this is a Pascal comment }</li>
</ul>
</li>
</ol>
<p>二、正则表达式转DFA</p>
<ol>
<li>基本例题<br>
例1:正则表达式 ab<br>
例2:正则表达式 a|b<br>
例3:正则表达式 a*<br>
例4:正则表达式 (ab)*<br>
例5:正则表达式 (a|b)*<br>
例6:正则表达式 ab|ac</li>
<li>例2.6: 串中仅有一个b的集合的正则表达式为： (not b )* b (not b ) *</li>
<li>Pascal注释 { ( ~} )* } 对应的DFA</li>
<li>C语言注释的DFA</li>
<li>例2.8 科学表示法的数字常量的正则表达式是什么？DFA是什么？</li>
</ol>
<p>三、正则表达式转NFA（Tompson的方法）</p>
<ol>
<li>基本例题<br>
例1:正则表达式 ab<br>
例2:正则表达式 a|b<br>
例3:正则表达式 a*<br>
例4:正则表达式 (ab)*<br>
例5:正则表达式 (a|b)*<br>
例6:正则表达式 ab|ac</li>
<li>例1 将正则表达式 ab|a 转换为NFA</li>
<li>例2 正则表达式 letter(letter|digit)*对应的NFA</li>
<li>例：正则表达式(a|c)*b按Thompson方法构 造所得NFA</li>
</ol>
<p>四、NFA转DFA（子集构造法）</p>
<ol>
<li>例1 求出正则表达式a*的NFA转换成DFA的过程</li>
<li>例2 将下面NFA转换为DFA.<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629162855.png" alt="Pasted image 20240629162855"></li>
<li>例3.将下面NFA转换为DFA。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629162938.png" alt="Pasted image 20240629162938"><br>
五、DFA最小化</li>
<li>例2.19 将下面与正则表达式(a|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>)b*对应的DFA进行 最小化（不过可以先尝试不看这个DFA，而是先写NFA，再NFA转DFA，再进行最小化）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629174557.png" alt="Pasted image 20240629174557"><br>
==六、用代码实现有穷自动机==</li>
<li>实验1、实验2的内容</li>
<li>用代码实现如下DFA图<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629183010.png" alt="Pasted image 20240629183010"></li>
<li>用代码实现如下DFA图<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629183038.png" alt="Pasted image 20240629183038"></li>
</ol>
<h2 id="第三章（重点）-——-文法">第三章（重点） —— 文法</h2>
<h3 id="文法、语言">文法、语言?</h3>
<h4 id="文法的定义">文法的定义</h4>
<p>文法适用于描述语言的语法结构，用四元组表示。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (VN, VT, P, S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>VN是非终结符</li>
<li>VT是终结符</li>
<li>S是开始符号</li>
<li>P是产生式集，形式为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><br>
文法的关键描述在于<strong>开始符号</strong>和<strong>规则</strong><br>
所以文法可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">[</mo><mtext>开始符号</mtext><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mtext>规则</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">G[开始符号]=\{规则\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">[</span><span class="mord cjk_fallback">开始符号</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">规则</span><span class="mclose">}</span></span></span></span><br>
==一个文法必须满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∩</mo><msub><mi>V</mi><mi>T</mi></msub><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">S\in V_N, V_N \cap V_T = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span>==</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li>文法推导式右部的规则：
<ul>
<li>运算符有：选择 | 、并置、括号（）</li>
<li>无重复符号（*），用递归实现重复</li>
<li>规则右部可以使用元符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，为了能产生空串</li>
</ul>
</li>
<li>注意文法表示的习惯用法：
<ul>
<li>大写字母表示非终结符</li>
<li>尖括号把非终结符括起来也可以表示非终结符</li>
<li>前面的小写字母表示单个终结符号</li>
<li>后面的小写字母u、v、w、x、y、z以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mtext>、</mtext><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha、\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>等符号表示（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">V=VN\cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>上的符号串）</li>
</ul>
</li>
</ol>
<h4 id="文法的存储结构以及推导过程在计算机内部的存储表示（PPT上说重点）">文法的存储结构以及推导过程在计算机内部的存储表示（PPT上说重点）</h4>
<p>文法的存储可以以数组表示的方法，也可以以链式存储的方法。重点介绍链式存储方法，后面的推导过程也是链式存储的方式。<br>
==这部分在PPT的第44页==<br>
一、数组表示方法<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629213802.png" alt="Pasted image 20240629213802"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214508.png" alt="Pasted image 20240629214508"></p>
<p>二、文法的链式存储<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214537.png" alt="Pasted image 20240629214537"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214550.png" alt="Pasted image 20240629214550"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214606.png" alt="Pasted image 20240629214606"></p>
<h4 id="语言的定义">语言的定义</h4>
<p>文法G所描述的语言用L(G)表示，它由文法G所产生的全部句子组成，即：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo>∈</mo><mi>V</mi><msup><mi>T</mi><mo>+</mo></msup><mtext>且</mtext><mi>S</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(G) = \{w | w \in VT^+ 且 S \Rightarrow^+ w \}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8213em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span></span></p>
<ul>
<li>符号串w是从开始符号s推导出来的</li>
<li>w仅由终结符号组成</li>
<li>W称为该语言的句子</li>
<li>L(G)是由所有这样的句子构成的<br>
<strong>设G1、G2 为两个文法,若它们所产生的语言相等,即 L(G1)= L(G2)，则称G1和G2等价</strong></li>
</ul>
<h4 id="上下文无关语言的定义">上下文无关语言的定义</h4>
<p>设CFG（Context-Free Grammer）上下文无关文法规则G=（VN, VT, P, S），定义G的语言为L(G) = {w | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>V</mi><msup><mi>T</mi><mo>∗</mo></msup><mo>∧</mo><mtext> </mtext><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>w</mi></mrow><annotation encoding="application/x-tex">w \in VT^* \land\ S \Rightarrow^* w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>}<br>
如果一个语言L是某个CFG G的语言，即L(G)=L，则L是上下文无关语言</p>
<h3 id="文法的分类是怎样的-它们之间有何关系">文法的分类是怎样的? 它们之间有何关系?</h3>
<h4 id="文法的分类">文法的分类</h4>
<p>文法（grammer）是一个四元组，G=（VN, VT, P, S），Chomsky通过对产生式施加不同的限制，把文法以及其对应的语言分为四种类型，即0型文法、1型文法、2型文法和3型文法。</p>
<ol>
<li>0型文法<br>
特点：没有对规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的边做限制，仅要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>中至少含一个非终结符号。因此又称为无限制文法或短语文法，也称为0型语言或递归可枚举语言；</li>
<li>1型文法（也称上下文有关的语法）<br>
特点：限制P中的每个规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>除了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>外，都要满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>β</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\alpha| \leq |\beta|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span></span></span></span>，并且要求S不能出现在任何产生式的右部<br>
这里的||是取串的长度，而不是绝对值；<br>
上下文有关是指对非终结符进行替换时，需要考虑该符号所处的上下文环境；<br>
例如：<br>
对于规则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mi>A</mi><mi>α</mi><mn>2</mn><mo>→</mo><mi>α</mi><mn>1</mn><mi>β</mi><mi>α</mi><mn>2</mn><mo stretchy="false">(</mo><mi>β</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi><mo separator="true">;</mo><mi>α</mi><mn>1</mn><mo separator="true">,</mo><mi>α</mi><mn>2</mn><mtext>不同时为</mtext><mi>ϵ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha1 A \alpha2 \to \alpha1 \beta \alpha2(\beta \neq \epsilon; \alpha1, \alpha2不同时为\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mord cjk_fallback">不同时为</span><span class="mord mathnormal">ϵ</span><span class="mclose">)</span></span></span></span> , 当用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，只能在上下文为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mtext>和</mtext><mi>α</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha1 和 \alpha2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span></span></span></span>时才能进行；</li>
<li><strong>2型文法</strong><br>
每个规则的特点限制为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，其中A为==单个非终结符==，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>T</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>N</mi></msub><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\beta \in (V_T\cup V_N)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>。也称上下文无关语法，即当使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，与A的上下文环境无关；</li>
<li>3型文法<br>
每个规则的特点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mtext>，</mtext><mi>A</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mtext>，</mtext><mi>a</mi><mo>∈</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">B，A\in V_N， a \in V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 他们都是单个符号，称为正规文法或者正则文法。<br>
由于规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>中，B位于a的右边，所以也称为右线性文法。类似地，正规文法也可以是左线性的（即产生式的形式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to Ba</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>）<br>
产生式也可以形如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi><mtext>或</mtext><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to Ba 或 A \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，此时称为左线性的</li>
</ol>
<h4 id="四种文法之间的关系">四种文法之间的关系</h4>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629224051.png" alt="Pasted image 20240629224051"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629224105.png" alt="Pasted image 20240629224105"></p>
<h3 id="推导、规约、语法树、文法的二义性？">推导、规约、语法树、文法的二义性？</h3>
<h4 id="归约与推导">归约与推导</h4>
<ul>
<li>归约：将产生式的右部替换为产生式的左部，归约的过程是自底向上构造了一棵树</li>
<li>推导：将产生式的左部替换为产生式的右部，推导的过程是自顶向下构造了一棵树</li>
</ul>
<h4 id="最左推导">最左推导</h4>
<p>若推导过程的每一步总是替换出现在最左边的非终结符，则称这样的推导为最左推导。最左推导关系用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>l</mi><mi>m</mi></mrow></munder></mo></mrow><annotation encoding="application/x-tex">\underset{lm}{\Rightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.119em;vertical-align:-0.7521em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span></span></span></span></span>表示，自反传递闭包用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>l</mi><mi>m</mi></mrow></munder></mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\underset{lm}{\Rightarrow}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4408em;vertical-align:-0.7521em;"></span><span class="mrel"><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>表示</p>
<h4 id="最右推导">最右推导</h4>
<p>若推导的每一步总是替换出现在最右边的非终结符，则称这样的推导为最右推导。最右推导关系用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>r</mi><mi>m</mi></mrow></munder></mo></mrow><annotation encoding="application/x-tex">\underset{rm}{\Rightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0669em;vertical-align:-0.7em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span>表示，自反传递闭包用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>r</mi><mi>m</mi></mrow></munder></mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\underset{rm}{\Rightarrow}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3887em;vertical-align:-0.7em;"></span><span class="mrel"><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>表示</p>
<h4 id="句子、句型，推导关系到自反传递闭包">句子、句型，推导关系到自反传递闭包</h4>
<ol>
<li>句型：如果符号串u是从开始符号s推导出来的，即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow^*u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>，则称u是一个句型<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&quot;</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">&quot;\Rightarrow^*&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span></span></span></span>表示经过0步或多部推导<br>
S=u称为0步推导<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⇒</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>称为1步推导<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>称为1步或多步推导</li>
<li>左推导得出的句型称为左句型，右推导得出来的是右句型</li>
<li>句子：仅含终结符的句型, 从开始符号推导出来的仅含有终结符的符号串；</li>
</ol>
<h4 id="分析树的定义">分析树的定义</h4>
<p>在文法G=(VN, VT, P, S)下的分析树具有以下特征：</p>
<ol>
<li>根节点标记为文法的开始符号S</li>
<li>每个结点上的标记都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">V = VN \cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>中的一个符号</li>
<li>如果一棵子树的根标记为A，且其所有的直接后代节点从左向右排列的顺序为A1，A2…AK，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2...</mn><mi>A</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">A \to A1,A2...AK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord">2...</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是P中的一个<strong>规则</strong></li>
<li>如果T1是根节点的唯一子树，且其标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在P中</li>
<li>如果树的所有叶子节点上的标记从左到右排列为字符串w，则w是G的<strong>句型</strong>，若w中仅含有终结字符，则它为G所产生的<strong>句子</strong><br>
<strong>相关术语</strong>：</li>
</ol>
<ul>
<li>句型：从树根开始的子树</li>
<li>短语：包含末端节点（叶子节点）所形成子树（不一定含树根）的符号串</li>
<li>简单短语：只有父子两代的子树的末端节点（叶子节点）形成的符号串</li>
<li>句柄：最左的简单短语<br>
<strong>分析树的构造方法</strong>：</li>
<li>步骤1 以识别符号Z建立根结点，序号为1，且以这仅包含一个 非终结符号的句型Z作为当前句型。</li>
<li>步骤2 从当前句型中找出最左的非终结符号U，显示以U为左 部的一切规则，根据所给的输入符号串，选择其中的一个规则 U::=X1X2…Xm,以U为分支名字结点，以X1X2…Xm作为分支结点符 号串，构造分支。建立父子兄弟结点关系。</li>
<li>步骤3 重复步骤2，直到当前句型中不再包含非终结符号，分 析树构造结束，最终的分析树为所求。<br>
<strong>分析树的优缺点</strong>：</li>
<li>优点：分析树可以反映推导的全过程，信息齐全，可以还原记号序列</li>
<li>缺点：过于复杂，耗费空间<br>
解决方法：压缩分析树，只存储有用的信息，于是就出现了<strong>语法树</strong></li>
</ul>
<h4 id="语法树">语法树</h4>
<p>语法树是分析树的精简版，只保留分析树中对后续分析<strong>有用的信息</strong>，比分析树的效率更高。<br>
<strong>问题关键</strong>：分析对应的语句的文法规则中，什么信息才是对后续有用的信息。比如算术表达式要保留表达式信息、运算符信息；if语句要保留测试表达式、then部分（正确要执行的部分）、else部分（错误要执行的部分）…<br>
==这里要把实验三在回顾一遍，重点回顾语法树的构建==<br>
例如：<br>
1)算术表达式的语法树存储结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Plus, Minus, Times, Divsion&#125; OpKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;OpKind, ConstKind, VarKind&#125; ExpKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">streetnode</span>&#123;</span><br><span class="line">	ExpKind kind;</span><br><span class="line">	OpKind op;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">streenode</span> *lchild, *rchild;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">char</span> varname[<span class="number">20</span>];</span><br><span class="line">&#125;STreeNode;</span><br><span class="line"><span class="keyword">typedef</span> STreetNode *SyntaxTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2)if的语法树存储结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; ExpK, StmtK&#125; NodeKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; Zero, One&#125; ExpKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; IfK, OtherK&#125; StmtKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">streenode</span> &#123; </span><br><span class="line">	NodeKind kind; </span><br><span class="line">	ExpKind ekind; </span><br><span class="line">	StmtKind skind; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">streenode</span> *test, *thenpart, *elsepart; </span><br><span class="line">&#125; STreeNode; </span><br><span class="line"><span class="keyword">typedef</span> STreeNode * SyntaxTree;</span><br></pre></td></tr></table></figure>
<p>TINY语言的各种语法树结构，如IF、REPEAT、READ、WRITE等等，参考书P100的图3-6和程序清单3-3；</p>
<h4 id="文法的二义性">文法的二义性</h4>
<p>定义：可生成带有两个不同分析树的串的文法称为二义性文法；<br>
<strong>判断文法是否有二义性的方法</strong>：</p>
<ul>
<li>举反例，举出一个表达式，然后根据文法规则画语法分析树，如果能画出两棵不同的分析树，则证明该文法有二义性；</li>
<li>一个 CFG是否为二义的问题是不可判 定的，即不存在解决该问题的算法，只能反证；<br>
<strong>消除二义性</strong>：没有通用的办法可以消除文法的二义性. 但在实践中，对于常用的文法，可以找到特定的消除歧 义性的办法.</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>对于程序设计语言来说，重要的是：描述它的文法 应是无二义性的。</li>
<li>一个语言，可以为它设计二义性的文法，也可以为 它设计无二义性的文法，因此一般说，讨论语言的二义 性是无意义的。重要的是对同一个语言，为它构造无二 义性文法，如果构造的是二义性文法，<strong>应设法在不改变 语言的前提下, 把二义性文法等价变换成无二义性文法</strong>。</li>
<li>鉴于二义性不可判定，所能做的是寻找一组充分条 件，使得满足这些条件的文法必定是无二义性的。注意, 这些条件只是充分条件，未必是无二义性的必要条件。</li>
</ul>
<h3 id="如何画语法树？">如何画语法树？</h3>
<p>画分析树的步骤（个人总结手工步骤）：</p>
<ol>
<li>从开始符号推导，作为树根</li>
<li>根据文法推导式一步一步向所求表达式靠近</li>
</ol>
<p>==画分析树的步骤（待总结）==：</p>
<h3 id="文法二义性的消除方法有多少种？">文法二义性的消除方法有多少种？</h3>
<h4 id="文法消除二义性的方法："><strong>文法消除二义性的方法</strong>：</h4>
<p>以if-else语句的悬挂问题为例来记忆。</p>
<ol>
<li>设臵一个限制规则，在分析程序中实现（加上强制规则）</li>
<li>改造文法</li>
<li>重新设计书写语法（用的最多）<br>
具体做法1：else部分一定要出现<br>
具体做法2：使用一个与if匹配的关键字作为语句的结束，比如end if</li>
</ol>
<h3 id="文法的构建问题">文法的构建问题</h3>
<p><strong>典型例子：构建算术表达式的文法规则的步骤</strong></p>
<ol>
<li>构造能反映运算符间优先关系的规则<br>
• 由于在树型中离根越近,则优先级越低,<br>
• 而推导过程均由文法开始符号进行分析,<br>
• 因此,在规则中==最接近文法开始符号==的运算符号 应该是+ - ,而 * /则远一点,而( )则更远.</li>
<li>考虑结合性：左递归规则可实现左结合，而右递归规则可实 现右结合<br>
• 同级运算符号的优先关系: 左结合<br>
• 根据语法树中谁深谁优先的原理可得<br>
• ==左方的同级运算符只能在左边产生,而不能在右边 产生，所以删除右递归，用一个新的非终结符代替==.<br>
<strong>注意</strong>：</li>
<li>关系之间的结合性<br>
左结合：同级运算先算左边，如：a+b+c，先算a+b，再算b+c<br>
右结合：同级运算先算右边</li>
</ol>
<h5 id="文法规则的扩展表示EBNF">文法规则的扩展表示EBNF</h5>
<p>前面讲到的文法的表示方法，常被称为BNF的表示方法<br>
BNF表示方法的缺点：</p>
<ol>
<li>表达能力弱，符号不丰富</li>
<li>程序设计语言的控制结构有：顺序、重复和可选结构，而BNF的表示方法没有重复和可选的结构<br>
引入两个新的运算符号，表达可选和重复，其实就类似于正则表达式中的可选和闭包。<br>
EBNF中用{…}表示重复，用[…](中括号)表示闭包可选。</li>
</ol>
<h3 id="自顶向下分析法的问题-左公共因子、左递归">自顶向下分析法的问题: 左公共因子、左递归</h3>
<h4 id="自顶向下分析的约定">自顶向下分析的约定</h4>
<ol>
<li>自定向下的推导都是<strong>最左推导</strong><br>
从左到右的分析算法，即总是从左到右地分 析输入符号串，首先分析符号串中的最左符 号，进而依次分析右边的一个符号，直到分 析结束。<br>
==注意：自顶向下的分析方法，必须先进行左工因子、左递归的消除，而要做到这两点，求First和Follow也是必不可少的==</li>
</ol>
<h4 id="左工因子问题解决">左工因子问题解决</h4>
<p>例子：写出下面的文法的递归子程序$$\displaylines{if-stmt\ \to\ if\ (exp)\  statement\ |\ if\ (exp)\ statement\ else\ statement}$$<strong>问题分析</strong>：</p>
<ol>
<li>由于该文法规则的推导有两种情况，所以需要分支语句；</li>
<li>但是由于两种情况的开头第一个符号都是相同的，都是if（非终结符号），所以对应着同一个函数或者终结符号，那么用前面的方法进行匹配，无法区分什么时候选第一条规则，什么时候选择第二条规则；</li>
</ol>
<p><strong>解决方法</strong>：</p>
<ol>
<li>方法一：提公因式，把规则进行改写：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>ϵ</mi><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ (\epsilon |\ else\ statement)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">ϵ</span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><br>
当提取公因子后，非公因子部分很长时，采用引入非终结符的方法：<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mtext> </mtext><mi>α</mi><mi>β</mi><mi mathvariant="normal">∣</mi><mi>α</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \to \ \alpha\beta|\alpha\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>可以进行公因子提取；在分解后，<strong>将该规则分解为两个规则</strong>(==一般在提取公因子后，非公因子部分很长的时候采用这种方法==)：</li>
</ol>
<p>\displaylines{A \to \alpha A^,\\
A^, \to \beta|\gamma
}</p>
<ol start="2">
<li>方法二：用扩充的BNF改造原来的文法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">[</mo><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ [else\ statement]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">[</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></li>
</ol>
<h4 id="左递归问题的解决">左递归问题的解决</h4>
<p>左递归分为直接左递归和间接左递归，直接左递归的处理比较简单，间接左递归的处理是在基于直接左递归的基础上进行的。</p>
<h5 id="直接左递归的消除">直接左递归的消除</h5>
<p><strong>方法一</strong>：使用EBNF的方法改写规则，消除左递归<br>
A→Aa|b (左递归)<br>
• 在EBNF中用花括号{ . . . }来表示重复<br>
• 因此上述规则可用以下规则写出: A→b{ a }<br>
<strong>方法二</strong>：<br>
A→Aa|b (左递归)<br>
• 改写为右递归 A→bA` A` <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> aA`| <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></p>
<h5 id="间接左递归">间接左递归</h5>
<p>研究下面文法： G[A]:<br>
A→ Aa| Bb | Cc<br>
B <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Ab | Bb<br>
C <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Ac |Cb<br>
解决思路：<br>
（１）逐个逐个非终结符进行解决；<br>
（２）将干净非终结符代入未解决的非终结 符中，并将其消除干净；<br>
（３）反复实施</p>
<h5 id="左递归消除算法">左递归消除算法</h5>
<p>(1)将文法G的所有非终结符号按任一种顺序排列为 A1 , . . . , Am;<br>
(2)执行循环语句：<br>
for( i=1; i&lt;=m ; i++ )<br>
{<br>
for ( j=1; j&lt;=i-1; j++)<br>
将规则Ai→Aj<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>改写；<br>
//改写方法如下：如果Aj→ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> |<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|…|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\beta_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> // Ai →<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_1\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>| <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_2\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> | … | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>k</mi></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_k\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span><br>
消除Ai 规则中的直接左递归；<br>
}<br>
(3)化简由(2)所得的文法，即消去多余规则</p>
<h3 id="文法的简化">文法的简化</h3>
<h4 id="文法规则有效性分析与化简文法">文法规则有效性分析与化简文法</h4>
<ul>
<li>有害规则：形如U→U的产生式，会导致文法出现二义性</li>
<li>多余规则：指文法中任何句子的推导都不会用到的规则 文法中不含有不可到达和不可终止的非终结符<br>
1）文法中<strong>某些非终结符不在任何规则的右部出现</strong>， 该非终结符称为不可到达。<br>
2）文法中<strong>某些非终结符,由它不能推出终结符号串</strong>， 该非终结符称为不可终止。</li>
<li>化简文法——删除无效规则<br>
目标：文法中不含有有害规则和多余规则</li>
</ul>
<h3 id="First-与follow集合-实验四">First 与follow集合(实验四)</h3>
<h4 id="First集合计算方法归纳">First集合计算方法归纳</h4>
<p>在递归下降程序中，为了提高分析效率，往往要求出每一条文法规则的开头的非终结符号的所有打头的终结符号，也称为First集合。这样可以避免回溯性。<br>
不过需要注意的是First集合不一定只有非终结元素，还有可能有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>空串。<br>
<strong>算法一</strong>：<br>
伪代码描述：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630114350.png" alt="Pasted image 20240630114350"><br>
==<strong>算法二</strong>==（递归表达）：<br>
·······················`</p>
<h4 id="Follow集合计算方法归纳">Follow集合计算方法归纳</h4>
<p>为了避免带有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的文法规则有多余的函数调用（视频26的36分50秒的分析解释了求Follow的原因），我们可以求非终结符号的Follow集合元素来决定是否要调用该非终结符号的函数。</p>
<p>Follow集合的运算可能遇到的情况如下：</p>
<ol>
<li>若A是开始符号，Follow(A) = ?</li>
<li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，Follow(B) = ?</li>
<li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)中，则Follow(A) = ?</li>
</ol>
<p>定义：给出一个非终结符号A，那么集合Follow(A)则是由终结符或结束符号$组成。<br>
集合Follow(A)定义如下：</p>
<ol>
<li>若A是开始符号，则$就在Follow(A)中</li>
<li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>γ</mi><mo stretchy="false">)</mo><mo>−</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">First(\gamma)-{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Follow(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>中</li>
<li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)集合中，则Follow(A)包括Follow(B)</li>
</ol>
<p><strong>算法</strong>：</p>
<ol>
<li>初始化：<br>
1.1 Follow(开始符号)={ $ }<br>
1.2 其他任何一个非终结符号A，则执行 Follow(A)={ }</li>
<li>循环：反复执行<br>
2.1 循环：对于文法中的每条规则 A<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> X1X2… Xn 都执行<br>
2.1.1 对于该规则中的每个属于非终结符号的Xi ，都执行<br>
2.1.1.1 把 First(Xi+1Xi+2… Xn) - {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>} 添加到 Follow(Xi)<br>
2.1.1.2 if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> in First(Xi+1Xi+2… Xn), 则把Follow(A)添加到 Follow(Xi)<br>
直到任何一个Follow集合的值都没有发生变化为止。<br>
<strong>伪代码</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630163944.png" alt="Pasted image 20240630163944"></li>
</ol>
<h3 id="总结习题-2">总结习题</h3>
<p>一、给定字符串，写出最左推导/最右推导过程（对应的文法在PPT第19页）</p>
<ol>
<li>例题：对于文法G(exp) ，下面是关于 v*(v＋d) 的一个最左推导</li>
<li>例题：对于文法G(exp) ，下面是关于 v*(v＋d) 的一个最右推导</li>
<li>递归推理出字符串 v*(v＋d) 的一个归约过程为</li>
</ol>
<p>二、给定某个文法，求出该文法描述的语言</p>
<ol>
<li>例2 设有文法 G1=(VN，VT，P，A) 其中， VN={A} VT={a} P={ A→a} 试问：此文法描述的语言L(G1)=?</li>
<li>例3 设有文法 G2=(VN，VT，P，A) 其中， VN={A} VT={a} P={ A→Aa, A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>} 试问：此文法描述的语言L(G2)=?</li>
</ol>
<p>三、给定文法规则和符号串，画出相应的分析树</p>
<ol>
<li>例 G[S]： S→V=E ，V→i ，E →F+F ｜F ，F →(E)｜i 分析所输入的符号串i=i+(i)是否为其句子，并画出相 应的分析树。</li>
</ol>
<p>四、给定文法规则，设计出语法树结构（什么是需要保留的信息），写出对应的语法树存储结构，==画出对应的语法树==</p>
<ol>
<li>这部分至少掌握TINY语言各个语句的语法树结构，结合实验，加上自己设计的语法树</li>
</ol>
<p>五、给定文法规则，判断文法二义性，若存在二义性，进行文法二义性消除</p>
<ol>
<li>例. G3=({if,then,else, e , a},{S},P,S)<br>
G3[S]：<br>
S→if e then S<br>
| if e then S else S<br>
|a<br>
判断该文法是否存在二义性？如果存在，请消除其二义性。</li>
</ol>
<p>六、构造文法规则</p>
<ol>
<li>基本例题：
<ul>
<li>例：L1={ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup><msup><mi>b</mi><mi>j</mi></msup><msup><mi>c</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^i b^j c^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>| i, j, k≥1 }</li>
<li>例：构造语言L2={ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">ab^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>| i≥0 }的文法</li>
<li>==例（未解决）==：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={a,b}的句子S的集合是由一个b及在其 前后有相同数目的a组成：<br>
S= { b,aba,aabaa,aaabaaa,…} = { <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mi>b</mi><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^nba^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>| n≥ 0 }</li>
</ul>
</li>
<li>如何用文法规则描述算术表达式?</li>
<li>==实验三中的各种表达式的文法规则构造==</li>
</ol>
<p>七、文法化简</p>
<ol>
<li>例，G[S] ：  S→Be<br>
B→Ce<br>
B→Af<br>
A→Ae<br>
A→e<br>
C→Cf<br>
D→f</li>
</ol>
<p>八、消除左递归，求Firts集合与Follow集合<br>
==如果是递归下降分析的前提下求First和Follow，一定要记得先消除左递归、提左工因子！==<br>
<strong>求First集合的题型</strong>：</p>
<ol>
<li>考虑情况1: G[S]={ S→AB A→Ba B→Cb C<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>ef } （1）<br>
求出first©=? （2）求出first(A)=?</li>
<li>考虑情况2: G[S]={ S→AB|CD A→aB|dD B→cC|bD C→ef |gh D→i | j }<br>
求出first(A)=? 求出first(S)=?</li>
<li>考虑情况3: G[S]={ S→ABC | D ，A→aB|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，B→cC|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，C→eC|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，D→i | j }<br>
求出first(D)=? 求出first(A)=? 求出first(S)=?<br>
<strong>求Follow集合的题型</strong>：</li>
<li>视频27中有介绍答案，习题从13分开始</li>
</ol>
<p><strong>消除左递归的题型</strong>：</p>
<ol>
<li>例 消除下面文法的左递归 A→ Ba| Aa| c<br>
B→ Bb| Ab| d</li>
<li>例.G[Z]： Z<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>Za | Sbc | dS<br>
S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Zef | gSh<br>
试消除左递归</li>
<li>例.文法G[Z]： Z <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Sa | Tb | cZ<br>
S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Tde | Zf | Sg<br>
T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Sh | jTk<br>
试消除左递归</li>
</ol>
<h2 id="第四章（重点）-——-自顶向下的分析">第四章（重点） —— 自顶向下的分析</h2>
<h3 id="递归下降语法分析方法-或称递归子程序">递归下降语法分析方法(或称递归子程序)</h3>
<h4 id="自顶向下分析方法相关概念">自顶向下分析方法相关概念</h4>
<p><strong>定义</strong>：从文法开始符号开始,不断利用文法规则进行推 导,直到推导出所要分析的符号串为止。</p>
<p>目前自顶向下的分析方法有两种：</p>
<ul>
<li>一种是回溯性自顶向下分析，本质上是对产生式的枚举</li>
<li>一种是预测性自顶向下分析，主要策略有LL分析法和递归下降分析法</li>
</ul>
<h4 id="一、回溯性自顶向下分析">一、回溯性自顶向下分析</h4>
<p><strong>引起递归下降分析的符号串匹配的回溯性的原因</strong>：</p>
<ol>
<li>情况1：非终结符A存在多个推导，选哪一个的问题<br>
对于非终结符A，A的两条规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">A\to ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>右部First集交集不为空，从而引起回溯</li>
<li>情况2：非终结符A存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>推导，是否要跳过该非终结符的问题<br>
对于非终结符A，如果A的产生式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>b</mi><mi>A</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A \to bAS | \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mi>A</mi><mi>S</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">Follow(A)\cap First(bAS) \notin \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>，也会隐私回溯</li>
<li>情况3：存在左递归，出现递归无限调用的问题——死递归</li>
</ol>
<h4 id="二、预测性自顶向下分析">二、预测性自顶向下分析</h4>
<p><strong>定义</strong>：<br>
预测性也称确定的自顶向下分析方法</p>
<ul>
<li><strong>非终结符选择</strong>和<strong>规则选择</strong>都是确定的在每一步推导中 ，总是对<strong>最左边的非终结符进行展开</strong>，且选择哪一个规则是确定的，因此是一种无回溯的方法。</li>
<li>具体实施策略有：<br>
递归下降分析法(Recursive-Descent Parser)<br>
LL(1)分析析法(LL(1) Parser)</li>
</ul>
<h5 id="无回溯自顶向下分析技术的文法条件">无回溯自顶向下分析技术的文法条件</h5>
<p>为应用无回溯的自顶向下分析技术，文法必须满足下 列条件：</p>
<ol>
<li>无左递归性 文法中关于任何非终结符号U，都不具有规则左递归 和文法左递归，即，不存在形如U::=U…的规则，也不存 在U <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> U…。</li>
<li>无回溯性 一个文法的任何<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">U\in V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，存在U::=u1|u2|…|uk， 若ui <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Ti…与uj <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Tj…，Ti、Tj <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> VT, i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> j，就有Ti <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Tj。（理解：就是如果存在一个非终结符U，以U为左部的产生式有多个，那么每一个产生式的First元素都不同，或者是没有交集）<br>
所以我们前面学的求First集合以及求Follow集合以及消除左递归，都是为了递归下降分析程序做准备，现将文法进行预处理，得到无回溯性文法，再递归下降分析。</li>
</ol>
<h4 id="递归下降分析法">递归下降分析法</h4>
<p><strong>定义</strong>：对每个非终结符按其规则结构产生相应语法分析子程序。</p>
<ul>
<li>终结符产生匹配命令</li>
<li>非终结符则产生调用命令<br>
由于文法递归相应函数也递归，所以称这种 方法为递归子程序方法或递归下降法。</li>
</ul>
<h5 id="语法图">语法图</h5>
<p>语法图是基于EBNF而绘制的，所以在绘制语法图之前，要先将文法规则转化成EBNF的形式。<br>
<strong>定义</strong>：</p>
<ul>
<li>语法图是语法规则的直观表达</li>
<li>递归下降分析程序处理逻辑的直观表达</li>
<li>每一个非终结符的文法规则确定一个语法图<br>
<strong>元素</strong>：</li>
<li>箭头，表示序列和选择</li>
<li>圆形或椭圆形框，表示终结符</li>
<li>方形框和矩形框，非终结符</li>
</ul>
<h5 id="递归下降分析程序的设计">递归下降分析程序的设计</h5>
<p>递归下降分析程序的设计方法：<br>
<strong>一、语法图法</strong><br>
每个非终结符都对应一个函数。该函数根据语法的描述来明确：根据下一个输入符号 来确定按照哪一个规则进行处理，再根据该规则的右端，<br>
• 每遇到一个终结符，则判断当前读入的单词是否 与该终结符相匹配，若匹配，再读取下一个单词 继续分析；不匹配，则进行出错处理<br>
• 每遇到一个非终结符，则调用相应的函数</p>
<p><strong>二、直接根据文法规则进行递归下降</strong><br>
U→x1 | x2 |…|xn，其中 x1,…xn均≠ ε<br>
U→x1 | x2 |…|xn|ε<br>
规则选择问题：通过分别求出first集合 和follow集合来解决</p>
<p>非终结符相应的分析子程序的构造方法<br>
(1)对于每个非终结符U，编写一个相应的子程序P(U);<br>
(2)对于规则U→x1 | x2 |…|xn，x1,…xn都≠ ε，关于U的函数P(U)按如下方法构造：<br>
if (TOKEN in first(x1) )<br>
p(x1);<br>
else if (TOKEN in first(x2) ) p(x2);<br>
else … …<br>
if (TOKEN in first(xn) ) p(xn);<br>
else ERROR( );<br>
(3)如果U还有空规则U→ ε,则算法中的语句： if (TOKEN in first(xn) ) p(xn) ; else ERROR( ); 改写为<br>
if (TOKEN in first(xn)) p(xn) ;<br>
else if (TOKEN not in follow(U) )<br>
ERROR( );<br>
(4)对于符号串x=y1y2…yn；p(x)的含义为： { p(y1);p(y2);…;p(yn); }<br>
如果yi∈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则P(yi)就代表调用yi的函数；<br>
如果yi∈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 为P(yi)设计下述的一段代码或设计一个match函数。<br>
if (TOKEN==yi ) getToken(TOKEN) else ERROR( );</p>
<p><strong>注意</strong>：</p>
<ol>
<li>递归下降分析器由一个主程序main和每个非终结符对应的递归函数组成。</li>
<li>用到的一些函数：
<ul>
<li>函数getToken( )负责读入下一个TOKEN单词</li>
<li>函数ERROR( )负责报告语法错误</li>
<li>函数match( )终结符号的匹配处理</li>
</ul>
</li>
<li>约定：全局变量TOKEN存放已读入的TOKEN单词</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(expectedToken)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(TOKEN == expectedToken)</span><br><span class="line">		<span class="built_in">getToken</span>();  <span class="comment">//  获取下一个信号</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">ERROR</span>();  <span class="comment">//  产生报错信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">getToken</span>();</span><br><span class="line">	<span class="built_in">S</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ERROR函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ERROR</span><span class="params">(<span class="type">int</span> ErrorNO)</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(ErrorNO)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: cout &lt;&lt; <span class="string">&quot;xxx&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三、实现语义功能</strong><br>
<strong>基本步骤</strong>：</p>
<ol>
<li>写出文法规则</li>
<li>改进文法规则（提取左工因子、消除左递归）</li>
<li>写出递归下降分析子程序，根据语义功能添加添加动作</li>
</ol>
<p>1）使用递归下降分析法实现算术表达式的计算</p>
<p>2）使用递归下降分析法实现算术表达式的语法树构建<br>
<strong>方法</strong>：</p>
<ol>
<li>写出文法规则</li>
<li>写出递归下降子程序</li>
<li>在递归下降子程序的基础上增加语法树生成功能：
<ul>
<li>遇到运算对象生成叶子节点并返回</li>
<li>遇到运算符号就将对应运算对象进行新树根的构造</li>
<li>遇到括号就返回括号中的表达式对应的语法树</li>
<li>因此，需要为每一个递归函数加上返回当前所生成的语法树的树根指针</li>
</ul>
</li>
</ol>
<p>3）使用递归下降分析法实现算术表达式汇编指令的产生<br>
<strong>常用的汇编指令的介绍</strong>：</p>
<ul>
<li>Ldc n 把常数n压入栈</li>
<li>Mpi 取出栈顶与次栈顶元素做乘法运算，结果入栈</li>
<li>Adi 取出栈顶与次栈顶元素做加法运算，结果入栈</li>
<li>Sbi 取出栈顶与次栈顶元素做减法运算，结果入栈</li>
<li>Dvi 取出栈顶与次栈顶元素做除法运算，结果入栈<br>
<strong>方法</strong>：</li>
</ul>
<ol>
<li>写出文法规则</li>
<li>写出递归下降分析程序</li>
<li>在递归下降分析程序中增加汇编代码生 成功能<br>
– 遇到运算对象则生成Ldc指令<br>
– 遇到运算符号就生成相应运算的指令<br>
– 遇到括号则不做指令生成处理</li>
</ol>
<p>4）为if语句构造语法树</p>
<h5 id="递归下降法的总结">递归下降法的总结</h5>
<ol>
<li>递归下降分析功能非常强大，比较适合于手工 方法；</li>
<li>分析效率低，仅适合于小型语言语法分析程序 的构造。</li>
<li>为了解决一些问题，通常先将BNF文法规则改 写为EBNF规则。</li>
<li>==在生成语法树时，要注意二义性问题的分析。==</li>
</ol>
<h3 id="LL-1-分析方法-–LL-1-判断方法-–LL-1-分析表-–LL-1-分析过程">LL(1)分析方法 –LL(1)判断方法 –LL(1)分析表 –LL(1)分析过程</h3>
<h4 id="LL-1-的分析方法相关概念">LL(1)的分析方法相关概念</h4>
<p><strong>产生背景</strong>：递归下降程序会产生回溯、选择，导致其效率较低，LL(1)技术用表的方式记录每一个非终结符遇到终结符去到哪一条文法规则，使得语法分析准确高效！</p>
<h5 id="LL-1-文法规则的判定定理">LL(1)文法规则的判定定理</h5>
<p><strong>定理/定义</strong>：若满足以下条件，则BNF中的文法就是LL(1) 文法(LL(1) grammar)。</p>
<ol>
<li>在每个规则A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> | … |<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中,对于所有的i 和j:1≤I,j≤n,i≠j,First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span>First (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>)为空。（<strong>如果不满足该条件，就会存在一个表项有两个文法的现象，本质上是原文法存在左工因子</strong>）</li>
<li>若对于每个非终结符A都有First(A) 包含了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，那 么First(A) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span> Follow (A)为空。（<strong>如果不满足，则也会存在一个表项有两个文法的现象，本质上是原文法存在二义性</strong>）</li>
</ol>
<h5 id="存储结构">存储结构</h5>
<p><strong>分析表的存储结构</strong>：<br>
根据递归分析法，是查看当前符号来决定选择哪条规则的， 因此，应该存储某个非终结符号遇到某个终结符号时该选择 哪条规则。<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701114849.png" alt="Pasted image 20240701114849"><br>
LL(1)分析表通常用M[N, T]表示：<br>
• N(即行)是文法的非终结符的集合；<br>
• T(即列)是终结符或记号的集合<br>
• M[N,T]即表示非终结符N面临输入符号T该选择的 规则。<br>
• M[N,T]缺省时(即为空)，则表示在分析中可能发生 的潜在错误。</p>
<p><strong>LL(1)分析表的构造步骤</strong>：<br>
为每个非终结符A和规则A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 重复以下两个 步骤：</p>
<ol>
<li>对于First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>)中的每个记号a，都将A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>添加 到项目M[A, a]中</li>
<li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>)中，则对于Follow (A) 的每个 元素a(记号或是$)，都将A→ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 添加到M[A, a] 中</li>
<li>把分析表A中每个未定义元素置为ERROR，通常用空白表示即可</li>
</ol>
<p><strong>分析过程的存储结构——分析栈</strong>：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701114923.png" alt="Pasted image 20240701114923"></p>
<h4 id="LL-1-分析方法以及过程">LL(1)分析方法以及过程</h4>
<p><strong>LL(1)分析</strong>：</p>
<ol>
<li>构造LL(1)分析表（LL(1)的parsing table）</li>
<li>针对某个符号串的分析过程（终结符号匹配，非终结符号替代）
<ol>
<li>初始化：文法开始符号入栈</li>
<li>查表</li>
<li>替换（逆向）</li>
<li>反复（2），（3）步骤，直到分析成功（两边同时为空）或失败</li>
</ol>
</li>
</ol>
<h4 id="LL-1-解决二义性问题的方法">LL(1)解决二义性问题的方法</h4>
<p>LL(1)分析表可能出现一个表项有多个元素的情况，这就是二义性问题，解决方法：</p>
<ol>
<li>弹窗，让用户选择一条规则继续执行</li>
<li>自己修改文法规则，决定选择哪一条文法应该保留</li>
</ol>
<h3 id="实验三">实验三</h3>
<h3 id="总结习题-3">总结习题</h3>
<p>一、绘制语法图</p>
<ol>
<li>例如，文法规则 factor→ (exp) | number 用语法图表示是</li>
<li>例3.10 画出简单算术表达式的语法图<br>
exp → exp addop term | term<br>
addop → + | -<br>
term → term mulop factor | factor<br>
mulop → *<br>
factor → ( exp ) | number</li>
<li>例3. 11 画出语法图<br>
statement → if-stmt | other<br>
if-stmt → if (exp) statement | if (exp) statement else statement<br>
exp → 0 | 1</li>
</ol>
<p>二、构建递归下降程序<br>
①根据语法图构建递归下降子程序</p>
<ol>
<li>非终结符号if_Stmt分析程序<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630190828.png" alt="Pasted image 20240630190828"><br>
②根据文法规则直接构造递归下降分析程序+写出递归下降子程序并分析表达式</li>
<li>G[S]= { S<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>aAb, A<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>cB, B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>e } 试编写一个能分析该文法所对应任何串(如 串aceb)的程序.</li>
<li>直接看PPT的题，有标记（Zotero）</li>
</ol>
<p>③用递归下降分析法实现语义功能</p>
<p>④构造LL(1)分析表并且进行分析<br>
<strong>疑问</strong>：PPT105页的问题3的构建！！</p>
<h2 id="第五章">第五章</h2>
<h3 id="LR-0-DFA、LR-1-DFA、-LALR-1-DFA？">LR(0) DFA、LR(1) DFA、 LALR(1) DFA？</h3>
<h4 id="LR-k-分析法">LR(k)分析法</h4>
<ul>
<li>L是指从左到右扫描输入符号串，left scan</li>
<li>R是指构造一个最右推导的逆过程，right analysis</li>
<li>K是指向前看的输入符号的个数，lookahead k<br>
LR分析方法是当前最广义的<strong>无回溯</strong>的“<strong>移进归约</strong>”方法。<br>
==根据栈中的符号串和向右顺序 查看输入串的k(k&gt;=0)个符号，就能唯一确定分析器的动作是移进还是归约，以及用哪个产生式进行归约。==</li>
</ul>
<h4 id="LR-0-分析在计算机上的实现">LR(0)分析在计算机上的实现</h4>
<h5 id="存储结构-2">存储结构</h5>
<ol>
<li>邻接矩阵</li>
<li>链接表</li>
<li>新二维表存储——LR(0)分析表<br>
（顶点跟边的关系的存储结构）<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701160855.png" alt="Pasted image 20240701160855"></li>
</ol>
<h4 id="SLR-1-分析">SLR(1)分析</h4>
<ul>
<li>简单LR(1)分析</li>
<li>SLR(1)还是使用LR(0)的项目集DFA</li>
<li><strong>只是在构造分析表时才考虑超前查看的符号</strong></li>
</ul>
<h4 id="LR-1-分析法">LR(1)分析法</h4>
<p>LR(1)克服了SLR和LR(0)的缺陷——不考虑先行符，LR(1)是对每条文法考虑其先行符号来解决归约-移进冲突。</p>
<h4 id="LALR-1-分析法">LALR(1)分析法</h4>
<p>LALR(1)分析法克服了LR(1)分析的弊端——冗余项目集，LALR(1)是在LR(1)的基础上合并状态的核心而达到压缩状态数的目的，有效地提高了LR(1)的存储效率，但是LALR(1)相比于LR(1)来说，出错稍有延迟。<br>
<strong>压缩方法</strong>：</p>
<ul>
<li>核心一样就合并</li>
<li>对应的先行符做并集<br>
合并后的DFA图的状态数和LR(0)相仿</li>
</ul>
<p><strong>LALR(1)的分析步骤</strong>：</p>
<ol>
<li>先构造出LALR(1)的DFA图</li>
<li>再构造出LALR(1)的分析表</li>
<li>==最后利用LAKR(1)的分析表对所要分析的符号串进行分析，PPT上说自行完成==</li>
</ol>
<h4 id="LALR-1-和LR-1-的效率区别">LALR(1)和LR(1)的效率区别</h4>
<ol>
<li>LALR(1)存储效率大大高于LR(1)</li>
<li>LR(1)的报错比LALR(1)及时一些</li>
</ol>
<h3 id="LR-0-分析表、LR-1-分析表、-SLR-1-分析表、-LALR-1-分析表？">LR(0)分析表、LR(1)分析表、 SLR(1)分析表、 LALR(1) 分析表？</h3>
<h4 id="SLR-1-的分析表的构建">SLR(1)的分析表的构建</h4>
<ol>
<li>构建好LR(0)/SLR(1)分析图（一样的）</li>
<li>求每一个非终结符的Follow集合元素</li>
<li>对于归约，将其中归约文法接收到其Follow集合元素对应的归约规则填入对应的表项</li>
<li>对于移进，将其中移进文法接收到什么符号移进到什么状态填入表</li>
</ol>
<h3 id="LR-0-文法、LR-1-文法、SLR-1-文法、-LALR-1-文法？如何判断LR-0-文法、SLR-1-文法？">LR(0)文法、LR(1)文法、SLR(1)文法、 LALR(1) 文法？如何判断LR(0)文法、SLR(1)文法？</h3>
<h4 id="LR-0-的分析法">LR(0)的分析法</h4>
<p>根据栈中的符号串以及向右顺序输入串的0个符号，确定分析是移进还是归约，以及用哪个产生式进行归约的分析方法。不考虑先行符。</p>
<h4 id="LALR-1-分析法-2">LALR(1)分析法</h4>
<p>LALR(1)分析法克服了LR(1)分析的弊端——冗余项目集，LALR(1)是在LR(1)的基础上合并状态的核心而达到压缩状态数的目的，有效地提高了LR(1)的存储效率，但是LALR(1)相比于LR(1)来说，出错稍有延迟。</p>
<h4 id="SLR-1-文法判断">SLR(1)文法判断</h4>
<p>当且仅当对于任何状态s，以下的两个条件：</p>
<ol>
<li>对于在s中的任何项目A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.X<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，当X是一个终结符，且X在Follow (B) 中时，s中没有完整的项目 B→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>.。 ==[移进-归约冲突]==</li>
<li>对于在s中的任何两个完整项目A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.和B→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.， Follow(A)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span> Follow(B)为空。==[归约-归约冲突]==<br>
均满足时，文法为SLR(1)文法。</li>
</ol>
<h3 id="文法如何利用LR-0-、LR-1-、-SLR-1-、LALR-1-进行语法分析？">文法如何利用LR(0) 、LR(1) 、 SLR(1)、LALR(1) 进行语法分析？</h3>
<h4 id="运用自底向上、自顶向下的方法进行语法分析">运用自底向上、自顶向下的方法进行语法分析</h4>
<h5 id="运用自顶向下的分析方法进行语法分析步骤（前面其实也总结过，本质是一样的）">运用自顶向下的分析方法进行语法分析步骤（前面其实也总结过，本质是一样的）</h5>
<ol>
<li>写出文法规则（形式化语言描述）</li>
<li>对文法规则进行消除左递归和消除左工因子</li>
<li>书写递归下降子程序</li>
<li>根据问题具体需求，在递归下降程序中增加相应的处理——语义动作</li>
</ol>
<h5 id="运用自底向上的分析方法进行语法分析的步骤">运用自底向上的分析方法进行语法分析的步骤</h5>
<ol>
<li>书写文法规则（自底向上的分析方法对文法规则不做约束）</li>
<li>画出对应的LR(0)/LR(1)的DFA图</li>
<li>根据所使用的分析方法对DFA图进行进一步处理，比如LALR(1)需要对LR(1)图进行状态压缩</li>
<li>根据DFA图写出对应的分析表</li>
<li>根据问题的具体需求，对每一条文法写上相应的处理——语义动作<br>
Tips：最好是找个具体实例分析一遍，在分析的过程中看看需要做什么动作<br>
==其中，画DFA图的步骤可以省略，直接对着文法进行分析语义动作也可以！==</li>
</ol>
<h4 id="语法分析的基本思想">语法分析的基本思想</h4>
<p>语法分析基本思想：在语法分析过程中，根据语言的语义定义随时分析并翻译已识别的那部分语 法成分的全部含义。翻译需要是通过调用为该语法成分事先编好的语义动作实现的。</p>
<p><strong>常用语法分析翻译方法</strong>：<br>
一、在确定的递归下降语法分析程序中， 利用隐含堆栈存储各递归下降函数内的局部变 量所表示的语义信息。<br>
二、在自底向上语法分析程序中使用和语法分 析栈同步操作的语义栈进行语法分析翻译。<br>
三、在LL(1)语法分析程序中，利用翻译文法实 施语法分析翻译。</p>
<ul>
<li>翻译文法是在描述语言的文法(即源文法或输入文法) 中加入语义动作符号而形成的。<br>
四、利用属性文法进行语法分析翻译。</li>
<li>属性文法也是一种翻译文法</li>
<li>其符号(文法符号和动作符号)都扩展为带有语义属性 和同一规则内各属性间的运算规则。</li>
</ul>
<h4 id="属性文法的概念">属性文法的概念</h4>
<p><strong>属性</strong>：对文法的每一个符号，引进一些属性，这些属性代 表与文法符号相关的信息，如类型、值、存储位置 等。<br>
<strong>语义规则</strong>：为文法的每一个产生式配备的计算属性的计算规则 ，称为语义规则。<br>
<strong>属性文法</strong>：属性文法是带属性的一种文法，他的主要思想如下：</p>
<ul>
<li>首先对于每个文法符号引进相关的属性符号</li>
<li>其次对于每个产生式写出计算属性值的语义规则<br>
<strong>属性文法的形式定义</strong>：<br>
一个属性文法是一个三元组，A=(G, V, A)</li>
<li>G是一个上下文无关文法</li>
<li>V是属性的有穷集</li>
<li>F是关于属性的断言的有穷集<br>
<strong>说明</strong>：</li>
</ul>
<ol>
<li>每个属性与文法符号相联，N.t表示文法符号N的 属性t。属性值又称语义值。存储属性值的变量又 称语义变量。</li>
<li><strong>每个断言与文法的某个产生式相联，写在{ }内</strong>。 属性的<strong>断言又称语义规则</strong>，它所描述的工作可以 包括属性计算、静态语义检查、符号表的操作、 代码生成等，有时写成函数或过程段。</li>
</ol>
<h4 id="语义分析的基本概念">语义分析的基本概念</h4>
<p><strong>语义分析的实施方式</strong>：</p>
<ul>
<li>语法分析程序通过直接调用语义分析函数进行 语义分析；</li>
<li>先生成相应的语法树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 再作语义分析<br>
<strong>语义分析的功能通常包括两个方面</strong>:</li>
<li>检查语法结构的静态语义,即分析句子的含义是 否有意义,实际工作多为作用域分析、类型的分析</li>
<li>将合乎语义的句子进行翻译，并生成某一种中 间形式<br>
<strong>语句的种类</strong>：</li>
<li>说明语句：用于定义各种名字的属性</li>
<li>可执行语句：用于完成指定功能<br>
<strong>语义分析的任务种类</strong>：</li>
<li>分析说明语句——需要把所定义名字的各种属性 登记到<strong>符号表</strong>，以便在分析到可执行语句时使用；</li>
<li>分析可执行语句——首先根据各语句的语法结构和语义设计出相应目标代码结构，然后再给出从源 语法结构到翻译过程图示的变换方法,语义分析程 序则根据这些变换方法进行分析并生成中间代码</li>
</ul>
<p><strong>符号表</strong>：</p>
<ul>
<li>标识符定义实体</li>
<li>实体属性保存在符号表<br>
<strong>符号表的形式</strong>：</li>
<li>每个名字对应一个表项</li>
<li>一个表项包括<strong>名字域</strong>和<strong>属性信息域</strong><br>
<strong>==符号表如何解决作用域的问题？==</strong></li>
</ul>
<p><strong>符号表操作函数</strong>：</p>
<ol>
<li>LOOKUP(NAME)：以符号名NAME(标识符)查符号表，若 表中已存在该标识符，则返回其在表中的位置(序号)，否则返回 NULL。</li>
<li>ENTER(NAME)：在符号表中新登记一名字为NAME的项， 并返回该项在表中的位置(序号)。</li>
<li>ENTRY(NAME):查、填符号表的语义函数</li>
<li>Fill(符号表位置，类型 )属性填写函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pointer <span class="title">ENTRY</span><span class="params">(NAME)</span></span>&#123;</span><br><span class="line">	ENTRYNo = <span class="built_in">LOOKUP</span>(NAME);</span><br><span class="line">	<span class="keyword">if</span>(ENTRYNo == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ENTER</span>(NAME);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验四">实验四</h3>
<h3 id="题型总结">题型总结</h3>
<p>一、LR(0)、LR(1)的DFA图的绘制</p>
<h2 id="第六章">第六章</h2>
<h3 id="语法制导翻译的方法有多少种？">语法制导翻译的方法有多少种？</h3>
<h4 id="语法分析的基本思想-2">语法分析的基本思想</h4>
<p>语法分析基本思想：在语法分析过程中，根据语言的语义定义随时分析并翻译已识别的那部分语法成分的全部含义。翻译需要是通过调用为该语法成分事先编好的语义动作实现的。</p>
<p><strong>常用语法分析翻译方法</strong>：<br>
一、在确定的递归下降语法分析程序中， 利用隐含堆栈存储各递归下降函数内的局部变 量所表示的语义信息。<br>
二、在自底向上语法分析程序中使用和语法分 析栈同步操作的语义栈进行语法分析翻译。<br>
三、在LL(1)语法分析程序中，利用翻译文法实 施语法分析翻译。</p>
<ul>
<li>翻译文法是在描述语言的文法(即源文法或输入文法) 中加入语义动作符号而形成的。<br>
四、利用属性文法进行语法分析翻译。</li>
<li>属性文法也是一种翻译文法</li>
<li>其符号(文法符号和动作符号)都扩展为带有语义属性 和同一规则内各属性间的运算规则。</li>
</ul>
<h3 id="中间代码？表示形式如何？">中间代码？表示形式如何？</h3>
<h4 id="常见的中间代码的形式">常见的中间代码的形式</h4>
<p>树、后缀表示、三元组、四元组、P代码<br>
<strong>中缀表示</strong></p>
<ul>
<li>运算符号位于两个运算对象中间，如a+b</li>
<li>不利于表达式的计算及目标代码的产生<br>
<strong>后缀表示——逆波兰表示</strong></li>
<li>将运算符放在运算对象的后面，如 a b +</li>
<li>表达式中各运算符的出现顺序决定其计算的先后 顺序，因此无括号</li>
<li>后缀表达式与相应的中缀表达式中的运算对象的 出现顺序是一致的</li>
</ul>
<h3 id="如何将一个算术表达式转换为逆波兰表示、四元组表示、三元组表示？">如何将一个算术表达式转换为逆波兰表示、四元组表示、三元组表示？</h3>
<h4 id="中缀转后缀（逆波兰表示）">中缀转后缀（逆波兰表示）</h4>
<p>方法：自顶向下分析（递归下降）、自底向上分析（LR） | 属性文法（LL(1)或LR）</p>
<h5 id="扩充的后缀表示">扩充的后缀表示</h5>
<ul>
<li>赋值语句</li>
<li>数组a[e]的后缀表示为<code>e a SUBS</code></li>
<li>条件语句<code>if u S1 else S2</code>的后缀表示<br>
<code>u L1 BZ S1 L2 BR S2</code><br>
<strong>例</strong>：<br>
if ( m &gt; n ) k=1 ； else m=0;<br>
后缀表示： m n &gt; 10 BZ k1= 20 BR<br>
10: m0=<br>
20:</li>
<li>while语句：<br>
while ( u ) S1 后缀表示：<br>
L2<br>
u L1 BZ S1 L2 BR<br>
L1<br>
<strong>例子</strong>：<br>
while ( m &gt; n ) k=1 ；<br>
后缀表示：<br>
10:<br>
m n &gt; 20 BZ k 1 = 10 BR<br>
20:</li>
<li>其他循环语句，如for、do-while、repeat-until</li>
</ul>
<h4 id="四元组表示方法以及其转换">四元组表示方法以及其转换</h4>
<p><strong>四元组表示方法</strong>：<br>
(OP , P1 , P2 , T) 其中OP为运算符，OP1、OP2 为运算对象，T为计算结果的临时暂存变量。<br>
<strong>注意</strong>：</p>
<ol>
<li>P1、P2 、T 可代表的含义
<ul>
<li>可以是一个指向<strong>符号表某一登记的入口位置</strong></li>
<li>可以是一个<strong>临时变量的整数码</strong></li>
</ul>
</li>
<li>即意味着在<strong>产生中间代码的过程</strong>中，也相应地进行查造符号表的工作——<strong>与符号表打交道</strong></li>
</ol>
<h4 id="三元组表示方法">三元组表示方法</h4>
<p>(OP , P1 , P2 )<br>
其中OP为运算符，P1、P2 为运算对象。<br>
用元组编号来来代表结果保存的位置。</p>
<h3 id="如何将一段代码翻译为中间代码（后缀、三元组、四元组）？">如何将一段代码翻译为中间代码（后缀、三元组、四元组）？</h3>
<h3 id="几种常用语句的翻译——能写出语义函数或语义动作">几种常用语句的翻译——能写出语义函数或语义动作</h3>
<p>1）算术表达式<br>
2）说明语句<br>
3）赋值语句</p>
<ol>
<li>分析书写格式</li>
<li>写出赋值语句的文法规则<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>i</mi><mi>d</mi><mo>=</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">S\to id = E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li>
<li>分析并理解其中的执行过程，写出语义动作
<ul>
<li>将算数表达式E的值写入符号表中id的值属性中</li>
<li>需先查符号表</li>
<li>还需要检查数据类型<br>
4）==逻辑表达式==</li>
</ul>
</li>
<li>分析逻辑表达式书写格式<br>
运算符号有：逻辑运算符、关系运算符，优先级各不相同</li>
<li>书写逻辑表达式的文法规则</li>
<li>根据逻辑表达式两种不同的应用场景书写不同的语义函数：
<ul>
<li>用作逻辑运算的逻辑表达式</li>
<li>用作控制语句中的条件表达式（区别是有跳跃关系，比如a||b||c，如果a||b已经满足，不需要再计算b||c）<br>
5）条件判断语句—— if语句<br>
6）循环语句——while语句<br>
7）扩展到其他程序设计语句</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Icserm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">http://example.com/2024/06/29/课程内学习/【编译原理】8. 期末复习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">nullptr</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div class="post_share"><div class="social-share" data-image="/self_img/head_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/" title="期末考点整理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">期末考点整理</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" title="数据库事务管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据库事务管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/" title="操作系统概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-15</div><div class="title">操作系统概览</div></div></a></div><div><a href="/2024/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/" title="处理器管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-21</div><div class="title">处理器管理</div></div></a></div><div><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">内存管理</div></div></a></div><div><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="文件系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">文件系统</div></div></a></div><div><a href="/2024/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="设备管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-29</div><div class="title">设备管理</div></div></a></div><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="基本概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">基本概念</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="this.onerror=null;this.src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Icserm</div><div class="author-info__description">无为之心，做有为之事</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ICserD"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ICserD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2862081626@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_73546177" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">期末复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序语言的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">程序翻译的方式有哪些？有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E5%8C%85%E5%90%AB%E5%A4%9A%E5%B0%91%E4%B8%AA%E9%98%B6%E6%AE%B5%E3%80%81%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">编译程序包含多少个阶段、各阶段的功能是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">第二章（重点）——词法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E6%9E%84%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">正则表达式运算及其构建方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toNFA-toDFA-toDFA%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">正则表达式→\to→NFA→\to→DFA→\to→DFA最小化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%8C%96%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BADFA%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">确定化有穷自动机DFA的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%A1%AE%E5%AE%9A%E5%8C%96%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BANFA%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">非确定化有穷自动机NFA的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E5%92%8CNFA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">DFA和NFA的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NFA%E8%BD%AC%E5%8C%96%E4%B8%BADFA%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">NFA转化为DFA的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#epsilon%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">ϵ\epsilonϵ闭包的定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%88%A4%E5%88%AB%E7%BB%88%E6%80%81%E4%BB%A5%E5%8F%8AERROR%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">注意判别终态以及ERROR状态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFA%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">DFA最小化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">词法分析程序的生成方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">代码实现有穷自动机（两种方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">方法一：状态转换方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BD%AC%E6%8D%A2%E8%A1%A8%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">方法二：转换表——二维数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%8E%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">实验一与实验二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%A0%E9%A2%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">总结习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%E2%80%94%E2%80%94-%E6%96%87%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">第三章（重点） —— 文法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E3%80%81%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">文法、语言?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">文法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E9%83%A8%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA%EF%BC%88PPT%E4%B8%8A%E8%AF%B4%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">文法的存储结构以及推导过程在计算机内部的存储表示（PPT上说重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">语言的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">上下文无关语言的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84-%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">文法的分类是怎样的? 它们之间有何关系?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">文法的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%96%87%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">四种文法之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC%E3%80%81%E8%A7%84%E7%BA%A6%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%91%E3%80%81%E6%96%87%E6%B3%95%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">推导、规约、语法树、文法的二义性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6%E4%B8%8E%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">归约与推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">最左推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%8F%B3%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">最右推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%A5%E5%AD%90%E3%80%81%E5%8F%A5%E5%9E%8B%EF%BC%8C%E6%8E%A8%E5%AF%BC%E5%85%B3%E7%B3%BB%E5%88%B0%E8%87%AA%E5%8F%8D%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">句子、句型，推导关系到自反传递闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">分析树的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">语法树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">文法的二义性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%BB%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">如何画语法树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E6%B6%88%E9%99%A4%E6%96%B9%E6%B3%95%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">文法二义性的消除方法有多少种？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E6%B6%88%E9%99%A4%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">文法消除二义性的方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E6%9E%84%E5%BB%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.6.</span> <span class="toc-text">文法的构建问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%E8%A1%A8%E7%A4%BAEBNF"><span class="toc-number">1.3.6.0.1.</span> <span class="toc-text">文法规则的扩展表示EBNF</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%B3%95%E7%9A%84%E9%97%AE%E9%A2%98-%E5%B7%A6%E5%85%AC%E5%85%B1%E5%9B%A0%E5%AD%90%E3%80%81%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">1.3.7.</span> <span class="toc-text">自顶向下分析法的问题: 左公共因子、左递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">自顶向下分析的约定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%B7%A5%E5%9B%A0%E5%AD%90%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">左工因子问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">左递归问题的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92%E7%9A%84%E6%B6%88%E9%99%A4"><span class="toc-number">1.3.7.3.1.</span> <span class="toc-text">直接左递归的消除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%B7%A6%E9%80%92%E5%BD%92"><span class="toc-number">1.3.7.3.2.</span> <span class="toc-text">间接左递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E9%80%92%E5%BD%92%E6%B6%88%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.7.3.3.</span> <span class="toc-text">左递归消除算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E7%9A%84%E7%AE%80%E5%8C%96"><span class="toc-number">1.3.8.</span> <span class="toc-text">文法的简化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99%E6%9C%89%E6%95%88%E6%80%A7%E5%88%86%E6%9E%90%E4%B8%8E%E5%8C%96%E7%AE%80%E6%96%87%E6%B3%95"><span class="toc-number">1.3.8.1.</span> <span class="toc-text">文法规则有效性分析与化简文法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#First-%E4%B8%8Efollow%E9%9B%86%E5%90%88-%E5%AE%9E%E9%AA%8C%E5%9B%9B"><span class="toc-number">1.3.9.</span> <span class="toc-text">First 与follow集合(实验四)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#First%E9%9B%86%E5%90%88%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">First集合计算方法归纳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Follow%E9%9B%86%E5%90%88%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E5%BD%92%E7%BA%B3"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">Follow集合计算方法归纳</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%A0%E9%A2%98-2"><span class="toc-number">1.3.10.</span> <span class="toc-text">总结习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89-%E2%80%94%E2%80%94-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">第四章（重点） —— 自顶向下的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95-%E6%88%96%E7%A7%B0%E9%80%92%E5%BD%92%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">递归下降语法分析方法(或称递归子程序)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">自顶向下分析方法相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9B%9E%E6%BA%AF%E6%80%A7%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">一、回溯性自顶向下分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A2%84%E6%B5%8B%E6%80%A7%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">二、预测性自顶向下分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E5%9B%9E%E6%BA%AF%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E7%9A%84%E6%96%87%E6%B3%95%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.1.3.1.</span> <span class="toc-text">无回溯自顶向下分析技术的文法条件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">递归下降分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%9B%BE"><span class="toc-number">1.4.1.4.1.</span> <span class="toc-text">语法图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.4.2.</span> <span class="toc-text">递归下降分析程序的设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.1.4.3.</span> <span class="toc-text">递归下降法的总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95-%E2%80%93LL-1-%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95-%E2%80%93LL-1-%E5%88%86%E6%9E%90%E8%A1%A8-%E2%80%93LL-1-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">LL(1)分析方法 –LL(1)判断方法 –LL(1)分析表 –LL(1)分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">LL(1)的分析方法相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LL-1-%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99%E7%9A%84%E5%88%A4%E5%AE%9A%E5%AE%9A%E7%90%86"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">LL(1)文法规则的判定定理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">LL(1)分析方法以及过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LL-1-%E8%A7%A3%E5%86%B3%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">LL(1)解决二义性问题的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">实验三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B9%A0%E9%A2%98-3"><span class="toc-number">1.4.4.</span> <span class="toc-text">总结习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">1.5.</span> <span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-DFA%E3%80%81LR-1-DFA%E3%80%81-LALR-1-DFA%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">LR(0) DFA、LR(1) DFA、 LALR(1) DFA？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-k-%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">LR(k)分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">LR(0)分析在计算机上的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-1-%E5%88%86%E6%9E%90"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">SLR(1)分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-1-%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">LR(1)分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LALR-1-%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">LALR(1)分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LALR-1-%E5%92%8CLR-1-%E7%9A%84%E6%95%88%E7%8E%87%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.6.</span> <span class="toc-text">LALR(1)和LR(1)的效率区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81LR-1-%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81-SLR-1-%E5%88%86%E6%9E%90%E8%A1%A8%E3%80%81-LALR-1-%E5%88%86%E6%9E%90%E8%A1%A8%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">LR(0)分析表、LR(1)分析表、 SLR(1)分析表、 LALR(1) 分析表？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-1-%E7%9A%84%E5%88%86%E6%9E%90%E8%A1%A8%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">SLR(1)的分析表的构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LR-0-%E6%96%87%E6%B3%95%E3%80%81LR-1-%E6%96%87%E6%B3%95%E3%80%81SLR-1-%E6%96%87%E6%B3%95%E3%80%81-LALR-1-%E6%96%87%E6%B3%95%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADLR-0-%E6%96%87%E6%B3%95%E3%80%81SLR-1-%E6%96%87%E6%B3%95%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">LR(0)文法、LR(1)文法、SLR(1)文法、 LALR(1) 文法？如何判断LR(0)文法、SLR(1)文法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LR-0-%E7%9A%84%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">LR(0)的分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LALR-1-%E5%88%86%E6%9E%90%E6%B3%95-2"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">LALR(1)分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SLR-1-%E6%96%87%E6%B3%95%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">SLR(1)文法判断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%B3%95%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8LR-0-%E3%80%81LR-1-%E3%80%81-SLR-1-%E3%80%81LALR-1-%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9F"><span class="toc-number">1.5.4.</span> <span class="toc-text">文法如何利用LR(0) 、LR(1) 、 SLR(1)、LALR(1) 进行语法分析？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E3%80%81%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">运用自底向上、自顶向下的方法进行语法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%89%8D%E9%9D%A2%E5%85%B6%E5%AE%9E%E4%B9%9F%E6%80%BB%E7%BB%93%E8%BF%87%EF%BC%8C%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%EF%BC%89"><span class="toc-number">1.5.4.1.1.</span> <span class="toc-text">运用自顶向下的分析方法进行语法分析步骤（前面其实也总结过，本质是一样的）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E7%94%A8%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.4.1.2.</span> <span class="toc-text">运用自底向上的分析方法进行语法分析的步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">语法分析的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">属性文法的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">语义分析的基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B"><span class="toc-number">1.5.5.</span> <span class="toc-text">实验四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.6.</span> <span class="toc-text">题型总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">1.6.</span> <span class="toc-text">第六章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">语法制导翻译的方法有多少种？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">语法分析的基本思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%EF%BC%9F%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">中间代码？表示形式如何？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">常见的中间代码的形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E3%80%81%E5%9B%9B%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E3%80%81%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">如何将一个算术表达式转换为逆波兰表示、四元组表示、三元组表示？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%BD%AC%E5%90%8E%E7%BC%80%EF%BC%88%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%EF%BC%89"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">中缀转后缀（逆波兰表示）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E7%9A%84%E5%90%8E%E7%BC%80%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">扩充的后缀表示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">四元组表示方法以及其转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">三元组表示方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%BF%BB%E8%AF%91%E4%B8%BA%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%EF%BC%88%E5%90%8E%E7%BC%80%E3%80%81%E4%B8%89%E5%85%83%E7%BB%84%E3%80%81%E5%9B%9B%E5%85%83%E7%BB%84%EF%BC%89%EF%BC%9F"><span class="toc-number">1.6.4.</span> <span class="toc-text">如何将一段代码翻译为中间代码（后缀、三元组、四元组）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%BF%BB%E8%AF%91%E2%80%94%E2%80%94%E8%83%BD%E5%86%99%E5%87%BA%E8%AF%AD%E4%B9%89%E5%87%BD%E6%95%B0%E6%88%96%E8%AF%AD%E4%B9%89%E5%8A%A8%E4%BD%9C"><span class="toc-number">1.6.5.</span> <span class="toc-text">几种常用语句的翻译——能写出语义函数或语义动作</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E3%80%912.%20%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/" title="文献检索方法">文献检索方法</a><time datetime="2024-09-08T16:00:00.000Z" title="发表于 2024-09-09 00:00:00">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/" title="结构化设计方法">结构化设计方法</a><time datetime="2024-08-23T16:00:00.000Z" title="发表于 2024-08-24 00:00:00">2024-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/" title="期末考点整理">期末考点整理</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="期末复习">期末复习</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" title="数据库事务管理">数据库事务管理</a><time datetime="2024-06-17T00:00:00.000Z" title="发表于 2024-06-17 08:00:00">2024-06-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/self_img/11c.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Icserm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>