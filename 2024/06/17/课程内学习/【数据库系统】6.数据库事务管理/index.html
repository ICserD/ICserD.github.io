<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库事务管理 | nullptr</title><meta name="author" content="Icserm"><meta name="copyright" content="Icserm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库事务管理 12flowchart LR事务管理 --&gt; 事务 &amp; 并发控制 &amp; 故障恢复 事务 &#x3D;&#x3D;事务是恢复和并发控制的基本单位！&#x3D;&#x3D; 事务的定义 事务的DBMS的基本执行单位，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。 例如： 例如银行转帐由两个操作组成： ① 转出帐户A 减去某一金额（A&#x3D;A－?） ② 转入帐户B 增加相同金">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库事务管理">
<meta property="og:url" content="http://example.com/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="nullptr">
<meta property="og:description" content="数据库事务管理 12flowchart LR事务管理 --&gt; 事务 &amp; 并发控制 &amp; 故障恢复 事务 &#x3D;&#x3D;事务是恢复和并发控制的基本单位！&#x3D;&#x3D; 事务的定义 事务的DBMS的基本执行单位，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。 例如： 例如银行转帐由两个操作组成： ① 转出帐户A 减去某一金额（A&#x3D;A－?） ② 转入帐户B 增加相同金">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/self_img/head_img.jpg">
<meta property="article:published_time" content="2024-06-17T00:00:00.000Z">
<meta property="article:modified_time" content="2024-06-17T00:50:00.000Z">
<meta property="article:author" content="Icserm">
<meta property="article:tag" content="课程学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/self_img/head_img.jpg"><link rel="shortcut icon" href="/self_img/bollon.png"><link rel="canonical" href="http://example.com/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库事务管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-17 08:50:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="onerror=null;src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/self_img/11c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="nullptr"><span class="site-name">nullptr</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fab fa-bandcamp"></i><span> 导航:</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据库事务管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-17T00:00:00.000Z" title="发表于 2024-06-17 08:00:00">2024-06-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-17T00:50:00.000Z" title="更新于 2024-06-17 08:50:00">2024-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据库事务管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>数据库事务管理</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">事务管理 --&gt; 事务 &amp; 并发控制 &amp; 故障恢复</span><br></pre></td></tr></table></figure>
<h2 id="事务">事务</h2>
<p>==事务是恢复和并发控制的基本单位！==</p>
<h3 id="事务的定义"><strong>事务的定义</strong></h3>
<p>事务的DBMS的<strong>基本执行单位</strong>，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。<br>
例如：<br>
例如银行转帐由两个操作组成：<br>
① 转出帐户A 减去某一金额（A=A－?）<br>
② 转入帐户B 增加相同金额（B=B + ?）<br>
这两个操作放在同一个事务里完成，要么全做，要么全不做。</p>
<h3 id="事务的性质（ACID）"><strong>事务的性质</strong>（ACID）</h3>
<p>一、 <strong>原子性（Atomicity）</strong><br>
事务中包含的所有操作（特指修改操作）要么全做，要么全不做。<br>
<strong>实现机制</strong>：原子性由<strong>恢复机制</strong>（本章第7节）实现</p>
<p>二、<strong>一致性</strong>（Consistency）<br>
事务执行的结果必须是使得数据库从一个一致性状态到另一个一致性状态。<br>
一致性状态：</p>
<ul>
<li>数据库中只包含成功事务的提交结果<br>
不一致状态：</li>
<li>数据库系统中发生故障，有些事务尚未完成就被中断</li>
<li>这些未完成事务对数据库所做的修改有一部分已经写入物理数据库，这时数据库就处于一种不正确状态</li>
</ul>
<p><strong>实现机制</strong>：保证单个事务的一致性，由编写事务的应用程序员来负责，借助<strong>完整性机制</strong>来协助实现，所以数据的一致性要求可以被定义为某些完整性规则</p>
<p>一致性视具体情况而定；<br>
例如：<br>
银行系统中，转帐事务的一致性要求是前后两个帐户的金额总和不变。假如一个事务为帐户A减去100，为帐户B加上50，那么这个事务就违反了一致性。</p>
<p><strong>一致性介绍以及例子解读，视频7分钟到8分钟</strong><br>
<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13J411J7Vu?p=71&amp;vd_source=fcc6783c4fd6e558539db82a5f89834a">https://www.bilibili.com/video/BV13J411J7Vu?p=71&amp;vd_source=fcc6783c4fd6e558539db82a5f89834a</a></p>
<h4 id="判断事务在事务调度过程中是否保持数据一致性">判断事务在事务调度过程中是否保持数据一致性</h4>
<ol>
<li>分析事务在每一步处理过程前后，数据是否有被其他事务处理过，若有则不保持数据一致性<br>
具体例子看PPT26页-27页两个并发调度的例子，第一个并发调度保持了数据一致性，第二个破坏了数据一致性</li>
</ol>
<p>三、<strong>隔离性</strong>（isolation）<br>
多个事务在并发执行的时候不会相互影响，好像他们是隔离开来的；并发执行的最后结果与顺序执行这些事务的结果一致；<br>
<strong>隔离性要求一个事务不会看到另一个事务的中间结果</strong><br>
例如：<br>
对两个事务T1，T2。如果事务T1读取的数据，一部分是事务T2修改前的数据，一部分是事务T2修改后的数据，这就违反了隔离性，并可能导致数据错误</p>
<p><strong>实现机制</strong>：隔离性通过<strong>并发控制机制</strong>实现</p>
<p>四、<strong>持久性</strong>（Durability）<br>
事务一旦提交，它对数据库的影响就是永久性的，无论发生什么事都无法取消这种影响。<br>
例如：<br>
一个事务将50元从帐户A转到帐户B，此事务一旦提交，这种交易是无法悔改的——即便发生故障，也不能把这50元“还”回去。<br>
<strong>实现机制</strong>：恢复机制</p>
<p><strong>破坏事务ACID特性的因素</strong><br>
保证事务的ACID特性是事务处理的任务<br>
破坏事务ACID特性的因素如下：</p>
<ul>
<li>多个事务并发运行，不同事务的操作交叉执行<br>
DBMS必须保证多个事务交叉运行不影响这些事务的隔离性（DBMS的并发控制机制的责任）</li>
<li>事务在运行过程中被强制停止<br>
数据库管理系统必须保证被强制终止的事务对数据库和其他事务没有任何影响，保证事务的原子性和一致性（DBMS恢复机制的责任）</li>
</ul>
<h3 id="事务的状态与操作">事务的状态与操作</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617104458.png" alt="Pasted image 20240617104458"></p>
<h4 id="事务的状态">事务的状态</h4>
<p>一、 活动状态</p>
<ul>
<li>事务开始后进入</li>
<li>事务处于本状态，依次执行事务中的每条语句</li>
</ul>
<p>二、部分提交状态</p>
<ul>
<li>执行完事务的全部语句后进入</li>
<li>事务处于本状态时，将已经做的<strong>每个修改操作提交，即永久化写入到==日志==</strong> 中。这样即使修改操作后来丢失了（例如数据库崩溃），也能根据日志来恢复它。</li>
</ul>
<p>三、失败状态</p>
<ul>
<li>在活动状态中，执行某条语句失败时而进入；或者在部分提交中，提交的永久化信息失败时进入</li>
<li>事务处于本状态时，不断回滚已经发生的修改操作，即把数据改为原来的旧值。</li>
</ul>
<p>四、提交状态</p>
<ul>
<li>提交完全部修改操作后进入；</li>
<li>事务处于本状态时，事务结束。为事务的结束状态之一</li>
</ul>
<p>五、中止状态</p>
<ul>
<li>回滚全部操作后进入</li>
<li>事务处于本状态，事务结束。为事务的结束状态之二</li>
</ul>
<h4 id="执行一个事务可能的状态序列">执行一个事务可能的状态序列</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">	subgraph 序列1</span><br><span class="line">		direction LR</span><br><span class="line">		1[&quot;活动状态&quot;] --&gt; 2[&quot;部分提交状态&quot;] --&gt; 3[&quot;提交状态&quot;]</span><br><span class="line">	end</span><br><span class="line">	subgraph 序列2</span><br><span class="line">		direction LR</span><br><span class="line">		4[&quot;活动状态&quot;] --&gt; 5[&quot;失败状态&quot;] --&gt; 6[&quot;中止状态&quot;]</span><br><span class="line">	end</span><br><span class="line">	subgraph 序列3</span><br><span class="line">		direction LR</span><br><span class="line">		7[&quot;活动状态&quot;] --&gt; 8[&quot;部分提交状态&quot;] --&gt; 9[&quot;失败状态&quot;] --&gt; 10[&quot;中止状态&quot;]</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>
<h3 id="SQL中的事务">SQL中的事务</h3>
<h4 id="相关语句">相关语句</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> Transaction <span class="comment">--开始事务</span></span><br><span class="line"><span class="keyword">Commit</span> (Transaction) <span class="comment">--提交事务，此时事务正常结束，事务所做的修改都有效且永久地写入数据库</span></span><br><span class="line"><span class="keyword">Rollback</span> (Transaction) <span class="comment">--回滚事务。此时事务非正常结束，事务所做的修改都无效并且必须撤销（数据改回原值）；</span></span><br></pre></td></tr></table></figure>
<p><strong>回滚后，数据库回退到事务开始前的状态，就好像事务从来没有发生过一样</strong><br>
<strong>注意</strong>：</p>
<ul>
<li>事务没有执行完commit之前，因种种原因（故障），而终止了，那么系统就会自动地回滚这个事务。</li>
<li>判断SQL语句属于哪个事务
<ul>
<li>如果SQL语句处于某个事务的Begin transaction和Commit/Rollback之间，那么它就属于这个事务</li>
<li>==如果以上不成立，那么这个SQL语句本身构成一个独立的事务==</li>
</ul>
</li>
</ul>
<h3 id="事务调度">事务调度</h3>
<p>定义：系统按什么时间顺序执行（进入系统的）一组事务/事务的指令</p>
<ul>
<li>虽然在微观上，这组事务是先后到达系统的，但宏观上可能是“同时”到达系统：即上一个事务还没结束时，下一个事务又进入了系统。<br>
一、串行调度</li>
<li>当一个事务完全结束后，下一个事务才开始执行</li>
<li>特定：从时间顺序看，同一事务的指令紧挨在一起w<br>
二、并发调度</li>
<li>未执行完一个事务，可转去执行另一个事务</li>
<li>事务的执行时间重叠，宏观上多个事务同时执行，微观上这些事物分时执行</li>
<li>特定：从时间顺序看，不同事务的指令彼此交叉</li>
</ul>
<h4 id="并发调度的优势（相比于串行调度）">并发调度的优势（相比于串行调度）</h4>
<ol>
<li>不同事务的不同指令，涉及到的系统资源也不同，同时执行这些指令，可以<strong>提高资源利用率和系统吞吐量</strong>。<br>
例如：<br>
事务A和事务B，都由指令1(要求CPU计算)和指令2(要求I/O)组成。CPU和I/O设备是可以并行工作的，所以并发执行事务A的指令2和事务B的指令1时，可以避免资源闲置和缩短总执行时间。</li>
<li>系统中存在着周期不等的各种事务，串行调度导致短事务可能要等待长事务完成。（串行的弊端）<br>
而采用并发调度，灵活决定事务的执行顺序，可以<strong>减少平均响应时间</strong></li>
</ol>
<h4 id="并发调度存在的问题">并发调度存在的问题</h4>
<p>一、可能破坏数据一致性<br>
即使单个事务的执行不会破坏数据的一致性，多个这样的事务在并发调度时，也可能破坏数据一致性。<br>
二、产生问题的原因<br>
隔离性要求事务T1不能看到另一个事务T2的中间结果（一部分数据是修改前的、一部分数据是修改后的），但是在并发执行的情况下，有时没有做到这一点<br>
三、解决方法（<strong>正确性原则</strong>）—— 使并发调度可串行化</p>
<ul>
<li>事务的串行调度显然不会破坏数据的一致性</li>
<li>如果事务的并发调度是可串行化的，即效果上等价于某个串行调度时，也不会破坏数据一致性</li>
</ul>
<p>保证单个事务有一致性的情况下：</p>
<ol>
<li>任何串行调度，不会破坏数据一致性</li>
<li>保证隔离性/可串行化的并发调度，也不会破坏一致性</li>
<li>隔离性得不到保证/不可串行化，可能会破坏数据的一致性，产生错误</li>
</ol>
<h4 id="并发调度产生的错误">并发调度产生的错误</h4>
<p>并发调度产生的错误，称为数据不一致性，主要分类三种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">三类不一致 --&gt; 丢失修改 &amp; 不可重复读 &amp; 1[&quot;`读“脏”数据`&quot;]</span><br></pre></td></tr></table></figure>
<ol>
<li>丢失修改的产生：
<ul>
<li>两个事务T1和T2从数据库中读入同一数据，然后分别修改并提交</li>
<li>假设T1先提交，然后T2后提交，则后面提交的修改覆盖前面提交的修改，导致前面的修改丢失</li>
</ul>
</li>
<li>不可重复读：
<ul>
<li>事务T1第一次读取某些数据后，事务T2对这些数据做了某些修改操作并提交，事务T1第二次读取该记录时得到的是与前一次不同的结果</li>
</ul>
</li>
<li>读取“脏”数据：
<ul>
<li>事务T1修改数据，并写入数据库（新值覆盖旧值），但未提交</li>
<li>事务T2读取了这个数据，<strong>读到的新值即为脏数据</strong>：<br>
<strong>脏数据</strong>：其他事务修改后，但还未提交的数据<br>
脏数据不一定是正确的，因为后续也可能会被回滚</li>
<li>事务T1由于某种原因回滚，数据改回旧值，导致前面T2读入的新值无效（一个不被承认的值）</li>
</ul>
</li>
</ol>
<h3 id="调度的几种情况">调度的几种情况</h3>
<h4 id="可串行化-是判断并发调度正确性的重要原则">可串行化(是判断并发调度正确性的重要原则)</h4>
<p>可串行化有两种，满足其中一种即可；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">可串行化 --&gt; 冲突可串行化 &amp; 视图可串行化</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据库管理系统对于并发事务不同的调度可能产生不同的结果，执行结果等价于串行调度的调度是才是正确的调度，称为可串行化调度</strong></li>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某次串行地执行这些事务时的结果相同</li>
<li>可串行性是并发事务调度的正确准则，一个给定的并发调度，当且仅当它是可串行化的，才认为他是正确的调度</li>
</ul>
<p>一、冲突可串行化<br>
<strong>冲突操作</strong>(特点：涉及同一个数据，多个事务，至少有一个写操作)：</p>
<ul>
<li>不同事务对同一事务的<strong>读写</strong>操作，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mrow><mi>T</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>和</mtext><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Read_{T1}(X)和Write_{T2}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>同时发生</li>
<li>不同事务对同一事务的<strong>写写</strong>操作，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>和</mtext><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Write_{T1}(X)和Write_{T2}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><br>
<strong>不能交换的操作</strong>：</li>
<li>同一事务的两个操作不能交换，因为同一事务中用户规定什么执行顺序就是什么执行顺序，要满足用户需求</li>
<li>不同事务的冲突操作不能交换<br>
<strong>冲突可串行化</strong>：</li>
<li>条件比可串行化更严格</li>
<li>一个调度Sc在保证冲突操作的次序不变的情况下（就是不交换冲突操作），通过交换两个事务不冲突操作的次序得到另一个调度Sc<code>，如果Sc</code>是串行的，称Sc是冲突可串行化调度</li>
<li>若一个调度是冲突可串行化的，则一定是可串行化调度<br>
如果并发调度<strong>冲突等价于某个串行调度</strong>，它就是冲突可串行化的；<br>
<strong>冲突等价</strong>：通过交换两条连续但不冲突得指令，得到新的调度，和原调度称为是冲突等价的</li>
</ul>
<h5 id="判定调度是否为冲突可串行化（判定调度正确性）">判定调度是否为冲突可串行化（判定调度正确性）</h5>
<p>视频的12分48秒之后的两个例题详细介绍了方法，通俗易懂！</p>
<iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142761539&p=80" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width: 100%;"></iframe>
<p>二、视图可串行化<br>
如果并发调度的<strong>视图等价于某个串行调度</strong>，它就是视图可串行化的<br>
<strong>视图等价</strong>：对某一个数据项，两个调度按照相同的事务顺序来读取和写入</p>
<h4 id="可恢复调度">可恢复调度</h4>
<p>考虑这样一个情形：</p>
<ol>
<li>事务T1写入数据，尚未提交前事务T2对该数据进行读取<br>
此时称T2依赖于T1，因为T2看到了T1产生的为提交确认的数据</li>
<li>然后T2先提交</li>
<li>接下来，事务T1由于某种原因（故障等）需要回滚<br>
这时，理论上T2也要回滚（之前读取的数据无效）。<br>
但此时T2已经提交了，无法回滚到前一个状态，所以出现了<strong>不可恢复调度</strong>——事务T1对数据库/其他事务的影响，不能全部取消（<strong>事务的持久性性质决定的</strong>）</li>
</ol>
<p><strong>可恢复调度的要求</strong>：<br>
如果事务T2依赖于T1，那么事务T2必须在T1提交之后才能提交</p>
<h4 id="无级联调度">无级联调度</h4>
<p>考虑这样一个情形：</p>
<ol>
<li>事务T1写入数据，尚未提交前事务T2对该数据进行读取<br>
此时称T2依赖于T1，因为T2看到了T1产生的为提交确认的数据</li>
<li>T2等待T1先提交，否则发生不可恢复调度</li>
<li>接下来，事务T1由于某种原因（故障等）需要回滚
<ul>
<li>那么T2也需要回滚（之前读取的数据无效），并且如果有其他事务T3依赖于T2，也需要递归级联回滚</li>
<li>所以这里出现了<strong>级联回滚</strong>——单个事务回滚，会引发其他一系列事务被回滚的现象</li>
</ul>
</li>
</ol>
<p><strong>无级联调度的要求</strong><br>
如果事务T2要读取T1写入的数据，只能在事务T1提交之后才能读取</p>
<h3 id="总结">总结</h3>
<p>一、事务调度分为串行调度和并发调度<br>
并发调度的优点：提高执行效率<br>
并发调度的问题：如果不作控制（保证隔离性、可串行化），就有可能产生三类数据不一致性错误：</p>
<ol>
<li>丢失修改</li>
<li>不可重复读</li>
<li>读取“脏”数据<br>
二、所以DBMS必须提供<strong>并发机制</strong>，来保证事务的并发调度是正确的，即保证隔离性、可串行化</li>
</ol>
<h2 id="并发控制">并发控制</h2>
<p><strong>并发控制任务</strong>：保证事务的并发调度是正确的（满足隔离性/可串行化——效果上等于某个串行调度），不会破坏数据的一致性</p>
<p><strong>并发控制技术</strong>：</p>
<ol>
<li>基于锁的机制（最常用，最通用）</li>
<li>基于时间戳的机制（自学、不重点）</li>
<li>基于多版本的机制（自学、不重点）</li>
</ol>
<h3 id="锁">锁</h3>
<h4 id="概念">概念</h4>
<ul>
<li>一个事务在对某个数据对象（表、元组、关系等）进行操作前，可以向系统申请对该<strong>数据对象</strong>加锁。==数据库上锁的数据对象是内存中的数据，不是磁盘中的数据）来自于励儒云的习题==<br>
<strong>注意</strong>：锁的对象是数据对象！而不是事务！</li>
<li>对数据对象加锁后，其他事务就不能对该数据对象进行某些操作，直到原来加锁的事务释放锁为止<br>
<strong>原因</strong>：其他事务也要加锁，但被前面这个事务的锁所阻挡或者排斥</li>
</ul>
<h4 id="锁的粒度">锁的粒度</h4>
<p>锁针对的数据对象从大到小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR </span><br><span class="line">锁的数据对象 --&gt; 数据库 &amp; 表 &amp; 页面 &amp; 记录 &amp; 记录的一个字段</span><br><span class="line">%%  %%数据库 --&gt; 表 --&gt; 页面 --&gt; 记录 --&gt; 记录的一个字段</span><br></pre></td></tr></table></figure>
<p><strong>锁的粒度越小，则：</strong></p>
<ul>
<li>并发度越大——（操作同个数据）冲突可能性下降</li>
<li>开销增大——管理更多的锁</li>
</ul>
<h4 id="类型">类型</h4>
<p><strong>X锁</strong>：又称为写锁/排他锁（Exclusive Lock）</p>
<ul>
<li>一个事务对数据A进行修改（写）操作前，给它加上X锁。获得X锁后，事务可以对数据A进行写，也可以对数据A进行读</li>
<li>==其他事务不能对A再加任何锁，直到X锁被释放为止！但这不意味着其他事务不能对A进行读写，要根据对应的封锁协议来确定，比如思考下面这个问题：==
<ol>
<li>一个数据库系统所有事务满足一级封锁协议，解决了丢失修改的问题，但是没有解决读取脏数据的问题，为什么？（脏数据指被修改但未提交的数据）
<ul>
<li>假设一个事务T1要修改数据R，所以在读取或修改数据R前对R上X锁</li>
<li>当事务T1修改完数据R后，还未提交</li>
<li>此时事务T2想要读取数据R，<strong>这是允许的，因为一级封锁协议仅要求，如果要修改某个数据必须上X锁直到事务结束，但对读数据没有限制，即读数据不需要上锁就可以读</strong></li>
<li>对于事物T2，在一级封锁协议下，他要能够读取数据R并没有限制条件，可以直接读取</li>
<li>那么可能你就会疑惑了，现在数据R身上有X锁，事务T2为什么能读数据R呢？<strong>根据排它锁X的定义，当一个数据库对象被上X锁后，其他事务不能对其上任何锁，并不是说不能对其进行读写！</strong></li>
<li>所以事务T2不能对数据R2上任何锁，但是在一级封锁协议下，事务T2不需要对数据R2上锁就能读，所以可以读到数据R2</li>
<li>事务T2读了数据R2，但是数据R2已经被事务T1修改了并且还没有提交，所以事务T2读取到了 <strong>脏数据</strong>。<br>
<strong>S锁</strong>：又称为读锁/共享锁（Shared Lock）</li>
</ul>
</li>
</ol>
</li>
<li>一个事务对数据A进行读取操作前，给它加上S锁，获得S锁后，该事物<strong>可以读，但不可以写</strong></li>
<li>其他事务可以对A加更多的锁（除了X锁）<br>
<strong>U锁</strong>：又称更新锁（==不要求==）<br>
一个事务对数据A进行更新（写）操作，分为以下步骤</li>
</ul>
<ol>
<li>对数据加U锁，然后对数据读取到内存，<strong>在内存中</strong>更新A的值<br>
此时其他事务可以对（外存上的）数据A加S锁进行读取</li>
<li>申请将数据上的U升级为X锁，升级后将更新写入外存
<ul>
<li>如果此时A上有其他事务的读锁，则申请要延迟到它们释放为止</li>
<li>升级X锁成功后，当然其他事务就不能再加任何锁了<br>
<strong>意向锁（部分锁）</strong>：（==不要求==）<br>
<strong>规则</strong>：事务在一个小粒度对象上加S/X锁之前，先要对上级的大粒度对象加<strong>意向S锁/意向X锁</strong>，表示要对这个大粒度对象“读/写一部分”。</li>
</ul>
</li>
</ol>
<ul>
<li>例如，表有10000条记录，分布在100个页面上。事务T1如果要写某条记录=某个页面的一部分，整个表的一部分，那么依次加 ① 整个表的意向X锁 ② 所在页面的意向X锁 ③ 这条记录的X锁<br>
<strong>作用</strong>：有了意向锁，检测锁冲突的开销、以及需要维持的锁的数量都减少了</li>
<li>比如，另一个事务T2，准备删除整个表，那么它在表这一级别上就检测到冲突的存在，而不是遍历10000条记录看有没有某个记录上存在锁</li>
</ul>
<h4 id="封锁协议">封锁协议</h4>
<p>封锁协议是事务对数据对象加锁时需要遵守的规则</p>
<blockquote>
<p>事务对数据对象加锁时，还需要遵守某种规则，包括：什么（读/写）操作要加锁、何时加锁、何时释放？我们称这些规则为封锁协议。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">封锁协议 --&gt; 一级封锁协议 &amp; 二级封锁协议 &amp; 三级封锁协议 &amp; 两段封锁协议</span><br></pre></td></tr></table></figure>
<h5 id="一级封锁协议">一级封锁协议</h5>
<p><strong>规则</strong>：数据对象D如果是修改/写操作，在第一次read/write之前需要加X锁，事务结束（commit/rollback）后才释放X锁<br>
<strong>规则的简洁表述</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放（事务的结束有两种状态，正常结束commit和非正常结束rollback）<br>
<strong>特点</strong>：仅对写操作加锁，==对读操作无要求！==<br>
<strong>作用</strong>：一级封锁协议可以解决==丢失修改==的问题，并保证了事务T是可恢复的（原因：没有事务能够修改其他事务正在修改，还未提交的数据）</p>
<p><strong>判断方法</strong>：<br>
简单来说就是检查事务的read，write前和commit后是否分别有加X锁和释放X锁</p>
<ol>
<li>检查事务中第一次read或者write，在该指令前是否加了X锁，即XLOCK</li>
<li>检查事务提交或回滚指令后，是否释放了X锁，即有UNXLOCK</li>
<li>同时满足1、2两点，即满足1级封锁协议</li>
</ol>
<p><strong>例子：</strong><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617181056.png" alt="Pasted image 20240617181056"></p>
<h5 id="二级封锁协议">二级封锁协议</h5>
<p><strong>规则</strong>：满足一级封锁协议的基础上，若要读取数据R，事务T必须先对其加S锁，读取完后，可以在任意时候释放S锁（瞬间S锁）<br>
<strong>特点</strong>：不仅对数据的读有要求，而且对数据的写有要求<br>
<strong>作用</strong>：可以解决<strong>读取脏数据</strong>的问题（原因：没有事务可以读取其他事务正在修改但是未提交的数据）</p>
<p>思考这样一种情况：</p>
<ol>
<li>对于事物T1，他对数据D的访问满足一级封锁协议（仅对写操作有写锁限制）</li>
<li>事务T1中还有对数据B的访问，但是对数据B是仅读，所以不加任何锁（依然满足1级封锁协议）</li>
<li>假设事务T1在时间t1对数据B进行读，在时间t2对数据B进行读，即前后有两次读操作</li>
<li>现有另一个事务T2，在t1到t2期间进行对数据B的写操作并提交完成，由于事务T2也需要满足1级封锁协议，所以在t1到t2期间其他事务不能访问数据B</li>
<li>在时间t2，数据B已经被修改，事务T1再读取的时候已经是被修改的数据，存在==重复读的问题==</li>
</ol>
<p><strong>例子</strong>：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617183647.png" alt="Pasted image 20240617183647"></p>
<p><strong>判断方法</strong>：</p>
<ol>
<li>将事务T中对数据对象的操作分为两种，一种是仅读数据B，一种是读写A</li>
<li>对于数据B，查看读取前后是否有S锁</li>
<li>对于数据A，查看第一次读取/修改A之前是否加X锁，commit之后是否释放X锁</li>
<li>同时满足1、2、3，即符合二级封锁协议</li>
</ol>
<h5 id="三级封锁协议">三级封锁协议</h5>
<p><strong>规则</strong>：一级封锁协议的基础上，若要读取数据R，事务T必须在第一次读取R之前加上S锁，直到事务结束之后才释放S锁<br>
<strong>作用</strong>：解决<strong>不可重复读</strong>的问题（原因：在同一事务的两次读数据中间，没有其他事务能够修改该数据）<br>
<strong>思考</strong>：三级、二级封锁协议都要求读加锁。为什么直到三级才能解决不可重复读的问题，二级不可以？<br>
原因：二级封锁中，如果释放了读但是下一次读还没加上读锁的时候被修改了，还是会读到脏数据<br>
例子：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617214359.png" alt="Pasted image 20240617214359"></p>
<h5 id="两段封锁协议">两段封锁协议</h5>
<p><strong>规则</strong>：</p>
<ul>
<li>事务对数据加S/X锁后，才能读写数据；释放锁后不能再读写该数据</li>
<li>事务分为两个阶段：
<ol>
<li>生长阶段：（一直在）获得锁，不能释放锁</li>
<li>收缩阶段：（一直在）释放锁，不能申请锁<br>
<strong>首次释放掉一个锁后，即由生长阶段转为收缩阶段</strong><br>
==注意：符合三级封锁协议的事务一定也符合两段封锁协议，因为三级封锁协议保证了每个数据都在加锁和释放锁之间==</li>
</ol>
</li>
</ul>
<p>例子：<br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002018.png" alt="Pasted image 20240618002018"></p>
<h5 id="定理（重要）"><strong>定理</strong>（重要）</h5>
<p>若所有事物均遵从两段封锁协议，则对这些事务的并发调度一定是可串行化的！<br>
反之，在一个可串行化的调度中，不一定所有事务都满足两段封锁协议！<br>
因此，<strong>所有事务都遵从两段封锁协议是可串行化的充分非必要条件</strong>！<br>
<strong>下面视频介绍了两段封锁协议一定满足可串行性的例子！5分钟左右</strong></p>
<iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142760571&p=81" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:640px; height:430px; max-width: 100%;"></iframe>
<h5 id="封锁协议小结">封锁协议小结</h5>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002402.png" alt="Pasted image 20240618002402"></p>
<p>一、三级封锁协议的主要区别：</p>
<ol>
<li><strong>什么操作需要申请封锁</strong>：比如对于一级封锁协议，读操作是不需要封锁的，但是对于二级封锁协议，是需要封S锁的</li>
<li><strong>何时释放锁</strong>：比如二级封锁协议对S锁的释放是读完就能释放，但是三级封锁协议是直到事务结束才能释放</li>
</ol>
<p>二、不同封锁协议使事务达到的一致性级别不同</p>
<ul>
<li>封锁协议级别越高，一致性程度越高</li>
<li>一致性程度越高的同时，并发度会越低</li>
</ul>
<h3 id="活锁、死锁以及死锁的防治">活锁、死锁以及死锁的防治</h3>
<p>各级封锁协议可以用于解决事务并发调度导致的数据不一致的问题，也就是能够避免出现错误的执行，但是又带来的新问题：</p>
<ul>
<li>活锁</li>
<li>死锁</li>
</ul>
<h4 id="活锁">活锁</h4>
<p><strong>定义</strong>：在锁过程中，系统可能使<strong>一个事务</strong>处于<strong>永远等待</strong>的状态，无法申请到想要的锁。<br>
例如，一个事务T1想对数据加写锁，数据原来有（之前其它事务T0的）读锁，所以它只能等待。在T1等待过程中，后续事务T2，T3，T4源源不断地对数据上读锁，导致T1无法摆脱等待状态。</p>
<h5 id="活锁的防治">活锁的防治</h5>
<ul>
<li>严格执行“先来先服务”的策略，即<strong>事务申请顺序=获得锁的顺序</strong>。多个事务申请锁同一对象时，按照它们申请的时间排队和获得锁。<br>
例如，事务A、B都申请数据D上的锁（锁的类型可以不同），如果顺序是事务A先申请，系统也按这个顺序，先满足A的申请，再满足B的申请。</li>
</ul>
<h4 id="死锁">死锁</h4>
<p><strong>定义</strong>：<strong>几个事务</strong>等待对方释放锁的同时，又持有对方所等待的锁，最后陷入<strong>循环相互等待</strong>的僵局。</p>
<h5 id="解决死锁问题（2类方法）">解决死锁问题（2类方法）</h5>
<p>一、预防死锁的产生<br>
<strong>产生死锁的原因</strong>：两个或多个事务都已经封锁一些数据对象，然后又都申请已经被其他事务封锁的数据对象，从而出现死等待。<br>
<strong>预防死锁</strong>：就是要破坏死锁产生的条件<br>
<strong>方法</strong>：</p>
<ol>
<li>一次封锁法<br>
要求每个事务必须一次将所有要使用的数据全部加锁，否则不能继续执行<br>
问题：
<ul>
<li>加锁过早，降低系统并发度</li>
<li>难以实现精确确定封锁对象</li>
</ul>
</li>
<li>顺序封锁法<br>
预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁<br>
问题：
<ul>
<li>维护成本高，因为数据对象非常多，每张表、每个元组等都需要维护锁资源</li>
<li>难以实现，事务的封锁请求随事务的执行而动态确定，难以确定每一个事务要封锁哪些对象，因此很难按照规定的顺序施加封锁<br>
<strong>小结</strong>：</li>
</ul>
</li>
<li>在操作系统中广为采用的预防死锁的策略并不适合数据库特定</li>
<li>数据库管理系统在解决死锁问题上更普遍采用诊断并解除死锁的方法</li>
</ol>
<p>二、死锁的诊断和解除<br>
<strong>诊断死锁方法</strong>：</p>
<ol>
<li>
<p>超时法<br>
设定最长等待时间，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁<br>
优点：实现简单<br>
缺点：等待时长不好设置，过长导致效率低、过短导致误判</p>
</li>
<li>
<p>等待图法<br>
事务等待图：<br>
用事务等待图动态反映所有事务的等待情况，事务等待图时一个有向图G=(T,U)，T为结点的集合，每个结点表示正在运行的事务；U表示边的集合，每条边表示事物等待的情况；若事务T1等待事务T2，那么会画一条事务T1指向T2的有向边</p>
<p>利用事务等待图检测死锁：<br>
并发控制子系统周期性地生成事务等待图，检测事务，如果发现图中存在回路，则表示系统中出现了死锁</p>
</li>
</ol>
<p><strong>解除死锁方法</strong>：</p>
<ol>
<li>选择一个处理死锁代价最小（完成工作量最少）的事务，将其撤销</li>
<li>释放此事务持有的所有锁，使其他事务能继续运行下去</li>
</ol>
<h3 id="SQL中的隔离性级别">SQL中的隔离性级别</h3>
<p>并发控制的目标，是通过保证事务隔离性，来保证事务并发调度是正确的。理想情况下，事务是完全隔离的，不会发生任何错误，包括丢失修改、读脏数据、不可重复读、幻影等等。<br>
但是要达到完全没有错误的这个目标，会增加开销——使用更高级的封锁协议、加更多的锁；并且降低了并发度—— 事务加的锁越多，阻碍其它事务的可能性就越大。<br>
所以在实际的数据库系统中，<strong>会允许用户适当降低隔离性的等级，允许出现某些可容忍的错误，来换得性能的提升</strong>。<br>
高的隔离性级别意味着错误减少，但开销变大，并发度降低。低的隔离性级别正好相反。</p>
<p><strong>SQL中的隔离性级别</strong>：</p>
<ul>
<li>serializable：可串行化。一个并发调度的执行必须等价于一个串行调度的结果。消除了所有错误，特别是幻影</li>
<li>repeatable read：可重复读。这一级别的隔离性通过三级封锁协议实现：读写都加锁且都保持到事务结束后。消除了可重复读、读脏数据、丢失修改的错误</li>
<li>read committed：只能读取已提交的记录。这一级别的隔离性通过二级封锁协议实现：写加锁且保持到事务结束后；读加锁但读之后即释放。消除了丢失修改、读脏数据的错误</li>
<li>read uncommitted：可读取未提交的记录（即脏数据）。这一级别的隔离性通过一级封锁协议实现：写加锁且保持到事务结束后；读不加锁。消除了丢失修改错误</li>
</ul>
<h2 id="数据库恢复">数据库恢复</h2>
<h3 id="恢复实现的技术">恢复实现的技术</h3>
<p>数据库恢复的基本原理：<strong>冗余</strong><br>
在故障发生、数据出错后，用存储在其他地方的数据副本（冗余数据）来重建正确的数据。<br>
平时<strong>建立数据冗余</strong>的方法：</p>
<ul>
<li>数据备份（周期），也称数据转储</li>
<li>登记日志文件（实时）</li>
</ul>
<h4 id="数据备份">数据备份</h4>
<p>定义：有数据库系统定期将数据进行复制，得到后备副本并保存在外部存储空间上的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0[&quot;</span><br><span class="line">数</span><br><span class="line">据</span><br><span class="line">备</span><br><span class="line">份&quot;] --&gt; 静态备份 &amp; 动态备份</span><br><span class="line">静态备份 --&gt; 1[&quot;备份期间，系统不能有事务运行&quot;] &amp; 2[&quot;优点: 实现简单，得到的数据库副本有一致性&lt;/br&gt;缺点: 备份时，数据库不可用&quot;]</span><br><span class="line">动态备份 --&gt; 3[&quot;备份期间，允许事务运行（存取数据）&quot;] &amp; 4[&quot;优点: 备份时，数据库可用&lt;/br&gt;缺点: 实现复杂，不能保证数据库副本的一致性&quot;]</span><br></pre></td></tr></table></figure>
<h5 id="完全备份和增量备份">完全备份和增量备份</h5>
<ul>
<li>完全备份：一次备份整个数据库的数据内容</li>
<li>增量备份：备份自上次备份以来发生变化的那部分数据
<ol>
<li>优点：容量小，速度快</li>
<li>缺点：必须联合上一次备份使用，可靠性不高（如果上一次备份失效，这一次的也不行）</li>
</ol>
</li>
</ul>
<h4 id="小结">小结</h4>
<p>数据备份在备份时机上分为两种，静态备份和动态备份；在备份内容上也分为两种，完全备份和增量备份。<br>
所以一共形成了四种备份方法：静态完全备份、静态增量备份、动态完全备份、动态增量备份<br>
在实际应用中，数据库系统会采取多种备份方式来进行数据库备份，比如1年进行一次静态增量备份等</p>
<h3 id="日志文件">日志文件</h3>
<p><strong>定义</strong>：日志文件是用于登记数据库系统中每一个事务每一次修改操作（插入、删除、更新）的信息，特别是<strong>操作前后的新旧值</strong>，数据库恢复时，可以REDO/UNDO这些操作，获得正确状态的数据</p>
<p><strong>日志文件的记录单位</strong>：<br>
日志文件的记录对象/单位有两种，分别为：记录、数据块</p>
<p><strong>一个事务登记到日志文件的内容</strong>：</p>
<ol>
<li>事务的开始标志（Begin Transaction）<br>
每个事务都有一条标志开始的日志记录</li>
<li>事务的结束标志（commit/rollback）</li>
<li>事务的所有修改操作<br>
每个事务有多个修改操作，但凡修改一个单位（记录或者数据块），就需要产生一条日志记录，记录下修改的单位编号，<strong>修改前的旧值、修改后的新值</strong></li>
</ol>
<p><strong>一条日志记录的数据结构（假设以记录为单位）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;一条</span><br><span class="line">日志</span><br><span class="line">记录&quot;] --&gt; 2[&quot;事务标识（事务编号）&quot;] &amp; 3[&quot;操作类型（事务开始、事务结束、添加、删除、更新）&quot;] &amp; 4[&quot;操作对象的标识(记录的内部编号)&quot;] &amp; 5[&quot;修改前的旧值，如果是插入操作则为空&quot;] &amp; 6[&quot;修改后的新值，如果是删除操作则为空&quot;]</span><br></pre></td></tr></table></figure>
<p>**日志文件的原则：</p>
<ol>
<li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li>
<li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li>
</ol>
<p><strong>事务提交</strong>：</p>
<ul>
<li>事务提交，意味着事务的所有操作（包括commit）都已经记录进入日志，并且日志也存入外存中</li>
</ul>
<h3 id="数据库恢复策略">数据库恢复策略</h3>
<p>数据库恢复的定义：<br>
在故障发生后，数据库从错误的不一致状态恢复到正确的一致性状态，就是数据库恢复</p>
<h4 id="数据库错误的情况">数据库错误的情况</h4>
<ol>
<li>已完成的事务（已经提交的事务）：修改未写入外存（即已经将所有修改记录写入日志，日志已经写入外存，但是真正对数据的修改还停留在缓存，没有写入外存，此时发生故障导致来不及作实际修改）</li>
<li>未完成的事务（未提交的事务，需要回滚）：修改写入了磁盘，但是事务还没有完成提交，此时发生故障来不及撤销</li>
</ol>
<h4 id="纠正数据库错误的策略">纠正数据库错误的策略</h4>
<ol>
<li>对于已完成的事务：事务中的所有操作重做（<strong>正向</strong>REDO，将新值写入磁盘）</li>
<li>对于未完成的事务：事务中所有的操作撤销（<strong>逆向</strong>UNDO，将旧值写入磁盘）</li>
</ol>
<h4 id="故障的类型以及恢复策略">故障的类型以及恢复策略</h4>
<p>一、事务故障<br>
<strong>定义</strong>：事务在运行至正常终止点前被终止<br>
比如溢出、除0操作、死锁等等<br>
<strong>性质</strong>：事务故障属于小型故障，影响范围仅限于一个事务，不会影响其他事务的正常运行。<br>
<strong>恢复方法</strong>：</p>
<ol>
<li>反向扫描日志文件，找到属于该事务的修改操作，不断执行撤销操作直到读到此事务的开始标记，则事务故障就恢复完成</li>
<li>撤销操作，将日志记录中的“修改前的值”写入磁盘</li>
<li>事务故障的恢复由==系统==自动完成，对==用户透明==</li>
</ol>
<p>二、系统故障<br>
<strong>定义</strong>：因某种原因，造成数据库管理系统（DBMS）停止运行<br>
比如硬件故障（cpu故障…），软件故障(os异常)，外部因素（停电…）</p>
<p><strong>性质</strong>：中型故障，DBMS故障会导致多个工作的事务被异常终止，系统需要重新启动；重启后，内存缓冲区中的数据丢失，但磁盘介质上数据依然完好</p>
<p><strong>系统故障造成数据库不一致状态的原因</strong>：</p>
<ul>
<li>未完成的事务对数据库的更新可能已经写入数据库</li>
<li>已提交的事务对数据库的更新可能还留在缓冲区没来得及写</li>
</ul>
<p><strong>恢复方法</strong>：<br>
DBMS在重新启动后自动完成，不需要用户的干预，对用户透明</p>
<ol>
<li>Undo故障发生时未完成的事务</li>
<li>Redo已经发生的事务</li>
</ol>
<p><strong>恢复步骤</strong>：</p>
<ol>
<li>正向扫描日志文件，找到已提交的事务（有begin transaction和commit），将其事务标志放入redo队列；<br>
找到未提交的事务（有begin transaction无commit）放入undo队列</li>
<li>反向扫描日志文件，找到找到属于撤销队列的事务的修改操作并执行撤销操作，即将修改前的旧值写入磁盘</li>
<li>正向扫描日志文件，找到属于重做队列中的事务的修改操作并执行重做操作，即将修改后的新值写入磁盘</li>
</ol>
<p><strong>小结恢复步骤</strong>：<br>
系统故障的恢复需要三次扫描日志文件<br>
第一次扫描建立undo和redo队列；<br>
第二次反向扫描日志文件，对需要undo的事件的修改操作进行undo操作；<br>
第三次正向扫描日志文件，对需要redo的事件的修改操作进行redo操作；</p>
<p>三、介质故障<br>
<strong>定义</strong>：因某种原因，磁盘上的物理数据部分或完全丢失<br>
<strong>原因</strong>：硬件损坏、计算机病毒、黑客…<br>
<strong>性质</strong>：属于大型故障，不仅DBMS中止，内存数据丢失，并且磁盘上的数据也会丢失和异常</p>
<p><strong>恢复方法</strong>：<br>
需要人工干预，需要数据库管理人员DBA来完成（唯一需要人工介入的故障）<br>
恢复过程：</p>
<ol>
<li>装入最近一次<strong>备份的数据库副本</strong>，即恢复数据库到最近的一次备份时的状态</li>
<li>装入备份后到故障发生时的<strong>日志文件或副本</strong>，然后把未提交的事务撤销，已提交的事务重做</li>
</ol>
<h4 id="检查点技术（不做要求）">检查点技术（不做要求）</h4>
<p><strong>传统数据库恢复的弊端</strong>：<br>
如果数据库系统运行了很长时间，产生了很长的日志文件。这时在恢复系统故障时，对整个日志文件的扫描，显然会花费非常长的时间。</p>
<p><strong>解决方法</strong>：<br>
DBMS在运行时，周期在日志文件中写入检查点(checkpoint)；<br>
对日志的扫描控制在大概 【最后一个检查点，文件末尾】这一段范围，效率大大提高了；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Icserm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">http://example.com/2024/06/17/课程内学习/【数据库系统】6.数据库事务管理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">nullptr</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/">课程学习</a></div><div class="post_share"><div class="social-share" data-image="/self_img/head_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/wechat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="期末复习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">期末复习</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/16/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%913.%20%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/" title="需求分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">需求分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/" title="操作系统概览"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-15</div><div class="title">操作系统概览</div></div></a></div><div><a href="/2024/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/" title="处理器管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-21</div><div class="title">处理器管理</div></div></a></div><div><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="内存管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">内存管理</div></div></a></div><div><a href="/2024/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="文件系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">文件系统</div></div></a></div><div><a href="/2024/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="设备管理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-29</div><div class="title">设备管理</div></div></a></div><div><a href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="基本概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-28</div><div class="title">基本概念</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/loading.gif" data-original="/self_img/head_img.jpg" onerror="this.onerror=null;this.src='/self_img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Icserm</div><div class="author-info__description">无为之心，做有为之事</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ICserD"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ICserD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2862081626@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_73546177" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数据库事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">事务的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%80%A7%E8%B4%A8%EF%BC%88ACID%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">事务的性质（ACID）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8B%E5%8A%A1%E5%9C%A8%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%98%AF%E5%90%A6%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">判断事务在事务调度过程中是否保持数据一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">事务的状态与操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">事务的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%8F%AF%E8%83%BD%E7%9A%84%E7%8A%B6%E6%80%81%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">执行一个事务可能的状态序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.4.</span> <span class="toc-text">SQL中的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">相关语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.5.</span> <span class="toc-text">事务调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%88%E7%9B%B8%E6%AF%94%E4%BA%8E%E4%B8%B2%E8%A1%8C%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">并发调度的优势（相比于串行调度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">并发调度存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E4%BA%A7%E7%94%9F%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">并发调度产生的错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">1.1.6.</span> <span class="toc-text">调度的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96-%E6%98%AF%E5%88%A4%E6%96%AD%E5%B9%B6%E5%8F%91%E8%B0%83%E5%BA%A6%E6%AD%A3%E7%A1%AE%E6%80%A7%E7%9A%84%E9%87%8D%E8%A6%81%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">可串行化(是判断并发调度正确性的重要原则)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%B0%83%E5%BA%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%86%B2%E7%AA%81%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%EF%BC%88%E5%88%A4%E5%AE%9A%E8%B0%83%E5%BA%A6%E6%AD%A3%E7%A1%AE%E6%80%A7%EF%BC%89"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">判定调度是否为冲突可串行化（判定调度正确性）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">可恢复调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BA%A7%E8%81%94%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">无级联调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">锁的粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">封锁协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.1.</span> <span class="toc-text">一级封锁协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.2.</span> <span class="toc-text">二级封锁协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.3.</span> <span class="toc-text">三级封锁协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.1.4.4.</span> <span class="toc-text">两段封锁协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E7%90%86%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.2.1.4.5.</span> <span class="toc-text">定理（重要）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.4.6.</span> <span class="toc-text">封锁协议小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E3%80%81%E6%AD%BB%E9%94%81%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E7%9A%84%E9%98%B2%E6%B2%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">活锁、死锁以及死锁的防治</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">活锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E7%9A%84%E9%98%B2%E6%B2%BB"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">活锁的防治</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%882%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">解决死锁问题（2类方法）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E7%BA%A7%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">SQL中的隔离性级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D"><span class="toc-number">1.3.</span> <span class="toc-text">数据库恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">恢复实现的技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">数据备份</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%A4%87%E4%BB%BD%E5%92%8C%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD"><span class="toc-number">1.3.1.1.1.</span> <span class="toc-text">完全备份和增量备份</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">日志文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">数据库恢复策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">数据库错误的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A0%E6%AD%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">纠正数据库错误的策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E6%81%A2%E5%A4%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">故障的类型以及恢复策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%8D%E5%81%9A%E8%A6%81%E6%B1%82%EF%BC%89"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">检查点技术（不做要求）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/09/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E3%80%912.%20%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/" title="文献检索方法">文献检索方法</a><time datetime="2024-09-08T16:00:00.000Z" title="发表于 2024-09-09 00:00:00">2024-09-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/" title="结构化设计方法">结构化设计方法</a><time datetime="2024-08-23T16:00:00.000Z" title="发表于 2024-08-24 00:00:00">2024-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/" title="期末考点整理">期末考点整理</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" title="期末复习">期末复习</a><time datetime="2024-06-29T00:00:00.000Z" title="发表于 2024-06-29 08:00:00">2024-06-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/" title="数据库事务管理">数据库事务管理</a><time datetime="2024-06-17T00:00:00.000Z" title="发表于 2024-06-17 08:00:00">2024-06-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/self_img/11c.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Icserm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>