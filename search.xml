<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>0 基础配置 Python 环境</title>
      <link href="/2025/11/08/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91%E9%85%8D%E7%BD%AE%20python%20%E7%8E%AF%E5%A2%83/"/>
      <url>/2025/11/08/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91%E9%85%8D%E7%BD%AE%20python%20%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1>0 基础 Python 环境配置</h1><blockquote><p>本文介绍在 Winodows 环境下 0 基础如何配置 python 环境</p></blockquote><h2 id="1-概要">1. 概要</h2><p>本文推荐方案：VsCode + python3 + 配置环境变量</p><ul><li>VsCode：用于写代码</li><li>python3：真正执行代码的解析器</li><li>配置环境变量：让自己的系统能够找到 python3 解析器去解析自己写的代码</li></ul><h2 id="2-第一步：安装-VsCode">2. 第一步：安装 VsCode</h2><p>官网下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p><p>选择适合自己电脑系统的进行下载，比如 windows 系统就应该下载下面这个：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20251108144819414.png" alt="image-20251108144819414"></p><p>下载后得到 exe 文件，双击即可进入安装流程，后面就不详细介绍了，网上有很多保姆级教程。</p><p>可以参考这个博客：<a href="https://blog.csdn.net/qq_30640671/article/details/109704940">https://blog.csdn.net/qq_30640671/article/details/109704940</a></p><h2 id="3-第二步：安装-python3">3. 第二步：安装 python3</h2><p>推荐 python3.8.10，当然选择什么版本可以由读者自由选择，其实都可以。</p><p>官网下载地址：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p><p>选择自己对应的版本进行下载，对于 windows 一般是下载 windows installer(64 bit)，2025 年了应该没人用 32 位机吧…</p><p>参考博客（第二步）：<a href="https://blog.csdn.net/m0_37758063/article/details/128615786">https://blog.csdn.net/m0_37758063/article/details/128615786</a></p><p><strong>注意</strong>：</p><ol><li>强烈推荐勾选 add python to path ！省的自己配环境变量，这一步就会把 python 以及 pip 的环境变量都配好</li><li>记住自己安装 python 的路径，后面无论是配置 VsCode 还是手动配置环境变量都要用到</li></ol><h3 id="3-1-检查是否配好环境变量">3.1. 检查是否配好环境变量</h3><p>打开 cmd 输入下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>如果输出 python 的版本，则表示环境变量配置成功。</p><p>还需要检查一下 pip 是否安装好，理论上 python3.4 以上的都会在安装 python 之后顺便把 pip 也装好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --version</span><br></pre></td></tr></table></figure><h2 id="4-第三步：配置环境变量">4. 第三步：配置环境变量</h2><p>参考博客：<a href="https://blog.csdn.net/qq_40584683/article/details/126954120">https://blog.csdn.net/qq_40584683/article/details/126954120</a></p><h2 id="5-第四步：安装-VsCode-扩展">5. 第四步：安装 VsCode 扩展</h2><h3 id="5-1-安装-Python-扩展">5.1 安装 Python 扩展</h3><p>参考这个博客的第三步：<a href="https://blog.csdn.net/m0_37758063/article/details/128615786">https://blog.csdn.net/m0_37758063/article/details/128615786</a></p><h3 id="5-2-安装-Jupyter-扩展（可选）">5.2 安装 Jupyter 扩展（可选）</h3><blockquote><p>我一般用 python 都是写脚本的，一个脚本开一个文件实在是有点麻烦，所以 Jupyter 是个很好的选择！</p></blockquote><p>参考这个博客：<a href="https://blog.csdn.net/weixin_51633501/article/details/137683959">https://blog.csdn.net/weixin_51633501/article/details/137683959</a></p><h2 id="6-第五步：愉快使用">6. 第五步：愉快使用</h2><p>完成上述步骤后，打开 vscode，新建一个 .py 或者 .ipynb 文件，写上你的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, Word!&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】4. 深度学习计算</title>
      <link href="/2024/11/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%914.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/"/>
      <url>/2024/11/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%914.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1>深度学习计算</h1><blockquote><p>本章学习利用深度学习组件构建模型、参数访问与初始化、设计自定义层和块、将模型读写到磁盘，利用GPU实现显著的加速。</p></blockquote><h2 id="构建模型">构建模型</h2><blockquote><p>要求掌握基本的模型的概念并能构建自定义的基础的块/模型</p></blockquote><h3 id="基础概念">基础概念</h3><p><strong>层</strong></p><ul><li>接受一组<strong>输入</strong></li><li>生成一组<strong>输出</strong></li><li>具有一组相关的<strong>参数</strong></li></ul><p><strong>块</strong></p><ul><li>由1个或多个层构成的“层组”</li></ul><blockquote><p>这里我对“模型”有了更抽象的理解，模型可以是一层，比如神经网络的全连接层，也可以是多个层的组合，也就是块，这是一个嵌套的概念。</p><p>模型、层、块是相对的，同一个体系中：模型&gt;块&gt;层</p></blockquote><h3 id="构建块">构建块</h3><blockquote><p>补充知识：</p><p>torch中的nn.linear是全连接层网络，实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>w</mi><mi>T</mi></msup><mi>X</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = w^TX + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9247em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>的线性变换，其中w是权重参数，b是偏置项，y是输出张量。</p><p>通常pytorch会自动初始化权重和偏置参数，我们只需要传递X即可，注意<strong>维度要匹配</strong>。</p><p><strong>维度匹配问题：</strong></p><ul><li>self.out = nn.linear(20, 256)表示接受20维的向量，输出1*256维的向量</li><li>所以self.out(X)，其中X的维度必须是20，若X.shpe是(5, 20)，表示有5个向量，每个向量维度20，可以成功运行</li></ul></blockquote><p>块由类表示，它的任何子类都必须定义一个将其输入转化为输出的前向传播函数，并且必须存储相应的参数。为了计算梯度，块必须有反向传播函数。</p><p><strong>块的构成要素：</strong></p><ul><li>将输入数据作为其前向传播函数的参数</li><li>通过前向传播函数来生成输出</li><li>计算其输出关于输入的梯度，可以通过其反向传播函数进行访问</li><li>存储和访问前向传播计算所需要的参数</li><li>根据需要初始化参数</li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module)&#123;</span><br><span class="line">    <span class="comment"># 模型参数声明</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.hidden = nn.linear(<span class="number">20</span>, <span class="number">256</span>)</span><br><span class="line">    self.out = nn.linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">    <span class="keyword">return</span> self.out(F.relu(self.hidden(X)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建层">构建层</h3><p>神经网络的灵活性很大程度上在于层的灵活性，我们可以自己设计不同的层，适用于完成各种任务，比如设计一些专门用于处理图像的层、设计一些专门用于处理文本的层等等。</p><p>下面用两个例子介绍如何构建层，以及在什么需求背景下构建层。</p><h4 id="构造不带参数的层"><strong>构造不带参数的层</strong></h4><p>需求：从输入中减去均值，目的是使得输入数据的均值为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CenteredLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> X - X.mean()</span><br></pre></td></tr></table></figure><h4 id="构造带参数的层">构造带参数的层</h4><p>需求：手撕Linear，并将Relu激活层加进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinear</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_units, units</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.randn(in_units, units)) <span class="comment"># 权重</span></span><br><span class="line">        self.bias = nn.Parameter(torch.rand(units,)) <span class="comment"># 偏置参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        linear = torch.matmul(X, self.weight.data) + self.bias.data</span><br><span class="line">        <span class="keyword">return</span> F.relu(linear) <span class="comment"># relu激活</span></span><br></pre></td></tr></table></figure><h2 id="参数管理">参数管理</h2><blockquote><ul><li>访问参数，用于调试、诊断和可视化</li><li>参数初始化</li><li>在不同模型组件共享参数</li></ul></blockquote><h3 id="参数访问">参数访问</h3><h4 id="通过state-dict访问参数">通过state_dict访问参数</h4><p>通过nn.Modeule类的state_dict()属性可以访问模型的参数，类型是Dict，特别的，对于Sequential模型是OrderedDict。</p><p>下面是关于state_dict的常见用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先定义一个模型</span></span><br><span class="line">net = nn.Sequential(nn.linear(<span class="number">4</span>,<span class="number">8</span>), nn.Relu(), nn.linear(<span class="number">8</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数访问</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].state_dict())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问目标参数</span></span><br><span class="line"><span class="comment"># Sequential的模型通常有两个参数: weight, bias，可以通过参数访问检验</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(net[<span class="number">2</span>].bias))</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias.data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以访问该参数的梯度</span></span><br><span class="line">net[<span class="number">2</span>].weight.grad <span class="comment"># 如果还没有计算过，则为None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次性访问有所参数(递归访问)</span></span><br><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net[<span class="number">0</span>].named_parameters()])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="通过模型层次来访问参数">通过模型层次来访问参数</h4><p>如果我们的模型稍微复杂，多个块嵌套，我们可以先查看模型的结构，根据模型的结构索引对应的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">block1</span>():</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(nn.linear(<span class="number">4</span>, <span class="number">8</span>), nn.Relu(), nn.linear(<span class="number">8</span>, <span class="number">4</span>), nn.Relu())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">block2</span>():</span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        net.add_model(<span class="string">f&#x27;block<span class="subst">&#123;i&#125;</span>&#x27;</span>, block1())</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">rgnet = nn.Sequential(block2(), nn.linear(<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line">rgnet(X)</span><br></pre></td></tr></table></figure><p>然后我们打印模型，查看层次，可以看到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rgnet)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (0): Sequential(</span><br><span class="line">    (block 0): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 1): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 2): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 3): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (1): Linear(in_features=4, out_features=1, bias=True)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据层次访问参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgnet[0][1][0].bias.data</span><br></pre></td></tr></table></figure><h3 id="参数初始化">参数初始化</h3><p>我们可以定义一个函数进行权重初始化，该函数接受一个网络层，不需要返回值。然后通过model的apply函数可以将该函数应用在对应层或者所有层的参数初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个自定义的参数初始化层, nn.init.uniform_是用于将参数初始化为均匀分布的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.linear:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init&quot;</span>, *[(name, param.shape) <span class="keyword">in</span> m.named_parameters()][<span class="number">0</span>])</span><br><span class="line">        nn.init.uniform_(m.weight, -<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部层应用该初始化</span></span><br><span class="line">net.apply(my_init)</span><br><span class="line"><span class="comment"># 第0层应用该初始化</span></span><br><span class="line">net[<span class="number">0</span>].apply(my_init)</span><br></pre></td></tr></table></figure><h3 id="参数绑定">参数绑定</h3><p>有时我们希望在多个层共享参数，我们可以定义一个稠密层，然后使用它的参数来设计另一个层的参数。</p><p>下面的例子中：</p><ul><li>神经网络第三层和第五层共享参数：即参数是一样的（可以理解为C++的引用，别名）</li><li>带来的影响：在第三层反向传播的时候，第五层的梯度和第三层的梯度会加在一起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们需要给共享层一个名称，以便可以引用它的参数</span></span><br><span class="line">shared = nn.linear(<span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">net = nn.Sequential(nn.linear(<span class="number">4</span>, <span class="number">8</span>), nn.Relu(), shared, nn.Relu(), shared, nn.linear(<span class="number">8</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><h3 id="延迟初始化">延迟初始化</h3><p>在构建模型时，我们都要慎重考虑以下的问题：</p><ul><li>定义了网络架构，输入维度是什么？</li><li>添加层的时候，前一层的输出维度是什么？</li><li>在初始化参数时，应该用什么维度的数据？</li></ul><p>各层的参数维度是我们在设计块/模型的时候不可避免的问题，并且对模型的正常训练起着关键作用，设置不当分分钟报错！</p><p>框架为了简化我们的模型设计，提供了<strong>延后初始化</strong>机制，即当数据第一次通过模型的时候，框架才会动态地判断每个层的大小。（pytorch中LazyModule机制）</p><p>优点：</p><ul><li>无需知道维度就可以设计参数</li><li>简化模型定义和模型修改</li><li>节省内存，省去无用的初始化</li></ul><p><strong>示例代码</strong></p><blockquote><p>如果需要延后初始化其他模型，调用nn.Lazy[Model]就行，其中Model是模型名称，比如nn.LazyConv2d(16, kernel_size = 3)，就定义了一个延后初始化的卷积神经网络层</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的代码会在第一次调用forward的时候确定线性模型的输入维度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LazyExampleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LazyExampleModel, self).__init__()</span><br><span class="line">        self.out = nn.LazyLinear(<span class="number">10</span>) <span class="comment"># 输出维度为10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> self.out(X)</span><br></pre></td></tr></table></figure><h2 id="模型持久化存储">模型持久化存储</h2><blockquote><p>有时模型的训练需要耗费非常多的时间，如果训练过程中断电或者出现其他意外，损失惨重。</p><p>所以我们需要有一种方法将模型参数存储起来。</p></blockquote><p>模型本身是代码架构和数据的集合，代码序列化存储比较麻烦和难以阅读，但是数据序列化可以很好地存储。</p><p>所以我们对模型的持久化存储，就是将模型的参数和模型的运行架构（各个层次设计）存储起来。</p><p>torch提供了save和load函数，方便我们进行模型的持久化存储。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以多层次感知机为例，进行模型的参数保存和加在</span></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>():</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.hidden = nn.linear(<span class="number">20</span>, <span class="number">256</span>)</span><br><span class="line">        self.out = nn.linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> self.output(F.relu(self.hidden(X)))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 模型初始化</span></span><br><span class="line">net = MLP()</span><br><span class="line">X = torch.randn(size=(<span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line">Y = net(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型保存</span></span><br><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;mlp.params&#x27;</span>) <span class="comment"># 将模型结构和参数保存在mlp.params文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型加载</span></span><br><span class="line">clone = MLP()</span><br><span class="line">clone.load_state_dict(torch.load(<span class="string">&#x27;mlp.params&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模型</span></span><br><span class="line">clone.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><h2 id="集群训练">集群训练</h2><h3 id="计算设备">计算设备</h3><p>在pytorch中，每个数组都有一个设备，我们通常称其为环境（context），默认情况下，所有变量和相关的计算都分配给CPU或GPU。</p><p>当我们跨多个服务器部署作业时，torch能够智能地将数组分配给<strong>环境</strong>，我们可以最大程度地减少在设备之间传输数据的时间。</p><h4 id="张量与设备">张量与设备</h4><p>下面通过代码演示：</p><ul><li>在pytorch中如何查看设备（CPU和GPU以及其数量）</li><li>张量目前处于什么设备</li><li>如何将张量放在其他设备</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看设备</span></span><br><span class="line">torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的gpu数量</span></span><br><span class="line">torch.cuda.device_count()</span><br></pre></td></tr></table></figure><p><strong>将张量放在其他设备：</strong></p><ul><li>创建时在GPU创建</li><li>复制</li></ul><p>详细解释一下复制的机制和注意事项，如下图，X在gpu0设备上，Z和Y在gpu1设备上。</p><p>如果想计算X+Y，不能直接相加，因为他们处于不同的环境，系统会报错（在一个环境找不到所有的数据资源）</p><p>我们的方法是将gpu0上的X复制到gpu1上的Z上，然后再X+Y。</p><p><img src="assets/image-20241128111736620.png" alt="image-20241128111736620"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 张量与设备</span></span><br><span class="line">X = torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">X.device <span class="comment"># 查看张量在哪里创建, 默认是CPU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在GPU上存储张量</span></span><br><span class="line"><span class="comment"># 方法一：创建张量时存储在GPU上</span></span><br><span class="line">X = torch.ones(<span class="number">2</span>, <span class="number">3</span>, torch.device(<span class="string">&#x27;cuda&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：复制</span></span><br><span class="line">Z = X.cuda(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输出可以看到他们的device信息</span></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br><span class="line"></span><br><span class="line">Y+Z</span><br></pre></td></tr></table></figure><h4 id="模型与设备">模型与设备</h4><p>类似地，神经网络模型也可以指定设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.linear(<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">net = net.to(device=torch.device(<span class="string">&#x27;cuda&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】5. 卷积神经网络（CNN）</title>
      <link href="/2024/10/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%915.%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/10/18/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%915.%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>卷积神经网络（CNN）</h1><h2 id="前言和背景">前言和背景</h2><h3 id="CNN基本介绍">CNN基本介绍</h3><p>卷积神经网络（convolutional neural network, cnn）是一类强大的、为处理图像数据而设计的神经网络。</p><p>卷积神经网络需要的参数少于全连接架构的网络，并且十分容易使用GPU进行并行计算，具有高效率和高精确的优点。</p><p>同时，卷积的思想在序列结构任务、图结构数据和推荐系统中也发挥作用。</p><h3 id="CNN的设计背景思想">CNN的设计背景思想</h3><p>假设我们的任务是图像实体识别，那么在图像中，实体应该与其在图像中的位置无关。</p><p>我们在图像中寻找实体时，是在局部进行识别，而较少地考虑全局。</p><p>CNN设计神经网络架构的思想：</p><ol><li>平移不变性（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面基层应该<strong>对相同的图像区域具有相似的反应</strong>——卷积核就是识别器</li><li>局部性（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不是过度在意图像中相隔较远的区域的关系——利用卷积核计算只计算图片的局部数据</li></ol><h4 id="卷积本质上就是利用了数据空间结构的全连接"><strong>卷积本质上就是利用了数据空间结构的全连接</strong></h4><p><strong>传统全连接操作</strong></p><p>回顾传统全连接层的计算：</p><ul><li>Y是输出张量</li><li>W是权重矩阵</li><li>X是输入张量</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>X</mi><msup><mi>W</mi><mi>T</mi></msup><mo>+</mo><mi>B</mi><mspace linebreak="newline"></mspace><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><msub><mi>X</mi><mi>i</mi></msub><msub><mi>W</mi><mi>j</mi></msub><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">Y = XW^T + B \\y_i = X_iW_j + B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span></p><p>把矩阵计算等价转换成累加求和计算：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><mo>∑</mo><msub><mi>x</mi><mi>i</mi></msub><msub><mi>W</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>b</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_j = \sum x_iW_{i, j} + b_{i, j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><strong>卷积操作</strong></p><p>对于卷积操作，处理的是多维数据而不是一维数据，所以我们以2维数据为例进行公式推导。输入是图像数据矩阵X（维度是高、宽），而不是向量，输出也是矩阵H，此时权重参数就是四维的权重矩阵（接受二维矩阵，输出二维矩阵），其中U是偏置项。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mrow><mo fence="true">[</mo><mi mathvariant="bold">H</mi><mo fence="true">]</mo></mrow><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">[</mo><mi mathvariant="bold">U</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><munder><mo>∑</mo><mi>k</mi></munder><munder><mo>∑</mo><mi>l</mi></munder><mo stretchy="false">[</mo><mi mathvariant="sans-serif">W</mi><msub><mo stretchy="false">]</mo><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub><mo stretchy="false">[</mo><mi mathvariant="bold">X</mi><msub><mo stretchy="false">]</mo><mrow><mi>k</mi><mo separator="true">,</mo><mi>l</mi></mrow></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \left[\mathbf{H}\right]_{i, j} &amp;= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.6521em;vertical-align:-1.0761em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5761em;"><span style="top:-3.5761em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">[</span><span class="mord mathbf">H</span><span class="mclose delimcenter" style="top:0em;">]</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0761em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5761em;"><span style="top:-3.5761em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">[</span><span class="mord mathbf">U</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathsf" style="margin-right:0.01389em;">W</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathbf">X</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0761em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="图像卷积">图像卷积</h2><p>图像一般是三维数据（宽、高、通道），我们这里只考虑二维（宽、高）进行演示图像卷积的操作。</p><p>具体计算过程比较简单。</p><p><img src="assets/image-20241128231531613.png" alt="image-20241128231531613"></p><p>这里我们注意输入数据到输出数据的维度变化，这是与卷积核有关的。其实这也对应于全连接层的输入、隐藏层、输出的关系。</p><p>假设输入数据是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>×</mo><msub><mi>n</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_h\times n_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，输出数据是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k_h\times k_w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，那么有输出数据的维度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>h</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n_h-k_h + 1)\times (h_w-k_w+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h3 id="手动实现一个2维卷积">手动实现一个2维卷积</h3><p>实现卷积操作函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">form torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X, K</span>):</span><br><span class="line">    kh, kw = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - K.shape[<span class="number">0</span>] + <span class="number">1</span>, X.shape[<span class="number">1</span>] - K.shape[<span class="number">1</span>] + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i+kh, j:j+kw]*K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><p>实现卷积层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(X, self.weight) + self.bias</span><br></pre></td></tr></table></figure><h3 id="特征映射和感受野的概念">特征映射和感受野的概念</h3><p>卷积层的输出有时被称为特征映射，因为它可以被视为从一个输入到下一层的空间维度的转换器。</p><p>在卷积神经网络中，对于某一层的任意元素x，其感受野是指在前向传播期间可能影响x计算的所有原先层的元素。</p><p>比如下面的计算中，19是由原先层的4个元素求出来的，它的感受野就是这四个元素。</p><ul><li>感受野的大小可能和卷积核相同</li><li>但是感受野指的是被卷积核覆盖进行计算的那部分元素</li></ul><p><img src="assets/image-20241128231531613.png" alt="image-20241128231531613"></p><h2 id="填充和步幅">填充和步幅</h2><h3 id="填充">填充</h3><p>我们可以发现，如果我们使用卷积核对原始的输入数据进行卷积计算，我们总会丢失几个像素，当我们的神经网络层次深起来的时候，累积丢失的像素就多了。</p><p>为了解决这个问题，我们对原始的图像数据的四周进行填充。一般我们填充为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>h</mi></msub><mo>=</mo><msub><mi>k</mi><mi>h</mi></msub><mo>−</mo><mn>1</mn><mtext>、</mtext><msub><mi>p</mi><mi>w</mi></msub><mo>=</mo><msub><mi>k</mi><mi>w</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_h = k_h-1、p_w = k_w-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><p>这样我们输入X(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">n_h, n_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)后，输出的Y的维度与原始的X一致，也就是卷积运算之后，图像不会缩小。</p><h3 id="步幅">步幅</h3><blockquote><p>当我们使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>的卷积核，对一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>224</mn><mo>×</mo><mn>224</mn></mrow><annotation encoding="application/x-tex">224\times 224</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">224</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">224</span></span></span></span>的图像数据，我们需要44层卷积网络才能得到一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">4\times 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>的输出，这样太耗费计算机资源。我们有没有可能有一种方法能快速将图像的输出维度减小呢？</p></blockquote><p>每次卷积运算时，我们卷积核移动的幅度就是步幅。前面的例子中我们都是以步幅为1进行移动的，但是这样会导致需要很多的计算。当我们增大步幅时，可以快速计算，并且得到的输出维度会减小。</p><p>通常，当垂直步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">s_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，水平步幅为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">s_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，输出形状为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><msub><mi>p</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>h</mi></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>n</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><msub><mi>p</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><msub><mi>s</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">(n_h - k_h + p_h + 1)/s_h , (n_w - k_w + p_w + 1)/s_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><h2 id="多输入输出通道">多输入输出通道</h2><h3 id="多输入通道">多输入通道</h3><p>以图像数据为例，图像数据实际上有三个维度：高、宽、通道</p><p>其中第三个维度通道我们称之为通道维度。</p><p>当输入包含多个通道时，需要<strong>构造具有相同数量</strong>的卷积核。</p><p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是输入通道数，卷积核窗口的形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>k</mi><mi>h</mi></msub><mtext>、</mtext><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">k_h、k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么在多输入通道单输出通道的情况下，卷积核的形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_i\times k_h \times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><img src="assets/image-20241129093659663.png" alt="image-20241129093659663"></p><h3 id="多输出通道">多输出通道</h3><p>有多个输入通道的时候，一般地我们也设置多个输出通道，因为每个通道的对应的卷积核就是一个识别器，但是<strong>我们无论有多少个卷积核，输出的只能是单通道的数据。</strong></p><p>为了能够学习到多个通道的识别器，我们一般会在输出的时候设置多个通道。</p><p>假设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别是输入通道数和输出通道数，那么我们的卷积核形状应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>0</mn></msub><mo>×</mo><msub><mi>c</mi><mi>i</mi></msub><mo>×</mo><msub><mi>k</mi><mi>h</mi></msub><mo>×</mo><msub><mi>k</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">c_0\times c_i \times k_h \times k_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0315em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><h3 id="1-times-1卷积层"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层就是卷积核形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的卷积层，此时卷积核的作用相当于传统的全连接层。</p><p>卷积的本质是有效提取相邻像素间的相关特征，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层不能提取到相关像素的特征。尽管如此，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积核依然十分受欢迎，经常包含在复杂深层的网络的设计中。</p><h4 id="1-times-1卷积层的作用"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层的作用</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层的作用发生在通道上，设计这样的卷积层可以学习到多通道融合的特征。</p><p>如下图，一个3输入，2输出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积层，将3通道的输入数据输出为宽高相同的2通道数据。</p><p>输出中每个元素都是输入图像中同一位置不同通道的线性组合！</p><p><img src="assets/image-20241129095229240.png" alt="image-20241129095229240"></p><h3 id="代码实现">代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个卷积层, 输入通道和输出通道都为1，卷积核为3*3, 填充为上下1, 步幅为上下2</span></span><br><span class="line">con2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size = <span class="number">3</span>, padding = <span class="number">1</span>, stride = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当卷积核的高宽不同时</span></span><br><span class="line">con2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size = (<span class="number">3</span>, <span class="number">5</span>), padding = (<span class="number">2</span>, <span class="number">4</span>), stride = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="池化层（pooling）">池化层（pooling）</h2><blockquote><p>问题背景：</p><ul><li>当网络层次深入后，每个神经元的感受野越大，我们最后一层的神经元通常对整个输入数据敏感，即感受野是整个图像</li><li>但是这样会导致最后一层对于数据过于敏感，导致在检测时，如果图像是扭曲或者其他微变形就会降低准确率</li><li>为了降低卷积层对位置的敏感性，同时降低对空间采样表示的敏感性，我们在最后一层加上一个池化层</li></ul></blockquote><h3 id="最大池化层和平均池化层">最大池化层和平均池化层</h3><p>池化层和卷积层类似，也是由一个固定形状的窗口组成，但是该窗口的计算通常有两种：取窗口内元素的平均值或取窗口内元素的最大值。</p><p>注意：</p><ul><li>池化层没有参数，不学习任何参数</li></ul><p>假设池化层的窗口形状为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p\times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，则称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>×</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \times q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>池化层。</p><h3 id="池化层的调整">池化层的调整</h3><p><strong>默认情况下，深度学习框架中的步幅与池化层窗口的大小相同</strong></p><ul><li>填充，池化层也可以改变输出形状，对输入进行填充即可</li><li>步幅，池化层也能控制窗口移动的幅度</li></ul><h2 id="LeNet">LeNet</h2><p>LeNet是最早发布的卷积神经网络之一（1989年），最早用于手写数字识别（MINIST数据集）</p><p>总体来看，LeNet由两部分组成：</p><ul><li>卷积编码器：由两个卷积层组成</li><li>全连接层密集块：由三个全连接层组成</li></ul><p><img src="assets/image-20241129103958977.png" alt="image-20241129103958977"></p><h2 id="现代卷积神经网络">现代卷积神经网络</h2><ul><li>重点关注<strong>ResNet</strong>及其实现，其他网络理解其产生的背景和创新点即可。</li><li>重点理解批量归一化</li></ul><h3 id="AlexNet">AlexNet</h3><p>2012年，AlexNet出现，其最有价值的思想就是认为特征也是机器学习的一部分，并且学习到的特征可以优于手工设计的特征！</p><h4 id="特点">特点</h4><ul><li><strong>模型设计</strong>：AlexNet的模型设计和LeNet框架类似，激活函数采用了Relu避免梯度消失，可以构建更深更大的网络。</li><li>**数据扩充：**对原始数据进行扩充、增强（比如图像翻转、裁剪、变色），更大的样本和差异化数据有效地减小了过拟合</li><li><strong>使用DropOut控制模型复杂度</strong>：通过暂退法控制全连接层的复杂度</li></ul><h3 id="VGG">VGG</h3><p>AlexNet效果虽然好，但是其模型为什么这样设计的解释性不强，对后面的人设计模型结构并没有什么很好的启发。</p><p>VGG将卷积层抽象出来，通过对卷积层的组合，最后再加上用于空间下采样的池化层组成一个块，称为VGG块。然后用VGG块以及不同的VGG块设计模型。</p><p><img src="assets/image-20241129165308941.png" alt="image-20241129165308941"></p><h3 id="NiN">NiN</h3><p>痛点：前面的神经网络在最后通过全连接层输出，需要的参数量是比较大的</p><p>NiN：在最后一层输出上，使用一个特殊的平均池化层，对不同通道的元素进行平均最后作为输出，这样既可以学习到多个特征，又能有效减少参数数量。</p><p><img src="assets/image-20241129165948142.png" alt="image-20241129165948142"></p><h3 id="GoogLeNet">GoogLeNet</h3><blockquote><p>kernel应该设计成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3\times 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5</span></span></span></span>还是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>11</mn><mo>×</mo><mn>11</mn></mrow><annotation encoding="application/x-tex">11\times 11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">11</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">11</span></span></span></span>，什么样的卷积核大小合适？GoogLeNet的都要。</p></blockquote><p>在GoogLeNet中，基本的卷积块称为Inception块：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1\times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>卷积块用于调整通道数</li><li>不同大小的卷积核用于从不同空间大小中提取信息</li></ul><p><img src="assets/image-20241129170928093.png" alt="image-20241129170928093"></p><p>一般地，通道数的分配如下：</p><ul><li>第一个输入通道到输出通道需要增加通道数</li><li>第一条路分配1/4的通道数</li><li>第二条路分配1/2</li><li>第三条和第四条分配1/8</li></ul><p>这样的设计是研究者通过大量的实验得出来的。（可能是网络搜索）</p><h3 id="批量规范化">批量规范化</h3><p>为什么要使用批量规范化？</p><ul><li>数据预处理会对最终结果产生巨大影响，我们在设计模型、训练模型的一开始，就必须先对数据进行预处理</li><li>对于多层次的神经网络，数据从输入端到输出端，经历多次复杂的线性、非线性变换</li><li>这样的设计导致可能每一层的输入数据与输出数据在分布上就出现了变化，批量规范化的初衷是减少内部协变量偏移</li></ul><h4 id="原理">原理</h4><p>在每次训练迭代中，首先规范化（减去均值并除以标准差）输入，然后设置比例系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>和比例偏移<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>（注意这两个参数是可以学习的参数），再进行后续操作。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">N</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold-italic">γ</mi><mo>⊙</mo><mfrac><mrow><mi mathvariant="bold">x</mi><mo>−</mo><msub><mover accent="true"><mi mathvariant="bold-italic">μ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mrow><msub><mover accent="true"><mi mathvariant="bold-italic">σ</mi><mo>^</mo></mover><mi mathvariant="script">B</mi></msub></mfrac><mo>+</mo><mi mathvariant="bold-italic">β</mi></mrow><annotation encoding="application/x-tex">\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">BN</span></span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.06389em;">γ</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.2209em;vertical-align:-0.836em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3849em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03704em;">σ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol">μ</span></span></span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2342em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.836em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.03403em;">β</span></span></span></span></span></span></span></p><p>注意：</p><ul><li>批量大小不能设置成1，如果设置成1，则隐藏单元变成0</li><li>在全连接层和卷积层的批量规范化方法有些许不同：<ul><li>在全连接层：我们通常将批量规范化层放在仿射变换和激活函数之间，所以直接对输入的元素进行BN规范化即可（规范化涉及到方差和平均值，这里计算方差和平均值计算的就是全部的输入元素）</li><li>在卷积层：通常也是将规范化层放在卷积层与激活函数之间，但是当卷积层有多个通道时，我们的方差和平均值的计算就需要格外注意，我们需要分别计算每个通道的平均值和方差</li></ul></li></ul><h3 id="ResNet">ResNet</h3><p>前面提到的网络都难以做到深层次的网络模型，其很大一个原因是梯度消失。</p><p>在网络变深后，高层次的参数的梯度变化较大，可以较快地收敛，所以很快可以到达一个较小的梯度值；</p><p>但是底层的参数是通过梯度反向传播来更新的，由于高层次的参数收敛比底层快很多，所以当梯度反向传播到底层的时候，即使在底层的网络梯度很大，但是由于反向传播的链式乘法，导致高层次的已经收敛的较小的梯度与底层网络的梯度想乘，导致底层收敛很慢。</p><p>一旦网络层次变得很深，就可能出现梯度消失，或者学习到不稳定的特征。</p><p>ResNet通过残差块有效地解决了这个问题。</p><h4 id="ResNet的核心思想">ResNet的核心思想</h4><ol><li>新加入的层，使得模型训练后的效果至少要比不加入的好<ul><li>解决了模型层次加深后，学习不稳定、学习方向偏移的问题</li></ul></li><li>要同时保留新加入的层和不加入的层给到模型进行学习，让模型学习到是否要加入这个层以及什么程度下加入这个层</li></ol><p><img src="assets/image-20241129181322783.png" alt="image-20241129181322783"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】3. 多层次感知机</title>
      <link href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%913.%20%E5%A4%9A%E5%B1%82%E6%AC%A1%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%913.%20%E5%A4%9A%E5%B1%82%E6%AC%A1%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>多层次感知机</h1><h2 id="激活函数">激活函数</h2><p>在多层网络中，我们除了要对每一层的输入进行仿射变换，还需要对每个隐藏单元应用非线性激活函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>，激活函数的输出值称为活性值。</p><h3 id="ReLU函数">ReLU函数</h3><blockquote><p>ReLU函数目前应用广泛而基础，得益于其简单的原理和出色的表现</p><p>ReLU，即非正线性单元（Rectified linear uint）</p></blockquote><p>ReLU提供了一种非常简单的线性变换，给定元素x，ReLU函数如下：</p><ul><li>ReLU要么求需要输入神经元的数据x求导表现好，要么现在消失让参数通过</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ReLU(x) = max(x,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10903em;">LU</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><h2 id="模型选择、欠拟合、过拟合">模型选择、欠拟合、过拟合</h2><h3 id="训练误差和泛化误差">训练误差和泛化误差</h3><ul><li>训练误差：模型在训练集上计算得到的误差<br>如果不能降低训练误差，意味着模型表达能力不足，无法捕获试图学习的模式，也称为欠拟合</li><li>泛化误差：模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望<br>如果训练误差明显小于验证误差，这时可能出现了过拟合问题</li></ul><p>《动手学深度学习》中，监督学习部分的前提假设：训练数据和测试数据都是从相同分布中独立提取出来的，即独立同分布假设。</p><p>几个可能影响模型泛化的因素：</p><ol><li>可调整参数的数量</li><li>参数采用的值</li><li>训练样本的数量</li></ol><h3 id="模型选择">模型选择</h3><p>在机器学习中，通常在评估几个候选模型后选择最终的模型，这个过程叫做模型选择。</p><p>**验证集：**由于我们在训练过程中可能会过拟合训练数据和测试数据，所以我们要对原始数据分为三份，分别是：训练数据、测试数据、验证数据。我们可以在验证数据集上评估模型的泛化能力。</p><p>**K折交叉验证：**当训练数据稀缺时，我们甚至无法提供足够的数据来构建一个合适的验证集，这时我们可以使用K折交叉验证。</p><ul><li>原始训练数据被分为K个不重叠的子集</li><li>执行K次模型训练和验证，每次在K-1个自己上进行训练，并在剩余的一个子集（在该轮中没有训练的子集）上进行验证</li><li>最后通过对K次实验的结果取平均来估计训练和验证误差</li></ul><p>**过于复杂模型的弊端：**相对数据集过于复杂的模型可能会学习到噪点数据，受到噪点数据影响较大，从而导致过拟合。</p><h3 id="正则化技术">正则化技术</h3><h4 id="权重衰退">权重衰退</h4><p>当面临小数据集时，我们使用高维复杂模型往往会过拟合，我们需要将模型“简单化”，这时我们可以选择丢弃一些维度，但这种方式似乎过于“生硬”。通过某种合理的方式降低模型复杂度从而提高模型的泛化能力的过程，称为正则化。</p><p>我们可以使用权重衰退的方法对模型进行正则化，权重衰减是最常用的正则化方法之一，也称为L2正则化。我们的方法是在损失函数中考虑到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>W</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">||W||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，我们引入一个非负的常数超参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></p><blockquote><p>L2标准范数是欧几里德距离，这里使用的是L2标准范数的平方，理由是便于计算</p><p>使用L2范数而不是L1范数，是因为L2正则化对权重向量的大分量施加巨大惩罚，使得我们的学习算法偏向于在大量特征上均匀分布权重的模型</p><p>而L1惩罚会导致权重集中在小部分特征上，其他权重清除为0，==<strong>L1范数正则化的特性也称为“特征选择”，这在降维等场景比较适用</strong>==</p></blockquote><p><strong>L2正则化相关公式：</strong></p><p>损失函数（MSE）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L(\mathbf{w}, b) = \frac{1}{n}\sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>正则化损失函数 ——&gt; 目标函数</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>λ</mi><mn>2</mn></mfrac><mi mathvariant="normal">∥</mi><mi mathvariant="bold">w</mi><msup><mi mathvariant="normal">∥</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L(\mathbf{w}, b) + \frac{\lambda}{2} \|\mathbf{w}\|^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∥</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mord"><span class="mord">∥</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>梯度更新公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">w</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>η</mi><mi>λ</mi><mo fence="true">)</mo></mrow><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\mathbf{w} &amp; \leftarrow \left(1- \eta\lambda \right) \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right).\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.7717em;vertical-align:-1.1359em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6359em;"><span style="top:-3.6359em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1359em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6359em;"><span style="top:-3.6359em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mord mathnormal">λ</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1359em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><blockquote><p>疑问:</p><ol><li><p>正则化的作用？</p></li><li><p>L2正则化的作用原理，和未使用正则化进行对比</p><p>【如何解决过拟合问题？L1、L2正则化及Dropout正则化讲解】 <a href="https://www.bilibili.com/video/BV18r4y1M71J/?share_source=copy_web&amp;vd_source=2ef0e81ddb4041a6e7f7c22a036d0599">https://www.bilibili.com/video/BV18r4y1M71J/?share_source=copy_web&amp;vd_source=2ef0e81ddb4041a6e7f7c22a036d0599</a></p></li></ol></blockquote><h4 id="暂退法（dropout）">暂退法（dropout）</h4><blockquote><p>1995年，毕晓普在数学上证明了具有输入噪声的训练等价于Tikhonov正则化</p></blockquote><p>经典泛化理论认为，为了缩小训练性能与测试性能的差距，应该以简单模型为目标。</p><p>简单模型的两个评估方向：</p><ul><li>模型维度</li><li>模型平滑性（不应该对其输入的微小变化敏感）</li></ul><p>暂退法（2014年，斯里瓦斯等人提出）：在网络训练过程中，在计算后续层之前向前向网络的每一层注入噪声，因为当训练一个有多层的深层网络时，注入噪声只会在输入-输出映射上增强平滑性。</p><p><strong>暂退法相关公式：</strong></p><p>暂退法的具体做法是在训练过程中随机地丢弃一些神经元，使得输出不过分依赖于任何一个输入神经元。</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>h</mi><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{h}{1-p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3612em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>是因为需要保证输出期望和原来的水平一致。因为dropout会导致p的概率下神经元不会产生作用，这样对x的作用的期望会下降为原来的1-p倍</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>h</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> 概率为 </mtext><mi>p</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mi>h</mi><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext> 其他情况</mtext></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}h&#x27; =\begin{cases}    0 &amp; \text{ 概率为 } p \\    \frac{h}{1-p} &amp; \text{ 其他情况}\end{cases}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.3em;vertical-align:-1.4em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9em;"><span style="top:-3.9em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8019em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7146em;"><span style="top:-3.7146em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.2746em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2146em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7146em;"><span style="top:-3.7146em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">概率为</span><span class="mord"> </span></span><span class="mord mathnormal">p</span></span></span><span style="top:-2.2746em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">其他情况</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2146em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>所以在一定的概率下，<strong>训练过程中</strong>会有部分神经元不起作用。</p><blockquote><p>注意，在测试和推理过程中，我们不需要使用暂退法，因为这是我们训练好的模型，不需要丢弃任何一个节点。</p></blockquote><h3 id="分布偏移">分布偏移</h3><p>分布偏移是指在机器学习和统计建模中，训练数据的分布与测试数据（或实际应用中的新数据）的分布不同的情况。例如，在图像分类任务中，训练图像可能是在特定的光照条件、角度和场景下采集的，而测试图像的这些条件发生了变化，这就导致了分布偏移。</p><h4 id="分布偏移的类型："><strong>分布偏移的类型：</strong></h4><blockquote><p>统计学基本知识：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_s(X, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>表示X和y的联合概率分布，其中X和y都是随机变量，如果给定X和y，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_s(X,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>表示X取某个特定值且y取某个特定值时的概率。</p><p>这里我们的讨论前提是：</p><ul><li>训练数据采样于分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_s(X,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li><li>测试数据采样于分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>T</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_T(X,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li></ul></blockquote><ol><li>协变量偏移：特征（协变量）的分布发生变化，而标签的生成机制不变。<br>例如，在预测疾病的模型中，训练数据来自一个地区的人群，其年龄、生活习惯等特征有特定的分布；而在测试数据中，人群来自另一个地区，年龄、生活习惯等特征的分布不同，但疾病和这些特征之间的关系（即生成标签的机制）没有改变</li><li>标签偏移：标签的先验概率分布发生变化，而给定标签下特征的条件分布不变。<br>例如，在一个产品质量检测模型中，训练时合格产品和不合格产品的比例是一定的，但在实际测试时，由于生产工艺的改进，合格产品的比例大幅增加，这就导致了标签偏移</li><li>概念偏移：特征和标签之间的关系发生变化，即标签的定义发生变化。<br>例如，精神疾病的诊断标准、时髦、工作头衔都是概念偏移的日常映射，事实证明，如果我们环游美国，根据所在地理位置改变数据源，我们会发现“软饮”名称的分布发生了相当大的概念偏移。</li></ol><blockquote><p>在当我们认为X导致y的情况下，我们可以认为协变量偏移是一种自然假设</p><p>在当我们认为y导致X的情况下，我们可以认为标签偏移是一种合理假设</p><p>概念偏移问题很难被发现，所以我们最好可以利用时间和空间上逐渐发生偏移的知识。</p></blockquote><h4 id="分布偏移的纠正"><strong>分布偏移的纠正</strong></h4><p><strong>经验风险与实际风险</strong></p><p>经验风险通常用损失函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">l(f(x),y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>在真实分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>上的期望来表示。公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>E</mi><mrow><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo>∫</mo><mo>∫</mo><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mi>p</mi><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mtext>  </mtext><mi>d</mi><mi mathvariant="bold">x</mi><mi>d</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">E_{p(\mathbf{x}, y)} [l(f(\mathbf{x}), y)] = \int\int l(f(\mathbf{x}), y) p(\mathbf{x}, y) \;d\mathbf{x}dy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mopen mtight">(</span><span class="mord mathbf mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2222em;vertical-align:-0.8622em;"></span><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫∫</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathbf">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">d</span><span class="mord mathbf">x</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p><p>这反映了预测结果与实际结果的平均误差，我们可以通过最小化经验风险来近似最小化实际风险</p><p><strong>协变量偏移纠正</strong></p><blockquote><p>未明白，以后要用到可以来学</p><p>大概就是将真实分布和训练分布的比作为权重，加入到损失函数之中</p></blockquote><p><strong>标签偏移纠正</strong></p><blockquote><p>未明白，以后要用到可以来学</p></blockquote><p><strong>概念偏移纠正</strong></p><p>概念偏移纠正往往难以使用原则性方法来解决，通常情况下是使用新的数据更新现有的网络权重。即模型不变数据变。</p><h2 id="问题">问题</h2><ol><li>正则化</li><li>分布偏移</li><li>kaggle比赛问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】2. 线性网络</title>
      <link href="/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%912.%20%E7%BA%BF%E6%80%A7%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%912.%20%E7%BA%BF%E6%80%A7%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1>线性网络</h1><h2 id="机器学习基本要素">机器学习基本要素</h2><p>机器学习模型中的关键要素：</p><ul><li>训练数据</li><li>损失函数，最基础的是均方误差</li><li>优化算法，最常用且有效的是梯度下降</li><li>模型本身，最简单的模型是线性模型</li></ul><h2 id="梯度下降">梯度下降</h2><p>梯度下降几乎可以优化所有深度学习模型，通过不断地在损失函数递减方向上更新参数来降低误差。</p><p>梯度下降最简单的用法是计算损失函数（数据集中样本的损失均值）关于模型参数的导数，这就是梯度，但是在实际执行过程中会非常慢：因为每一次更新参数之前，我们会遍历整个数据集，因此我们会在每次需要计算更新的时候抽取一小批样本来更新参数。这种变体的方法叫做：随机梯度下降</p><p>在每次迭代中，我们首先随机抽样一个<strong>小批量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">B</mi></mrow><annotation encoding="application/x-tex">\mathcal{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.03041em;">B</span></span></span></span></strong>，它是由固定数量的训练样本组成的。然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。最后，我们将梯度乘以一个预先确定的正数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span>（<strong>学习率</strong>），并从当前参数的值中减掉。</p><p>我们用下面的数学公式来表示这一更新过程（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∂</mi></mrow><annotation encoding="application/x-tex">\partial</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span>表示偏导数）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4293em;vertical-align:-1.3217em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>总结一下，算法的步骤如下：</p><p>（1）初始化模型参数的值，如随机初始化；</p><p>（2）从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。</p><p>对于平方损失和仿射变换，我们可以明确地写成如下形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">w</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi mathvariant="bold">w</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="bold">w</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mi>b</mi></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.5434em;vertical-align:-2.5217em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0217em;"><span style="top:-5.0217em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5217em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.0217em;"><span style="top:-5.0217em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1611em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.15em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.5217em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h2 id="神经网络基本概念">神经网络基本概念</h2><ol><li><p>全连接层：每一个输入与每一个输出有关，假设该层的输入为NxM维，输出为NxQ维，那么这层的权重参数矩阵为MxQ维。</p><blockquote><p>一般地，全连接层的输入一般会被展平为一维向量，所以最后的输出为1xQ维，即将M维映射到Q维</p></blockquote></li></ol><h3 id="solfmax回归理论">solfmax回归理论</h3><p>solfmax回归也是一个单层神经网络，并且其输出层也是全连接层。</p><p>以分类输出为例，假设我们输出的是预测2x2图片内容属于猫、狗、鸡中的哪个类别，则输出是三维向量，每个维度上为概率值。</p><p>我们的模型要保证输出满足概率基本公理：和为1，非负</p><p>可是我们的模型可能会产生负数，也不能保证输出的向量和为1，这就需要我们对输出进行一定的处理，社会科学家邓肯·卢斯卡在1959年于选择模型的基础上发明了softmax函数解决了这个问题，solftmax函数能够将为规范化的预测输出变换为非负数且综合为1的输出。</p><p>方法：</p><ul><li>非负要求：对每个为规范化的输出求幂</li><li>和为1：归一化处理，即每个求幂后再除以它们的求幂后的总和</li></ul><p>得到的solftmax函数如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">o</mi><mo stretchy="false">)</mo><mspace width="1em"/><mtext>其中</mtext><mspace width="1em"/><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\hat{\mathbf{y}} = \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j = \frac{\exp(o_j)}{\sum_k \exp(o_k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9023em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">softmax</span></span><span class="mopen">(</span><span class="mord mathbf">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord text"><span class="mord cjk_fallback">其中</span></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4127em;vertical-align:-0.9857em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>损失函数/负对数似然</strong></p><h2 id="数理统计基础">数理统计基础</h2><ol><li>最大似然估计、对数似然估计</li><li><strong>信息熵、交叉熵、交叉熵损失函数</strong>（==1==）</li><li>仿射变换：带有偏置项的线性变换</li></ol><h3 id="似然函数和似然估计">似然函数和似然估计</h3><p><strong>似然函数</strong></p><p>对于一个概率模型P(X|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>)，其中X=(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,x_3,...,x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)是观测数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>是模型参数。似然函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>θ</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(\theta|X)=P(X|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，也就是在参数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>的情况下，观测到数据X的概率。</p><p><strong>似然估计</strong></p><p>似然估计是一种参数估计方法，通过寻找似然函数最大化参数值，来确定最优可能产生观测数据的参数。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22环境下配置安卓作为扩展屏</title>
      <link href="/2024/09/21/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E5%B9%B3%E6%9D%BF%E4%BD%9C%E4%B8%BA%E6%89%A9%E5%B1%95%E5%B1%8F/"/>
      <url>/2024/09/21/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%AE%89%E5%8D%93%E5%B9%B3%E6%9D%BF%E4%BD%9C%E4%B8%BA%E6%89%A9%E5%B1%95%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu22环境下配置安卓平板作为扩展屏</h1><h2 id="准备工作">准备工作</h2><p>卸载独立显卡驱动/禁用独立显卡，经验证，我的独显即使禁用，也会和集显交替作用，影响后续扩展屏的配置。所以我直接卸载了，确保只使用集成显卡。（只使用集显发热比较严重，但是续航非常顶！）</p><blockquote><p>下面仅介绍关键步骤，更详细的原理和介绍可以参考最下文的参考博客。</p></blockquote><h2 id="xrandr配置虚拟扩展屏">xrandr配置虚拟扩展屏</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建平板显示的分辨率信息，这里不要设置分辨率太高，否则很卡</span></span><br><span class="line">cvt 960 600</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产生一个新的分辨率模式</span></span><br><span class="line">xrandr --newmode &quot;960x600_60.00&quot;   45.25  960 992 1088 1216  600 603 609 624 -hsync +vsync</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向虚拟显示器添加分辨率模式</span></span><br><span class="line">xrandr --addmode VIRTUAL1  &quot;960x600_60.00&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置虚拟显示器和主显示器的相对位置</span></span><br><span class="line">xrandr --output VIRTUAL1 --mode 960x600_60.00 --left-of eDP1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虚拟显示器内容映射到平板上</span></span><br><span class="line">x11vnc -clip 960x600-1920+0 -wait 1 -defer 1 -nowf -sb 0</span><br></pre></td></tr></table></figure><h2 id="局域网连接">局域网连接</h2><p>让平板和电脑连在同一个局域网下，然后通过vncViewer等工具进行连接即可。</p><h2 id="参考博客">参考博客</h2><p><a href="https://blog.csdn.net/u010750137/article/details/104277527?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=104277527&amp;sharerefer=PC&amp;sharesource=weixin_73546177&amp;sharefrom=from_link">https://blog.csdn.net/u010750137/article/details/104277527?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=104277527&amp;sharerefer=PC&amp;sharesource=weixin_73546177&amp;sharefrom=from_link</a></p><p><a href="https://blog.csdn.net/u010750137/article/details/104277527?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=104277527&amp;sharerefer=PC&amp;sharesource=weixin_73546177&amp;sharefrom=from_link">https://blog.csdn.net/u010750137/article/details/104277527?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=104277527&amp;sharerefer=PC&amp;sharesource=weixin_73546177&amp;sharefrom=from_link</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献检索方法</title>
      <link href="/2024/09/09/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E3%80%91%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/"/>
      <url>/2024/09/09/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E4%B8%8E%E5%86%99%E4%BD%9C%E3%80%91%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1>文献检索方法</h1><p>文献引擎</p><ol><li>google scholar</li><li>web of science<br>数据库<br>NSFC  自然科学基金，面向本科生开放</li></ol><h3 id="判断论文质量">判断论文质量</h3><ol><li>ccf list（大学、研究生毕业条件）</li><li>ccf list只认T1：计算机学报、软件学报、计算机研究院与发展</li><li>中国人工智能学会，国际学术会议A类、B类</li><li>IEEE，必须要有 transection on xxxx 才比较顶级</li><li>ESI，被引次数</li></ol><h3 id="看论文的哪些方面">看论文的哪些方面</h3><p>研究生、博士阶段：看导师<br>本科：看学校<br>author、institute、content</p>]]></content>
      
      
      <categories>
          
          <category> 论文写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程】4. 结构化设计方法</title>
      <link href="/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
      <url>/2024/08/24/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%914.%20%E7%BB%93%E6%9E%84%E5%8C%96%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>结构化设计方法</h1><h2 id="软件设计的概念以及原则">软件设计的概念以及原则</h2><h3 id="软件设计的概念">软件设计的概念</h3><ul><li>设计是一项核心的工程活动</li><li>软件设计是软件工程中的一个关键过程，指的是在开发软件时，为了实现特定的功能需求和性能目标，对软件系统的结构、组件、接口及其交互进行规划和定义的过程。</li></ul><h3 id="软件设计的原则">软件设计的原则</h3><ol><li>分而治之</li><li>模块独立性：<ul><li>指软件系统中每个模块中只涉及软件要求的具体的子功能，而和软件系统中其他模块的接口是简单的</li><li>优点：有效的模块化使得软件便于分工协作开发；独立的模块比较容易测试和维护</li><li>衡量准则：<ol><li>耦合：模块之间的相互连接的紧密程度的度量</li><li>内聚：一个模块内部各个元素彼此结合的紧密程度的度量</li></ol></li></ul></li><li>提高抽象层次（信息隐藏，接口设计）</li><li>复用性设计（软件的重用部分称为软构件）</li><li>灵活性设计：保证软件灵活性设计的关键是抽象</li></ol><h4 id="在设计中引入灵活性设计的方法">在设计中引入灵活性设计的方法</h4><ol><li>降低耦合并提高内聚（易于提高替换能力）</li><li>建立抽象（创建有多态操作的接口和父类）</li><li>不要将代码写死（消除代码中的常数）</li><li>抛出异常（由操作的调用者处理异常）</li><li>使用并创建可复用的代码</li></ol><h2 id="结构化设计">结构化设计</h2><h3 id="概念">概念</h3><p>结构化设计是将结构化分析得到的数据流图映射成软件体系结构的一种设计方法，有模块化、自顶向下逐步求精、信息隐藏、高内聚低耦合等准则。</p><h3 id="结构化设计的任务">结构化设计的任务</h3><ol><li>软件设计的主要任务是要解决如何做的问题，要在需求分析的基础上，建立各种设计模型，并通过对设计模型的分析和评估，来确定这些模型是否能够满足需求。</li><li>软件设计是将用户需求准确地转化成为最终的软件产品的唯一途径，在需求到构造之间起到了桥梁作用。</li><li>在软件设计阶段，往往存在多种设计方案，通常需要在多种设计方案之中进行决策和折中，并使用选定的方案进行后续的开发活动。</li></ol><h3 id="软件设计的阶段和任务">软件设计的阶段和任务</h3><ul><li>从工程管理的角度，可以将软件设计分为概要设计阶段和详细设计阶段</li><li><strong>从技术的角度</strong>，传统的结构化方法将软件设计划分为<br>体系结构设计（软件的构成元素以及其之间的关系）<br>数据设计（根据E-R图确定数据库表结构和文件结构）<br>接口设计（外部接口和内部接口，实现信息隐藏）<br>过程设计（数据结构和算法实现）<br>==其中前三步是概要设计阶段，最后一步是详细设计阶段==</li><li>面向对象方法则将软件设计划分为体系结构设计、类设计/数据设计、接口设计和构件级设计4部分</li></ul><h3 id="结构化设计和结构化分析的关系">结构化设计和结构化分析的关系</h3><p>结构化分析为结构化设计提供基本的输入信息。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902080229.png" alt="Pasted image 20240902080229"></p><h3 id="模块结构以及表示">模块结构以及表示</h3><ul><li>一般通过功能划分过程来完成软件结构设计。</li><li>功能划分过程从需求分析确立的目标系统的模型出发，对整个问题进行分割，使其每一部分用一个或几个软件模块加以解决，整个问题就解决了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/NGSJCBF/img@main/img/202406171322456.png" alt="image-20240531222854309"></p><p><strong>模块</strong>：</p><ul><li>一个软件系统通常由很多模块组成，结构化程序设计中的函数和子程序都可称为模块，它是程序语句按逻辑关系建立起来的组合体。</li><li>模块用矩形框表示，并用模块的名字标记它。</li></ul><h3 id="结构图">结构图</h3><p>结构图（structure chart，SC）是精确表达模块结构的图形表示工具。</p><ol><li>模块的调用关系和接口：在结构图中，两个模块之间用单向箭头连接。</li><li>模块间的信息传递：当一个模块调用另一个模块时，调用模块把数据或控制信息传送给被调用模块，以使被调用模块能够运行。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902094024.png" alt="Pasted image 20240902094024"></li><li>条件调用和循环调用 ：当模块A有条件地调用另一个模块B时，在模块A的箭头尾部标以一个菱形符号；当一个模块A反复地调用模块C和模块D时，在调用箭头尾部则标以一个弧形符号。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902094111.png" alt="Pasted image 20240902094111"></li><li>结构图的形态特征。在图中，上级模块调用下级模块，它们之间存在主从关系。</li></ol><h2 id="体系结构设计">体系结构设计</h2><h3 id="基于数据流方法的设计过程">基于数据流方法的设计过程</h3><ul><li>典型的数据流类型有变换型数据流和事务型数据流，数据流的类型不同，得到的系统结构也不同;</li><li>通常，一个系统中的所有数据流都可以认为是变换流，但是，当遇到有明显事务特性的数据流时，建议采用事务型映射方法进行设计;</li></ul><h4 id="变换型系统结构图">变换型系统结构图</h4><p>变换型数据处理问题的工作分为三步：</p><ol><li>获取数据，对应输入图</li><li>变换数据，对应变换图</li><li>输出数据，对应输出图<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902110853.png" alt="Pasted image 20240902110853"></li></ol><h5 id="变换分析方法（变换数据流图绘制）">变换分析方法（变换数据流图绘制）</h5><ol><li>重画数据流图。在需求分析阶段得到的数据流图侧重于描述系统如何加工数据，而重画数据流图的出发点是描述系统中的数据是如何流动的</li><li>在数据流图上<strong>区分系统的逻辑输入</strong>、<strong>逻辑输出</strong>和<strong>中心变换</strong>部分</li><li>具体步骤：<ol><li>划定输入流和输出流的边界，确定变换中心</li><li>进行一级分解</li><li>进行二级分解</li><li>精化、改进</li><li>标注输入输出信息</li></ol></li></ol><p><strong>例题</strong>：<br>【软件工程——5-2-1-变换型数据流图的设计】 <a href="https://www.bilibili.com/video/BV1TY4y1A7C1/?share_source=copy_web&amp;vd_source=2ef0e81ddb4041a6e7f7c22a036d0599">https://www.bilibili.com/video/BV1TY4y1A7C1/?share_source=copy_web&amp;vd_source=2ef0e81ddb4041a6e7f7c22a036d0599</a></p><h3 id="事务型系统结构图">事务型系统结构图</h3><p><strong>特点</strong>：</p><ol><li>有明显的事务中心</li><li>事务中心分析事务（即输入数据）的类型</li><li>事务中心选择与该事物对应的一条活动流来执行</li><li>各活动流以实物中心为起点呈辐射状流出<br><strong>设计步骤</strong>：</li><li>确定事务中心和个活动流的特性<ul><li>事务中心为d，位于活动流起点</li><li>活动流从该点呈辐射状流出</li><li>活动流可以是变换流、也可以是事务流</li></ul></li><li>将事务型数据流图映射成高层体系结构<ul><li>主模块：整个系统的功能</li><li>调度模块：控制下层所有活动模块</li><li>接受模块（即输入）：接受输入事务数据</li><li>事务模块：对应活动流、由活动流映射而成<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902135527.png" alt="Pasted image 20240902135527"></li></ul></li></ol><h3 id="软件模块结构图的改进">软件模块结构图的改进</h3><ol><li>模块功能的完善。一个完整的模块应该有以下部分：<ul><li>执行规定的功能的部分</li><li>出错处理部分，当模块不能完成规定功能时必须送出出错标志，向调用者报告出错信息和原因</li><li>如果需要返回一系列数据给它的调用者，在完成数据加工或结束时，应当给它的调用者返回一个“结束标志”</li></ul></li><li>消除重复功能，改善软件结构</li><li>模块的作用范围应该在控制范围之内</li><li>减少高扇出、高扇入结构</li><li>模块大小适中</li></ol><h2 id="数据设计">数据设计</h2><p>数据设计主要包括文件设计和数据库设计。<br>文件设计要根据文件特性来设计文件的组织方式：顺序文件、直接存取文件、索引顺序文件、分区文件、虚拟存储文件…<br>数据库设计，一般用关系型数据库，建立E-R图</p><h2 id="接口设计">接口设计</h2><p>接口设计主要包括三个方面：</p><ul><li>软件与其他软硬件系统之间的接口设计</li><li>软件与人（用户）之间的交互设计</li><li>模块或软件构建间的接口设计</li></ul><h2 id="过程设计（详细设计阶段）">过程设计（详细设计阶段）</h2><h3 id="过程设计概述">过程设计概述</h3><p>表达过程规格说明的工具称为过程描述工具，可以将过程描述工具分为以下三种：</p><ol><li>图形工具：程序流程图、NS图、PAD图、决策树等</li><li>表格工具：用一张表来表达过程的细节，这张表列出了各种可能得操作以及其相应的条件</li><li>语言工具：伪代码</li></ol><h3 id="程序流程图">程序流程图</h3><p>一、程序流程图的基本符号以及基本控制结构<br>基本符号：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902150126.png" alt="Pasted image 20240902150126"><br>基本控制结构：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902150035.png" alt="Pasted image 20240902150035"></p><h3 id="N-S图">N-S图</h3><p>基本符号：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902151812.png" alt="Pasted image 20240902151812"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】7. 期末考点整理</title>
      <link href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%917.%20%E6%9C%9F%E6%9C%AB%E8%80%83%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章——数据库系统概述">第一章——数据库系统概述</h2><h3 id="1、四个概念：什么是数据-什么是数据库-什么是数据库管理系统（DBMS）？什么是数据库系统-DBS-？">1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？</h3><p><strong>数据</strong>：用以描述事务性质的符号<br><strong>数据库</strong>：一个相互联合的数据的集合<br>数据的重要特点：数据是相互联系的<br><strong>数据库管理系统</strong>：</p><ul><li>广义的数据库管理系统包括：相互联系的数据集合以及存取和管理这些数据的一套程序，即<strong>数据库</strong>和<strong>数据库管理系统软件</strong></li><li>一般的数据库管理系统：仅指数据库管理系统软件<br><strong>数据库系统</strong>：是指以<strong>数据库</strong>为核心的整个计算机系统。其目的是向用户提供方便、高效、可靠的存取数据的功能。</li></ul><p>DBMS的功能：</p><ol><li>数据组织定义</li><li>数据操作与查询优化</li><li>数据管理以及维护</li><li>事务管理和运行控制</li><li>对外提供多种接口（实用工具）</li></ol><h3 id="2、熟记数据库系统的组成。">2、熟记数据库系统的组成。</h3><p><strong>数据库系统的组成</strong>：</p><ol><li>数据库</li><li>硬件：CPU、内存…</li><li>软件：DBMS，操作系统，数据库应用程序…</li><li>人员：数据库管理人员DBA，应用程序员，用户</li></ol><h3 id="3、理解DBA是对数据库进行集中控制和管理的最重要人员。">3、理解DBA是对数据库进行集中控制和管理的最重要人员。</h3><p>数据库管理员（DBA）是整个数据库系统进行集中控制和管理的人员，是系统中最重要的人员。<br><strong>数据库管理员的具体职责</strong>：</p><ol><li>数据库设计：决定数据库中的信息结构和内容</li><li>数据库维护：维护数据的安全性、完整性，以及<strong>并发控制、故障恢复</strong>等等</li><li>改善系统性能：监视系统性能变化，在性能下降时找出瓶颈所在，并解决问题</li></ol><h3 id="4、实例和模式的对比（内容-状态-vs-结构，变化-vs-稳定）">4、实例和模式的对比（内容/状态 vs 结构，变化 vs 稳定）</h3><p><strong>数据模式</strong>：数据库/表的结构（比如表中有什么字段，关系有什么属性）<br><strong>实例</strong>：数据库/表在特定时刻的内容<br><strong>区别：</strong></p><ol><li>对于一个数据库/表，由于记录不断地插入/删除/更新，所以它的实例（内容）是变化的，但模式（结构）是稳定的</li></ol><h3 id="5、熟记5和6全部内容三级模式的名称和定义（注意物理模式又称内模式，逻辑模式又称模式，子模式又称外模式）。三级模式的数量：一个数据库有几个物理模式，逻辑模式和子模式？-三级模式间的两极映射？由谁（DMBS）来完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——">5、熟记5和6全部内容三级模式的名称和定义（注意物理模式又称内模式，逻辑模式又称模式，子模式又称外模式）。三级模式的数量：一个数据库有几个物理模式，逻辑模式和子模式？ 三级模式间的两极映射？由谁（DMBS）来完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——</h3><h4 id="三级模式结构">三级模式结构</h4><p>三级模式结构主要是指数据抽象分为内模式、模式、外模式三级结构。<br><strong>一、内模式</strong>（又称物理模式、存储模式）<br><strong>定义</strong>：整体数据库的物理/存储结构，描述全体数据在硬盘等介质上如何存储。<br>==一个数据库只有一个内模式==</p><p><strong>二、模式</strong>（又称逻辑模式）<br><strong>定义</strong>：整体数据库的逻辑结构，描述所有数据的结构和数据间的联系，向下屏蔽了物理模式，即不需要知道数据的物理存储结构。<br>==一个数据库只有一个模式==</p><p><strong>三、外模式</strong>（也称子模式、用户模式）<br><strong>定义</strong>：</p><ul><li>外模式是一部分数据库的逻辑结构，即特定用户能看到的部分，描述这部分数据的结构和彼此间的关系；</li><li>向下屏蔽了逻辑模式，即不需要知道其他的数据结构和联系；</li><li>外模式等同于用户模式，实际上是逻辑模式的子集，逻辑模式是所有外模式之和<br>==一个数据库可以有多个外模式，外模式是保障数据安全性的一个有力措施==</li></ul><h4 id="三级模式结构的两级映射">三级模式结构的两级映射</h4><p><strong>DBMS</strong>内部在这三种模式之间提供两级映射功能，以实现上下模式间的联系和转换，分别是<strong>模式/内模式映射</strong>和<strong>外模式/模式映射</strong>。<br>==DBMS数据库管理系统来完成这种映射==</p><h4 id="两级映射的优点">两级映射的优点</h4><ol><li>保证了数据的物理独立性：<br>当数据库的物理存储结构发生改变时（如存储位置发生改变），应用程序不发生变化。<br><strong>原因</strong>：当内模式改变时，（DBA手动或者DBMS自动地修改模式/内模式映像，最终使）模式保持不变；</li><li>保证了数据逻辑的独立性：<strong>外模式/概念模式映射就是逻辑独立性的关键</strong><br>当数据库整体逻辑结构改变时（如字段的增减，字段名的修改），应用程序不一定要改变。<br><strong>原因</strong>：当模式改变时，（DBA手动或DBMS自动地修改外模式/模式映像，最终使）外模式<strong>可能</strong>保持不变；</li></ol><h3 id="6、什么是逻辑数据独立性？什么是物理数据独立性？这两种数据独立性，分别是怎么实现的？（用到的A模式-B模式映射搞清楚，当…变…不变的过程也搞清楚）">6、什么是逻辑数据独立性？什么是物理数据独立性？这两种数据独立性，分别是怎么实现的？（用到的A模式/B模式映射搞清楚，当…变…不变的过程也搞清楚）</h3><h4 id="逻辑独立性和物理独立性的概念">逻辑独立性和物理独立性的概念</h4><ol><li>物理逻辑独立性：<br>当数据库的物理存储结构发生改变时（如存储位置发生改变），应用程序不发生变化。<br><strong>原因</strong>：当内模式改变时，（DBA手动或者DBMS自动地修改模式/内模式映像，最终使）模式保持不变；</li><li>逻辑数据的独立性：<strong>外模式/概念模式映射就是逻辑独立性的关键</strong><br>当数据库整体逻辑结构改变时（如字段的增减，字段名的修改），应用程序不一定要改变。<br><strong>原因</strong>：当模式改变时，（DBA手动或DBMS自动地修改外模式/模式映像，最终使）外模式可能保持不变；<br>==数据库系统（DBMS）通过两个子系统：DBCS（Data Controlling System）和DBSS（Data Storage System）来实现三级模式的结构和两级映射的功能。==</li></ol><h3 id="7、用户或者应用程序面向的到底是哪一级数据库模式？">7、用户或者应用程序面向的到底是哪一级数据库模式？</h3><p>用户或者应用程序面向的是外模式。</p><h3 id="8、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。">8、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。</h3><h4 id="模型的基本概念">模型的基本概念</h4><p>模型是对现实世界某些事物和特征的模拟和抽象，数据模型用于描述数据结构、数据联系、数据语义和数据约束的一套工具和方法。</p><h4 id="区分数据模型、数据模式、数据实例">区分数据模型、数据模式、数据实例</h4><table><thead><tr><th></th><th>数据模型</th><th>数据模式</th><th>数据实例</th></tr></thead><tbody><tr><td>定义</td><td>描述数据结构与联系的方法</td><td>某一数据库的结构与联系(用数据模型描述的结果)</td><td>遵循以上结构的数据库，在某一时点的内容/状态<br></td></tr><tr><td>对比理解</td><td>程序语言(例如, PHP)</td><td>开发的一套程序(例如, 新闻网站)</td><td>程序运行到某一时点(例如, 今日的新闻网站)</td></tr></tbody></table><h4 id="数据模型的层次分类">数据模型的层次分类</h4><p><strong>一、概念数据模型</strong>（概念模型、信息模型）</p><ul><li>概念数据模型是对现实世界的建模，与具体的数据库/DBMS无关</li><li>用于数据库设计，是设计人员与用户交流的基本工具<br><strong>最常见的例子</strong>：<strong>ER图</strong></li></ul><p><strong>二、逻辑数据模型</strong>（结构数据模型）</p><ul><li>对数据库里的数据（的逻辑结构）建模，与具体的DBMS有关，每种DBMS至少支持一种特定的逻辑数据结构模型</li><li>通过适当的方法，可以将概念数据模型转化为逻辑数据模型<br><strong>最常见的例子</strong>：<strong>关系模型</strong><br>==如无特别说明，以后讲到数据库模型，专指逻辑数据模型==</li></ul><p><strong>三、物理数据模型</strong></p><ul><li>对数据在物理介质的存储方法和组织结构建模，不仅与具体的DBMS有关，还与具体硬件和操作系统有关</li><li>DBMS能够自动完成大部分物理数据模型的工作，即自动将逻辑数据模型映射为物理数据模型。</li></ul><h4 id="（逻辑）数据模型的三要素">（逻辑）数据模型的三要素</h4><ol><li>数据结构<ul><li>数据的<strong>组织方式和相互联系</strong></li><li>系统的静态特性</li></ul></li><li>数据操作<ul><li>对各种数据对象所允许执行的操作以及有关的操作规则</li><li>系统的动态特性</li></ul></li><li>数据完整性约束<ul><li>一组约束条件的集合</li><li>强制约束数据的状态以及状态变化符合这些约束条件，以保证数据的正确、有效、相容</li></ul></li></ol><h4 id="常见的数据模型">常见的数据模型</h4><ol><li>格式化模型：<ul><li>层次模型</li><li>网状模型</li></ul></li><li>经典数据模型：<ul><li>关系模型</li></ul></li><li>新型数据模型：<ul><li>对象数据模型</li><li>对象关系模型</li></ul></li></ol><h2 id="第二章">第二章</h2><h3 id="1、数据模型的三要素？关系模型的三要素？">1、数据模型的三要素？关系模型的三要素？</h3><h4 id="数据模型三要素">数据模型三要素</h4><ol><li>数据结构</li><li>数据操作</li><li>数据完整性约束</li></ol><h4 id="关系模型三要素">关系模型三要素</h4><ol><li>关系（关系的数据结构）</li><li>关系操作（关系的数据操作）</li><li>关系完整性约束（关系的数据完整性约束）</li></ol><h4 id="关系模型的相关概念">关系模型的相关概念</h4><p>关系模型是一种常见的（逻辑）数据模型，<strong>数据结构为二维表（关系）</strong>，可以表示任意实体以及实体间的联系。<br>一、关系模型的数据结构</p><ul><li>在关系模型中，数据结构是若干二维表，二维表又称关系，由行（元组）和列（关系）组成</li><li>关系既可以表示实体，又可以表示实体间的联系</li></ul><p>二、关系模型的数据操作<br>关系模型的数据数据操作包括：</p><ul><li>查询</li><li>插入</li><li>删除</li><li>更新<br>数据操作的对象和结构都是关系，所以是<strong>集合操作</strong>（关系=许多元组的集合）<br><strong>存取路径对用户透明</strong>，用户只要指出“做什么”，不需要说明或知道“怎么做”的过程和细节（<strong>非过程化</strong>）</li></ul><p>三、关系模型的完整性约束</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义完整性</li></ul><h4 id="关系模型的优缺点">关系模型的优缺点</h4><ol><li>优点：<ul><li>建立在严格的数学基础上</li><li>概念单一，实体和各类联系都用关系表示、对数据的检索结果也是关系</li><li>关系模型的存取路径对用户透明，具有更高的数据独立性，更好的安全保密性；简化了程序员的工作和数据库开发建立的工作</li></ul></li><li>缺点：<ul><li>存取路径对用户透明导致<strong>查询效率</strong>往往不如非关系数据模型</li><li>为了提高性能，必须对用户的<strong>查询请求</strong>进行<strong>优化</strong>，增加了开发DBMS的难度</li></ul></li></ol><h3 id="2、关系的组成：什么是属性？什么是元组？什么是分量？">2、关系的组成：什么是属性？什么是元组？什么是分量？</h3><h4 id="关系的相关概念">关系的相关概念</h4><h4 id="关系的组成">关系的组成</h4><p>关系是一个命名的二维表，由以下部分组成：</p><ul><li>关系有名字，即关系名</li><li>关系的一列是<strong>属性</strong>，属性有名字（属性名）</li><li>关系的一行是<strong>元组</strong></li><li><strong>分量</strong>是行和列的交叉，或者说，分量是某个元组的某个属性值</li></ul><p>注意其他概念：</p><ul><li>关系的度：属性的个数</li><li>关系的基数：元组的个数</li><li>（属性的）域：该属性的取值集合（范围）</li></ul><h3 id="3、理解关系有哪些基本性质？">3、理解关系有哪些基本性质？</h3><h4 id="关系的性质（关系必须满足的条件）">关系的性质（关系必须满足的条件）</h4><ol><li>列的同质性：同一列中的分量（值）必须具有相同的类型，因为它们来自同一个域</li><li>异列同域性：不同列可以来自同一个域，但属性名不能相同</li><li>元组相异性：关系里的任意两行不能相同，因为关系是一个元组集合（数学上严格禁止，但是实际数据库里面可以容忍重复）</li><li>行列无序性：关系的行或列是顺序无关的。即改变行或列的次序（例如交换两行或者两列），关系不会变</li><li>属性值原子性：每一个属性值(分量)都必须是原子的(不可分)，不允许出现组合数据，更不允许“表中有表”。满足该条件的关系称作第一范式</li></ol><h3 id="4、关系有哪四种码？数量（一或多个）？并能根据定义判定！外部码从E-R图的什么概念转化而来？外部码的属性名可以和所对应的主码不同，外部码可以指向同一个关系的主码。例如：学生（学号，姓名，班长学号…）。">4、关系有哪四种码？数量（一或多个）？并能根据定义判定！外部码从E-R图的什么概念转化而来？外部码的属性名可以和所对应的主码不同，外部码可以指向同一个关系的主码。例如：学生（学号，姓名，班长学号…）。</h3><h4 id="关系的码">关系的码</h4><ol><li>超码：关系中能够唯一标识每个元组的属性或者属性组</li><li>候选码：最小的超码（一个超码可能含有多余的属性）</li><li>主码：虽然在一个关系中里可能存在几个候选码，但是只<strong>选出一个作为主码</strong></li><li>外部码：关系R1中的属性或属性组，对应关系R2的主码，R1称为参照关系，R2称为被参照关系<ul><li>外部码的属性名，和对应主码的属性名不一定要相同<br>（外部码参照对应的主码，是属性值的参照，不是属性名的参照）</li><li>外部码的<strong>取值（范围）</strong>，就是对应主码的取值（范围），<strong>以此判断外部码</strong></li><li><strong>外部码反映联系</strong>，一个元组的外部码，说明了它是和另外的哪一个（主码）元组相联系的</li></ul></li></ol><h4 id="外部码与E-R图的关系">外部码与E-R图的关系</h4><p>外部码是从E-R图的联系的概念中转化而来</p><h4 id="外部码的判别依据">外部码的判别依据</h4><ol><li>该属性是不是某个关系的主码（能唯一决定该关系的一个元组的最小的候选码之一）</li><li>该属性与对应关系的域是否相同（值的范围是否一致）<br>满足以上两个条件即可判别是否为外部码</li></ol><h3 id="5、关系模式和关系实例的对比。">5、关系模式和关系实例的对比。</h3><h4 id="关系模式的定义">关系模式的定义</h4><p>一、关系模式是关系的逻辑设计（数据结构、数据关系的设计）<br>二、关系模式的完整定义：<br><code>R(U, D, dom, F)</code></p><ul><li>R: 关系名</li><li>U: 关系的属性的集合</li><li>D: 域的集合</li><li>dom: 属性到域的映射（每个属性属于什么域）</li><li>F: 属性间依赖关系的集合<br>简记为：<code>R(A1,A2,...)</code>，其中A为关系中的所有属性</li></ul><h4 id="关系实例的定义">关系实例的定义</h4><ul><li>关系实例是关系在某一特定时刻的状态，强调具体的关系内容</li><li>我们提到的关系有时指关系实例，有时指关系模式</li></ul><h4 id="关系模式与关系实例的对比">关系模式与关系实例的对比</h4><ul><li>关系模式比较稳定，关系实例随时间变化</li></ul><h3 id="6、关系操作分为查询和更新操作。表示关系操作的语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。">6、关系操作分为查询和更新操作。表示关系操作的语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。</h3><h4 id="关系操作的类型">关系操作的类型</h4><p>一、查询操作</p><ul><li>查询操作是静态操作，在一个关系内或多个关系间检索/定位数据，但不改变原有数据<br>二、修改操作</li><li>动态操作，改变一个关系的数据<br>三、两类操作的关系</li><li>查询操作是修改操作的基础，修改操作实际是对查询操作定位后的结果进行修改</li></ul><h4 id="关系操作的表示——查询语言">关系操作的表示——查询语言</h4><p>一、关系操作是通过某一种查询语言来表示的，比如关系代数、关系演算</p><ul><li>关系代数：用一组对关系的运算来表示查询和修改</li><li><strong>关系演算：用谓词演算来表示查询和修改，根据谓词的不同，又分为元组演算和域演算</strong><br>二、查询语言的分类</li><li>过程化：<ol><li>用户要指定查询什么</li><li>怎么查询，用什么方法</li></ol></li><li>非过程化：<ol><li>用户只需要指定要查询什么</li><li>系统自动返回查询的内容<br>查询优化：寻找（近似）最优的查询方法就是查询优化<br><strong>关系代数是过程化的，而SQL和关系演算是非过程化的</strong></li></ol></li></ul><h3 id="7、过程化和非过程化语言的区分和理解——看课件。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。">7、过程化和非过程化语言的区分和理解——看课件。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。</h3><h3 id="8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？可以替代的运算，是怎么用其它运算的组合式子来替代的？">8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？可以替代的运算，是怎么用其它运算的组合式子来替代的？</h3><h4 id="关系代数概述">关系代数概述</h4><p>一、代数系统</p><ul><li>代数系统包括运算对象和基于对象的一组运算</li><li>特点：运算封闭性<br>二、关系代数<br>关系代数也是一个代数系统，关系代数的运算对象是关系，并且关系代数是封闭的，任何关系运算的结果还是一个关系</li></ul><h4 id="关系运算的分类">关系运算的分类</h4><ol><li>基本运算<ul><li>选择: 输出无名字的关系，保留输入关系的全部属性，但只包含哪些满足条件的元组</li><li>投影: 从输入关系r产生一个仅包含r中某些属性的新关系，并<strong>消去重复元素</strong></li><li>笛卡尔积、集合并、集合差、更名</li></ul></li><li>附加运算：非基本的、可替代的运算，可以用基本运算组合来替换<ul><li><strong>集合交</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>−</mo><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \cap S = R - (R-S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></li><li><strong>自然连接</strong>: 一种特殊的连接运算，连接条件是（两边元组的）同名属性相等，并且在连接结果中<strong>去掉重复的同名属性</strong>（其他连接运算没有去重这一点）<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo>⋈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∏</mo><mrow><mi>A</mi><mo separator="true">,</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo separator="true">,</mo><mi>E</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>R</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>∧</mo><mi>R</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo>=</mo><mi>S</mi><mi mathvariant="normal">.</mi><mi>D</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(A, B, C, D) \Join S(B, D, E) = \prod_{A, R.B, C, R.D, E}(\sigma_{R.B=S.B\wedge R.D=S.D}(R \times S))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">∧</span><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">))</span></span></span></span></li><li><strong>除</strong>: 是笛卡尔积的逆运算</li><li><strong>赋值</strong></li></ul></li><li>扩展运算: 前两种基础上对运算能力进行扩展和增强<ul><li>广义投影: 对投影运算的扩展，在属性列表中允许使用表达式构造新属性</li><li><strong>外连接</strong>: 外连接是对自然连接的扩展</li><li>聚集运算</li></ul></li><li>一元运算<ul><li>输入为一个关系</li></ul></li><li>二元运算<ul><li>输入为两个关系</li></ul></li></ol><h4 id="外连接？">外连接？</h4><p>一、为什么要扩展自然连接，产生外连接？<br>自然连接可能会造成信息的丢失。造成信息丢失的根本原因在于自然连接只会保留关系在相同属性上有相同值的元组。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809094059.png" alt="Pasted image 20240809094059"><br>二、外连接的基本内容</p><ul><li>外连接：<ul><li>因为自然连接运算的结果不包括那些失配的元组，造成信息丢失</li><li>为了避免这种情况，把失配的元组连接上一个空元组（所有属性值为NULL），添加到结果关系中去，这就是外连接运算</li></ul></li><li>外连接的三种类型：<ul><li>左外连接 = 自然连接 + 左侧失配元组（与空元组连接）</li><li>右外连接 = 自然连接 + 右侧失配元组</li><li>全外连接 = 自然连接 + 两侧失配元组</li></ul></li><li>计算外连接的方法：<ol><li>计算自然连接</li><li>加上失配元组</li></ol></li></ul><h4 id="聚集函数">聚集函数</h4><p>一、聚集函数的基本概念</p><ol><li>输入：一个值的“集合”，因为相同值可以出现多次，这样的“集合”称为多重集</li><li>输出：单一值，如：<br>sum<br>count<br>avg<br>max<br>min</li><li>如果希望在计算中忽略重复值，则应该在函数名后面加上 -distinct，比如count-distinct就表示计算多重集中的不同值的个数<br>二、聚集运算<br><strong>聚集运算的形式</strong>通常如下：</li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow></mrow><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>F</mi><mi>m</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{G_1,G_2,...,G_n}\mathcal{G}_{F_1(A_1),F_2(A_2),...,F_m(A_m)}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p><p>其中，E是关系代数表达式，也可以理解为一个未命名的关系，实际上也是元组集合；<br>F是聚集函数，A是E的属性；<br>G是用于分组的一系列属性；</p><p><strong>该运算的计算过程</strong>：<br>先分组：</p><ul><li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的值相同的元组，分为同一组；</li><li>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的值不同的元组，分为不同组；<br>再统计：<br>各组属性可以由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值唯一标识；<br>对于每一个组来说，其结果都有且仅有一个结果（因为聚集函数接受一个元组集合，返回一个值）元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>g</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>m</mi></msub><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（g_1,g_2,g_3,...g_n,a_1,a_2,...,a_m）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span> ，其中每个a都是由聚集函数F作用于该组所有元素在A属性上的结果；<br><strong>聚集运算的结果</strong>：</li><li>一个新关系，属性有m + n个，前 n 个属性来自左下标的分组属性，后 m 个来自右下标的聚集函数（新属性无属性名，或用 as 命名）</li><li>（第二步中）原来关系被分成多少组，最后结果关系中就有多少个元组。因为每一个分组被统计为结果中的一个元组。</li></ul><p><strong>举例说明</strong>：求出每个系的平均工资<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{dept\_name}\mathcal{G}_{avg(salary)}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">pt</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">vg</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span></span></span></span><br>上面的例子中，对instructor教师表，按照dept_name属性分成每个系的教书组，然后对每个系的教师求平均工资；</p><p><strong>计算方法</strong>：</p><ol><li>确定关系的属性（m + n）</li><li>根据分组属性划分组</li><li>为每个分好的组，在结果关系内添加一个元组t：前n个属性值等于该分组在n个分组属性（左下标）上的值，后m个属性等于在该分组上统计m个聚集函数（右下标）的结果<br>PPT讲的很精彩，可以看看。</li></ol><h3 id="9、除运算不要求。">9、除运算不要求。</h3><p>一、关于除运算需要掌握的基础</p><ul><li>除运算是笛卡尔积的逆运算</li><li>更一般地，两个关系 T, R 相除<br>T ÷ R = S, S 是满足 R × S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span> T ( 不超过 T) 的最大关系</li><li>T ÷ R 合法有效的充要条件：T 包含 R 的全部属性，并额外含有不在 R 中的属性——这些属性将会出现在除的结果中</li><li><strong>除运算的输出</strong>:  T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>÷</mo></mrow><annotation encoding="application/x-tex">\div</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">÷</span></span></span></span> R<ol><li>输出的属性Z：T的属性-R的属性</li><li>输出的元组必须同时满足以下条件：<ul><li>是T元组在Z投影下的子集</li><li>与R的所有元组的连接都出现在关系T中（所以从这一点也可以看出它是笛卡尔积的逆运算）<br>二、除运算的应用场景<br>一般涉及到“全部”的时候考虑使用除运算。</li></ul></li></ol></li></ul><p>三、除运算与其他运算的等价<br>除运算通用可以表示为其他运算的组合，所以也是附加运算。<br>例如，关系 T 的属性集为 X ，关系 R 的属性集为<br>Y 。 Z = X － Y ，则 T ÷ R 可重写为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>÷</mo><mi>R</mi><mo>=</mo><msub><mo>∏</mo><mi>Z</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mo>∏</mo><mi>Z</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>×</mo><mi>R</mi><mo>−</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T \div R = \prod_Z(T) - \prod_Z((T)\times R - T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">((</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></p><p>10、查询优化不要求。</p><h2 id="第三章-——-关系数据库语言SQL">第三章 —— 关系数据库语言SQL</h2><h3 id="1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点。">1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点。</h3><p>一、SQL简介</p><ul><li>SQL是Sructured Query Language(结构化查询语言)的缩写</li><li>SQL是一种数据库语言 —— 为使用关系数据库提供了<strong>数据结构的定义(DDL)</strong>、<strong>数据内容的操纵(DML)</strong>(查询和修改)、和<strong>日常运行控制(DCL)</strong> 等功能。</li></ul><p><strong>二、SQL的特点</strong>：</p><ol><li>综合统一性：<br>功能统一，都提供数据定义、数据操作、数据控制等功能；<br>操作过程统一，都是针对关系的操作，包括操作对象和操作结果；</li><li>高度非过程化</li><li>面向集合的操作方式：<br>每条操作语句的对象和结果都是关系（记录集合）；</li><li>两种使用方式，统一的语法结构：<br>自含式SQL：数据库管理系统自带，供用户与数据库联机使用，又称为联机式<br>嵌入式SQL：嵌入到高级语言里面，供程序员用这些高级语言开发数据库应用程序时使用（JDBC等）</li></ol><h3 id="2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？">2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？</h3><p>一、SQL的四种功能</p><ol><li>数据定义，用数据定义语言实现（DDL, Data Defined Language）</li><li>数据查询，用数据操作语言实现</li><li>数据修改，用数据操作语言实现（DML，Data Manipulate Language）</li><li>数据控制，用数据控制语言实现（DCL，Data Control Language）</li></ol><p>二、四种功能以及对应的SQL操作语句</p><table><thead><tr><th>SQL功能</th><th>操作语句</th><th>备注</th></tr></thead><tbody><tr><td>数据定义</td><td>CREATE、ALTER、DROP</td><td>可定义的对象包括数据库、表、索引、视图等…</td></tr><tr><td>数据操作</td><td>SELECT</td><td>又称数据查询</td></tr><tr><td></td><td>INSERT、DELETE、UPDATE</td><td>又称数据修改</td></tr><tr><td>数据控制</td><td>GRANT、REVOKE、…</td><td>包括事务控制、安全性控制等…</td></tr></tbody></table><h3 id="3、SQL对数据库三级模式的规定：每级模式由什么组成？">3、SQL对数据库三级模式的规定：每级模式由什么组成？</h3><p>一、数据库的三级模式</p><ol><li>物理模式<ul><li>整体数据库的物理结构</li><li>描述所有数据是如何在硬盘等介质上存储的</li></ul></li><li>逻辑模式<ul><li>整体数据库的逻辑结构</li><li>描述所有数据的结构以及所有数据间的联系</li></ul></li><li>子模式<ul><li>部分数据库的逻辑结构</li><li>描述某个特定用户能看到的那一部分数据的结构以及他们之间的联系</li></ul></li></ol><h3 id="4、理解SQL中的系统数据类型，char-varchar-numeric等。">4、理解SQL中的系统数据类型，char/varchar/numeric等。</h3><p>补充知识：SQL的数据类型<br>SQL-92标准中的部分数据类型如下：</p><ul><li>char(n) : 长度固定为n的字符串</li><li>varchar(n): 长度可变，最大长度为n的字符串</li><li>int: 整数</li><li>smallint: 短整数</li><li>numeric(p, q): 总共位数不多于p，小数点右边不多于q位的定点数</li><li>real: 浮点数</li><li>float(n): 精度至少为n位的浮点数</li><li>date: 日期(年, 月, 日)</li><li>time: 时间(时, 分, 秒)</li></ul><h3 id="5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。">5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。</h3><p>一、数据定义的对象</p><ul><li>数据库</li><li>关系（基本表）</li><li>视图</li><li>索引</li><li>用户域（数据类型）<br>二、数据定义功能语句</li></ul><table><thead><tr><th></th><th>创建</th><th>修改</th><th>销毁</th></tr></thead><tbody><tr><td>数据库</td><td>CREATE DATABASE</td><td>——</td><td>DROP DATABASE</td></tr><tr><td>关系</td><td>CREATE TABLE</td><td>ALTER TABLE</td><td>DROP TABLE</td></tr><tr><td>视图</td><td>CREATE VIEW</td><td>——</td><td>DROP VIEW</td></tr><tr><td>索引</td><td>CREATE INDEX</td><td>——</td><td>DROP INDEX</td></tr><tr><td>域</td><td>CREATE DOMAIN</td><td>——</td><td>DROP DOMAIN</td></tr><tr><td>三、SQL语法</td><td></td><td></td><td></td></tr></tbody></table><ol><li>基本表/关系的定义<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809162656.png" alt="Pasted image 20240809162656"></li><li>修改表/关系<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809162832.png" alt="Pasted image 20240809162832"></li><li>销毁关系   drop table 关系名<br><strong>注意</strong>：销毁关系后，关系的结构（属性/字段）和内容（元组/记录）都不再存在。依赖于这个关系的索引、视图也被销毁</li><li>新建索引<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809163303.png" alt="Pasted image 20240809163303"></li><li>销毁索引   DROP INDEX 索引名</li></ol><p>四、索引的有关概念<br>索引的基本概念：</p><ul><li>索引是一种常用的物理存储结构，作用包括：加快查询速度、保证某一列或几列的唯一性等</li><li>例如，在学生表的“年龄”字段上建立索引，可能加快带一类“年龄=？ 年龄&gt;? 年龄&lt; ?”条件的查询</li></ul><h3 id="6、掌握SQL的Select数据查询语句。掌握Like运算符的使用。">6、掌握SQL的Select数据查询语句。掌握Like运算符的使用。</h3><h4 id="一、基本语法结构">一、基本语法结构</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, A3,..., An</span><br><span class="line"><span class="keyword">FROM</span> R1, R2, R3, ..., Rn</span><br><span class="line">[<span class="keyword">WHERE</span> P]</span><br></pre></td></tr></table></figure><ul><li>SELECT相当于关系代数中的投影</li><li>FROM相当于关系代数中的笛卡尔积</li><li>WHERE相当于关系代数中的选择</li><li>执行顺序：FROM -&gt; WHERE -&gt; SELECT</li></ul><p><strong>细节</strong>：<br>SELECT后面，属性列表前面，可以加上关键字<strong>ALL或者DISTINCT</strong></p><ul><li>DISTINCT  表明结果中消去重复行</li><li>==ALL  表明结果中不去重==</li><li>默认为ALL</li></ul><p><strong>WHERE子句中可能出现的运算符号：</strong></p><ol><li>比较运算符：<ul><li><blockquote></blockquote></li><li>&lt;</li><li>=</li><li><blockquote><p>=</p></blockquote></li><li>&lt;=</li><li>&lt;&gt;</li></ul></li><li>逻辑运算符：<ul><li>and</li><li>or</li><li>not</li></ul></li><li>范围运算符<ul><li>between 下界 and 上界</li></ul></li><li>集合运算：<ul><li>in  集合；  例如： 姓名  in {‘小陈’, ‘小李’}</li><li>not in  集合</li></ul></li><li>匹配运算：<ul><li>like 匹配串（一个可能含有特殊字符的字符串）</li><li>%，通配符，匹配0个或多个字符串</li><li>_ ，通配符，匹配任意一个字符串</li><li>\\，转义字符</li></ul></li></ol><h4 id="二、汇合多个SELECT的查询语句（集合运算）">二、汇合多个SELECT的查询语句（<strong>集合运算</strong>）</h4><p>基本的集合运算：</p><ul><li>Union：并运算</li><li>Intersect：交运算</li><li>Except：差运算</li><li>all关键字表示不去重<br>集合运算要点：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">union</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">intersect</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">except</span> <span class="keyword">all</span> B</span><br><span class="line">A <span class="keyword">union</span> B</span><br><span class="line">A <span class="keyword">intersect</span> B</span><br><span class="line">A <span class="keyword">except</span> B</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>虽然 SQL 标准中支持 Intersect 和 Except ，许多实际的 DBMS 产品如 SQL Server 2000 及以前的版本， ACCESS 等，并不提供这两种运算符。</li><li>在这些 DBMS 实现中差运算或者交运算，应使用exist/in 和 not exist/not in 形式的嵌套子查询。</li></ul><h4 id="三、扩展基本结构">三、扩展基本结构</h4><ol><li>Group By子句<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809175842.png" alt="Pasted image 20240809175842"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180057.png" alt="Pasted image 20240809180057"><br>小结：</li></ol><ul><li>出现统计词（平均、最高,…）等问题，就需要考虑Group By<ul><li>如果还有“每…”，那么Group By   相应的属性</li><li>如果没有，那么Group By  无属性</li></ul></li></ul><ol start="2"><li>Having子句<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180257.png" alt="Pasted image 20240809180257"></li><li>Order By子句<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809180846.png" alt="Pasted image 20240809180846"></li></ol><p><strong>SELECT语句执行次序</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, A3, ...</span><br><span class="line"><span class="keyword">FROM</span> R1, R2, R3, ...</span><br><span class="line">[<span class="keyword">WHERE</span> P]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> A1, A2, A3, ...</span><br><span class="line"><span class="keyword">HAVING</span> P</span><br><span class="line">]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> A1 [<span class="keyword">DESC</span> <span class="operator">|</span> <span class="keyword">ASC</span>]</span><br><span class="line">  A2 [<span class="keyword">DESC</span> <span class="operator">|</span> <span class="keyword">ASC</span>]</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>执行次序：<br>From(笛卡尔积)-&gt;WHERE(选择)-&gt;GROUP BY(分组)-&gt;HAVING(筛选分组)-&gt;SELECT(投影)-&gt;ORDER BY(对结果进行排序)</p><h4 id="嵌套子查询">嵌套子查询</h4><ol><li>格式</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ..., (<span class="keyword">SELECT</span> 子查询) (<span class="keyword">AS</span>) 关系名...,</span><br><span class="line"><span class="keyword">FROM</span> ..., (<span class="keyword">SELECT</span> 子查询) (<span class="keyword">AS</span>) 关系名(属性<span class="number">1</span>, 属性<span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure><ul><li>新关系必须重命名，其属性也可以重命名</li></ul><ol start="2"><li>WHERE子句中用子查询构造条件<ul><li>条件1：判定一个值（比如属性值）是否在查询结果中   A [not in] (子查询)<br>意义：A是否出现在子查询的结果（多个值）之中？如果出现则为真，否则为假<br>要求：<strong>A往往是一个属性或表达式的值</strong>，此时子查询要相当于一个值的集合。即<strong>子查询可以有多个元组，但==只能有一个属性==</strong></li><li>条件2：将一个值（比如属性值）与查询结果作比较<br>A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>(比较运算 &gt;, &lt;, =, …)some|all(子查询)<br>意义：<ul><li>some : A与子查询的结果中的一个值满足比较条件时为真</li><li>all：A与子查询的结果中的所有值满足比较条件时为真<br>要求：A是一个值，而子查询的结果是一个值的集合。子查询可以有多个元组，但是只能有一个属性</li></ul></li><li>条件3：判定子查询的结果是否存在（至少一条）记录<br>格式（exist运算符）<br>[not] exists (子查询)<br>意义：子查询结果存在（至少一条）记录<br>要点：<ol><li>子查询的结果关系，不要求只有一个属性，可以有多个属性（exists是对记录数的判断，和属性无关）</li><li>子查询可引用付查询关系的属性（此时最好标明关系前缀），作为子查询的“参数”。这一点对于其他类型（in, some, all）的子查询也是使用的</li></ol></li></ul></li><li>子查询的注意事项：<ul><li>子查询会降低执行速度：<ul><li>同一个问题，用子查询，和不用子查询相比，速度可能更慢，甚至慢若干数量级，最好的情况是两者相等。即使考虑到必要的查询优化，这个结论也是成立的。</li><li>如果子查询带参数，情况会更糟糕</li></ul></li><li>慎用子查询，特别是带参数子查询，<strong>大多数的子查询都可以用复杂的连接条件等价表示</strong>，但是少数情况下，比如DBMS不支持的交、差运算，只能用子查询</li></ul></li></ol><h4 id="连接关系">连接关系</h4><p>一、连接的基本概念<br>在From子句中的两个相邻关系之间，可以是一个逗号——表示进行笛卡尔积运算（无条件链接）；也可以是一个连接运算 —— 表示按照指定条件进行连接。</p><p>二、连接运算的类型<br>内连接：</p><ul><li>格式： A [inner] join B on 条件</li><li>内连接的结果不包含失配元组<br>左外连接：</li><li>格式：A left [outer] join B on 条件</li><li>左外连接的结果包含左边关系的失配元组<br>右外连接：</li><li>格式：A right [outer] join B on 条件</li><li>右外连接的结果包含右边关系的失配元组<br>全外连接：</li><li>格式：A full [outer] join B on 条件</li><li>全外连接的结果包含两边关系的失配元组</li></ul><p>三、多个表的连接<br>格式：<br>A [left | right] join B on 条件1<br>[left | right] join C on 条件2<br>[left | right] join D on 条件3<br>[left | right] join E on 条件4<br>…<br>关系A和关系B按照条件1连接后，得到结果关系，再和关系C作连接，但是系统在具体执行时，可能会为了优化而改变连接顺序，但是最终结果是一样的！<br>注意：<br>所以条件 1 应该是关系 A 、 B 的属性比较，条件 2 则可能是 A+B 的属性与关系 C 的属性比较 ( 上一步 A, B已经连接成一个关系了 )</p><h4 id="7、掌握SQL的各个数据修改语句：-Insert-Update-Delete。">7、掌握SQL的各个数据修改语句： Insert, Update, Delete。</h4><p>一、基本概念<br>SQL的数据修改功能，指对表的元组（记录）进行修改。又分为以下三个操作：</p><ol><li>插入元组，用insert语句实现</li><li>删除元组，用delete语句实现</li><li>更新元组（的属性值），用update语句实现<br><strong>注意</strong>：如果是针对属性进行修改，请用alter table语句</li></ol><p>二、插入操作语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条新纪录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...)] <span class="keyword">values</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多条新纪录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名[(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...)] <span class="keyword">select</span> 字段s1, 字段s2, ...</span><br><span class="line"><span class="comment">-- 新纪录的个数和值来自select的查询结果</span></span><br></pre></td></tr></table></figure><p>三、删除操作语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> 关系 [<span class="keyword">WHERE</span> 条件]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>从表中删除符合条件的元组。如果不写where条件，则删除全部元组（<strong>但表的结构如字段、主码等保留</strong>）</li><li>一次只能删除一个关系中的元组</li><li>找到全部符合条件的记录后再一起删除<br>四、更新操作语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line"><span class="keyword">Set</span> 字段<span class="number">1</span> <span class="operator">=</span> 表达式<span class="number">1</span></span><br><span class="line">[, 字段<span class="number">2</span> <span class="operator">=</span> 表达式<span class="number">2</span>]</span><br><span class="line">......</span><br><span class="line">[<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在表中找到满足where条件的记录（如果没有where条件，就默认是全部记录），然后更新。</li><li>set子句说明怎么更新记录：更新哪些字段、以及更新后的值（表达式的结果）</li><li>同样是全部找到符合条件的记录后再一起更新</li></ul><h3 id="8、空值的意义。空值的判定方法（IS-NULL）。掌握空值的运算规则（包括聚集函数忽略空值等），能计算一个包含空值式子的结果。">8、空值的意义。空值的判定方法（IS NULL）。掌握空值的运算规则（包括聚集函数忽略空值等），能计算一个包含空值式子的结果。</h3><p>一、空值的意义<br>空值表示两种情况：</p><ol><li>值不存在</li><li>值未知</li></ol><p>二、空值的计算<br>空值参与各种运算，被当做一个未知的值。</p><ul><li>算数运算出现空值，结果一定是null</li><li>比较运算出现空值，结果一定是unknown</li><li>布尔运算中出现空值，把空值替换为unknown再计算（结果为true/false/unknown）<br><strong>对于一个表达式，如果最后一步计算得到的结果是unknown，那么就替换为false</strong><br>下面这里例子中，比较运算null &lt; 20返回unknown，所以最终结果为false，所以不会选择王小明<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240809213320.png" alt="Pasted image 20240809213320"></li></ul><p>三、聚集函数与空值的关系</p><ul><li>聚集函数除了count(*)以外都忽略空值</li><li>count(*)会统计<strong>记录</strong>的个数，也会把空值算在内</li></ul><p>四、空值的判定<br>格式： A is null<br>其中A是属性值或表达式<br><strong>不能用=null判断空值</strong></p><h3 id="9、熟记视图的优点。并理解！！！">9、熟记视图的优点。并理解！！！</h3><p>一、视图的基本概念<br>视图的定义：</p><ul><li>视图是一个命名，是用查询从基本表中导出的基本表</li><li>==视图的本质：命名查询==。真正存在、存储在数据库里的是视图的名字和对应的查询（视图的定义）</li><li>视图的表象：虚拟表。<br>逻辑上，对用户而言视图与基本表无差别，都可以查询/修改；<br>物理上，表中的数据/记录平时并没有存储在数据库里，而是用到的时候才执行查询算出来；</li></ul><p>对视图的理解：</p><ol><li><strong>每次访问视图都要重新计算一次“查询”</strong>，<strong>以获取最新的内容</strong>。所以当（查询）相关基本表发生改变后，我们再去访问视图，看到的虚拟表也会相应的变化。</li><li>用户对视图的查询（编写的Select语句），系统在执行时必须转化为对相关基本表的查询——用户不知道视图这个“表”不存在，但系统是知道的。</li><li>用户对视图的修改（Insert、Update、Delete），系统在执行时必须转化为对相关基本表的修改。</li></ol><p>物化视图：<br>概念：在某些数据库系统中，允许视图某一时刻的内容（当时的查询结果关系）真正存储起来，这样的“快照”称为物化视图。<br>优点：</p><ul><li>访问快，避免了每次计算查询结果的过程<br>缺点：</li><li>只反映基本表当时的查询结果，所以基本表变化后要考虑<strong>同步的问题</strong><br>适用场合：读多于写</li></ul><p>==二、视图的优点==</p><ol><li>简化用户操作（比如，物理老师有专门的物理成绩单，不需要每次编写对选修表的查询才查询到物理成绩单）</li><li>个性化服务<br>为不同用户量身打造不同的数据（视图）</li><li>安全性<br>限制用户访问的数据范围为他所需要的数据</li><li>逻辑独立性<br>提供了从模式（基本表）到子模式（视图）的映像<br>视图往往只抽取基本表的一部分数据。所以如果不相关的基本表数据的结构发生了变化（模式改变），不会影响到视图（子模式不变）和面向此视图的应用程序（应用程序也不变），即逻辑独立性</li></ol><h3 id="10、掌握定义视图的语句。什么是视图的嵌套定义？">10、掌握定义视图的语句。什么是视图的嵌套定义？</h3><p>一、视图定义语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 新建视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 [(属性名&#123;,属性名&#125;)] <span class="keyword">as</span> (<span class="keyword">Select</span>查询) [<span class="keyword">with</span> <span class="keyword">check</span> option]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>视图的属性可以显示命名，也可以缺省查询结果中的属性名（推荐这个，要更名在select查询中更名）</li><li>with check option：当对视图进行插入、更新时，要检查新元组是否满足视图对应查询的条件（出现在哪个子句），否则拒绝</li></ul><p>==二、视图的嵌套定义==</p><ul><li>定义视图A时，可以在对应查询中<strong>使用其他已有的视图</strong>，比如B、C。此时我们说视图A是定义在视图B、C上的</li><li>这又称视图的嵌套定义</li></ul><h3 id="11、理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：执行时展开视图——替换视图为它所对应的查询。视图的修改：执行时转化为对基本表的修改，这种转化可能因为哪些原因失败，从而无法修改-修改受限）。所以，视图是不可能提高查询效率的，但可以简化查询的书写（把整个查询或者其中固定的部分预先做成一个视图）">11、理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：执行时展开视图——替换视图为它所对应的查询。视图的修改：执行时转化为对基本表的修改，这种转化可能因为哪些原因失败，从而无法修改/修改受限）。所以，视图是不可能提高查询效率的，但可以简化查询的书写（把整个查询或者其中固定的部分预先做成一个视图）</h3><p>一、视图的操作</p><ol><li>视图的查询<br>用户可以像基本表一样（写SQL语句）查询视图；<ul><li>系统收到这样的SELECT查询后，必须转化成对基本表的查询，方法是展开视图——用定义中的查询取代视图本身；</li><li>如果展开一个视图后，（它定义中的）查询又还出现了其他视图，那么继续展开，直到没有任何视图为止；</li></ul></li><li>视图的修改<br>用户可以向基本表一样（写Insert、Delete、Update语句）修改视图<ul><li>系统收到这样的修改后，必须转化为对基本表的修改；</li><li>这种转化有时能成功——视图可修改，有时失败——视图不可修改，因此<strong>我们对视图的修改是受限的</strong></li></ul></li></ol><p>二、什么样的视图可以被修改？</p><ul><li>用查询从单个基本表（From子句只有一个表）抽取一部分元组（Where子句）和一部分属性（Select子句）所构造的视图，称为行列子集视图。<strong>且这一部分属性包含了候选码，没包含的其它属性上没有not null等约束</strong></li><li>原因：修改这样视图的一个记录，可以在基本表找到对应的一条源记录然后进行修改（<strong>逆映射</strong>）。方法为按视图记录中包含的候选码值进行查找。</li></ul><p>三、什么样的视图不能被修改？<br>不能被修改的根本原因：</p><ol><li>无法逆映射（字段名找不到、不能唯一确定一个元组）</li><li>视图中一个元组，基本表中多个满足条件的元组（无法确定修改哪一个以及修改多少个）<br>不能被修改的情况：</li><li>Select子句中选出的属性不包含候选码（无法逆映射）</li><li>Select子句中使用distinct关键字（基本表中有多条记录，但是视图中只有一条记录）</li><li>有group by子句或出现聚集函数（基本表中多条记录，但是视图中一条记录）</li><li>包含用表达式构造的新属性（无法进行逆映射，找不到对应字段）</li><li>From中列出多个关系（无法进行逆映射，找不到对应元组）</li></ol><p>12、嵌入式SQL不要求。<br>13、应用题型（必考！！！参考作业）：用SQL表达查询问题（看查询习题课件）。用SQL建表，建视图等定义语句。第二、三章的应用题型（查询表达等）占30分。</p><h2 id="第七章-数据库设计和E-R模型">第七章 数据库设计和E-R模型</h2><h3 id="1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。">1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。</h3><p>一、E-R模型<br>E-R模型的建模思想：现实世界可以建模为具有属性的实体的集合以及这些实体间的联系<br>建模可以理解为：用…描述</p><p>E-R模型的基本元素：</p><ul><li>实体：客观存在的并可以与其他相<strong>区分</strong>的某一物体<br>实体集是实体的集合(×)<br>实体集是同类型实体的集合(√)</li><li>属性：实体区分于其他实体所具有的属性；实体集中每个实体都拥有的，起描述作用的性质<br>特殊类型的属性：<br>1. 复合属性：可以划分为其他更小的属性（成分属性），比如Parents就是一个复合属性<br>2. 多值属性：可以分解为不止一个值的属性，分解后的个数不确定，比如Phone-numbers属性是多值的，因为可以有多个<br>3. 派生属性：可以从其他属性（基属性）计算得来，例如tax = salary * 0.05</li><li>联系：联系是实体间的相互关联<br>联系集：联系集是相同类型的联系的集合。<br>相同类型：这些联系涉及相同数量的实体，且来自同一序列的实体集<br><strong>联系可能发生在同类型实体之间，即一个实体集内部彼此之间有联系</strong>（同类实体参与联系时，发挥的作用/角色可能不同，比如雇佣关系）<br>联系集的属性：联系集也可以有其描述作用的属性<br>例如：borrow联系集可以用borrow-date属性<br>联系的度：参与联系集的实体集的个数（次数），比如borrow联系集涉及到customer和loan，度为2，称为二元联系集；三元及以上的联系集较少</li></ul><p>其他相关元素：</p><ul><li>参与：参与是指实体集与联系集之间的关联。如果联系集R涉及到实体集E1，E2，…,En，那么等于说实体集E1，E2，…,参与了联系集R。（例如：实体集customer和loan参与联系集borrower）<br><strong>注意</strong>：一个实体集能两次参与同一个联系集吗？<br>例子：work-for = customer : customer 这一联系集<br>参与的类型：<br>1. 完全参与：如果E中全部实体都参与R中的联系，那么E对R的参与就是完全的<br>2. 部分参与：如果实体集E中的某些实体不参与联系集R中的任何联系，那么这种参与就是部分的</li><li>角色：实体集参与联系集时发挥的作用。<ul><li>如果实体集仅参与联系集一次，那么它只有一个角色且隐含在名字中，不用特别注明</li><li>如果实体集参与联系集两次或以上，那么相应地，它有两个或以上的角色。这是单靠实体的名字无法区分这些角色，需要单独说明每次以什么角色参与</li></ul></li><li>映射基数：表示某一实体通过联系集能够和几个其他实体关联（1对1，1对多，多对多）</li><li>码</li></ul><h3 id="2、三种特殊类型的属性，并能够判断。">2、三种特殊类型的属性，并能够判断。</h3><p>特殊类型的属性：</p><ol><li>复合属性：可以划分为其他更小的属性（成分属性），比如Parents就是一个复合属性</li><li>多值属性：可以分解为不止一个值的属性，分解后的个数不确定，比如Phone-numbers属性是多值的，因为可以有多个</li><li>派生属性：可以从其他属性（基属性）计算得来，例如tax = salary * 0.05</li></ol><h3 id="3、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。">3、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。</h3><p>一、映射基数</p><ul><li><p>映射基数表示某一实体集通过联系集能够和几个其他实体集关联，在描述二元联系集时特别有用。</p></li><li><p>假设在实体集A和B之间有二元联系集R，它的映射基数必是以下之一：</p><ol><li>一对一联系（丈夫：妻子）<ul><li>A的每个实体，最多和B的一个实体相联系（可以是1个，也可以是0个）</li><li>B的每个实体，最多和A的一个实体相联系</li></ul></li><li>一对多联系（公司：部门）<ul><li>A的每个实体，和B的任意多个实体相联系（可以是0， 1， 2，…个）</li><li>B的每个实体，最多和A的一个实体相联系</li></ul></li><li>多对一联系（院系：学校）<ul><li>一对多反过来就是多对一</li></ul></li><li>多对多联系（学生：课程）<ul><li>A的每个实体，可以和B的任意多个实体联系</li><li>B的每个实体，可以和A的任意多个实体联系</li></ul></li></ol></li></ul><p>二、在E-R图中如何表示映射基数</p><ul><li>从联系集到“一”方实体集，画一条有向线，箭头指向“一”方实体集</li><li>从联系集到“多”放实体集，画一条无向线</li><li>巧记：箭头所指的方向是“一”方实体集</li></ul><p>三、补充：判断多元联系的映射基数<br>多元联系：E1 : E2 : E3 : … = ? : ? : ? : …</p><ul><li>Ei是“一”方的条件：对于每个非Ei的实体集Ej，Ej的每个实体最多对应Ei的一个实体</li><li>Ei是“多”方的条件：对于每个非Ei的实体集Ej，Ej的每个实体可对应Ei的任意多个实体</li></ul><p>四、实体的码</p><ol><li>超码：特殊的单个属性或属性集合，它的值可以唯一标识实体集里的每个实体</li><li>候选码：最小的超码</li><li>主码：虽然在一个实体集里可能存在几个候选码，但是只选出一个作为主码</li></ol><h3 id="4、能将E-R图转化为关系模型。注意：多值属性的处理（如果有n个多值属性，n个分开来处理）；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。">4、能将E-R图转化为关系模型。注意：多值属性的处理（如果有n个多值属性，n个分开来处理）；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。</h3><p>一、用户需求转化为E-R图<br>基本过程：</p><ol><li>找出实体集：实体集的属性、主码</li><li>找出联系集：参与、角色、映射基数</li><li>画出E-R图</li></ol><p>二、E-R模型转化为关系模型（in 逻辑设计）</p><ul><li>E-R模型的基本元素：实体、联系、属性</li><li>关系模型基本元素：关系、属性</li><li>E-R模型到关系模型：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810102757.png" alt="Pasted image 20240810102757"></li><li><strong>方法</strong>：<ol><li>实体 —&gt; 关系，属性 —&gt; 属性：<br>每个实体转化为一个关系，实体属性转化为该关系的属性，实体的主码转化为该关系的主码；<br><strong>消除多值属性，否则违反第一范式：多值属性移出去形成一个新关系，这个新关系包含原来的主码（新关系的主码为这两者之和）</strong></li><li>联系 —&gt; 关系/属性：<br><strong>一对一联系</strong>：转化为新属性，方法是将某“一”方关系的主码，与联系自身属性一起，添加到另一个“一”方关系里面（属性可以更名）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810104914.png" alt="Pasted image 20240810104914"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810104942.png" alt="Pasted image 20240810104942"><br><strong>一对多联系/多对一联系</strong>：转化为新属性，方法是将“一”方关系的主码与联系自身的属性加到“多”方关系中（属性可更名）<br><strong>多对多联系</strong>：转化为一个新关系，新关系的属性包括两个“多”方的主码，以及联系自身的属性<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240810105224.png" alt="Pasted image 20240810105224"><br><strong>三元及以上的联系</strong>：转化为一个新关系，其属性包括<strong>各个设计实体的主码</strong>和联系自身的属性</li></ol></li></ul><h3 id="5、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？">5、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？</h3><p>一、数据库设计过程<br>第一阶段：用户需求分析</p><ul><li>与应用领域专家、数据库用户广泛地交流，获得用户预期的数据和功能需求</li><li>结果：得到用户需求说明书<br>第二阶段：概念设计</li><li>将用户需求转化为选定的某种概念模型（常见的是E-R模型）</li><li>结果：得到数据库概念模式（常见的是E-R模型表示的概念模式）<br>第三阶段：逻辑设计</li><li>将概念模型转化为选定的某种数据模型（常见的是关系型模型）</li><li>结果：得到（以关系模型表示的）数据库逻辑模式<br>第四阶段：物理设计</li><li>在上阶段得到逻辑模式的基础上，补充定义数据库的物理特征。比如索引、内部存储结构、文件组织方式等</li><li>结果：得到数据库的物理模式<br><strong>注意</strong>：<br>在设计数据库时，要尽量避免两个方面的问题：</li></ul><ol><li>冗余</li><li>表达不完整：某些特定的信息无法存储。比如，如果我们选择在选修表中保存课程的全部或大部分信息，那一门没人选的课将无法插入到数据库</li></ol><p>6、应用题型（必考！！！参考作业）：<br>a)给出用户需求，画E-R图（概念设计）。<br>b)将E-R图转化为关系模型（逻辑设计）。</p><h2 id="第八章-关系数据库模式设计">第八章  关系数据库模式设计</h2><h3 id="1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。">1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。</h3><p>一、坏的关系模式可能出现的四种问题</p><ol><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常<br>产生问题的原因：不良的数据依赖。</li></ol><h3 id="2、理解函数依赖X→Y的含义。掌握判定函数依赖的方法（以课件的“排课”关系为例）。">2、理解函数依赖X→Y的含义。掌握判定函数依赖的方法（以课件的“排课”关系为例）。</h3><p>一、数据依赖的基本概念</p><ul><li>数据依赖是一种数学工具，刻画了（同一关系内）属性间的联系</li><li>最常见的数据依赖：函数依赖 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，其中X，Y是属性值<ul><li>一个X对应一个Y</li><li>X值相等则Y也相等</li></ul></li><li>其他类型的数据依赖：多值依赖、连接依赖等等</li></ul><p>二、函数依赖的定义</p><ol><li>相关符号：<ul><li>r：一个关系模式</li><li>R：r的全部属性，此时r又可以写作r®</li><li>X，Y：R的子集</li></ul></li><li>定义：<br>关系模式r上存在以下函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，读作：X函数确定Y/Y函数依赖X/X是Y的决定元素<br>条件：当且仅当两个元组如果在属性集X上相等，则它们在属性集Y上也相等（同一个X值只对应一个Y值）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>⇒</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mo>→</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t_1[X]=t_2[X] \Rightarrow t_1[Y] \to t_2[Y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">]</span></span></span></span>，这对r在任何时间的任何实例上都成立</li></ol><h3 id="3、三对特殊类型的函数依赖：平凡-非平凡，部分-完全，传递-非传递。根据定义去理解和判定它们。">3、三对特殊类型的函数依赖：平凡/非平凡，部分/完全，传递/非传递。根据定义去理解和判定它们。</h3><p>一、平凡/非平凡的函数依赖</p><ol><li>平凡的函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \to Y, Y \subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，（右边的属性，每个都在左边出现）<br>平凡的函数依赖的定义决定了它必然成立</li><li>非平凡的函数依赖：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \to Y, Y\nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><br>非平凡的函数依赖不一定成立</li></ol><p>二、部分/完全的函数依赖</p><ol><li>部分的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>：存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X` \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X` \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>成立<ul><li>理解：左边的一部分就能决定右边</li></ul></li><li>完全的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>：不存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>⊂</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X` \subset X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X` \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>成立<ul><li>理解：不存在左边的一部分可以决定右边，一定要左边的全部才能</li></ul></li></ol><p>三、特殊类型的函数依赖：传递、非传递</p><ol><li>函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是传递的，当<ul><li>存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Z, Z \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>同时成立，<strong>但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Z \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>不成立（Z不是X的等价因素）</strong></li><li>理解：左边和右边是间接的决定关系，存在中间元素</li></ul></li><li>函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是非传递的，当<ul><li>不存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mi>Z</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Z, Z \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>同时成立，<strong>但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Z \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>不成立（Z不是X的等价因素）</strong></li><li>理解：左边和右边是直接的决定关系，不存在中间元素</li></ul></li><li>证明：如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是部分函数依赖，那么它也是传递的</li></ol><h3 id="4、用函数依赖判断一个属性集是否超码，或者是否候选码的方法。">4、用函数依赖判断一个属性集是否超码，或者是否候选码的方法。</h3><p>一、码和函数依赖<br><strong>超码</strong><br>在关系r®中：</p><ol><li>属性（组）K是一个超码，当且仅当：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span><br><strong>候选码</strong></li><li>属性（组）K是一个候选码，当且仅当：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K \to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>且任何K的真子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>都不满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">K`\to R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li></ul></li></ol><p>二、坏的函数依赖——对候选码的部分/传递依赖</p><ol><li>对候选码的部分函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span><ul><li>存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K` \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">K`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">‘</span></span></span></span>无唯一性，会引起冗余</li></ul></li><li>对候选码K的传递函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span><ul><li>存在Z，使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>Z</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K \to Z \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，但<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">Z \to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>不成立</li><li>Z不是超码（否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">Z \to R \to K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>成立），这种情况也会产生冗余</li></ul></li></ol><h3 id="5、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。">5、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。</h3><p>一、函数依赖集的闭包</p><ul><li>r®：一个关系模式，R为全部属性</li><li>F：r满足的（若干个）函数依赖的集合</li><li>从F推出（又称逻辑蕴含）其他函数依赖</li><li>从一个函数依赖集F推出的全部函数依赖（包括F自身）的全集，就是F的闭包，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><br>二、计算函数依赖集的闭包——Armstrong公理<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240811100631.png" alt="Pasted image 20240811100631"><br><strong>实际上</strong>，找到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中的所有函数依赖是非常复杂的工作，意义也不大。<br>更常见和重要的是给出一些函数依赖（F），判断另一个函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是否成立（在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中）</li></ul><p>三、属性集的闭包<br>r®： 一个关系模式<br>F：r所满足的函数依赖集合<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>：r中一个或多个属性的集合</p><p>属性集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>的闭包：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>能决定的全部属性的全集，包括<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>自身。记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>α</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">\alpha_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>A</mi><mo>⇒</mo><mi>A</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mtext> </mtext><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \to A \Rightarrow A\ is\ in\ \alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal">in</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></p><p><strong>判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是否成立，等价的方法是判断<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是否在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中</strong></p><h3 id="6、最小函数依赖集不要求。4-3这一节不要求。">6、最小函数依赖集不要求。4.3这一节不要求。</h3><p>一、函数依赖集的等价和覆盖<br>函数依赖集的关系——等价和覆盖</p><ol><li>函数依赖集的覆盖<br>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>⊆</mo><msup><mi>G</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+ \subseteq G^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9073em;vertical-align:-0.136em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>时，称G覆盖F<br>简言之，F能推导出（逻辑蕴含）的，也能被G推导出，G的表达能力强于F</li><li>函数依赖集的等价<br>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>=</mo><msup><mi>G</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+=G^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，称G和F等价<br>简言之，F、G能相互推导出，它们的表达能力一样</li><li><strong>最小函数依赖集</strong>（==最小覆盖就是最小函数依赖集==）<br>函数依赖集F的最小覆盖，是与F等价、且满足以下条件的函数依赖集，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li>单属性化：F中任意函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，右边A必是单属性</li><li>无冗余化：F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，使得F与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>−</mo><mo stretchy="false">{</mo><mi>x</mi><mo>→</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F-\{x\to A\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span></span></span></span>等价(即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>多余)</li><li>既约化：F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，X重写为真子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">X`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord">‘</span></span></span></span>后，变化后的F与原来等价<br>任何一个给定的函数依赖集F，必定存在最小覆盖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（可通过方法找到），但可能会有多个</li></ul></li></ol><p>二、求最小函数依赖集</p><ol><li>逐一检查 F 中各函数依赖 : X→Y ，若 Y=A1A2 …Ak，则替换为 X→A1 ， X→A2 ，…， X→Ak—— 单属性化：右边多个属性的，拆分成单个属性 ( 左边不变 )</li><li>逐一检查 F 中各函数依赖： X→A ，若去掉 X→A 后，仍有 A <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">⊆</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">X^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> ，则删去该函数依赖—— 去冗余化：检查是否有函数依赖多余，即可从其它导出</li><li>逐一检查 F 中各函数依赖： X→A ，若 X=B1B2…Bm ， 考虑左边能否用 X-Bi (i=1,2,…,m) 取代 X ，即 A 是否在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>−</mo><msub><mi>B</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">(X-B_i)^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span><br>—— 既约化：每个函数依赖，看减少左边的某个属性后，是否仍成立。</li></ol><p>三、正则覆盖<br>对 F 的最小函数依赖集，其中左半部相同的函数依赖（右半部）作合并，即得到 F 的正则覆盖。</p><h3 id="7、掌握1NF、2NF、3NF、BCNF的定义-要求，并能依此进行判定。">7、掌握1NF、2NF、3NF、BCNF的定义/要求，并能依此进行判定。</h3><p>一、范式的基本概念</p><ol><li>为什么要使用范式<br>范式能够帮助我们判断一个关系模式的好坏，是否有不良的数据依赖，越高级的范式表示越好的关系，不良数据依赖越少</li><li>范式的概念：范式是数据依赖满足一定要求的所有关系模式的全集</li><li>不同范式之间的联系：高级范式是低级范式的真子集<br>范式从从低到高，要求也从低到高，满足高要求的关系（属于高级范式），肯定也满足低要求（属于低级范式）</li></ol><p>二、相关术语</p><ol><li>码属性（主属性）<br>一个属性出现在某个候选码中，码特指候选码</li><li>非码属性（非主属性）<br>一个属性，不出现在任何候选码中</li><li>码的一部分：候选码的真子集</li><li>超码：具有唯一性的属性组，从超码中去掉多余属性可得到候选码</li></ol><p>三、第一范式（1NF）</p><ol><li>要求：关系模式的每个属性都是原子的</li><li>判断方法：逐个属性分析，如果遇到多值属性则不满足1NF</li></ol><p>四、第二范式（2NF）</p><ol><li>要求：关系模式在1NF中<br>每一个非码属性完全函数依赖于码</li><li>判断：检查码以外的每个属性A所依赖的X（即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>），若X是候选码的一部分，违反2NF</li></ol><p>五、第三范式（3NF）</p><ol><li>要求：关系模式在1NF中<br>每一个非码属性非传递函数依赖于码</li><li>判断：检查码以外的每个属性A所依赖的X（即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>），若X不包含码（不是超码），违反3NF<br>推导：码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>X</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>A</mi><mo separator="true">,</mo><mi>X</mi><mo>↛</mo><mi>K</mi><mo separator="true">,</mo><mi>K</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">K\to X, X\to A, X \nrightarrow K, K \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，所以A传递函数依赖于K</li></ol><p>六、BC范式</p><ol><li>要求：关系在1NF中<br>每一个属性（码属性，非码属性）不传递函数依赖于码（也没有任何属性部分函数依赖于码，因为非传递函数依赖一定能推到出非部分函数依赖）<br>充要条件：每一个非平凡函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，无论Y是什么，X必含码<br>证明：若X不含码，码<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>X</mi><mtext>且</mtext><mi>X</mi><mo>↛</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">K\to X且X \nrightarrow K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>，又有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，所以存在传递函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">K\to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></li></ol><p>七、三种范式的比较以及判定</p><ol><li>三种范式的比较<br>2NF保证函数依赖：如果右边非码属性，则左边不会是码的一部分<br>3NF保证函数依赖：如果右边非码属性，则左边含有码（或&gt;=码）<br>BCNF保证函数依赖：右边不论是码属性还是非码属性，左边必含有码</li></ol><ul><li>到了BCNF，任何有意义、非平凡的函数依赖都是好的，右边无论是什么，左边都具有唯一性（超码含码）</li><li>但是，虽然BCNF中所有函数依赖都是好的，可能还有不好的其他依赖，比如多值依赖…因此BCNF不是最高级的范式，往上还有4NF…</li></ul><p>八、认识</p><ul><li>低级范式肯定有问题，高级范式问题相对较少，但仍然可能有问题。</li><li>我们往往不期望完美的关系模式——最高范式、没有任何问题；<br>而是期望“足够好”的关系模式，到达足够高级别的范式、是问题在容忍范围内最少</li></ul><h3 id="8、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。">8、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。</h3><p>一、关系模式规范化（如何让关系达到更高的范式？）<br>方法：分解</p><ul><li>把个属于低级范式的坏关系，分解成几个属于高级范式的好关系</li><li>但是某些情况下分解会带来信的问题，比如信息丢失，这样的分解是不正确的（无损连接…）<br>确保分解方案的正确性：</li><li>无损连接分解（不丢失信息）</li><li>不丢失函数依赖的分解，但某些场合允许丢失<br>规范化：将一个属于低级范式的“坏”关系，分解为多个属于高级范式的“好”关系，且无信息丢失的过程</li></ul><p>二、无损连接分解的判断<br>判定“一分为二”是否为无损连接分解的充分必要条件：</p><ul><li>将关系r分解为r1和r2，这种分解是无损的条件是以下两个函数之一能够成立：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mn>1</mn><mo>∩</mo><mi>r</mi><mn>2</mn><mo>→</mo><mi>r</mi><mn>1</mn><mo>−</mo><mi>r</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">r1 \cap r2 \to r1 - r2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mn>1</mn><mo>∩</mo><mi>r</mi><mn>2</mn><mo>→</mo><mi>r</mi><mn>2</mn><mo>−</mo><mi>r</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">r1 \cap r2 \to r2 - r1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">1</span></span></span></span></li></ul><p>三、规范化到1NF<br>方法：将关系中每个非原子的属性转化为原子的<br><strong>复合属性</strong>的处理：转化为若干个（成员）原子属性<br><strong>多值属性</strong>的处理：移出去形成一个新的关系，同时包含原来的主码，==新关系的主码为这两者之和==</p><p>四、规范化到3NF<br>方法步骤：</p><ol><li><strong>先求出最小函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">F_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></li><li>求候选码<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603002339.png" alt="Pasted image 20240603002339"></li></ol><p>五、规范化到BCNF<br>分解成BCNF并且无损连接的算法<br>给定关系模式R&lt;U , F&gt; ，<br>⒈令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> = {R&lt;U , F&gt;}<br>⒉检查<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中各关系模式是否属于BCNF，若是，则算法终止。<br>⒊设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中Ri&lt;Ui , Fi&gt;不属于BCNF，<br>则存在函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi><mo>∈</mo><msubsup><mi>F</mi><mi>i</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X\to A \in F_i^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4231em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span></span>，且X不是Ri的码，<br>XA是Ri的真子集，将Ri分解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>={S1，S2}，<br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>S</mi><mn>1</mn></mrow></msub><mo>=</mo><mi>X</mi><mi>A</mi><mtext>，</mtext><msub><mi>U</mi><mrow><mi>S</mi><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>U</mi><mi>i</mi></msub><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">U_{S1}  = XA， U_{S2}  = U_i - {A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span></span></span></span></span><br>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>代替Ri ，返回到⒉</p><p>证明无损连接性：</p><p>\displaylines{\because U_{S1} = XA,\ \ U_{S2} = U_i - {A} \\ \therefore U_{S1} \cap U_{S2} = X \\U_{S1} - U_{S2} = A \\\therefore U_{S1} \cap U_{S2} \to U_{S1} - U_{S2} \\得证}</p><p>例题：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603091647.png" alt="Pasted image 20240603091647"></p><p>9、多值依赖不要求。</p><p>10、应用题型（必考！！！参考作业）：给出关系和函数依赖<br>a)找出候选码，并证明。<br>b)判断某个函数依赖是否成立，给出证明。<br>c)判断关系所属的最高范式，给出证明。<br>d)将关系规范化到3NF，或者BCNF<br>e)判断一个分解是否无损依赖，给出证明</p><h2 id="补充-数据库安全性与完整性">补充  数据库安全性与完整性</h2><h3 id="1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户及合法操作产生的。">1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户及合法操作产生的。</h3><p>一、安全性和完整性辨析：</p><ol><li>非法用户：安全性（未授权用户进入了数据库系统）</li><li>非法操作：安全性（已授权的用户执行了超出其权限的范围的操作）</li><li>非法数据：合法用户的合法操作，也可能产生错误的数据，例如负的年龄</li></ol><p>二、安全保护技术</p><ol><li>基于视图的技术<br>为不同需求的用户打造不同的视图</li><li>基于访问控制的技术<ul><li>控制每一个用户对数据库的访问，都在事先允许的范围内</li><li>实现方法：<ol><li>用户身份鉴别</li><li>用户权限管理</li><li>用户权限验证</li></ol></li></ul></li><li>审计追踪技术<ul><li>记录用户访问数据库的全过程</li></ul></li></ol><h3 id="2、掌握用SQL授予权限和回收、禁止权限的语句-grant-revoke-deny-。with-grant-option子句的作用。">2、掌握用SQL授予权限和回收、禁止权限的语句(grant, revoke, deny)。with grant option子句的作用。</h3><p>一、SQL授权机制</p><ol><li>授权命令格式</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限[,...n] <span class="keyword">on</span> 对象名 <span class="keyword">to</span> 用户[,...n] <span class="operator">|</span> public [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">to</span> 教务员王 <span class="keyword">with</span> <span class="keyword">grant</span> opetion</span><br><span class="line"><span class="comment">--教务员王有对选修表的查询、更新权限，并且可以转授</span></span><br></pre></td></tr></table></figure><ul><li>public代表所有用户</li><li>with grant option代表用户可以把获得的权限转授</li></ul><ol start="2"><li><p>权限类型</p><ul><li>CREATE</li><li>SELECT</li><li>INSERT</li><li>DELETE</li><li>UDATE</li><li>REFERENCE：针对表，表示可以引用该表的主码来定义其他表的外部码</li><li>ALL：对象上的所有权限</li></ul></li><li><p>数据对象的类型</p><ul><li><strong>SCHEMA：数据库模式</strong></li><li>TABLE：基本表</li><li>VIEW：视图</li><li>ATTRIBUTE：属性</li></ul></li></ol><p>二、回收权限</p><ol><li>命令格式</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限[,...n] <span class="keyword">on</span> 对象名 <span class="keyword">from</span> 用户[,...n] <span class="operator">|</span> public [CASCADE <span class="operator">|</span> RESTRICT]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">from</span> 教务员王 cascade</span><br></pre></td></tr></table></figure><ul><li>CASCADE：级联式收回权限（若干用户已将权限转授给其他用户，则一并收回）</li><li>RESTRICT：不存在级联时收回权限成功，存在级联时（用户已把授权转授出去）则命令失败</li></ul><p>三、禁止权限</p><ol><li>命令格式</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deny ... <span class="keyword">to</span> 用户</span><br></pre></td></tr></table></figure><ul><li>禁止权限：使用户以后绝对不可以做相应操作</li></ul><p>四、对比三种权限<br>grant … to 用户</p><ul><li>授予正权限：使用户可以做相应的操作</li><li>特殊情况：A，B授予同一个用户同一个权限X，即该用户的权限有两个来源；此时该用户有两个X，当A收回该权限，此用户对应X消失，但他还拥有B给他的X，所以他仍然有权限；</li></ul><p>deny … to 用户</p><ul><li><strong>禁用（授予负）权限：使用户以后绝对不可以做相应的操作</strong></li><li>比如上面的例子，C禁止该用户的X权限，即给了用户一个-X，那么用户无法再做此权限的操作，即使之前A，B授予了“正权限X”；</li><li><strong>所以负权限大于正权限，只要有一个负权限，无论得到多少正权限都无法获得权限</strong></li></ul><p>revoke … from 用户</p><ul><li>收回，相当于取消此前授予的（正、负）权限；注意：取消禁止权限，也是通过revoke</li><li><strong>思考</strong>：如果B收回授予用户的正权限X，有什么效果？接下来C取消他授予的负权限（禁止权限）呢？<br>现在用户有两个X和一个-X，B收回后，用户有一个X和一个-X，仍然无法使用权限；<br>C撤销负权限后，用户有一个X，无-X，则拥有权限；</li></ul><p><strong>小结：一个用户无法使用权限的情况：1. 无权限；2. 被授予负权限；</strong></p><p>五、角色机制<br>“角色”出现的必要性：<br>如果有一组用户，他们的权限相同或非常相近，那么设置一个角色代表这组用户，同意给角色授权，可以大大减少工作量；</p><p>角色的概念：</p><ol><li>角色就是一个用户集合</li><li>角色也是一个权限集合</li></ol><p>例子：<br>辅导员小王、小李、…想访问数据库里面的学生表；但只能允许他们查询和更新某些字段，比如年龄、宿舍。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="comment">--创建角色</span></span><br><span class="line"><span class="keyword">grant</span> 角色名 <span class="keyword">to</span> 用户 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--把用户拉入角色</span></span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">to</span> 角色名 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--集合中每个用户以及以后得新用户都具有该权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--角色即可以出现在to前面，又可以出现在to后面，所以它即是权限集合，又是用户集合</span></span><br></pre></td></tr></table></figure><p><strong>角色即可以出现在to前面，又可以出现在to后面，所以==它即是权限集合，又是用户集合==</strong></p><p>思考：<br>如果所有辅导员权限不完全一致，比如某一个辅导员比其他辅导员权限<strong>多一点</strong>或<strong>少一点</strong>，那还可以应用角色吗？怎么处理？<br>多一点：按照用户赋给额外的权限<br>少一点：deny掉该用户的权限</p><h3 id="3、理解常见权限的含义。（例如-insert-on-table-S-update-on-view-A等">3、理解常见权限的含义。（例如 insert on (table) S, update on (view) A等)</h3><h3 id="4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。">4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。</h3><p>一、完整性的概念</p><ol><li>定义：完整性指的是数据的正确性、有效性、相容性</li><li>完整性规则：完整性规则是为了保证完整性，数据所必须满足的约束条件，又称完整性约束/完整性约束条件<br>可分为两类：<ul><li>静态约束：数据取值条件</li><li>动态约束：数据变化/修改数据的条件(新旧值比较)</li></ul></li><li>完整性控制：在数据库系统中，保证数据的完整性，这一工作由DBMS完整性子系统完成<br>完整性控制围绕完整性规则进行，包括：<ul><li>定义完整性规则（check…）</li><li>检查完整性并做处理（在用户发出操作（update、insert…）、修改数据后检查是否仍然满足完整性规则，如果不满足则进行处理）</li></ul></li></ol><h3 id="5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？">5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？</h3><p>一、关系模型三要素</p><ol><li>关系</li><li>关系操作</li><li>关系完整性<ul><li>实体完整性：元组主码唯一且非空</li><li>参照完整性：外部码要么为空，要么取一个存在的对应主码值</li><li>用户定义完整性：用户根据具体的应用环境定义</li></ul></li></ol><p>思考：创建表时，外部码中的属性应该设为什么类型？<br><strong>外部码的属性类型要严格等于主码字段类型</strong></p><p>二、什么会破坏这些完整性规则</p><ul><li>显然查询操作不会破坏完整性，只有改变数据的修改操作才可能；</li><li>只有删除操作不会破坏实体完整性，其他修改数据的操作都会破坏三种完整性；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603185945.png" alt="Pasted image 20240603185945"></li></ul><h3 id="6、掌握用SQL定义主码约束、外码约束、非空-not-null-约束、唯一-unique-约束、域约束、检查-check-约束的语句？以及这些约束的含义、作用。">6、掌握用SQL定义主码约束、外码约束、非空(not null)约束、唯一(unique)约束、域约束、检查(check)约束的语句？以及这些约束的含义、作用。</h3><p>一、关系数据库里的完整性约束</p><ol><li>主码约束</li><li>外部码约束</li><li>非空约束</li><li>检查约束</li><li>唯一约束</li><li>断言</li><li>触发器</li></ol><p>二、各种约束<br>主码约束</p><ol><li>规则：主码值不允许为空，也不允许重复</li><li>定义：创建/修改表的语句中，用<strong>PRIMARY KEY</strong>声明主码的同时定义一个主码约束；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">读者编号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">借阅日期 <span class="type">date</span></span><br><span class="line"><span class="keyword">primary</span> key (书号, 借阅日期)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部码约束</p><ol><li>规则：外部码要求取值要么空值要么取对应的主码值</li><li>定义：创建/修改表的语句中，用FOREIGN KEY声明外部码的同时，即定义一个外部码约束</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreign</span> key (外部码属性)</span><br><span class="line">refernce 被参照表名(主码属性) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="operator">&lt;</span>参照动作<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>参照动作</strong>：说明当（被参照关系的）某个主码值被删除/更新时，如何处理自己表中对应的外部码值<br>RESTRCT方式（for server: no action）：仅当没有任何对应外部码值时才能删除/更新这个主码值，否则系统拒绝执行此操作<br>CASCADE方式：连带所有对应的外部码值一起删除/更新<br>SET NULL方式：将所有外部码值设为空<br>SET DEFALUT方式：将所有对应外部码值设置为默认值</li></ol><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Libroary</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">数名 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key(书号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">读者编号 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">借阅日期 <span class="type">date</span></span><br><span class="line"><span class="keyword">primary</span> key (...),</span><br><span class="line"><span class="keyword">foreign</span> key (书号)</span><br><span class="line"><span class="keyword">references</span> 图书表(书号)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非空约束<br>规则：属性值不允许取空值<br>定义：创建/修改表的语句中，声明某个属性NOT NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认值约束<br>规则：插入记录时，没有指定数据的属性值取默认值<br>定义：创建/修改表的语句中，声明某个属性时，用DEFAULT关键字引出其默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一约束<br>规则：制定属性或属性组，不能取重复值<br>定义：创建/修改表的语句中，<strong>用Unique关键字声明</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">e<span class="operator">-</span>mail <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">...</span><br><span class="line"><span class="keyword">unique</span>(e<span class="operator">-</span>mail)</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查约束<br>规则：每个元组内部一个或多个属性值，必须满足用户指定的条件<br>定义：创建/修改表的语句中，check关键字后说明条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line"><span class="keyword">check</span>(性别 <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">or</span> 性别 <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> 性别 <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>域约束<br>规则：域（数据类型）中的值要满足用户指定的条件<br>目的：间接地约束属性。因为如果把某个属性声明为这个域（数据类型），则该属性的取值也连带要满足这一条件。<br>定义：在创建域的语句中，在constraint关键字后面说明约束的名称和条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式</span></span><br><span class="line"><span class="keyword">create</span> domain 用于域名 系统预定义域 [<span class="keyword">constraint</span> 约束名 <span class="keyword">check</span>(条件)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> domain 性别类型 <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">constraint</span> 约束名 <span class="keyword">check</span>(<span class="keyword">value</span> <span class="keyword">in</span> (<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="keyword">Null</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 性别类型 <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、在定义外部码约束时，有哪几种参照动作？代表什么意义？">7、在定义外部码约束时，有哪几种参照动作？代表什么意义？</h3><p><strong>参照动作</strong>：说明当（被参照关系的）某个主码值被删除/更新时，如何处理自己表中对应的外部码值<br>RESTRCT方式（for server: no action）：仅当没有任何对应外部码值时才能删除/更新这个主码值，否则系统拒绝执行此操作<br>CASCADE方式：连带所有对应的外部码值一起删除/更新<br>SET NULL方式：将所有外部码值设为空<br>SET DEFALUT方式：将所有对应外部码值设置为默认值</p><h3 id="8、断言不作要求">8、断言不作要求</h3><h3 id="9、熟记以下全部-触发器的概念。触发器有哪些作用？触发器-ECA规则构成的三个方面，包括英文单词。哪些事件会激活（INSERT-UPDATE-DELETE操作）。">9、熟记以下全部 触发器的概念。触发器有哪些作用？触发器/ECA规则构成的三个方面，包括英文单词。哪些事件会激活（INSERT,UPDATE,DELETE操作）。</h3><p>一、触发器基本概念<br>概念：自动执行的过程</p><ul><li>传统过程是用户调用才手动执行，否则不执行</li><li>在系统检测到某些事情发生时才会去主动执行相应（预先跟这些时间绑定的）触发器<br>构成：</li><li>Event ： 发生什么是？</li><li>Condition ： 检查什么条件？</li><li>Action：再执行什么动作（条件成立）？</li></ul><p>==二、触发器作用==</p><ol><li>保证数据完整性，例如在增删改记录时，验证一些复杂的条件是否满足</li><li>审计（例如把一个用户对数据库的操作和时间都记录下来）</li><li>满足特定条件自动执行某项任务（例如，商品库存不足时，自动生成一张订单）</li></ol><p>例子：当职工工资增幅超过10%，放弃修改（改回原值）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 触发器模板</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> <span class="keyword">trigger</span><span class="operator">-</span>name</span><br><span class="line">[before <span class="operator">|</span> after] <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">delete</span><span class="operator">/</span><span class="keyword">update</span> [<span class="keyword">of</span> <span class="keyword">column</span><span class="operator">-</span>name] <span class="keyword">on</span> <span class="keyword">table</span><span class="operator">-</span>name</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="keyword">as</span> ?</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">as</span> ?</span><br><span class="line"><span class="keyword">when</span>(<span class="keyword">search</span><span class="operator">-</span><span class="keyword">condition</span>)</span><br><span class="line"><span class="keyword">begin</span> [<span class="keyword">atomic</span>]</span><br><span class="line"> triggered<span class="operator">-</span><span class="keyword">SQL</span><span class="operator">-</span>statement</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trig_SALARY_LIMIT</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">of</span> 工资 <span class="keyword">on</span> 职工表</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">as</span> newrow </span><br><span class="line"><span class="keyword">old</span> <span class="keyword">as</span> <span class="keyword">old</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (newrow.工资 <span class="operator">&gt;</span> <span class="number">1.1</span><span class="operator">*</span>oldrow.工资)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> 职工表</span><br><span class="line"><span class="keyword">set</span> 工资 <span class="operator">=</span> oldrow.工资</span><br><span class="line"><span class="keyword">where</span> 员工号 <span class="operator">=</span> oldrow.员工号</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="第十二章——事务管理">第十二章——事务管理</h2><h3 id="1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、保障机制）。">1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、保障机制）。</h3><p><strong>事务的概念</strong>：事务的DBMS的<strong>基本执行单位</strong>，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。事务是恢复和并发控制的基本单位！</p><p><strong>事务的性质</strong>（ACID）：</p><ol><li>原子性（Atomicity）：事务中包含的所有操作（特指修改操作）要么全做，要么全不做。<br>保障机制：恢复机制</li><li>一致性（Consistency）：单独执行一个事务（无其他事务同时并发执行）的结果必须保证数据的一致性，即事务开始之前数据满足一致性要求；事务结束之后，数据可能被修改了，但仍然满足一致性要求。<br>保障机制：完整性机制</li><li>隔离性（Isolation）：多个事务在并发执行的时候不会相互影响，好像他们是隔离开来的；并发执行的最后结果与顺序执行这些事务的结果一致；<strong>隔离性要求一个事务不会看到另一个事务的中间结果</strong><br>保障机制：并发控制机制</li><li>持久性（Durability）：事务一旦提交，它对数据库的影响就是永久性的，无论发生什么事都无法取消这种影响。<br>保障机制：恢复机制</li></ol><h3 id="2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。不能提交的事务结局只能是回滚。">2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。不能提交的事务结局只能是回滚。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询学生人数</span></span><br><span class="line">IF (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> students) <span class="operator">&gt;</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 如果学生人数大于100，提交事务</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 如果学生人数不大于100，回滚事务</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、事务调度分串行调度和并发调度，并发调度的效率高，但也有问题：破坏数据一致性，产生错误。">3、事务调度分串行调度和并发调度，并发调度的效率高，但也有问题：破坏数据一致性，产生错误。</h3><h3 id="4、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。">4、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。</h3><ol><li><p>并发调度会带来三种数据不一致问题，分别是：丢失修改、不可重复读以及读取脏数据。</p></li><li><p>丢失修改：多个事务从数据库中读取同一数据，分别仅修改并提交，会产生修改覆盖的现象，从而丢失修改。</p></li><li><p>不可重复度：事务T1读取某个数据后，事务T2对该数据进行了修改并提交，事务T1第二次读取该数据会和第一次有不同的结果（出现幻影现象）</p></li><li><p>读取脏数据：事务T1读取某个数据后，事务T2对该数据进行了修改但还未提交，此时事务T1被称为读取了脏数据；脏数据是指被修改但是未提交的数据。</p></li></ol><h3 id="5、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。">5、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。</h3><h3 id="6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。各个锁的含义（例如排他锁是读-写，共享是读），相容-排斥关系？">6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。各个锁的含义（例如排他锁是读+写，共享是读），相容/排斥关系？</h3><p><strong>锁</strong>：一个事务在对某个数据对象（表、元组、关系等）进行操作前，可以向系统申请对该<strong>数据对象</strong>加锁。==数据库上锁的数据对象是内存中的数据，不是磁盘中的数据）来自于励儒云的习题==</p><p><strong>X锁</strong>：又称为写锁/排他锁（Exclusive Lock）</p><ul><li>一个事务对数据A进行修改（写）操作前，给它加上X锁。获得X锁后，事务可以对数据A进行写，也可以对数据A进行读</li><li>==其他事务不能对A再加任何锁，直到X锁被释放为止！==<br><strong>S锁</strong>：又称为读锁/共享锁（Shared Lock）</li><li>一个事务对数据A进行读取操作前，给它加上S锁，获得S锁后，该事物<strong>可以读，但不可以写</strong></li><li>其他事务可以对A加更多的锁（除了X锁）</li></ul><h3 id="7、意向锁不要求。更新锁不要求。">7、意向锁不要求。更新锁不要求。</h3><h3 id="8、有哪几种封锁协议？规则是什么？它们的作用（各自解决了哪些数据不一致性问题）？两段封锁协议是可串行化调度的充分非必要条件。">8、有哪几种封锁协议？规则是什么？它们的作用（各自解决了哪些数据不一致性问题）？两段封锁协议是可串行化调度的充分非必要条件。</h3><p><strong>封锁协议</strong>：封锁协议是事务对数据对象加锁时需要遵守的规则</p><h4 id="一级封锁协议">一级封锁协议</h4><p><strong>规则</strong>：数据对象D如果是修改/写操作，在第一次read/write之前需要加X锁，事务结束（commit/rollback）后才释放X锁<br><strong>规则的简洁表述</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放（事务的结束有两种状态，正常结束commit和非正常结束rollback）<br><strong>特点</strong>：仅对写操作加锁，==对读操作无要求！==<br><strong>作用</strong>：一级封锁协议可以解决==丢失修改==的问题，并保证了事务T是可恢复的（原因：没有事务能够修改其他事务正在修改，还未提交的数据）</p><h4 id="二级封锁协议">二级封锁协议</h4><p><strong>规则</strong>：满足一级封锁协议的基础上，若要读取数据R，事务T必须先对其加S锁，读取完后，可以在任意时候释放S锁（瞬间S锁）<br><strong>特点</strong>：不仅对数据的读有要求，而且对数据的写有要求<br><strong>作用</strong>：可以解决<strong>读取脏数据</strong>的问题（原因：没有事务可以读取其他事务正在修改但是未提交的数据）</p><h4 id="三级封锁协议">三级封锁协议</h4><p><strong>规则</strong>：一级封锁协议的基础上，若要读取数据R，事务T必须在第一次读取R之前加上S锁，直到事务结束之后才释放S锁<br><strong>作用</strong>：解决<strong>不可重复读</strong>的问题（原因：在同一事务的两次读数据中间，没有其他事务能够修改该数据）</p><h4 id="两段封锁协议">两段封锁协议</h4><p><strong>规则</strong>：</p><ul><li>事务对数据加S/X锁后，才能读写数据；释放锁后不能再读写该数据</li><li>事务分为两个阶段：<ol><li>生长阶段：（一直在）获得锁，不能释放锁</li><li>收缩阶段：（一直在）释放锁，不能申请锁<br><strong>首次释放掉一个锁后，即由生长阶段转为收缩阶段</strong><br>==注意：符合三级封锁协议的事务一定也符合两段封锁协议，因为三级封锁协议保证了每个数据都在加锁和释放锁之间==</li></ol></li></ul><h4 id="两段封锁协议是可串行化的充分非必要条件">两段封锁协议是可串行化的充分非必要条件</h4><p>若所有事物均遵从两段封锁协议，则对这些事务的并发调度一定是可串行化的！<br>反之，在一个可串行化的调度中，不一定所有事务都满足两段封锁协议！<br>因此，<strong>所有事务都遵从两段封锁协议是可串行化的充分非必要条件</strong>！</p><h4 id="小结">小结</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002402.png" alt="Pasted image 20240618002402"></p><h3 id="9、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。">9、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。</h3><p>数据库恢复的基本原理：<strong>冗余</strong><br>在故障发生、数据出错后，用存储在其他地方的数据副本（冗余数据）来重建正确的数据。<br>平时<strong>建立数据冗余</strong>的方法：</p><ul><li>数据备份（周期），也称数据转储</li><li>登记日志文件（实时）</li></ul><h3 id="10、静态备份-vs-动态备份（有否一致性；是否允许用户运行事务来操作数据库）。">10、静态备份 vs 动态备份（有否一致性；是否允许用户运行事务来操作数据库）。</h3><p><strong>数据备份定义</strong>：有数据库系统定期将数据进行复制，得到后备副本并保存在外部存储空间上的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0[&quot;</span><br><span class="line">数</span><br><span class="line">据</span><br><span class="line">备</span><br><span class="line">份&quot;] --&gt; 静态备份 &amp; 动态备份</span><br><span class="line">静态备份 --&gt; 1[&quot;备份期间，系统不能有事务运行&quot;] &amp; 2[&quot;优点: 实现简单，得到的数据库副本有一致性&lt;/br&gt;缺点: 备份时，数据库不可用&quot;]</span><br><span class="line">动态备份 --&gt; 3[&quot;备份期间，允许事务运行（存取数据）&quot;] &amp; 4[&quot;优点: 备份时，数据库可用&lt;/br&gt;缺点: 实现复杂，不能保证数据库副本的一致性&quot;]</span><br></pre></td></tr></table></figure><h3 id="11、日志文件的定义：是用来记录事务对数据库进行更新操作的文件">11、日志文件的定义：是用来记录事务对数据库进行更新操作的文件</h3><h3 id="12、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记更新操作的日志记录时，更新前后的旧值与新值都要保存到日志记录中。">12、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记更新操作的日志记录时，更新前后的旧值与新值都要保存到日志记录中。</h3><p><strong>日志文件的记录单位</strong>：<br>日志文件的记录对象/单位有两种，分别为：记录、数据块</p><p><strong>一个事务登记到日志文件的内容</strong>：</p><ol><li>事务的开始标志（Begin Transaction）<br>每个事务都有一条标志开始的日志记录</li><li>事务的结束标志（commit/rollback）</li><li>事务的所有修改操作<br>每个事务有多个修改操作，但凡修改一个单位（记录或者数据块），就需要产生一条日志记录，记录下修改的单位编号，<strong>修改前的旧值、修改后的新值</strong></li></ol><p><strong>一条日志记录的数据结构（假设以记录为单位）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;一条</span><br><span class="line">日志</span><br><span class="line">记录&quot;] --&gt; 2[&quot;事务标识（事务编号）&quot;] &amp; 3[&quot;操作类型（事务开始、事务结束、添加、删除、更新）&quot;] &amp; 4[&quot;操作对象的标识(记录的内部编号)&quot;] &amp; 5[&quot;修改前的旧值，如果是插入操作则为空&quot;] &amp; 6[&quot;修改后的新值，如果是删除操作则为空&quot;]</span><br></pre></td></tr></table></figure><p>**日志文件的原则：</p><ol><li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li><li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li></ol><p><strong>事务提交</strong>：</p><ul><li>事务提交，意味着事务的所有操作（包括commit）都已经记录进入日志，并且日志也存入外存中</li></ul><h3 id="13、什么是运行记录优先（先写日志）原则？">13、什么是运行记录优先（先写日志）原则？</h3><p>**日志文件的原则：</p><ol><li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li><li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li></ol><h3 id="14、熟记以下全部不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），及由谁完成（系统自动-or-用户干预？）">14、熟记以下全部不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），及由谁完成（系统自动 or 用户干预？）</h3><p>一、事务故障<br><strong>定义</strong>：事务在运行至正常终止点前被终止<br>比如溢出、除0操作、死锁等等<br><strong>影响范围</strong>：事务故障属于小型故障，影响范围仅限于一个事务，不会影响其他事务的正常运行。<br><strong>恢复方法</strong>：</p><ol><li>反向扫描日志文件，找到属于该事务的修改操作，不断执行撤销操作直到读到此事务的开始标记，则事务故障就恢复完成</li><li>撤销操作，将日志记录中的“修改前的值”写入磁盘</li><li>事务故障的恢复由==系统==自动完成，对==用户透明==</li></ol><p>二、系统故障<br><strong>定义</strong>：因某种原因，造成数据库管理系统（DBMS）停止运行<br>比如硬件故障（cpu故障…），软件故障(os异常)，外部因素（停电…）<br><strong>影响范围/性质</strong>：中型故障，DBMS故障会导致多个工作的事务被异常终止，系统需要重新启动；重启后，内存缓冲区中的数据丢失，但磁盘介质上数据依然完好<br><strong>系统故障造成数据库不一致状态的原因</strong>：</p><ul><li>未完成的事务对数据库的更新可能已经写入数据库</li><li>已提交的事务对数据库的更新可能还留在缓冲区没来得及写<br><strong>恢复方法</strong>：<br>DBMS在重新启动后自动完成，不需要用户的干预，对用户透明</li></ul><ol><li>Undo故障发生时未完成的事务</li><li>Redo已经发生的事务<br><strong>恢复步骤</strong>：</li><li>正向扫描日志文件，找到已提交的事务（有begin transaction和commit），将其事务标志放入redo队列；<br>找到未提交的事务（有begin transaction无commit）放入undo队列</li><li>反向扫描日志文件，找到找到属于撤销队列的事务的修改操作并执行撤销操作，即将修改前的旧值写入磁盘</li><li>正向扫描日志文件，找到属于重做队列中的事务的修改操作并执行重做操作，即将修改后的新值写入磁盘<br><strong>小结恢复步骤</strong>：<br>系统故障的恢复需要三次扫描日志文件<br>第一次扫描建立undo和redo队列；<br>第二次反向扫描日志文件，对需要undo的事件的修改操作进行undo操作；<br>第三次正向扫描日志文件，对需要redo的事件的修改操作进行redo操作；</li></ol><p>三、介质故障<br><strong>定义</strong>：因某种原因，磁盘上的物理数据部分或完全丢失<br><strong>原因</strong>：硬件损坏、计算机病毒、黑客…<br><strong>影响范围/性质</strong>：属于大型故障，不仅DBMS中止，内存数据丢失，并且磁盘上的数据也会丢失和异常<br><strong>恢复方法</strong>：<br>需要人工干预，需要数据库管理人员DBA来完成（唯一需要人工介入的故障）<br>恢复过程：</p><ol><li>装入最近一次<strong>备份的数据库副本</strong>，即恢复数据库到最近的一次备份时的状态</li><li>装入备份后到故障发生时的<strong>日志文件或副本</strong>，然后把未提交的事务撤销，已提交的事务重做</li></ol><h3 id="15、检查点不要求">15、检查点不要求</h3>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】8. 期末复习</title>
      <link href="/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%918.%20%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>期末复习</h1><h2 id="第一章">第一章</h2><h3 id="程序语言的分类">程序语言的分类</h3><p>程序语言分为两种，高级语言和低级语言。<br>其中低级语言可以直接控制硬件，如汇编语言、机器语言<br>高级语言接近人类自热语言，如C++、Python、Java</p><h3 id="程序翻译的方式有哪些？有何不同？">程序翻译的方式有哪些？有何不同？</h3><p>程序翻译的方式有两种，分别是编译程序、解释程序。<br>编译程序借助编译器生成目标程序，目标程序收到输入数据和运行库后执行得到结果，优势是效率高，劣势是不跨平台<br>解释程序直接将输入的数据和源程序进行解释并执行得到结果，优势是跨平台，劣势是暴露源码</p><h3 id="编译程序包含多少个阶段、各阶段的功能是什么？">编译程序包含多少个阶段、各阶段的功能是什么？</h3><p>程序编译的过程包含6个阶段，分别是：扫描程序、语法分析程序、语义分析程序、源代码优化程序、代码生成器、目标代码优化程序。</p><ol><li>扫描程序：功能是词法分析，将源程序进行分词</li><li>语法分析程序：功能是定义程序的符号元素以及元素之间的关系</li><li>语义分析程序：功能是理解程序的意思，并进行声明和类型检查</li><li>源代码优化程序：对代码进行改进或优化</li><li>代码生成器：得到中间代码（逆波兰、三元组、四元组），并将其生成目标代码</li><li>目标代码优化程序：与机器有关的优化，利用机器指令的特征对目标代码进行优化</li></ol><h2 id="第二章（重点）——词法分析">第二章（重点）——词法分析</h2><h3 id="正则表达式运算及其构建方法">正则表达式运算及其构建方法</h3><h3 id="正则表达式-toNFA-toDFA-toDFA最小化">正则表达式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>NFA<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>DFA<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>DFA最小化</h3><h4 id="确定化有穷自动机DFA的定义">确定化有穷自动机DFA的定义</h4><h4 id="非确定化有穷自动机NFA的定义">非确定化有穷自动机NFA的定义</h4><h4 id="DFA和NFA的区别">DFA和NFA的区别</h4><h4 id="NFA转化为DFA的方法">NFA转化为DFA的方法</h4><h5 id="epsilon闭包的定义"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包的定义</h5><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包是指可由一个或多个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\epsilon-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">−</span></span></span></span>转换从某个状态或某些状态达到的所有状态的集合。<br>算法实现：深度优先或者广度优先，从初态出发，经过每一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>得到的状态都添加到该初态的集合上去。</p><h5 id="注意判别终态以及ERROR状态">注意判别终态以及ERROR状态</h5><p>如果某个状态集合中包含原来的终态，该状态集合为终态，对终态求非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包如果是空集，得到接受状态ACC，在状态转换表中不用写；<br>如果某个状态集合为非终态（不包含原来的终态），对该集合求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>非</mtext><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">非\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">非</span><span class="mord mathnormal">ϵ</span></span></span></span>闭包如果是空集，则得到出错状态ERROR，在状态转换表中不用写；</p><h4 id="DFA最小化">DFA最小化</h4><h3 id="词法分析程序的生成方法">词法分析程序的生成方法</h3><h4 id="代码实现有穷自动机（两种方法）">代码实现有穷自动机（两种方法）</h4><h5 id="方法一：状态转换方法">方法一：状态转换方法</h5><ol><li>利用一个变量保持当前状态，并将转换写成一个双层嵌套的case语句而不是一个循环</li><li>其中第一个case语句测试当前的状态，嵌套着的第二层测试输入字符以及所给状态</li></ol><h5 id="方法二：转换表——二维数组">方法二：转换表——二维数组</h5><ol><li>通过表示转换函数T值的状态和输入字符来索引（构建查表的方法）</li></ol><h3 id="实验一与实验二">实验一与实验二</h3><h3 id="总结习题">总结习题</h3><p>==注意的问题：经常忘记画自环！！！==<br><strong>PPT习题</strong>：<br>一、构建正则表达式习题<br>chapter2的P37-38页</p><ol><li>例2.1：在仅由字母表中的3个字符组成的简单 字母表={a,b,c}中，考虑在这个字母表上的 仅包括一个b的所有串的集合</li><li>例2.2：在与上面相同的字母表中，如果集合是包 括了最多一个b的所有串</li><li>标识符的正则表达式的写法（必须由一个字母开头并且只包含字母和数字）</li><li>整数正则表达式（可以带正号、负号或者不带）</li><li>十进制数可以是整数、浮点数、或带有指数的 数(由e或E表示)的序列。如：123 3.14 -4.5 2.71E-2</li><li>注释的正则表达式：<ul><li>pascal语言的注释，如{ this is a Pascal comment }</li></ul></li></ol><p>二、正则表达式转DFA</p><ol><li>基本例题<br>例1:正则表达式 ab<br>例2:正则表达式 a|b<br>例3:正则表达式 a*<br>例4:正则表达式 (ab)*<br>例5:正则表达式 (a|b)*<br>例6:正则表达式 ab|ac</li><li>例2.6: 串中仅有一个b的集合的正则表达式为： (not b )* b (not b ) *</li><li>Pascal注释 { ( ~} )* } 对应的DFA</li><li>C语言注释的DFA</li><li>例2.8 科学表示法的数字常量的正则表达式是什么？DFA是什么？</li></ol><p>三、正则表达式转NFA（Tompson的方法）</p><ol><li>基本例题<br>例1:正则表达式 ab<br>例2:正则表达式 a|b<br>例3:正则表达式 a*<br>例4:正则表达式 (ab)*<br>例5:正则表达式 (a|b)*<br>例6:正则表达式 ab|ac</li><li>例1 将正则表达式 ab|a 转换为NFA</li><li>例2 正则表达式 letter(letter|digit)*对应的NFA</li><li>例：正则表达式(a|c)*b按Thompson方法构 造所得NFA</li></ol><p>四、NFA转DFA（子集构造法）</p><ol><li>例1 求出正则表达式a*的NFA转换成DFA的过程</li><li>例2 将下面NFA转换为DFA.<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629162855.png" alt="Pasted image 20240629162855"></li><li>例3.将下面NFA转换为DFA。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629162938.png" alt="Pasted image 20240629162938"><br>五、DFA最小化</li><li>例2.19 将下面与正则表达式(a|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>)b*对应的DFA进行 最小化（不过可以先尝试不看这个DFA，而是先写NFA，再NFA转DFA，再进行最小化）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629174557.png" alt="Pasted image 20240629174557"><br>==六、用代码实现有穷自动机==</li><li>实验1、实验2的内容</li><li>用代码实现如下DFA图<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629183010.png" alt="Pasted image 20240629183010"></li><li>用代码实现如下DFA图<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629183038.png" alt="Pasted image 20240629183038"></li></ol><h2 id="第三章（重点）-——-文法">第三章（重点） —— 文法</h2><h3 id="文法、语言">文法、语言?</h3><h4 id="文法的定义">文法的定义</h4><p>文法适用于描述语言的语法结构，用四元组表示。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (VN, VT, P, S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p><ul><li>VN是非终结符</li><li>VT是终结符</li><li>S是开始符号</li><li>P是产生式集，形式为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><br>文法的关键描述在于<strong>开始符号</strong>和<strong>规则</strong><br>所以文法可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">[</mo><mtext>开始符号</mtext><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mtext>规则</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">G[开始符号]=\{规则\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">[</span><span class="mord cjk_fallback">开始符号</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">规则</span><span class="mclose">}</span></span></span></span><br>==一个文法必须满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∩</mo><msub><mi>V</mi><mi>T</mi></msub><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">S\in V_N, V_N \cap V_T = \varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6633em;vertical-align:-0.0817em;"></span><span class="mord amsrm">∅</span></span></span></span>==</li></ul><p><strong>注意</strong>：</p><ol><li>文法推导式右部的规则：<ul><li>运算符有：选择 | 、并置、括号（）</li><li>无重复符号（*），用递归实现重复</li><li>规则右部可以使用元符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，为了能产生空串</li></ul></li><li>注意文法表示的习惯用法：<ul><li>大写字母表示非终结符</li><li>尖括号把非终结符括起来也可以表示非终结符</li><li>前面的小写字母表示单个终结符号</li><li>后面的小写字母u、v、w、x、y、z以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mtext>、</mtext><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha、\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>等符号表示（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">V=VN\cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>上的符号串）</li></ul></li></ol><h4 id="文法的存储结构以及推导过程在计算机内部的存储表示（PPT上说重点）">文法的存储结构以及推导过程在计算机内部的存储表示（PPT上说重点）</h4><p>文法的存储可以以数组表示的方法，也可以以链式存储的方法。重点介绍链式存储方法，后面的推导过程也是链式存储的方式。<br>==这部分在PPT的第44页==<br>一、数组表示方法<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629213802.png" alt="Pasted image 20240629213802"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214508.png" alt="Pasted image 20240629214508"></p><p>二、文法的链式存储<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214537.png" alt="Pasted image 20240629214537"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214550.png" alt="Pasted image 20240629214550"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629214606.png" alt="Pasted image 20240629214606"></p><h4 id="语言的定义">语言的定义</h4><p>文法G所描述的语言用L(G)表示，它由文法G所产生的全部句子组成，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo>∈</mo><mi>V</mi><msup><mi>T</mi><mo>+</mo></msup><mtext>且</mtext><mi>S</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(G) = \{w | w \in VT^+ 且 S \Rightarrow^+ w \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8213em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span></span></p><ul><li>符号串w是从开始符号s推导出来的</li><li>w仅由终结符号组成</li><li>W称为该语言的句子</li><li>L(G)是由所有这样的句子构成的<br><strong>设G1、G2 为两个文法,若它们所产生的语言相等,即 L(G1)= L(G2)，则称G1和G2等价</strong></li></ul><h4 id="上下文无关语言的定义">上下文无关语言的定义</h4><p>设CFG（Context-Free Grammer）上下文无关文法规则G=（VN, VT, P, S），定义G的语言为L(G) = {w | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>V</mi><msup><mi>T</mi><mo>∗</mo></msup><mo>∧</mo><mtext> </mtext><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>w</mi></mrow><annotation encoding="application/x-tex">w \in VT^* \land\ S \Rightarrow^* w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>}<br>如果一个语言L是某个CFG G的语言，即L(G)=L，则L是上下文无关语言</p><h3 id="文法的分类是怎样的-它们之间有何关系">文法的分类是怎样的? 它们之间有何关系?</h3><h4 id="文法的分类">文法的分类</h4><p>文法（grammer）是一个四元组，G=（VN, VT, P, S），Chomsky通过对产生式施加不同的限制，把文法以及其对应的语言分为四种类型，即0型文法、1型文法、2型文法和3型文法。</p><ol><li>0型文法<br>特点：没有对规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的边做限制，仅要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>中至少含一个非终结符号。因此又称为无限制文法或短语文法，也称为0型语言或递归可枚举语言；</li><li>1型文法（也称上下文有关的语法）<br>特点：限制P中的每个规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>除了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>外，都要满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>β</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\alpha| \leq |\beta|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span></span></span></span>，并且要求S不能出现在任何产生式的右部<br>这里的||是取串的长度，而不是绝对值；<br>上下文有关是指对非终结符进行替换时，需要考虑该符号所处的上下文环境；<br>例如：<br>对于规则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mi>A</mi><mi>α</mi><mn>2</mn><mo>→</mo><mi>α</mi><mn>1</mn><mi>β</mi><mi>α</mi><mn>2</mn><mo stretchy="false">(</mo><mi>β</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi><mo separator="true">;</mo><mi>α</mi><mn>1</mn><mo separator="true">,</mo><mi>α</mi><mn>2</mn><mtext>不同时为</mtext><mi>ϵ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha1 A \alpha2 \to \alpha1 \beta \alpha2(\beta \neq \epsilon; \alpha1, \alpha2不同时为\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mord cjk_fallback">不同时为</span><span class="mord mathnormal">ϵ</span><span class="mclose">)</span></span></span></span> , 当用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，只能在上下文为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mtext>和</mtext><mi>α</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha1 和 \alpha2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span></span></span></span>时才能进行；</li><li><strong>2型文法</strong><br>每个规则的特点限制为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，其中A为==单个非终结符==，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>T</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>N</mi></msub><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\beta \in (V_T\cup V_N)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>。也称上下文无关语法，即当使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，与A的上下文环境无关；</li><li>3型文法<br>每个规则的特点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mtext>，</mtext><mi>A</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mtext>，</mtext><mi>a</mi><mo>∈</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">B，A\in V_N， a \in V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, 他们都是单个符号，称为正规文法或者正则文法。<br>由于规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>中，B位于a的右边，所以也称为右线性文法。类似地，正规文法也可以是左线性的（即产生式的形式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to Ba</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>）<br>产生式也可以形如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi><mtext>或</mtext><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to Ba 或 A \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">或</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，此时称为左线性的</li></ol><h4 id="四种文法之间的关系">四种文法之间的关系</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629224051.png" alt="Pasted image 20240629224051"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240629224105.png" alt="Pasted image 20240629224105"></p><h3 id="推导、规约、语法树、文法的二义性？">推导、规约、语法树、文法的二义性？</h3><h4 id="归约与推导">归约与推导</h4><ul><li>归约：将产生式的右部替换为产生式的左部，归约的过程是自底向上构造了一棵树</li><li>推导：将产生式的左部替换为产生式的右部，推导的过程是自顶向下构造了一棵树</li></ul><h4 id="最左推导">最左推导</h4><p>若推导过程的每一步总是替换出现在最左边的非终结符，则称这样的推导为最左推导。最左推导关系用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>l</mi><mi>m</mi></mrow></munder></mo></mrow><annotation encoding="application/x-tex">\underset{lm}{\Rightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.119em;vertical-align:-0.7521em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span></span></span></span></span>表示，自反传递闭包用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>l</mi><mi>m</mi></mrow></munder></mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\underset{lm}{\Rightarrow}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4408em;vertical-align:-0.7521em;"></span><span class="mrel"><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.3479em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7521em;"><span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>表示</p><h4 id="最右推导">最右推导</h4><p>若推导的每一步总是替换出现在最右边的非终结符，则称这样的推导为最右推导。最右推导关系用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>r</mi><mi>m</mi></mrow></munder></mo></mrow><annotation encoding="application/x-tex">\underset{rm}{\Rightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0669em;vertical-align:-0.7em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span></span></span></span>表示，自反传递闭包用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo><munder><mo><mo>⇒</mo></mo><mrow><mi>r</mi><mi>m</mi></mrow></munder></mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\underset{rm}{\Rightarrow}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3887em;vertical-align:-0.7em;"></span><span class="mrel"><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3669em;"><span style="top:-2.4em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">m</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⇒</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7em;"><span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>表示</p><h4 id="句子、句型，推导关系到自反传递闭包">句子、句型，推导关系到自反传递闭包</h4><ol><li>句型：如果符号串u是从开始符号s推导出来的，即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow^*u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>，则称u是一个句型<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&quot;</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">&quot;\Rightarrow^*&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span></span></span></span>表示经过0步或多部推导<br>S=u称为0步推导<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⇒</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>称为1步推导<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>称为1步或多步推导</li><li>左推导得出的句型称为左句型，右推导得出来的是右句型</li><li>句子：仅含终结符的句型, 从开始符号推导出来的仅含有终结符的符号串；</li></ol><h4 id="分析树的定义">分析树的定义</h4><p>在文法G=(VN, VT, P, S)下的分析树具有以下特征：</p><ol><li>根节点标记为文法的开始符号S</li><li>每个结点上的标记都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">V = VN \cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>中的一个符号</li><li>如果一棵子树的根标记为A，且其所有的直接后代节点从左向右排列的顺序为A1，A2…AK，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2...</mn><mi>A</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">A \to A1,A2...AK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord">2...</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是P中的一个<strong>规则</strong></li><li>如果T1是根节点的唯一子树，且其标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在P中</li><li>如果树的所有叶子节点上的标记从左到右排列为字符串w，则w是G的<strong>句型</strong>，若w中仅含有终结字符，则它为G所产生的<strong>句子</strong><br><strong>相关术语</strong>：</li></ol><ul><li>句型：从树根开始的子树</li><li>短语：包含末端节点（叶子节点）所形成子树（不一定含树根）的符号串</li><li>简单短语：只有父子两代的子树的末端节点（叶子节点）形成的符号串</li><li>句柄：最左的简单短语<br><strong>分析树的构造方法</strong>：</li><li>步骤1 以识别符号Z建立根结点，序号为1，且以这仅包含一个 非终结符号的句型Z作为当前句型。</li><li>步骤2 从当前句型中找出最左的非终结符号U，显示以U为左 部的一切规则，根据所给的输入符号串，选择其中的一个规则 U::=X1X2…Xm,以U为分支名字结点，以X1X2…Xm作为分支结点符 号串，构造分支。建立父子兄弟结点关系。</li><li>步骤3 重复步骤2，直到当前句型中不再包含非终结符号，分 析树构造结束，最终的分析树为所求。<br><strong>分析树的优缺点</strong>：</li><li>优点：分析树可以反映推导的全过程，信息齐全，可以还原记号序列</li><li>缺点：过于复杂，耗费空间<br>解决方法：压缩分析树，只存储有用的信息，于是就出现了<strong>语法树</strong></li></ul><h4 id="语法树">语法树</h4><p>语法树是分析树的精简版，只保留分析树中对后续分析<strong>有用的信息</strong>，比分析树的效率更高。<br><strong>问题关键</strong>：分析对应的语句的文法规则中，什么信息才是对后续有用的信息。比如算术表达式要保留表达式信息、运算符信息；if语句要保留测试表达式、then部分（正确要执行的部分）、else部分（错误要执行的部分）…<br>==这里要把实验三在回顾一遍，重点回顾语法树的构建==<br>例如：<br>1)算术表达式的语法树存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;Plus, Minus, Times, Divsion&#125; OpKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;OpKind, ConstKind, VarKind&#125; ExpKind;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">streetnode</span>&#123;</span><br><span class="line">ExpKind kind;</span><br><span class="line">OpKind op;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">streenode</span> *lchild, *rchild;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">char</span> varname[<span class="number">20</span>];</span><br><span class="line">&#125;STreeNode;</span><br><span class="line"><span class="keyword">typedef</span> STreetNode *SyntaxTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2)if的语法树存储结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; ExpK, StmtK&#125; NodeKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; Zero, One&#125; ExpKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; IfK, OtherK&#125; StmtKind; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">streenode</span> &#123; </span><br><span class="line">NodeKind kind; </span><br><span class="line">ExpKind ekind; </span><br><span class="line">StmtKind skind; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">streenode</span> *test, *thenpart, *elsepart; </span><br><span class="line">&#125; STreeNode; </span><br><span class="line"><span class="keyword">typedef</span> STreeNode * SyntaxTree;</span><br></pre></td></tr></table></figure><p>TINY语言的各种语法树结构，如IF、REPEAT、READ、WRITE等等，参考书P100的图3-6和程序清单3-3；</p><h4 id="文法的二义性">文法的二义性</h4><p>定义：可生成带有两个不同分析树的串的文法称为二义性文法；<br><strong>判断文法是否有二义性的方法</strong>：</p><ul><li>举反例，举出一个表达式，然后根据文法规则画语法分析树，如果能画出两棵不同的分析树，则证明该文法有二义性；</li><li>一个 CFG是否为二义的问题是不可判 定的，即不存在解决该问题的算法，只能反证；<br><strong>消除二义性</strong>：没有通用的办法可以消除文法的二义性. 但在实践中，对于常用的文法，可以找到特定的消除歧 义性的办法.</li></ul><p><strong>注意</strong>：</p><ul><li>对于程序设计语言来说，重要的是：描述它的文法 应是无二义性的。</li><li>一个语言，可以为它设计二义性的文法，也可以为 它设计无二义性的文法，因此一般说，讨论语言的二义 性是无意义的。重要的是对同一个语言，为它构造无二 义性文法，如果构造的是二义性文法，<strong>应设法在不改变 语言的前提下, 把二义性文法等价变换成无二义性文法</strong>。</li><li>鉴于二义性不可判定，所能做的是寻找一组充分条 件，使得满足这些条件的文法必定是无二义性的。注意, 这些条件只是充分条件，未必是无二义性的必要条件。</li></ul><h3 id="如何画语法树？">如何画语法树？</h3><p>画分析树的步骤（个人总结手工步骤）：</p><ol><li>从开始符号推导，作为树根</li><li>根据文法推导式一步一步向所求表达式靠近</li></ol><p>==画分析树的步骤（待总结）==：</p><h3 id="文法二义性的消除方法有多少种？">文法二义性的消除方法有多少种？</h3><h4 id="文法消除二义性的方法："><strong>文法消除二义性的方法</strong>：</h4><p>以if-else语句的悬挂问题为例来记忆。</p><ol><li>设臵一个限制规则，在分析程序中实现（加上强制规则）</li><li>改造文法</li><li>重新设计书写语法（用的最多）<br>具体做法1：else部分一定要出现<br>具体做法2：使用一个与if匹配的关键字作为语句的结束，比如end if</li></ol><h3 id="文法的构建问题">文法的构建问题</h3><p><strong>典型例子：构建算术表达式的文法规则的步骤</strong></p><ol><li>构造能反映运算符间优先关系的规则<br>• 由于在树型中离根越近,则优先级越低,<br>• 而推导过程均由文法开始符号进行分析,<br>• 因此,在规则中==最接近文法开始符号==的运算符号 应该是+ - ,而 * /则远一点,而( )则更远.</li><li>考虑结合性：左递归规则可实现左结合，而右递归规则可实 现右结合<br>• 同级运算符号的优先关系: 左结合<br>• 根据语法树中谁深谁优先的原理可得<br>• ==左方的同级运算符只能在左边产生,而不能在右边 产生，所以删除右递归，用一个新的非终结符代替==.<br><strong>注意</strong>：</li><li>关系之间的结合性<br>左结合：同级运算先算左边，如：a+b+c，先算a+b，再算b+c<br>右结合：同级运算先算右边</li></ol><h5 id="文法规则的扩展表示EBNF">文法规则的扩展表示EBNF</h5><p>前面讲到的文法的表示方法，常被称为BNF的表示方法<br>BNF表示方法的缺点：</p><ol><li>表达能力弱，符号不丰富</li><li>程序设计语言的控制结构有：顺序、重复和可选结构，而BNF的表示方法没有重复和可选的结构<br>引入两个新的运算符号，表达可选和重复，其实就类似于正则表达式中的可选和闭包。<br>EBNF中用{…}表示重复，用[…](中括号)表示闭包可选。</li></ol><h3 id="自顶向下分析法的问题-左公共因子、左递归">自顶向下分析法的问题: 左公共因子、左递归</h3><h4 id="自顶向下分析的约定">自顶向下分析的约定</h4><ol><li>自定向下的推导都是<strong>最左推导</strong><br>从左到右的分析算法，即总是从左到右地分 析输入符号串，首先分析符号串中的最左符 号，进而依次分析右边的一个符号，直到分 析结束。<br>==注意：自顶向下的分析方法，必须先进行左工因子、左递归的消除，而要做到这两点，求First和Follow也是必不可少的==</li></ol><h4 id="左工因子问题解决">左工因子问题解决</h4><p>例子：写出下面的文法的递归子程序$$\displaylines{if-stmt\ \to\ if\ (exp)\  statement\ |\ if\ (exp)\ statement\ else\ statement}$$<strong>问题分析</strong>：</p><ol><li>由于该文法规则的推导有两种情况，所以需要分支语句；</li><li>但是由于两种情况的开头第一个符号都是相同的，都是if（非终结符号），所以对应着同一个函数或者终结符号，那么用前面的方法进行匹配，无法区分什么时候选第一条规则，什么时候选择第二条规则；</li></ol><p><strong>解决方法</strong>：</p><ol><li>方法一：提公因式，把规则进行改写：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>ϵ</mi><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ (\epsilon |\ else\ statement)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">ϵ</span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><br>当提取公因子后，非公因子部分很长时，采用引入非终结符的方法：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mtext> </mtext><mi>α</mi><mi>β</mi><mi mathvariant="normal">∣</mi><mi>α</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \to \ \alpha\beta|\alpha\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>可以进行公因子提取；在分解后，<strong>将该规则分解为两个规则</strong>(==一般在提取公因子后，非公因子部分很长的时候采用这种方法==)：</li></ol><p>\displaylines{A \to \alpha A^,\\A^, \to \beta|\gamma}</p><ol start="2"><li>方法二：用扩充的BNF改造原来的文法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">[</mo><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ [else\ statement]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">[</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span></li></ol><h4 id="左递归问题的解决">左递归问题的解决</h4><p>左递归分为直接左递归和间接左递归，直接左递归的处理比较简单，间接左递归的处理是在基于直接左递归的基础上进行的。</p><h5 id="直接左递归的消除">直接左递归的消除</h5><p><strong>方法一</strong>：使用EBNF的方法改写规则，消除左递归<br>A→Aa|b (左递归)<br>• 在EBNF中用花括号{ . . . }来表示重复<br>• 因此上述规则可用以下规则写出: A→b{ a }<br><strong>方法二</strong>：<br>A→Aa|b (左递归)<br>• 改写为右递归 A→bA` A` <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> aA`| <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></p><h5 id="间接左递归">间接左递归</h5><p>研究下面文法： G[A]:<br>A→ Aa| Bb | Cc<br>B <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Ab | Bb<br>C <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Ac |Cb<br>解决思路：<br>（１）逐个逐个非终结符进行解决；<br>（２）将干净非终结符代入未解决的非终结 符中，并将其消除干净；<br>（３）反复实施</p><h5 id="左递归消除算法">左递归消除算法</h5><p>(1)将文法G的所有非终结符号按任一种顺序排列为 A1 , . . . , Am;<br>(2)执行循环语句：<br>for( i=1; i&lt;=m ; i++ )<br>{<br>for ( j=1; j&lt;=i-1; j++)<br>将规则Ai→Aj<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>改写；<br>//改写方法如下：如果Aj→ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> |<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\beta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|…|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\beta_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> // Ai →<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_1\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>| <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>2</mn></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_2\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> | … | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>k</mi></msub><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta_k\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span><br>消除Ai 规则中的直接左递归；<br>}<br>(3)化简由(2)所得的文法，即消去多余规则</p><h3 id="文法的简化">文法的简化</h3><h4 id="文法规则有效性分析与化简文法">文法规则有效性分析与化简文法</h4><ul><li>有害规则：形如U→U的产生式，会导致文法出现二义性</li><li>多余规则：指文法中任何句子的推导都不会用到的规则 文法中不含有不可到达和不可终止的非终结符<br>1）文法中<strong>某些非终结符不在任何规则的右部出现</strong>， 该非终结符称为不可到达。<br>2）文法中<strong>某些非终结符,由它不能推出终结符号串</strong>， 该非终结符称为不可终止。</li><li>化简文法——删除无效规则<br>目标：文法中不含有有害规则和多余规则</li></ul><h3 id="First-与follow集合-实验四">First 与follow集合(实验四)</h3><h4 id="First集合计算方法归纳">First集合计算方法归纳</h4><p>在递归下降程序中，为了提高分析效率，往往要求出每一条文法规则的开头的非终结符号的所有打头的终结符号，也称为First集合。这样可以避免回溯性。<br>不过需要注意的是First集合不一定只有非终结元素，还有可能有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>空串。<br><strong>算法一</strong>：<br>伪代码描述：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630114350.png" alt="Pasted image 20240630114350"><br>==<strong>算法二</strong>==（递归表达）：<br>·······················`</p><h4 id="Follow集合计算方法归纳">Follow集合计算方法归纳</h4><p>为了避免带有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的文法规则有多余的函数调用（视频26的36分50秒的分析解释了求Follow的原因），我们可以求非终结符号的Follow集合元素来决定是否要调用该非终结符号的函数。</p><p>Follow集合的运算可能遇到的情况如下：</p><ol><li>若A是开始符号，Follow(A) = ?</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，Follow(B) = ?</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)中，则Follow(A) = ?</li></ol><p>定义：给出一个非终结符号A，那么集合Follow(A)则是由终结符或结束符号$组成。<br>集合Follow(A)定义如下：</p><ol><li>若A是开始符号，则$就在Follow(A)中</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>γ</mi><mo stretchy="false">)</mo><mo>−</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">First(\gamma)-{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Follow(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>中</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)集合中，则Follow(A)包括Follow(B)</li></ol><p><strong>算法</strong>：</p><ol><li>初始化：<br>1.1 Follow(开始符号)={ $ }<br>1.2 其他任何一个非终结符号A，则执行 Follow(A)={ }</li><li>循环：反复执行<br>2.1 循环：对于文法中的每条规则 A<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> X1X2… Xn 都执行<br>2.1.1 对于该规则中的每个属于非终结符号的Xi ，都执行<br>2.1.1.1 把 First(Xi+1Xi+2… Xn) - {<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>} 添加到 Follow(Xi)<br>2.1.1.2 if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> in First(Xi+1Xi+2… Xn), 则把Follow(A)添加到 Follow(Xi)<br>直到任何一个Follow集合的值都没有发生变化为止。<br><strong>伪代码</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630163944.png" alt="Pasted image 20240630163944"></li></ol><h3 id="总结习题-2">总结习题</h3><p>一、给定字符串，写出最左推导/最右推导过程（对应的文法在PPT第19页）</p><ol><li>例题：对于文法G(exp) ，下面是关于 v*(v＋d) 的一个最左推导</li><li>例题：对于文法G(exp) ，下面是关于 v*(v＋d) 的一个最右推导</li><li>递归推理出字符串 v*(v＋d) 的一个归约过程为</li></ol><p>二、给定某个文法，求出该文法描述的语言</p><ol><li>例2 设有文法 G1=(VN，VT，P，A) 其中， VN={A} VT={a} P={ A→a} 试问：此文法描述的语言L(G1)=?</li><li>例3 设有文法 G2=(VN，VT，P，A) 其中， VN={A} VT={a} P={ A→Aa, A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>} 试问：此文法描述的语言L(G2)=?</li></ol><p>三、给定文法规则和符号串，画出相应的分析树</p><ol><li>例 G[S]： S→V=E ，V→i ，E →F+F ｜F ，F →(E)｜i 分析所输入的符号串i=i+(i)是否为其句子，并画出相 应的分析树。</li></ol><p>四、给定文法规则，设计出语法树结构（什么是需要保留的信息），写出对应的语法树存储结构，==画出对应的语法树==</p><ol><li>这部分至少掌握TINY语言各个语句的语法树结构，结合实验，加上自己设计的语法树</li></ol><p>五、给定文法规则，判断文法二义性，若存在二义性，进行文法二义性消除</p><ol><li>例. G3=({if,then,else, e , a},{S},P,S)<br>G3[S]：<br>S→if e then S<br>| if e then S else S<br>|a<br>判断该文法是否存在二义性？如果存在，请消除其二义性。</li></ol><p>六、构造文法规则</p><ol><li>基本例题：<ul><li>例：L1={ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup><msup><mi>b</mi><mi>j</mi></msup><msup><mi>c</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">a^i b^j c^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>| i, j, k≥1 }</li><li>例：构造语言L2={ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msup><mi>b</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">ab^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>| i≥0 }的文法</li><li>==例（未解决）==：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>={a,b}的句子S的集合是由一个b及在其 前后有相同数目的a组成：<br>S= { b,aba,aabaa,aaabaaa,…} = { <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mi>b</mi><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^nba^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mord mathnormal">b</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>| n≥ 0 }</li></ul></li><li>如何用文法规则描述算术表达式?</li><li>==实验三中的各种表达式的文法规则构造==</li></ol><p>七、文法化简</p><ol><li>例，G[S] ：  S→Be<br>B→Ce<br>B→Af<br>A→Ae<br>A→e<br>C→Cf<br>D→f</li></ol><p>八、消除左递归，求Firts集合与Follow集合<br>==如果是递归下降分析的前提下求First和Follow，一定要记得先消除左递归、提左工因子！==<br><strong>求First集合的题型</strong>：</p><ol><li>考虑情况1: G[S]={ S→AB A→Ba B→Cb C<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>ef } （1）<br>求出first©=? （2）求出first(A)=?</li><li>考虑情况2: G[S]={ S→AB|CD A→aB|dD B→cC|bD C→ef |gh D→i | j }<br>求出first(A)=? 求出first(S)=?</li><li>考虑情况3: G[S]={ S→ABC | D ，A→aB|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，B→cC|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，C→eC|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，D→i | j }<br>求出first(D)=? 求出first(A)=? 求出first(S)=?<br><strong>求Follow集合的题型</strong>：</li><li>视频27中有介绍答案，习题从13分开始</li></ol><p><strong>消除左递归的题型</strong>：</p><ol><li>例 消除下面文法的左递归 A→ Ba| Aa| c<br>B→ Bb| Ab| d</li><li>例.G[Z]： Z<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>Za | Sbc | dS<br>S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Zef | gSh<br>试消除左递归</li><li>例.文法G[Z]： Z <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Sa | Tb | cZ<br>S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Tde | Zf | Sg<br>T <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> Sh | jTk<br>试消除左递归</li></ol><h2 id="第四章（重点）-——-自顶向下的分析">第四章（重点） —— 自顶向下的分析</h2><h3 id="递归下降语法分析方法-或称递归子程序">递归下降语法分析方法(或称递归子程序)</h3><h4 id="自顶向下分析方法相关概念">自顶向下分析方法相关概念</h4><p><strong>定义</strong>：从文法开始符号开始,不断利用文法规则进行推 导,直到推导出所要分析的符号串为止。</p><p>目前自顶向下的分析方法有两种：</p><ul><li>一种是回溯性自顶向下分析，本质上是对产生式的枚举</li><li>一种是预测性自顶向下分析，主要策略有LL分析法和递归下降分析法</li></ul><h4 id="一、回溯性自顶向下分析">一、回溯性自顶向下分析</h4><p><strong>引起递归下降分析的符号串匹配的回溯性的原因</strong>：</p><ol><li>情况1：非终结符A存在多个推导，选哪一个的问题<br>对于非终结符A，A的两条规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">A\to ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">ab</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>右部First集交集不为空，从而引起回溯</li><li>情况2：非终结符A存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>推导，是否要跳过该非终结符的问题<br>对于非终结符A，如果A的产生式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>b</mi><mi>A</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A \to bAS | \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>b</mi><mi>A</mi><mi>S</mi><mo stretchy="false">)</mo><mo mathvariant="normal">∉</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">Follow(A)\cap First(bAS) \notin \phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>，也会隐私回溯</li><li>情况3：存在左递归，出现递归无限调用的问题——死递归</li></ol><h4 id="二、预测性自顶向下分析">二、预测性自顶向下分析</h4><p><strong>定义</strong>：<br>预测性也称确定的自顶向下分析方法</p><ul><li><strong>非终结符选择</strong>和<strong>规则选择</strong>都是确定的在每一步推导中 ，总是对<strong>最左边的非终结符进行展开</strong>，且选择哪一个规则是确定的，因此是一种无回溯的方法。</li><li>具体实施策略有：<br>递归下降分析法(Recursive-Descent Parser)<br>LL(1)分析析法(LL(1) Parser)</li></ul><h5 id="无回溯自顶向下分析技术的文法条件">无回溯自顶向下分析技术的文法条件</h5><p>为应用无回溯的自顶向下分析技术，文法必须满足下 列条件：</p><ol><li>无左递归性 文法中关于任何非终结符号U，都不具有规则左递归 和文法左递归，即，不存在形如U::=U…的规则，也不存 在U <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> U…。</li><li>无回溯性 一个文法的任何<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">U\in V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，存在U::=u1|u2|…|uk， 若ui <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Ti…与uj <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Tj…，Ti、Tj <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> VT, i <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> j，就有Ti <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> Tj。（理解：就是如果存在一个非终结符U，以U为左部的产生式有多个，那么每一个产生式的First元素都不同，或者是没有交集）<br>所以我们前面学的求First集合以及求Follow集合以及消除左递归，都是为了递归下降分析程序做准备，现将文法进行预处理，得到无回溯性文法，再递归下降分析。</li></ol><h4 id="递归下降分析法">递归下降分析法</h4><p><strong>定义</strong>：对每个非终结符按其规则结构产生相应语法分析子程序。</p><ul><li>终结符产生匹配命令</li><li>非终结符则产生调用命令<br>由于文法递归相应函数也递归，所以称这种 方法为递归子程序方法或递归下降法。</li></ul><h5 id="语法图">语法图</h5><p>语法图是基于EBNF而绘制的，所以在绘制语法图之前，要先将文法规则转化成EBNF的形式。<br><strong>定义</strong>：</p><ul><li>语法图是语法规则的直观表达</li><li>递归下降分析程序处理逻辑的直观表达</li><li>每一个非终结符的文法规则确定一个语法图<br><strong>元素</strong>：</li><li>箭头，表示序列和选择</li><li>圆形或椭圆形框，表示终结符</li><li>方形框和矩形框，非终结符</li></ul><h5 id="递归下降分析程序的设计">递归下降分析程序的设计</h5><p>递归下降分析程序的设计方法：<br><strong>一、语法图法</strong><br>每个非终结符都对应一个函数。该函数根据语法的描述来明确：根据下一个输入符号 来确定按照哪一个规则进行处理，再根据该规则的右端，<br>• 每遇到一个终结符，则判断当前读入的单词是否 与该终结符相匹配，若匹配，再读取下一个单词 继续分析；不匹配，则进行出错处理<br>• 每遇到一个非终结符，则调用相应的函数</p><p><strong>二、直接根据文法规则进行递归下降</strong><br>U→x1 | x2 |…|xn，其中 x1,…xn均≠ ε<br>U→x1 | x2 |…|xn|ε<br>规则选择问题：通过分别求出first集合 和follow集合来解决</p><p>非终结符相应的分析子程序的构造方法<br>(1)对于每个非终结符U，编写一个相应的子程序P(U);<br>(2)对于规则U→x1 | x2 |…|xn，x1,…xn都≠ ε，关于U的函数P(U)按如下方法构造：<br>if (TOKEN in first(x1) )<br>p(x1);<br>else if (TOKEN in first(x2) ) p(x2);<br>else … …<br>if (TOKEN in first(xn) ) p(xn);<br>else ERROR( );<br>(3)如果U还有空规则U→ ε,则算法中的语句： if (TOKEN in first(xn) ) p(xn) ; else ERROR( ); 改写为<br>if (TOKEN in first(xn)) p(xn) ;<br>else if (TOKEN not in follow(U) )<br>ERROR( );<br>(4)对于符号串x=y1y2…yn；p(x)的含义为： { p(y1);p(y2);…;p(yn); }<br>如果yi∈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则P(yi)就代表调用yi的函数；<br>如果yi∈<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则 为P(yi)设计下述的一段代码或设计一个match函数。<br>if (TOKEN==yi ) getToken(TOKEN) else ERROR( );</p><p><strong>注意</strong>：</p><ol><li>递归下降分析器由一个主程序main和每个非终结符对应的递归函数组成。</li><li>用到的一些函数：<ul><li>函数getToken( )负责读入下一个TOKEN单词</li><li>函数ERROR( )负责报告语法错误</li><li>函数match( )终结符号的匹配处理</li></ul></li><li>约定：全局变量TOKEN存放已读入的TOKEN单词</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// match函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(expectedToken)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(TOKEN == expectedToken)</span><br><span class="line"><span class="built_in">getToken</span>();  <span class="comment">//  获取下一个信号</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">ERROR</span>();  <span class="comment">//  产生报错信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">getToken</span>();</span><br><span class="line"><span class="built_in">S</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ERROR函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ERROR</span><span class="params">(<span class="type">int</span> ErrorNO)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(ErrorNO)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: cout &lt;&lt; <span class="string">&quot;xxx&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三、实现语义功能</strong><br><strong>基本步骤</strong>：</p><ol><li>写出文法规则</li><li>改进文法规则（提取左工因子、消除左递归）</li><li>写出递归下降分析子程序，根据语义功能添加添加动作</li></ol><p>1）使用递归下降分析法实现算术表达式的计算</p><p>2）使用递归下降分析法实现算术表达式的语法树构建<br><strong>方法</strong>：</p><ol><li>写出文法规则</li><li>写出递归下降子程序</li><li>在递归下降子程序的基础上增加语法树生成功能：<ul><li>遇到运算对象生成叶子节点并返回</li><li>遇到运算符号就将对应运算对象进行新树根的构造</li><li>遇到括号就返回括号中的表达式对应的语法树</li><li>因此，需要为每一个递归函数加上返回当前所生成的语法树的树根指针</li></ul></li></ol><p>3）使用递归下降分析法实现算术表达式汇编指令的产生<br><strong>常用的汇编指令的介绍</strong>：</p><ul><li>Ldc n 把常数n压入栈</li><li>Mpi 取出栈顶与次栈顶元素做乘法运算，结果入栈</li><li>Adi 取出栈顶与次栈顶元素做加法运算，结果入栈</li><li>Sbi 取出栈顶与次栈顶元素做减法运算，结果入栈</li><li>Dvi 取出栈顶与次栈顶元素做除法运算，结果入栈<br><strong>方法</strong>：</li></ul><ol><li>写出文法规则</li><li>写出递归下降分析程序</li><li>在递归下降分析程序中增加汇编代码生 成功能<br>– 遇到运算对象则生成Ldc指令<br>– 遇到运算符号就生成相应运算的指令<br>– 遇到括号则不做指令生成处理</li></ol><p>4）为if语句构造语法树</p><h5 id="递归下降法的总结">递归下降法的总结</h5><ol><li>递归下降分析功能非常强大，比较适合于手工 方法；</li><li>分析效率低，仅适合于小型语言语法分析程序 的构造。</li><li>为了解决一些问题，通常先将BNF文法规则改 写为EBNF规则。</li><li>==在生成语法树时，要注意二义性问题的分析。==</li></ol><h3 id="LL-1-分析方法-–LL-1-判断方法-–LL-1-分析表-–LL-1-分析过程">LL(1)分析方法 –LL(1)判断方法 –LL(1)分析表 –LL(1)分析过程</h3><h4 id="LL-1-的分析方法相关概念">LL(1)的分析方法相关概念</h4><p><strong>产生背景</strong>：递归下降程序会产生回溯、选择，导致其效率较低，LL(1)技术用表的方式记录每一个非终结符遇到终结符去到哪一条文法规则，使得语法分析准确高效！</p><h5 id="LL-1-文法规则的判定定理">LL(1)文法规则的判定定理</h5><p><strong>定理/定义</strong>：若满足以下条件，则BNF中的文法就是LL(1) 文法(LL(1) grammar)。</p><ol><li>在每个规则A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\alpha_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> | … |<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中,对于所有的i 和j:1≤I,j≤n,i≠j,First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span>First (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>)为空。（<strong>如果不满足该条件，就会存在一个表项有两个文法的现象，本质上是原文法存在左工因子</strong>）</li><li>若对于每个非终结符A都有First(A) 包含了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，那 么First(A) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span> Follow (A)为空。（<strong>如果不满足，则也会存在一个表项有两个文法的现象，本质上是原文法存在二义性</strong>）</li></ol><h5 id="存储结构">存储结构</h5><p><strong>分析表的存储结构</strong>：<br>根据递归分析法，是查看当前符号来决定选择哪条规则的， 因此，应该存储某个非终结符号遇到某个终结符号时该选择 哪条规则。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701114849.png" alt="Pasted image 20240701114849"><br>LL(1)分析表通常用M[N, T]表示：<br>• N(即行)是文法的非终结符的集合；<br>• T(即列)是终结符或记号的集合<br>• M[N,T]即表示非终结符N面临输入符号T该选择的 规则。<br>• M[N,T]缺省时(即为空)，则表示在分析中可能发生 的潜在错误。</p><p><strong>LL(1)分析表的构造步骤</strong>：<br>为每个非终结符A和规则A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 重复以下两个 步骤：</p><ol><li>对于First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>)中的每个记号a，都将A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>添加 到项目M[A, a]中</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>)中，则对于Follow (A) 的每个 元素a(记号或是$)，都将A→ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 添加到M[A, a] 中</li><li>把分析表A中每个未定义元素置为ERROR，通常用空白表示即可</li></ol><p><strong>分析过程的存储结构——分析栈</strong>：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701114923.png" alt="Pasted image 20240701114923"></p><h4 id="LL-1-分析方法以及过程">LL(1)分析方法以及过程</h4><p><strong>LL(1)分析</strong>：</p><ol><li>构造LL(1)分析表（LL(1)的parsing table）</li><li>针对某个符号串的分析过程（终结符号匹配，非终结符号替代）<ol><li>初始化：文法开始符号入栈</li><li>查表</li><li>替换（逆向）</li><li>反复（2），（3）步骤，直到分析成功（两边同时为空）或失败</li></ol></li></ol><h4 id="LL-1-解决二义性问题的方法">LL(1)解决二义性问题的方法</h4><p>LL(1)分析表可能出现一个表项有多个元素的情况，这就是二义性问题，解决方法：</p><ol><li>弹窗，让用户选择一条规则继续执行</li><li>自己修改文法规则，决定选择哪一条文法应该保留</li></ol><h3 id="实验三">实验三</h3><h3 id="总结习题-3">总结习题</h3><p>一、绘制语法图</p><ol><li>例如，文法规则 factor→ (exp) | number 用语法图表示是</li><li>例3.10 画出简单算术表达式的语法图<br>exp → exp addop term | term<br>addop → + | -<br>term → term mulop factor | factor<br>mulop → *<br>factor → ( exp ) | number</li><li>例3. 11 画出语法图<br>statement → if-stmt | other<br>if-stmt → if (exp) statement | if (exp) statement else statement<br>exp → 0 | 1</li></ol><p>二、构建递归下降程序<br>①根据语法图构建递归下降子程序</p><ol><li>非终结符号if_Stmt分析程序<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240630190828.png" alt="Pasted image 20240630190828"><br>②根据文法规则直接构造递归下降分析程序+写出递归下降子程序并分析表达式</li><li>G[S]= { S<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>aAb, A<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>cB, B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>e } 试编写一个能分析该文法所对应任何串(如 串aceb)的程序.</li><li>直接看PPT的题，有标记（Zotero）</li></ol><p>③用递归下降分析法实现语义功能</p><p>④构造LL(1)分析表并且进行分析<br><strong>疑问</strong>：PPT105页的问题3的构建！！</p><h2 id="第五章">第五章</h2><h3 id="LR-0-DFA、LR-1-DFA、-LALR-1-DFA？">LR(0) DFA、LR(1) DFA、 LALR(1) DFA？</h3><h4 id="LR-k-分析法">LR(k)分析法</h4><ul><li>L是指从左到右扫描输入符号串，left scan</li><li>R是指构造一个最右推导的逆过程，right analysis</li><li>K是指向前看的输入符号的个数，lookahead k<br>LR分析方法是当前最广义的<strong>无回溯</strong>的“<strong>移进归约</strong>”方法。<br>==根据栈中的符号串和向右顺序 查看输入串的k(k&gt;=0)个符号，就能唯一确定分析器的动作是移进还是归约，以及用哪个产生式进行归约。==</li></ul><h4 id="LR-0-分析在计算机上的实现">LR(0)分析在计算机上的实现</h4><h5 id="存储结构-2">存储结构</h5><ol><li>邻接矩阵</li><li>链接表</li><li>新二维表存储——LR(0)分析表<br>（顶点跟边的关系的存储结构）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240701160855.png" alt="Pasted image 20240701160855"></li></ol><h4 id="SLR-1-分析">SLR(1)分析</h4><ul><li>简单LR(1)分析</li><li>SLR(1)还是使用LR(0)的项目集DFA</li><li><strong>只是在构造分析表时才考虑超前查看的符号</strong></li></ul><h4 id="LR-1-分析法">LR(1)分析法</h4><p>LR(1)克服了SLR和LR(0)的缺陷——不考虑先行符，LR(1)是对每条文法考虑其先行符号来解决归约-移进冲突。</p><h4 id="LALR-1-分析法">LALR(1)分析法</h4><p>LALR(1)分析法克服了LR(1)分析的弊端——冗余项目集，LALR(1)是在LR(1)的基础上合并状态的核心而达到压缩状态数的目的，有效地提高了LR(1)的存储效率，但是LALR(1)相比于LR(1)来说，出错稍有延迟。<br><strong>压缩方法</strong>：</p><ul><li>核心一样就合并</li><li>对应的先行符做并集<br>合并后的DFA图的状态数和LR(0)相仿</li></ul><p><strong>LALR(1)的分析步骤</strong>：</p><ol><li>先构造出LALR(1)的DFA图</li><li>再构造出LALR(1)的分析表</li><li>==最后利用LAKR(1)的分析表对所要分析的符号串进行分析，PPT上说自行完成==</li></ol><h4 id="LALR-1-和LR-1-的效率区别">LALR(1)和LR(1)的效率区别</h4><ol><li>LALR(1)存储效率大大高于LR(1)</li><li>LR(1)的报错比LALR(1)及时一些</li></ol><h3 id="LR-0-分析表、LR-1-分析表、-SLR-1-分析表、-LALR-1-分析表？">LR(0)分析表、LR(1)分析表、 SLR(1)分析表、 LALR(1) 分析表？</h3><h4 id="SLR-1-的分析表的构建">SLR(1)的分析表的构建</h4><ol><li>构建好LR(0)/SLR(1)分析图（一样的）</li><li>求每一个非终结符的Follow集合元素</li><li>对于归约，将其中归约文法接收到其Follow集合元素对应的归约规则填入对应的表项</li><li>对于移进，将其中移进文法接收到什么符号移进到什么状态填入表</li></ol><h3 id="LR-0-文法、LR-1-文法、SLR-1-文法、-LALR-1-文法？如何判断LR-0-文法、SLR-1-文法？">LR(0)文法、LR(1)文法、SLR(1)文法、 LALR(1) 文法？如何判断LR(0)文法、SLR(1)文法？</h3><h4 id="LR-0-的分析法">LR(0)的分析法</h4><p>根据栈中的符号串以及向右顺序输入串的0个符号，确定分析是移进还是归约，以及用哪个产生式进行归约的分析方法。不考虑先行符。</p><h4 id="LALR-1-分析法-2">LALR(1)分析法</h4><p>LALR(1)分析法克服了LR(1)分析的弊端——冗余项目集，LALR(1)是在LR(1)的基础上合并状态的核心而达到压缩状态数的目的，有效地提高了LR(1)的存储效率，但是LALR(1)相比于LR(1)来说，出错稍有延迟。</p><h4 id="SLR-1-文法判断">SLR(1)文法判断</h4><p>当且仅当对于任何状态s，以下的两个条件：</p><ol><li>对于在s中的任何项目A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.X<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，当X是一个终结符，且X在Follow (B) 中时，s中没有完整的项目 B→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>.。 ==[移进-归约冲突]==</li><li>对于在s中的任何两个完整项目A→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.和B→<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>.， Follow(A)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∩</span></span></span></span> Follow(B)为空。==[归约-归约冲突]==<br>均满足时，文法为SLR(1)文法。</li></ol><h3 id="文法如何利用LR-0-、LR-1-、-SLR-1-、LALR-1-进行语法分析？">文法如何利用LR(0) 、LR(1) 、 SLR(1)、LALR(1) 进行语法分析？</h3><h4 id="运用自底向上、自顶向下的方法进行语法分析">运用自底向上、自顶向下的方法进行语法分析</h4><h5 id="运用自顶向下的分析方法进行语法分析步骤（前面其实也总结过，本质是一样的）">运用自顶向下的分析方法进行语法分析步骤（前面其实也总结过，本质是一样的）</h5><ol><li>写出文法规则（形式化语言描述）</li><li>对文法规则进行消除左递归和消除左工因子</li><li>书写递归下降子程序</li><li>根据问题具体需求，在递归下降程序中增加相应的处理——语义动作</li></ol><h5 id="运用自底向上的分析方法进行语法分析的步骤">运用自底向上的分析方法进行语法分析的步骤</h5><ol><li>书写文法规则（自底向上的分析方法对文法规则不做约束）</li><li>画出对应的LR(0)/LR(1)的DFA图</li><li>根据所使用的分析方法对DFA图进行进一步处理，比如LALR(1)需要对LR(1)图进行状态压缩</li><li>根据DFA图写出对应的分析表</li><li>根据问题的具体需求，对每一条文法写上相应的处理——语义动作<br>Tips：最好是找个具体实例分析一遍，在分析的过程中看看需要做什么动作<br>==其中，画DFA图的步骤可以省略，直接对着文法进行分析语义动作也可以！==</li></ol><h4 id="语法分析的基本思想">语法分析的基本思想</h4><p>语法分析基本思想：在语法分析过程中，根据语言的语义定义随时分析并翻译已识别的那部分语 法成分的全部含义。翻译需要是通过调用为该语法成分事先编好的语义动作实现的。</p><p><strong>常用语法分析翻译方法</strong>：<br>一、在确定的递归下降语法分析程序中， 利用隐含堆栈存储各递归下降函数内的局部变 量所表示的语义信息。<br>二、在自底向上语法分析程序中使用和语法分 析栈同步操作的语义栈进行语法分析翻译。<br>三、在LL(1)语法分析程序中，利用翻译文法实 施语法分析翻译。</p><ul><li>翻译文法是在描述语言的文法(即源文法或输入文法) 中加入语义动作符号而形成的。<br>四、利用属性文法进行语法分析翻译。</li><li>属性文法也是一种翻译文法</li><li>其符号(文法符号和动作符号)都扩展为带有语义属性 和同一规则内各属性间的运算规则。</li></ul><h4 id="属性文法的概念">属性文法的概念</h4><p><strong>属性</strong>：对文法的每一个符号，引进一些属性，这些属性代 表与文法符号相关的信息，如类型、值、存储位置 等。<br><strong>语义规则</strong>：为文法的每一个产生式配备的计算属性的计算规则 ，称为语义规则。<br><strong>属性文法</strong>：属性文法是带属性的一种文法，他的主要思想如下：</p><ul><li>首先对于每个文法符号引进相关的属性符号</li><li>其次对于每个产生式写出计算属性值的语义规则<br><strong>属性文法的形式定义</strong>：<br>一个属性文法是一个三元组，A=(G, V, A)</li><li>G是一个上下文无关文法</li><li>V是属性的有穷集</li><li>F是关于属性的断言的有穷集<br><strong>说明</strong>：</li></ul><ol><li>每个属性与文法符号相联，N.t表示文法符号N的 属性t。属性值又称语义值。存储属性值的变量又 称语义变量。</li><li><strong>每个断言与文法的某个产生式相联，写在{ }内</strong>。 属性的<strong>断言又称语义规则</strong>，它所描述的工作可以 包括属性计算、静态语义检查、符号表的操作、 代码生成等，有时写成函数或过程段。</li></ol><h4 id="语义分析的基本概念">语义分析的基本概念</h4><p><strong>语义分析的实施方式</strong>：</p><ul><li>语法分析程序通过直接调用语义分析函数进行 语义分析；</li><li>先生成相应的语法树 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 再作语义分析<br><strong>语义分析的功能通常包括两个方面</strong>:</li><li>检查语法结构的静态语义,即分析句子的含义是 否有意义,实际工作多为作用域分析、类型的分析</li><li>将合乎语义的句子进行翻译，并生成某一种中 间形式<br><strong>语句的种类</strong>：</li><li>说明语句：用于定义各种名字的属性</li><li>可执行语句：用于完成指定功能<br><strong>语义分析的任务种类</strong>：</li><li>分析说明语句——需要把所定义名字的各种属性 登记到<strong>符号表</strong>，以便在分析到可执行语句时使用；</li><li>分析可执行语句——首先根据各语句的语法结构和语义设计出相应目标代码结构，然后再给出从源 语法结构到翻译过程图示的变换方法,语义分析程 序则根据这些变换方法进行分析并生成中间代码</li></ul><p><strong>符号表</strong>：</p><ul><li>标识符定义实体</li><li>实体属性保存在符号表<br><strong>符号表的形式</strong>：</li><li>每个名字对应一个表项</li><li>一个表项包括<strong>名字域</strong>和<strong>属性信息域</strong><br><strong>==符号表如何解决作用域的问题？==</strong></li></ul><p><strong>符号表操作函数</strong>：</p><ol><li>LOOKUP(NAME)：以符号名NAME(标识符)查符号表，若 表中已存在该标识符，则返回其在表中的位置(序号)，否则返回 NULL。</li><li>ENTER(NAME)：在符号表中新登记一名字为NAME的项， 并返回该项在表中的位置(序号)。</li><li>ENTRY(NAME):查、填符号表的语义函数</li><li>Fill(符号表位置，类型 )属性填写函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pointer <span class="title">ENTRY</span><span class="params">(NAME)</span></span>&#123;</span><br><span class="line">ENTRYNo = <span class="built_in">LOOKUP</span>(NAME);</span><br><span class="line"><span class="keyword">if</span>(ENTRYNo == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ENTER</span>(NAME);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实验四">实验四</h3><h3 id="题型总结">题型总结</h3><p>一、LR(0)、LR(1)的DFA图的绘制</p><h2 id="第六章">第六章</h2><h3 id="语法制导翻译的方法有多少种？">语法制导翻译的方法有多少种？</h3><h4 id="语法分析的基本思想-2">语法分析的基本思想</h4><p>语法分析基本思想：在语法分析过程中，根据语言的语义定义随时分析并翻译已识别的那部分语法成分的全部含义。翻译需要是通过调用为该语法成分事先编好的语义动作实现的。</p><p><strong>常用语法分析翻译方法</strong>：<br>一、在确定的递归下降语法分析程序中， 利用隐含堆栈存储各递归下降函数内的局部变 量所表示的语义信息。<br>二、在自底向上语法分析程序中使用和语法分 析栈同步操作的语义栈进行语法分析翻译。<br>三、在LL(1)语法分析程序中，利用翻译文法实 施语法分析翻译。</p><ul><li>翻译文法是在描述语言的文法(即源文法或输入文法) 中加入语义动作符号而形成的。<br>四、利用属性文法进行语法分析翻译。</li><li>属性文法也是一种翻译文法</li><li>其符号(文法符号和动作符号)都扩展为带有语义属性 和同一规则内各属性间的运算规则。</li></ul><h3 id="中间代码？表示形式如何？">中间代码？表示形式如何？</h3><h4 id="常见的中间代码的形式">常见的中间代码的形式</h4><p>树、后缀表示、三元组、四元组、P代码<br><strong>中缀表示</strong></p><ul><li>运算符号位于两个运算对象中间，如a+b</li><li>不利于表达式的计算及目标代码的产生<br><strong>后缀表示——逆波兰表示</strong></li><li>将运算符放在运算对象的后面，如 a b +</li><li>表达式中各运算符的出现顺序决定其计算的先后 顺序，因此无括号</li><li>后缀表达式与相应的中缀表达式中的运算对象的 出现顺序是一致的</li></ul><h3 id="如何将一个算术表达式转换为逆波兰表示、四元组表示、三元组表示？">如何将一个算术表达式转换为逆波兰表示、四元组表示、三元组表示？</h3><h4 id="中缀转后缀（逆波兰表示）">中缀转后缀（逆波兰表示）</h4><p>方法：自顶向下分析（递归下降）、自底向上分析（LR） | 属性文法（LL(1)或LR）</p><h5 id="扩充的后缀表示">扩充的后缀表示</h5><ul><li>赋值语句</li><li>数组a[e]的后缀表示为<code>e a SUBS</code></li><li>条件语句<code>if u S1 else S2</code>的后缀表示<br><code>u L1 BZ S1 L2 BR S2</code><br><strong>例</strong>：<br>if ( m &gt; n ) k=1 ； else m=0;<br>后缀表示： m n &gt; 10 BZ k1= 20 BR<br>10: m0=<br>20:</li><li>while语句：<br>while ( u ) S1 后缀表示：<br>L2<br>u L1 BZ S1 L2 BR<br>L1<br><strong>例子</strong>：<br>while ( m &gt; n ) k=1 ；<br>后缀表示：<br>10:<br>m n &gt; 20 BZ k 1 = 10 BR<br>20:</li><li>其他循环语句，如for、do-while、repeat-until</li></ul><h4 id="四元组表示方法以及其转换">四元组表示方法以及其转换</h4><p><strong>四元组表示方法</strong>：<br>(OP , P1 , P2 , T) 其中OP为运算符，OP1、OP2 为运算对象，T为计算结果的临时暂存变量。<br><strong>注意</strong>：</p><ol><li>P1、P2 、T 可代表的含义<ul><li>可以是一个指向<strong>符号表某一登记的入口位置</strong></li><li>可以是一个<strong>临时变量的整数码</strong></li></ul></li><li>即意味着在<strong>产生中间代码的过程</strong>中，也相应地进行查造符号表的工作——<strong>与符号表打交道</strong></li></ol><h4 id="三元组表示方法">三元组表示方法</h4><p>(OP , P1 , P2 )<br>其中OP为运算符，P1、P2 为运算对象。<br>用元组编号来来代表结果保存的位置。</p><h3 id="如何将一段代码翻译为中间代码（后缀、三元组、四元组）？">如何将一段代码翻译为中间代码（后缀、三元组、四元组）？</h3><h3 id="几种常用语句的翻译——能写出语义函数或语义动作">几种常用语句的翻译——能写出语义函数或语义动作</h3><p>1）算术表达式<br>2）说明语句<br>3）赋值语句</p><ol><li>分析书写格式</li><li>写出赋值语句的文法规则<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>i</mi><mi>d</mi><mo>=</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">S\to id = E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li><li>分析并理解其中的执行过程，写出语义动作<ul><li>将算数表达式E的值写入符号表中id的值属性中</li><li>需先查符号表</li><li>还需要检查数据类型<br>4）==逻辑表达式==</li></ul></li><li>分析逻辑表达式书写格式<br>运算符号有：逻辑运算符、关系运算符，优先级各不相同</li><li>书写逻辑表达式的文法规则</li><li>根据逻辑表达式两种不同的应用场景书写不同的语义函数：<ul><li>用作逻辑运算的逻辑表达式</li><li>用作控制语句中的条件表达式（区别是有跳跃关系，比如a||b||c，如果a||b已经满足，不需要再计算b||c）<br>5）条件判断语句—— if语句<br>6）循环语句——while语句<br>7）扩展到其他程序设计语句</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】6. 数据库事务管理</title>
      <link href="/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2024/06/17/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%916.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1>数据库事务管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">事务管理 --&gt; 事务 &amp; 并发控制 &amp; 故障恢复</span><br></pre></td></tr></table></figure><h2 id="事务">事务</h2><p>==事务是恢复和并发控制的基本单位！==</p><h3 id="事务的定义"><strong>事务的定义</strong></h3><blockquote><p>SQL中事务的定义事务以Begin transaction开始，以Commit work或 Rollback work结束Commit work表示提交，事务正常结束Rollback work表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态</p></blockquote><p>事务的DBMS的<strong>基本执行单位</strong>，由一序列的数据库访问和修改组成。这些操作要么全做、要么不做，是一个不可分割的整体。<br>例如：<br>例如银行转帐由两个操作组成：<br>① 转出帐户A 减去某一金额（A=A－?）<br>② 转入帐户B 增加相同金额（B=B + ?）<br>这两个操作放在同一个事务里完成，要么全做，要么全不做。</p><h3 id="事务的性质（ACID）"><strong>事务的性质</strong>（ACID）</h3><p>一、 <strong>原子性（Atomicity）</strong><br>事务中包含的所有操作（特指修改操作）要么全做，要么全不做。<br><strong>实现机制</strong>：原子性由<strong>恢复机制</strong>（本章第7节）实现</p><p>二、<strong>一致性</strong>（Consistency）<br>事务执行的结果必须是使得数据库从一个一致性状态到另一个一致性状态。<br>一致性状态：</p><ul><li>数据库中只包含成功事务的提交结果<br>不一致状态：</li><li>数据库系统中发生故障，有些事务尚未完成就被中断</li><li>这些未完成事务对数据库所做的修改有一部分已经写入物理数据库，这时数据库就处于一种不正确状态</li></ul><p><strong>实现机制</strong>：</p><ul><li>保证单个事务的一致性，由编写事务的应用程序员来负责，借助<strong>完整性机制</strong>来协助实现，所以数据的一致性要求可以被定义为某些完整性规则</li><li>数据库的一致性状态由用户来负责，由并发控制机制实现</li></ul><p>一致性视具体情况而定；<br>例如：<br>银行系统中，转帐事务的一致性要求是前后两个帐户的金额总和不变。假如一个事务为帐户A减去100，为帐户B加上50，那么这个事务就违反了一致性。</p><p><strong>一致性介绍以及例子解读，视频7分钟到8分钟</strong><br><a href="https://www.bilibili.com/video/BV13J411J7Vu?p=71&amp;vd_source=fcc6783c4fd6e558539db82a5f89834a">https://www.bilibili.com/video/BV13J411J7Vu?p=71&amp;vd_source=fcc6783c4fd6e558539db82a5f89834a</a></p><p>判断事务在事务调度过程中是否保持数据一致性</p><ol><li>分析事务在每一步处理过程前后，数据是否有被其他事务处理过，若有则不保持数据一致性<br>具体例子看PPT26页-27页两个并发调度的例子，第一个并发调度保持了数据一致性，第二个破坏了数据一致性</li></ol><p>三、<strong>隔离性</strong>（isolation）<br>多个事务在并发执行的时候不会相互影响，好像他们是隔离开来的；并发执行的最后结果与顺序执行这些事务的结果一致；<br><strong>隔离性要求一个事务不会看到另一个事务的中间结果</strong><br>例如：<br>对两个事务T1，T2。如果事务T1读取的数据，一部分是事务T2修改前的数据，一部分是事务T2修改后的数据，这就违反了隔离性，并可能导致数据错误</p><p><strong>实现机制</strong>：隔离性通过<strong>并发控制机制</strong>实现</p><p>四、<strong>持久性</strong>（Durability）<br>事务一旦提交，它对数据库的影响就是永久性的，无论发生什么事都无法取消这种影响。<br>例如：<br>一个事务将50元从帐户A转到帐户B，此事务一旦提交，这种交易是无法悔改的——即便发生故障，也不能把这50元“还”回去。<br><strong>实现机制</strong>：恢复机制</p><p><strong>破坏事务ACID特性的因素</strong><br>保证事务的ACID特性是事务处理的任务<br>破坏事务ACID特性的因素如下：</p><ul><li>多个事务并发运行，不同事务的操作交叉执行<br>DBMS必须保证多个事务交叉运行不影响这些事务的隔离性（DBMS的并发控制机制的责任）</li><li>事务在运行过程中被强制停止<br>数据库管理系统必须保证被强制终止的事务对数据库和其他事务没有任何影响，保证事务的原子性和一致性（DBMS恢复机制的责任）</li></ul><h3 id="事务的状态与操作">事务的状态与操作</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617104458.png" alt="Pasted image 20240617104458"></p><h4 id="事务的状态">事务的状态</h4><p>一、 活动状态</p><ul><li>事务开始后进入</li><li>事务处于本状态，依次执行事务中的每条语句</li></ul><p>二、部分提交状态</p><ul><li>执行完事务的全部语句后进入</li><li>事务处于本状态时，将已经做的<strong>每个修改操作提交，即永久化写入到==日志==</strong> 中。这样即使修改操作后来丢失了（例如数据库崩溃），也能根据日志来恢复它。</li></ul><p>三、失败状态</p><ul><li>在活动状态中，执行某条语句失败时而进入；或者在部分提交中，提交的永久化信息失败时进入</li><li>事务处于本状态时，不断回滚已经发生的修改操作，即把数据改为原来的旧值。</li></ul><p>四、提交状态</p><ul><li>提交完全部修改操作后进入；</li><li>事务处于本状态时，事务结束。为事务的结束状态之一</li></ul><p>五、中止状态</p><ul><li>回滚全部操作后进入</li><li>事务处于本状态，事务结束。为事务的结束状态之二</li></ul><h4 id="执行一个事务可能的状态序列">执行一个事务可能的状态序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">subgraph 序列1</span><br><span class="line">direction LR</span><br><span class="line">1[&quot;活动状态&quot;] --&gt; 2[&quot;部分提交状态&quot;] --&gt; 3[&quot;提交状态&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph 序列2</span><br><span class="line">direction LR</span><br><span class="line">4[&quot;活动状态&quot;] --&gt; 5[&quot;失败状态&quot;] --&gt; 6[&quot;中止状态&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph 序列3</span><br><span class="line">direction LR</span><br><span class="line">7[&quot;活动状态&quot;] --&gt; 8[&quot;部分提交状态&quot;] --&gt; 9[&quot;失败状态&quot;] --&gt; 10[&quot;中止状态&quot;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="SQL中的事务">SQL中的事务</h3><h4 id="相关语句">相关语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span> Transaction <span class="comment">--开始事务</span></span><br><span class="line"><span class="keyword">Commit</span> (Transaction) <span class="comment">--提交事务，此时事务正常结束，事务所做的修改都有效且永久地写入数据库</span></span><br><span class="line"><span class="keyword">Rollback</span> (Transaction) <span class="comment">--回滚事务。此时事务非正常结束，事务所做的修改都无效并且必须撤销（数据改回原值）；</span></span><br></pre></td></tr></table></figure><p><strong>回滚后，数据库回退到事务开始前的状态，就好像事务从来没有发生过一样</strong><br><strong>注意</strong>：</p><ul><li>事务没有执行完commit之前，因种种原因（故障），而终止了，那么系统就会自动地回滚这个事务。</li><li>判断SQL语句属于哪个事务<ul><li>如果SQL语句处于某个事务的Begin transaction和Commit/Rollback之间，那么它就属于这个事务</li><li>==如果以上不成立，那么这个SQL语句本身构成一个独立的事务==</li></ul></li></ul><h3 id="事务调度">事务调度</h3><p>定义：系统按什么时间顺序执行（进入系统的）一组事务/事务的指令</p><ul><li>虽然在微观上，这组事务是先后到达系统的，但宏观上可能是“同时”到达系统：即上一个事务还没结束时，下一个事务又进入了系统。</li></ul><p>一、串行调度</p><ul><li>当一个事务完全结束后，下一个事务才开始执行</li><li>特定：从时间顺序看，同一事务的指令紧挨在一起</li></ul><p>二、并发调度</p><ul><li>未执行完一个事务，可转去执行另一个事务</li><li>事务的执行时间重叠，宏观上多个事务同时执行，微观上这些事物分时执行</li><li>特定：从时间顺序看，不同事务的指令彼此交叉</li></ul><h4 id="并发调度的优势（相比于串行调度）">并发调度的优势（相比于串行调度）</h4><ol><li>不同事务的不同指令，涉及到的系统资源也不同，同时执行这些指令，可以<strong>提高资源利用率和系统吞吐量</strong>。<br>例如：<br>事务A和事务B，都由指令1(要求CPU计算)和指令2(要求I/O)组成。CPU和I/O设备是可以并行工作的，所以并发执行事务A的指令2和事务B的指令1时，可以避免资源闲置和缩短总执行时间。</li><li>系统中存在着周期不等的各种事务，串行调度导致短事务可能要等待长事务完成。（串行的弊端）<br>而采用并发调度，灵活决定事务的执行顺序，可以<strong>减少平均响应时间</strong></li><li>核心问题：在保证一致性的前提下最大限度地提高并发度</li></ol><h4 id="并发调度存在的问题">并发调度存在的问题</h4><p>一、可能破坏数据一致性<br>即使单个事务的执行不会破坏数据的一致性，多个这样的事务在并发调度时，也可能破坏数据一致性。</p><p>二、产生问题的原因<br>隔离性要求事务T1不能看到另一个事务T2的中间结果（一部分数据是修改前的、一部分数据是修改后的），但是在并发执行的情况下，有时没有做到这一点<br>三、解决方法（<strong>正确性原则</strong>）—— 使并发调度可串行化</p><ul><li>事务的串行调度显然不会破坏数据的一致性</li><li>如果事务的并发调度是可串行化的，即效果上等价于某个串行调度时，也不会破坏数据一致性</li></ul><p>保证单个事务有一致性的情况下：</p><ol><li>任何串行调度，不会破坏数据一致性</li><li>保证隔离性/可串行化的并发调度，也不会破坏一致性</li><li>隔离性得不到保证/不可串行化，可能会破坏数据的一致性，产生错误</li></ol><h4 id="并发调度产生的错误">并发调度产生的错误</h4><p>并发调度产生的错误，称为数据不一致性，主要分类三种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">三类不一致 --&gt; 丢失修改 &amp; 不可重复读 &amp; 1[&quot;`读“脏”数据`&quot;]</span><br></pre></td></tr></table></figure><ol><li>丢失修改的产生：<ul><li>两个事务T1和T2从数据库中读入同一数据，然后分别修改并提交</li><li>假设T1先提交，然后T2后提交，则后面提交的修改覆盖前面提交的修改，导致前面的修改丢失</li></ul></li><li>不可重复读：<ul><li>事务T1第一次读取某些数据后，事务T2对这些数据做了某些修改操作并提交，事务T1第二次读取该记录时得到的是与前一次不同的结果</li></ul></li><li>读取“脏”数据：<ul><li>事务T1修改数据，并写入数据库（新值覆盖旧值），但未提交</li><li>事务T2读取了这个数据，<strong>读到的新值即为脏数据</strong>：<br><strong>脏数据</strong>：其他事务修改后，但还未提交的数据<br>脏数据不一定是正确的，因为后续也可能会被回滚</li><li>事务T1由于某种原因回滚，数据改回旧值，导致前面T2读入的新值无效（一个不被承认的值）</li></ul></li></ol><h3 id="调度的几种情况">调度的几种情况</h3><h4 id="可串行化-是判断并发调度正确性的重要原则">可串行化(是判断并发调度正确性的重要原则)</h4><blockquote><ul><li><p>可串行化：若调度S与一个串行调度的执行有相同的效果，则称调度S是可串行化的。</p></li><li><p>只关心read和write操作。</p></li></ul></blockquote><p>可串行化有两种，满足其中一种即可；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">可串行化 --&gt; 冲突可串行化 &amp; 视图可串行化</span><br></pre></td></tr></table></figure><ul><li><strong>数据库管理系统对于并发事务不同的调度可能产生不同的结果，执行结果等价于串行调度的调度是才是正确的调度，称为可串行化调度</strong></li><li>多个事务的并发执行是正确的，当且仅当其结果与按某次串行地执行这些事务时的结果相同</li><li>可串行性是并发事务调度的正确准则，一个给定的并发调度，当且仅当它是可串行化的，才认为他是正确的调度</li></ul><p>一、冲突可串行化</p><p><strong>冲突操作</strong>(特点：涉及同一个数据，多个事务，至少有一个写操作)：</p><ul><li>不同事务对同一事务的<strong>读写</strong>操作，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>a</mi><msub><mi>d</mi><mrow><mi>T</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>和</mtext><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Read_{T1}(X)和Write_{T2}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span>同时发生</li><li>不同事务对同一事务的<strong>写写</strong>操作，比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mtext>和</mtext><mi>W</mi><mi>r</mi><mi>i</mi><mi>t</mi><msub><mi>e</mi><mrow><mi>T</mi><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Write_{T1}(X)和Write_{T2}(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></li></ul><p><strong>不能交换的操作</strong>：</p><ul><li>同一事务的两个操作不能交换，因为同一事务中用户规定什么执行顺序就是什么执行顺序，要满足用户需求</li><li>不同事务的冲突操作不能交换</li></ul><p><strong>冲突可串行化</strong>：</p><ul><li>条件比可串行化更严格</li><li>一个调度Sc在保证冲突操作的次序不变的情况下（就是不交换冲突操作），通过交换两个事务不冲突操作的次序得到另一个调度Sc<code>，如果Sc</code>是串行的，称Sc是冲突可串行化调度</li><li>若一个调度是冲突可串行化的，则一定是可串行化调度<br>如果并发调度<strong>冲突等价于某个串行调度</strong>，它就是冲突可串行化的；<br><strong>冲突等价</strong>：通过交换两条连续但不冲突得指令，得到新的调度，和原调度称为是冲突等价的</li></ul><h5 id="判定调度是否为冲突可串行化（判定调度正确性）">判定调度是否为冲突可串行化（判定调度正确性）</h5><p>视频的12分48秒之后的两个例题详细介绍了方法，通俗易懂！</p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142761539&p=80" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width: 100%;"></iframe><p>优先图判定冲突可串行化：</p><blockquote><p>优先图(precedence graph)</p><p>一个调度S的优先图是这样构造的：它是一个有向图G =（V，E），V是顶点集，E是边集。顶点集由所有参与调度的事务组成，边集由满足下述条件之一的边Ti —&gt; Tj组成：</p><p>①在Tj执行read(Q)之前，Ti执行write(Q)</p><p>②在Tj执行write(Q)之前，Ti执行read(Q)</p><p>③在Tj执行write(Q)之前，Ti执行write(Q)</p></blockquote><p><img src="assets/image-20241210124243666.png" alt="image-20241210124243666"></p><p><img src="assets/image-20241210124254436.png" alt="image-20241210124254436"></p><p>二、视图可串行化</p><p>如果并发调度的<strong>视图等价于某个串行调度</strong>，它就是视图可串行化的</p><p><strong>视图等价</strong>：对某一个数据项，两个调度按照相同的事务顺序来读取和写入</p><p><strong>视图等价的判定规则：</strong></p><p>考虑关于某个事务集的两个调度S，S’，若调度S，S’满足以下条件，则称它们是视图等价的：</p><p>①对于每个数据项Q，若事务Ti在调度S中读取了Q的初始值，那么Ti在调度S’中也必须读取Q的初始值</p><p>②对于每个数据项Q，若事务Ti在调度S中执行了read(Q)，并且读取的值是由Tj产生的，那么Ti在调度S’中读取的Q值也必须是由Tj产生的</p><p>③对于每个数据项Q，若在调度S中有事务执行了最后的write(Q)，则在调度S’中该事务也必须执行最后的write(Q)</p><h4 id="可恢复调度">可恢复调度</h4><p><strong>事务的恢复：</strong></p><p>一个事务失败了，应该能够撤消该事务对数据库的影响。如果有其它事务读取了失败事务写入的数据，则该事务也应该撤消</p><p>考虑这样一个情形：</p><ol><li>事务T1写入数据，尚未提交前事务T2对该数据进行读取<br>此时称T2依赖于T1，因为T2看到了T1产生的为提交确认的数据</li><li>然后T2先提交</li><li>接下来，事务T1由于某种原因（故障等）需要回滚<br>这时，理论上T2也要回滚（之前读取的数据无效）。<br>但此时T2已经提交了，无法回滚到前一个状态，所以出现了<strong>不可恢复调度</strong>——事务T1对数据库/其他事务的影响，不能全部取消（<strong>事务的持久性性质决定的</strong>）</li></ol><p><strong>可恢复调度的要求</strong>：</p><p>如果事务T2依赖于T1，那么事务T2必须在T1提交之后才能提交</p><h4 id="无级联调度">无级联调度</h4><p>考虑这样一个情形：</p><ol><li>事务T1写入数据，尚未提交前事务T2对该数据进行读取<br>此时称T2依赖于T1，因为T2看到了T1产生的为提交确认的数据</li><li>T2等待T1先提交，否则发生不可恢复调度</li><li>接下来，事务T1由于某种原因（故障等）需要回滚<ul><li>那么T2也需要回滚（之前读取的数据无效），并且如果有其他事务T3依赖于T2，也需要递归级联回滚</li><li>所以这里出现了<strong>级联回滚</strong>——单个事务回滚，会引发其他一系列事务被回滚的现象</li></ul></li></ol><p><strong>无级联调度的要求</strong></p><p>如果事务T2要读取T1写入的数据，只能在事务T1提交之后才能读取</p><h3 id="总结">总结</h3><p>一、事务调度分为串行调度和并发调度<br>并发调度的优点：提高执行效率<br>并发调度的问题：如果不作控制（保证隔离性、可串行化），就有可能产生三类数据不一致性错误：</p><ol><li>丢失修改</li><li>不可重复读</li><li>读取“脏”数据</li></ol><p>二、所以DBMS必须提供<strong>并发机制</strong>，来保证事务的并发调度是正确的，即保证隔离性、可串行化</p><h2 id="与事务执行相关的地址空间">与事务执行相关的地址空间</h2><p><img src="assets/image-20241210131452406.png" alt="image-20241210131452406"></p><p><img src="assets/image-20241210131521932.png" alt="image-20241210131521932"></p><h3 id="事务的操作原语">事务的操作原语</h3><p><img src="assets/image-20241210131554228.png" alt="image-20241210131554228"></p><p><img src="assets/image-20241210131652844.png" alt="image-20241210131652844"></p><h2 id="并发控制">并发控制</h2><p><strong>并发控制任务</strong>：保证事务的并发调度是正确的（满足隔离性/可串行化——效果上等于某个串行调度），不会破坏数据的一致性</p><p><strong>并发控制技术</strong>：</p><ol><li>基于锁的机制（最常用，最通用）</li><li>基于时间戳的机制（自学、不重点）</li><li>基于多版本的机制（自学、不重点）</li></ol><h3 id="锁">锁</h3><h4 id="基于封锁的方法">基于封锁的方法</h4><p><img src="assets/image-20241210131931513.png" alt="image-20241210131931513"></p><h4 id="锁表">锁表</h4><p><img src="assets/image-20241210131949453.png" alt="image-20241210131949453"></p><p><img src="assets/image-20241210132042846.png" alt="image-20241210132042846"></p><h4 id="加锁解锁下的处理">加锁解锁下的处理</h4><p><img src="assets/image-20241210132148892.png" alt="image-20241210132148892"></p><h4 id="概念">概念</h4><ul><li>一个事务在对某个数据对象（表、元组、关系等）进行操作前，可以向系统申请对该<strong>数据对象</strong>加锁。==数据库上锁的数据对象是内存中的数据，不是磁盘中的数据）来自于励儒云的习题==<br><strong>注意</strong>：锁的对象是数据对象！而不是事务！</li><li>对数据对象加锁后，其他事务就不能对该数据对象进行某些操作，直到原来加锁的事务释放锁为止<br><strong>原因</strong>：其他事务也要加锁，但被前面这个事务的锁所阻挡或者排斥</li></ul><h4 id="锁的粒度">锁的粒度</h4><p>锁针对的数据对象从大到小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR </span><br><span class="line">锁的数据对象 --&gt; 数据库 &amp; 表 &amp; 页面 &amp; 记录 &amp; 记录的一个字段</span><br><span class="line">%%  %%数据库 --&gt; 表 --&gt; 页面 --&gt; 记录 --&gt; 记录的一个字段</span><br></pre></td></tr></table></figure><p><strong>锁的粒度越小，则：</strong></p><ul><li>并发度越大——（操作同个数据）冲突可能性下降</li><li>开销增大——管理更多的锁</li></ul><h4 id="类型">类型</h4><p><strong>X锁</strong>：又称为写锁/排他锁（Exclusive Lock）</p><ul><li>一个事务对数据A进行修改（写）操作前，给它加上X锁。获得X锁后，事务可以对数据A进行写，也可以对数据A进行读</li><li>==其他事务不能对A再加任何锁，直到X锁被释放为止！但这不意味着其他事务不能对A进行读写，要根据对应的封锁协议来确定，比如思考下面这个问题：==<ol><li>一个数据库系统所有事务满足一级封锁协议，解决了丢失修改的问题，但是没有解决读取脏数据的问题，为什么？（脏数据指被修改但未提交的数据）<ul><li>假设一个事务T1要修改数据R，所以在读取或修改数据R前对R上X锁</li><li>当事务T1修改完数据R后，还未提交</li><li>此时事务T2想要读取数据R，<strong>这是允许的，因为一级封锁协议仅要求，如果要修改某个数据必须上X锁直到事务结束，但对读数据没有限制，即读数据不需要上锁就可以读</strong></li><li>对于事物T2，在一级封锁协议下，他要能够读取数据R并没有限制条件，可以直接读取</li><li>那么可能你就会疑惑了，现在数据R身上有X锁，事务T2为什么能读数据R呢？<strong>根据排它锁X的定义，当一个数据库对象被上X锁后，其他事务不能对其上任何锁，并不是说不能对其进行读写！</strong></li><li>所以事务T2不能对数据R2上任何锁，但是在一级封锁协议下，事务T2不需要对数据R2上锁就能读，所以可以读到数据R2</li><li>事务T2读了数据R2，但是数据R2已经被事务T1修改了并且还没有提交，所以事务T2读取到了 <strong>脏数据</strong>。<br><strong>S锁</strong>：又称为读锁/共享锁（Shared Lock）</li></ul></li></ol></li><li>一个事务对数据A进行读取操作前，给它加上S锁，获得S锁后，该事物<strong>可以读，但不可以写</strong></li><li>其他事务可以对A加更多的锁（除了X锁）<br><strong>U锁</strong>：又称更新锁（==不要求==）<br>一个事务对数据A进行更新（写）操作，分为以下步骤</li></ul><ol><li>对数据加U锁，然后对数据读取到内存，<strong>在内存中</strong>更新A的值<br>此时其他事务可以对（外存上的）数据A加S锁进行读取</li><li>申请将数据上的U升级为X锁，升级后将更新写入外存<ul><li>如果此时A上有其他事务的读锁，则申请要延迟到它们释放为止</li><li>升级X锁成功后，当然其他事务就不能再加任何锁了<br><strong>意向锁（部分锁）</strong>：（==不要求==）<br><strong>规则</strong>：事务在一个小粒度对象上加S/X锁之前，先要对上级的大粒度对象加<strong>意向S锁/意向X锁</strong>，表示要对这个大粒度对象“读/写一部分”。</li></ul></li></ol><ul><li>例如，表有10000条记录，分布在100个页面上。事务T1如果要写某条记录=某个页面的一部分，整个表的一部分，那么依次加 ① 整个表的意向X锁 ② 所在页面的意向X锁 ③ 这条记录的X锁<br><strong>作用</strong>：有了意向锁，检测锁冲突的开销、以及需要维持的锁的数量都减少了</li><li>比如，另一个事务T2，准备删除整个表，那么它在表这一级别上就检测到冲突的存在，而不是遍历10000条记录看有没有某个记录上存在锁</li></ul><h4 id="封锁协议">封锁协议</h4><p>封锁协议是事务对数据对象加锁时需要遵守的规则</p><blockquote><p>事务对数据对象加锁时，还需要遵守某种规则，包括：什么（读/写）操作要加锁、何时加锁、何时释放？我们称这些规则为封锁协议。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">封锁协议 --&gt; 一级封锁协议 &amp; 二级封锁协议 &amp; 三级封锁协议 &amp; 两段封锁协议</span><br></pre></td></tr></table></figure><h5 id="一级封锁协议">一级封锁协议</h5><p><strong>规则</strong>：数据对象D如果是修改/写操作，在第一次read/write之前需要加X锁，事务结束（commit/rollback）后才释放X锁<br><strong>规则的简洁表述</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放（事务的结束有两种状态，正常结束commit和非正常结束rollback）<br><strong>特点</strong>：仅对写操作加锁，==对读操作无要求！==<br><strong>作用</strong>：一级封锁协议可以解决==丢失修改==的问题，并保证了事务T是可恢复的（原因：没有事务能够修改其他事务正在修改，还未提交的数据）</p><p><strong>判断方法</strong>：<br>简单来说就是检查事务的read，write前和commit后是否分别有加X锁和释放X锁</p><ol><li>检查事务中第一次read或者write，在该指令前是否加了X锁，即XLOCK</li><li>检查事务提交或回滚指令后，是否释放了X锁，即有UNXLOCK</li><li>同时满足1、2两点，即满足1级封锁协议</li></ol><p><strong>例子：</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617181056.png" alt="Pasted image 20240617181056"></p><h5 id="二级封锁协议">二级封锁协议</h5><p><strong>规则</strong>：满足一级封锁协议的基础上，若要读取数据R，事务T必须先对其加S锁，读取完后，可以在任意时候释放S锁（瞬间S锁）<br><strong>特点</strong>：不仅对数据的读有要求，而且对数据的写有要求<br><strong>作用</strong>：可以解决<strong>读取脏数据</strong>的问题（原因：没有事务可以读取其他事务正在修改但是未提交的数据）</p><p>思考这样一种情况：</p><ol><li>对于事物T1，他对数据D的访问满足一级封锁协议（仅对写操作有写锁限制）</li><li>事务T1中还有对数据B的访问，但是对数据B是仅读，所以不加任何锁（依然满足1级封锁协议）</li><li>假设事务T1在时间t1对数据B进行读，在时间t2对数据B进行读，即前后有两次读操作</li><li>现有另一个事务T2，在t1到t2期间进行对数据B的写操作并提交完成，由于事务T2也需要满足1级封锁协议，所以在t1到t2期间其他事务不能访问数据B</li><li>在时间t2，数据B已经被修改，事务T1再读取的时候已经是被修改的数据，存在==重复读的问题==</li></ol><p><strong>例子</strong>：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617183647.png" alt="Pasted image 20240617183647"></p><p><strong>判断方法</strong>：</p><ol><li>将事务T中对数据对象的操作分为两种，一种是仅读数据B，一种是读写A</li><li>对于数据B，查看读取前后是否有S锁</li><li>对于数据A，查看第一次读取/修改A之前是否加X锁，commit之后是否释放X锁</li><li>同时满足1、2、3，即符合二级封锁协议</li></ol><h5 id="三级封锁协议">三级封锁协议</h5><p><strong>规则</strong>：一级封锁协议的基础上，若要读取数据R，事务T必须在第一次读取R之前加上S锁，直到事务结束之后才释放S锁<br><strong>作用</strong>：解决<strong>不可重复读</strong>的问题（原因：在同一事务的两次读数据中间，没有其他事务能够修改该数据）<br><strong>思考</strong>：三级、二级封锁协议都要求读加锁。为什么直到三级才能解决不可重复读的问题，二级不可以？<br>原因：二级封锁中，如果释放了读但是下一次读还没加上读锁的时候被修改了，还是会读到脏数据<br>例子：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240617214359.png" alt="Pasted image 20240617214359"></p><h5 id="两段封锁协议">两段封锁协议</h5><p><img src="assets/image-20241210131131239.png" alt="image-20241210131131239"></p><p><strong>规则</strong>：</p><ul><li>事务对数据加S/X锁后，才能读写数据；释放锁后不能再读写该数据</li><li>事务分为两个阶段：<ol><li>生长阶段：（一直在）获得锁，不能释放锁</li><li>收缩阶段：（一直在）释放锁，不能申请锁<br><strong>首次释放掉一个锁后，即由生长阶段转为收缩阶段</strong><br>==注意：符合三级封锁协议的事务一定也符合两段封锁协议，因为三级封锁协议保证了每个数据都在加锁和释放锁之间==</li></ol></li></ul><p>例子：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002018.png" alt="Pasted image 20240618002018"></p><h5 id="定理（重要）"><strong>定理</strong>（重要）</h5><p>若所有事物均遵从两段封锁协议，则对这些事务的并发调度一定是可串行化的！<br>反之，在一个可串行化的调度中，不一定所有事务都满足两段封锁协议！<br>因此，<strong>所有事务都遵从两段封锁协议是可串行化的充分非必要条件</strong>！<br><strong>下面视频介绍了两段封锁协议一定满足可串行性的例子！5分钟左右</strong></p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142760571&p=81" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:640px; height:430px; max-width: 100%;"></iframe><h5 id="封锁协议小结">封锁协议小结</h5><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240618002402.png" alt="Pasted image 20240618002402"></p><p>一、三级封锁协议的主要区别：</p><ol><li><strong>什么操作需要申请封锁</strong>：比如对于一级封锁协议，读操作是不需要封锁的，但是对于二级封锁协议，是需要封S锁的</li><li><strong>何时释放锁</strong>：比如二级封锁协议对S锁的释放是读完就能释放，但是三级封锁协议是直到事务结束才能释放</li></ol><p>二、不同封锁协议使事务达到的一致性级别不同</p><ul><li>封锁协议级别越高，一致性程度越高</li><li>一致性程度越高的同时，并发度会越低</li></ul><h3 id="活锁、死锁以及死锁的防治">活锁、死锁以及死锁的防治</h3><p>各级封锁协议可以用于解决事务并发调度导致的数据不一致的问题，也就是能够避免出现错误的执行，但是又带来的新问题：</p><ul><li>活锁</li><li>死锁</li></ul><h4 id="活锁">活锁</h4><p><strong>定义</strong>：在锁过程中，系统可能使<strong>一个事务</strong>处于<strong>永远等待</strong>的状态，无法申请到想要的锁。<br>例如，一个事务T1想对数据加写锁，数据原来有（之前其它事务T0的）读锁，所以它只能等待。在T1等待过程中，后续事务T2，T3，T4源源不断地对数据上读锁，导致T1无法摆脱等待状态。</p><h5 id="活锁的防治">活锁的防治</h5><ul><li>严格执行“先来先服务”的策略，即<strong>事务申请顺序=获得锁的顺序</strong>。多个事务申请锁同一对象时，按照它们申请的时间排队和获得锁。<br>例如，事务A、B都申请数据D上的锁（锁的类型可以不同），如果顺序是事务A先申请，系统也按这个顺序，先满足A的申请，再满足B的申请。</li></ul><h4 id="死锁与饿死">死锁与饿死</h4><blockquote><p>如果系统中存在一个事务集，集合中的每个事务在等待该集合中的另一个事务所锁住的数据项，则称系统处于死锁状态</p></blockquote><p><strong>定义</strong>：<strong>几个事务</strong>等待对方释放锁的同时，又持有对方所等待的锁，最后陷入<strong>循环相互等待</strong>的僵局。</p><p><img src="assets/image-20241210131037633.png" alt="image-20241210131037633"></p><h5 id="解决死锁问题（2类方法）">解决死锁问题（2类方法）</h5><h6 id="一、预防死锁的产生">一、预防死锁的产生</h6><p><img src="assets/image-20241210132444333.png" alt="image-20241210132444333"></p><p><img src="assets/image-20241210132505347.png" alt="image-20241210132505347"></p><p><strong>产生死锁的原因</strong>：两个或多个事务都已经封锁一些数据对象，然后又都申请已经被其他事务封锁的数据对象，从而出现死等待。</p><p><strong>预防死锁</strong>：就是要破坏死锁产生的条件</p><p><strong>方法</strong>：</p><ol><li>一次封锁法<br>要求每个事务必须一次将所有要使用的数据全部加锁，否则不能继续执行<br>问题：<ul><li>加锁过早，降低系统并发度</li><li>难以实现精确确定封锁对象</li></ul></li><li>顺序封锁法<br>预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁<br>问题：<ul><li>维护成本高，因为数据对象非常多，每张表、每个元组等都需要维护锁资源</li><li>难以实现，事务的封锁请求随事务的执行而动态确定，难以确定每一个事务要封锁哪些对象，因此很难按照规定的顺序施加封锁<br><strong>小结</strong>：</li></ul></li><li>在操作系统中广为采用的预防死锁的策略并不适合数据库特定</li><li>数据库管理系统在解决死锁问题上更普遍采用诊断并解除死锁的方法</li></ol><h6 id="二、死锁检测与死锁恢复">二、死锁检测与死锁恢复</h6><p><strong>诊断死锁方法</strong>：</p><ol><li><p>超时法</p><p><img src="assets/image-20241210132638681.png" alt="image-20241210132638681"></p><p>设定最长等待时间，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁<br>优点：实现简单<br>缺点：等待时长不好设置，过长导致效率低、过短导致误判</p></li><li><p>等待图法<br>事务等待图：<br>用事务等待图动态反映所有事务的等待情况，事务等待图时一个有向图G=(T,U)，T为结点的集合，每个结点表示正在运行的事务；U表示边的集合，每条边表示事物等待的情况；若事务T1等待事务T2，那么会画一条事务T1指向T2的有向边</p><p>利用事务等待图检测死锁：<br>并发控制子系统周期性地生成事务等待图，检测事务，如果发现图中存在回路，则表示系统中出现了死锁</p></li></ol><p><strong>解除死锁方法</strong>：</p><p><img src="assets/image-20241210132612229.png" alt="image-20241210132612229"></p><ol><li>选择一个处理死锁代价最小（完成工作量最少）的事务，将其撤销</li><li>释放此事务持有的所有锁，使其他事务能继续运行下去</li></ol><h3 id="SQL中的隔离性级别">SQL中的隔离性级别</h3><p>并发控制的目标，是通过保证事务隔离性，来保证事务并发调度是正确的。理想情况下，事务是完全隔离的，不会发生任何错误，包括丢失修改、读脏数据、不可重复读、幻影等等。<br>但是要达到完全没有错误的这个目标，会增加开销——使用更高级的封锁协议、加更多的锁；并且降低了并发度—— 事务加的锁越多，阻碍其它事务的可能性就越大。<br>所以在实际的数据库系统中，<strong>会允许用户适当降低隔离性的等级，允许出现某些可容忍的错误，来换得性能的提升</strong>。<br>高的隔离性级别意味着错误减少，但开销变大，并发度降低。低的隔离性级别正好相反。</p><p><strong>SQL中的隔离性级别</strong>：</p><ul><li>serializable：可串行化。一个并发调度的执行必须等价于一个串行调度的结果。消除了所有错误，特别是幻影</li><li>repeatable read：可重复读。这一级别的隔离性通过三级封锁协议实现：读写都加锁且都保持到事务结束后。消除了可重复读、读脏数据、丢失修改的错误</li><li>read committed：只能读取已提交的记录。这一级别的隔离性通过二级封锁协议实现：写加锁且保持到事务结束后；读加锁但读之后即释放。消除了丢失修改、读脏数据的错误</li><li>read uncommitted：可读取未提交的记录（即脏数据）。这一级别的隔离性通过一级封锁协议实现：写加锁且保持到事务结束后；读不加锁。消除了丢失修改错误</li></ul><h2 id="数据库恢复">数据库恢复</h2><h3 id="恢复实现的技术">恢复实现的技术</h3><p>数据库恢复的基本原理：<strong>冗余</strong></p><p>在故障发生、数据出错后，用存储在其他地方的数据副本（冗余数据）来重建正确的数据。</p><p>平时<strong>建立数据冗余</strong>的方法：</p><ul><li>数据备份（周期），也称数据转储</li><li>登记日志文件（实时）</li></ul><h4 id="数据备份">数据备份</h4><p>定义：有数据库系统定期将数据进行复制，得到后备副本并保存在外部存储空间上的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0[&quot;</span><br><span class="line">数</span><br><span class="line">据</span><br><span class="line">备</span><br><span class="line">份&quot;] --&gt; 静态备份 &amp; 动态备份</span><br><span class="line">静态备份 --&gt; 1[&quot;备份期间，系统不能有事务运行&quot;] &amp; 2[&quot;优点: 实现简单，得到的数据库副本有一致性&lt;/br&gt;缺点: 备份时，数据库不可用&quot;]</span><br><span class="line">动态备份 --&gt; 3[&quot;备份期间，允许事务运行（存取数据）&quot;] &amp; 4[&quot;优点: 备份时，数据库可用&lt;/br&gt;缺点: 实现复杂，不能保证数据库副本的一致性&quot;]</span><br></pre></td></tr></table></figure><h5 id="完全备份和增量备份">完全备份和增量备份</h5><ul><li>完全备份：一次备份整个数据库的数据内容</li><li>增量备份：备份自上次备份以来发生变化的那部分数据<ol><li>优点：容量小，速度快</li><li>缺点：必须联合上一次备份使用，可靠性不高（如果上一次备份失效，这一次的也不行）</li></ol></li></ul><h4 id="小结">小结</h4><p>数据备份在备份时机上分为两种，静态备份和动态备份；在备份内容上也分为两种，完全备份和增量备份。</p><p>所以一共形成了四种备份方法：静态完全备份、静态增量备份、动态完全备份、动态增量备份</p><p>在实际应用中，数据库系统会采取多种备份方式来进行数据库备份，比如1年进行一次静态增量备份等</p><h3 id="日志文件">日志文件</h3><blockquote><p>日志是日志记录的序列。每个日志记录记载有关某个事务已做的事的某些情况。</p><p>日志在事务执行的过程中记录。</p><p>不同事务的日志记录在日志文件中可以交错</p><p>日志用于保证事务的原子性和持久性</p></blockquote><h4 id="概念与记号">概念与记号</h4><p><img src="assets/image-20241210125215521.png" alt="image-20241210125215521"></p><h4 id="undo日志">undo日志</h4><p><img src="assets/image-20241210125426715.png" alt="image-20241210125426715"></p><p><img src="assets/image-20241210125508857.png" alt="image-20241210125508857"></p><p><img src="assets/image-20241210125640004.png" alt="image-20241210125640004"></p><p><img src="assets/image-20241210125649833.png" alt="image-20241210125649833"></p><p><img src="assets/image-20241210125758052.png" alt="image-20241210125758052"></p><p><img src="assets/image-20241210125911454.png" alt="image-20241210125911454"></p><h4 id="redo日志">redo日志</h4><p><img src="assets/image-20241210125931174.png" alt="image-20241210125931174"></p><p><img src="assets/image-20241210130030016.png" alt="image-20241210130030016"></p><h4 id="redo和undo的缺点">redo和undo的缺点</h4><p><img src="assets/image-20241210130141482.png" alt="image-20241210130141482"></p><h4 id="redo-undo日志">==redo/undo日志==</h4><p><img src="assets/image-20241210130213091.png" alt="image-20241210130213091"></p><p><img src="assets/image-20241210130250629.png" alt="image-20241210130250629"></p><p><img src="assets/image-20241210130313148.png" alt="image-20241210130313148"></p><p><strong>定义</strong>：日志文件是用于登记数据库系统中每一个事务每一次修改操作（插入、删除、更新）的信息，特别是<strong>操作前后的新旧值</strong>，数据库恢复时，可以REDO/UNDO这些操作，获得正确状态的数据</p><p><strong>几种类型的日志</strong></p><ul><li>undo日志保证事务的原子性</li><li>redo日志保证事务的持久性</li><li>undo/redo日志保证事务的原子性和持久性</li></ul><p><strong>日志文件的记录单位</strong>：<br>日志文件的记录对象/单位有两种，分别为：记录、数据块</p><p><strong>一个事务登记到日志文件的内容</strong>：</p><ol><li>事务的开始标志（Begin Transaction）<br>每个事务都有一条标志开始的日志记录</li><li>事务的结束标志（commit/rollback）</li><li>事务的所有修改操作<br>每个事务有多个修改操作，但凡修改一个单位（记录或者数据块），就需要产生一条日志记录，记录下修改的单位编号，<strong>修改前的旧值、修改后的新值</strong></li></ol><p><strong>一条日志记录的数据结构（假设以记录为单位）</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;一条</span><br><span class="line">日志</span><br><span class="line">记录&quot;] --&gt; 2[&quot;事务标识（事务编号）&quot;] &amp; 3[&quot;操作类型（事务开始、事务结束、添加、删除、更新）&quot;] &amp; 4[&quot;操作对象的标识(记录的内部编号)&quot;] &amp; 5[&quot;修改前的旧值，如果是插入操作则为空&quot;] &amp; 6[&quot;修改后的新值，如果是删除操作则为空&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>日志缓冲区：</p><ul><li>在内存中开辟的临时保存日志记录的区域。</li><li>每个缓冲块中能容纳若干个日志记录。</li><li>根据需要一次将一个或多个缓冲块写入磁盘，从而减少写磁盘的次数。</li><li>写到磁盘中的日志记录顺序必须与写入日志缓冲区的次序完全一致。</li></ul></blockquote><p><strong>日志文件的原则</strong>：</p><ol><li><strong>先写日志文件</strong>，一个修改操作，必须先登记日志，再修改数据，否则可能导致数据无法恢复的问题</li><li><strong>登记的次序严格按照并发事务执行的时间次序</strong></li></ol><p><strong>事务提交</strong>：</p><ul><li>事务提交，意味着事务的所有操作（包括commit）都已经记录进入日志，并且日志也存入外存中</li></ul><h3 id="数据库恢复策略">数据库恢复策略</h3><p>数据库恢复的定义：<br>在故障发生后，数据库从错误的不一致状态恢复到正确的一致性状态，就是数据库恢复</p><h4 id="数据库错误的情况">数据库错误的情况</h4><ol><li>已完成的事务（已经提交的事务）：修改未写入外存（即已经将所有修改记录写入日志，日志已经写入外存，但是真正对数据的修改还停留在缓存，没有写入外存，此时发生故障导致来不及作实际修改）</li><li>未完成的事务（未提交的事务，需要回滚）：修改写入了磁盘，但是事务还没有完成提交，此时发生故障来不及撤销</li></ol><h4 id="纠正数据库错误的策略">纠正数据库错误的策略</h4><ol><li>对于已完成的事务：事务中的所有操作重做（<strong>正向</strong>REDO，将新值写入磁盘）</li><li>对于未完成的事务：事务中所有的操作撤销（<strong>逆向</strong>UNDO，将旧值写入磁盘）</li></ol><h4 id="故障的类型以及恢复策略">故障的类型以及恢复策略</h4><p>一、事务故障</p><p><strong>定义</strong>：事务在运行至正常终止点前被终止，比如溢出、除0操作、死锁等等</p><p><strong>性质</strong>：事务故障属于小型故障，影响范围仅限于一个事务，不会影响其他事务的正常运行。</p><p><strong>恢复方法</strong>：</p><ol><li>反向扫描日志文件，找到属于该事务的修改操作，不断执行撤销操作直到读到此事务的开始标记，则事务故障就恢复完成</li><li>撤销操作，将日志记录中的“修改前的值”写入磁盘</li><li>事务故障的恢复由==系统==自动完成，对==用户透明==</li></ol><p>二、系统故障</p><p><strong>定义</strong>：因某种原因，造成数据库管理系统（DBMS）停止运行，比如硬件故障（cpu故障…），软件故障(os异常)，外部因素（停电…）</p><p><strong>性质</strong>：中型故障，DBMS故障会导致多个工作的事务被异常终止，系统需要重新启动；重启后，内存缓冲区中的数据丢失，但磁盘介质上数据依然完好</p><p><strong>系统故障造成数据库不一致状态的原因</strong>：</p><ul><li>未完成的事务对数据库的更新可能已经写入数据库</li><li>已提交的事务对数据库的更新可能还留在缓冲区没来得及写</li></ul><p><strong>恢复方法</strong>：<br>DBMS在重新启动后自动完成，不需要用户的干预，对用户透明</p><ol><li>Undo故障发生时未完成的事务</li><li>Redo已经发生的事务</li></ol><p><strong>恢复步骤</strong>：</p><ol><li>正向扫描日志文件，找到已提交的事务（有begin transaction和commit），将其事务标志放入redo队列；<br>找到未提交的事务（有begin transaction无commit）放入undo队列</li><li>反向扫描日志文件，找到找到属于撤销队列的事务的修改操作并执行撤销操作，即将修改前的旧值写入磁盘</li><li>正向扫描日志文件，找到属于重做队列中的事务的修改操作并执行重做操作，即将修改后的新值写入磁盘</li></ol><p><strong>小结恢复步骤</strong>：</p><p>系统故障的恢复需要三次扫描日志文件</p><p>第一次扫描建立undo和redo队列；</p><p>第二次反向扫描日志文件，对需要undo的事件的修改操作进行undo操作；</p><p>第三次正向扫描日志文件，对需要redo的事件的修改操作进行redo操作；</p><p>三、介质故障</p><p><strong>定义</strong>：因某种原因，磁盘上的物理数据部分或完全丢失</p><p><strong>原因</strong>：硬件损坏、计算机病毒、黑客…</p><p><strong>性质</strong>：属于大型故障，不仅DBMS中止，内存数据丢失，并且磁盘上的数据也会丢失和异常</p><p><strong>恢复方法</strong>：<br>需要人工干预，需要数据库管理人员DBA来完成（唯一需要人工介入的故障）<br>恢复过程：</p><ol><li>装入最近一次<strong>备份的数据库副本</strong>，即恢复数据库到最近的一次备份时的状态</li><li>装入备份后到故障发生时的<strong>日志文件或副本</strong>，然后把未提交的事务撤销，已提交的事务重做</li></ol><h4 id="检查点技术">检查点技术</h4><p><strong>传统数据库恢复的弊端</strong>：<br>如果数据库系统运行了很长时间，产生了很长的日志文件。这时在恢复系统故障时，对整个日志文件的扫描，显然会花费非常长的时间。</p><p><strong>解决方法</strong>：<br>DBMS在运行时，周期在日志文件中写入检查点(checkpoint)；<br>对日志的扫描控制在大概 【最后一个检查点，文件末尾】这一段范围，效率大大提高了；</p><h5 id="背景问题">背景问题</h5><p><img src="assets/image-20241210130508433.png" alt="image-20241210130508433"></p><h5 id="检查点行为">检查点行为</h5><p><img src="assets/image-20241210130544061.png" alt="image-20241210130544061"></p><p><img src="assets/image-20241210130553413.png" alt="image-20241210130553413"></p><p><img src="assets/image-20241210130607862.png" alt="image-20241210130607862"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程】3. 需求分析</title>
      <link href="/2024/06/16/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%913.%20%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/16/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%913.%20%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>软件需求</h1><p><strong>重要性</strong>：软件需求是决定软件开发是否成功的关键因素<br><strong>定义</strong>：（1997年，IEEE工程标准）</p><ol><li>用户解决问题或系统目标所需要的<strong>条件</strong></li><li>为满足一个协约、标准、规格或其他正式制定的文档，系统或系统构件所需要满足和具有的<strong>条件或能力</strong></li><li>对上述条件文档化的描述</li></ol><h2 id="需求分析的任务">需求分析的任务</h2><h3 id="需求分析任务">需求分析任务</h3><ol><li>确定对系统的综合要求：<ul><li>功能需求：系统必须提供的服务功能</li><li>性能需求：系统必须满足的约束条件</li><li>可靠性和可用性需求：可靠性定量、可用性量化</li><li>出错处理需求：错误响应机制</li><li>接口需求：应用系统与环境通信格式常用的用户接口需求、硬件接口需求、软件接口需求、通信接口需求</li><li>约束：用户或环境强加的限制条件（工具、语言等）</li><li>逆向需求：系统不应该做什么</li><li>将来可能提出的要求：将来可能要实现的需求</li></ul></li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ol><h3 id="基本任务（结构化需求分析法）">基本任务（结构化需求分析法）</h3><p>准确定义系统的目标，回答“系统必须做什么？”<br>（任务承担者：需求分析小组或系统分析员。）</p><h3 id="结构化需求分析的三种模型">结构化需求分析的三种模型</h3><p><strong>模型</strong>：是指为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。</p><ul><li>数据模型：描述问题信息域，描述数据对象以及数据对象之间的关系 —— 实体-联系图</li><li>功能模型：定义软件功能，描述数据在系统中流动时被处理的逻辑过程，指明系统具有的变换数据的功能 —— 数据流图</li><li>行为模型：描述软件行为，描绘系统各种行为模式在不同状态之间的转换模式 —— 状态转换图</li></ul><h3 id="需求分析的三个阶段">需求分析的三个阶段</h3><ol><li>需求获取阶段（问题+分析）</li><li>需求规约/规格说明阶段（需求描述）</li><li>需求验证阶段（需求评审）</li></ol><h4 id="需求获取阶段">需求获取阶段</h4><ol><li>任务：<br>通过多种方式（与用户交流、实践等）清晰地理解所需要解决的问题，完整获取用户的需求。</li><li>方法：<ul><li>对用户需求进行<strong>建模</strong></li><li>分析用户的要求和期望</li></ul></li><li>作用：<ul><li>建模可以从多个不同的视角、不同抽象层次上对问题及目标软件系统进行可视化，以便于用户和系统分析人员对软件功能达成一致；</li><li>帮助需求分析人员分析和发现用户需求中的不一致性，分析其中的不合理部分，挖掘潜在的用户需求；</li><li>有助于形成需求规格说明书；</li></ul></li></ol><h4 id="需求规约阶段">需求规约阶段</h4><ol><li>任务：以需求分析模型为基础，考虑到问题的软件可解性，生成软件的需求规格说明书和初步的用户手册</li><li>原则：<ul><li>确保需求规格说明书对用户需求描述的完整性、一致性和准确性（满足需求的质量属性）</li><li>鼓励用户参与需求规格说明书以及用户手册的制定</li></ul></li></ol><h4 id="需求验证阶段——需求评审">需求验证阶段——需求评审</h4><ol><li>任务：让用户和设计人员对需求规格说明以及用户手册的理解达成一致</li><li>原则：<ul><li>确保需求规格说明书和用户手册是一致的、完全和准确的（需要满足需求文档的质量属性）</li><li>各方（用户、需求分析人员、设计人员）参与评审工作</li></ul></li></ol><h2 id="需求工程">需求工程</h2><h3 id="需求的分类">需求的分类</h3><p>用户对软件的要求可以分为功能要求和非功能要求两大类；通常一开始是产品的功能需求取胜，时间长了之后，产品的非功能需求取胜。</p><ol><li>功能需求：描述系统应该提供的功能或服务，通常涉及用户或外部系统与该系统之间的交互，一般不考虑系统实现细节<br>比如：在转盘界面上显示学生姓名和学号</li><li>非功能需求（用户体验）：从各个角度对系统的约束和限制，反映了应用对软件系统质量和特性的额外要求，例如响应时间、数据精度、可靠性、开发过程的标准等<br>例子：<ul><li>系统5秒内响应声控请求（性能要求）</li><li>对于一个没有经验的用户，经过2小时培训可以上手使用系统所有功能（可用性要求）</li></ul></li></ol><h4 id="非功能需求——可用性相关概念">非功能需求——可用性相关概念</h4><p>非功能需求主要分为两大类，性能要求以及可用性要求，这里重点关注一下可用性要求。<br>可用性相关概念：</p><ul><li>程序错误：系统没有按程序员意图工作</li><li>功能需求遗漏：系统无法执行某一项任务</li><li>可用性问题：系统既无程序错误，又功能需求遗漏，但是用户仍然不知道如何使用系统执行任务或者不喜欢使用系统执行任务<br>描述可用性的例子（在文档中写需求分析的可用性部分时可以这样写）：</li></ul><ol><li>可以使用键盘完成所有操作</li><li>将显示内容分为两部分（基本和高级），基本部分默认显示，高级部分只有用户需要才显示</li></ol><h2 id="需求获取的方法">需求获取的方法</h2><h3 id="需求获取中存在的问题">需求获取中存在的问题</h3><p>需求获取中用户、系统分析员、程序员等各方都存在各自的问题，导致需求获取不准确，浪费人力物力资源。</p><ol><li>用户存在的问题：<strong>“拍脑袋”</strong>，想起一出是一出，不知道或者不能明确表达自己的需求</li><li>系统分析员存在的问题：<strong>“拍脑袋”</strong>，认为自己比用户更明白用户的问题；<strong>“拍胸脯”</strong>，认为自己能实现用户提出的所有问题<br>主要原因：背景差异，不能有效沟通</li></ol><h3 id="需求获取的过程">需求获取的过程</h3><p>需求获取的<strong>关键在于通过与用户的有效沟通与交流</strong>，收集和理解用户的各项要求。<br>需求获取的过程如下图：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240612155946.png" alt="Pasted image 20240612155946"></p><h3 id="与用户沟通的方法">与用户沟通的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;与</span><br><span class="line">用</span><br><span class="line">户</span><br><span class="line">沟</span><br><span class="line">通</span><br><span class="line">的</span><br><span class="line">方</span><br><span class="line">法&quot;] --&gt; 文档研究 &amp; 用户调研 &amp; 头脑风暴 &amp; 问卷调查 &amp; 2[&quot;观察现有产品、环境以及工作流程&quot;] &amp; 原型方法 &amp; 使用用例 &amp; 逆向沟通</span><br></pre></td></tr></table></figure><h4 id="文档研究">文档研究</h4><p>内容：收集和分析文档（比如收集工作手册、行业手册、报表、旧系统设计文档…），根据目前的文档资料分析用户的业务过程，为下一步工作储备必须的背景知识<br>需要注意的问题：</p><ol><li>文档资料重复</li><li>文档资料冲突</li><li>有些资料是被废弃的</li></ol><p>好处：</p><ol><li>根据目前的文档资料分析用户的业务过程，为下一步工作储备必要的<strong>背景知识</strong></li><li>和用户的沟通建立在相同的背景知识上，沟通才是有效的</li></ol><h4 id="需求调研">需求调研</h4><p>需求调研是一种理解商业功能和商业规则的最有效的方法；<br>个人理解：就是通过访谈等形式，和相关方进行直接沟通，经过充分沟通后获取相关方需求</p><h5 id="需求调研的过程">需求调研的过程</h5><p><strong>调研之前</strong>（认真的计划和准备）：</p><ol><li>查阅有关文档和资料，对业务有一个基本的理解</li><li>建立调研提纲（列出 要调研的问题和要点）</li><li>建立调研计划（什么时间、什么地点），调研提纲需要提前提交给用户，使用户有所准备</li><li>通知所有参加者有关调研的目的、时间和地点</li><li>调研用户的顺序最好是：管理人员 ——&gt; 业务人员<br><strong>调研过程中</strong>：（有效地听取）</li><li>善于诱导用户把问题描述完整</li><li>深入调查细节</li><li>有完整的详细记录</li><li>对未明确、有歧义的问题应该特殊标记<br><strong>调研完成后</strong>：</li><li>复查记录的准确性、完整性和可理解性</li><li>把收集的信息转化为适当的模型和文档</li><li>确定需要进一步澄清的问题域</li><li>会议记录发送给参加会议的每一个人员（不同人背景不同。尽量处于统一背景进行有效沟通）</li></ol><h5 id="需求调研的提问方法">需求调研的提问方法</h5><p><strong>5W1H</strong>：</p><ol><li>WHO，用户角色</li><li>WHAT，完成什么功能</li><li>WHERE</li><li>WHEN</li><li>WHY，这些功能要达到什么目的，或为什么有这些功能</li><li>HOW</li><li>Competitors，竞争对手的功能是什么样的？相比优点和缺点如何？</li></ol><p><strong>与用户有效沟通的方法还有：头脑风暴、问卷调查、现场观察、逆向沟通等方法，可以看PPT了解一下，感觉不是重点，就不整理了，PPT的42-45页</strong></p><h2 id="分析建模与需求规格说明书">分析建模与需求规格说明书</h2><h3 id="需求分析和建模">需求分析和建模</h3><p>需求分析的目的：<br>分解需求、提炼需求，并且在这个过程中消除出现的矛盾，和客户需求达成一致；</p><p>提炼需求：</p><ol><li>分解过程中出现需求相互重叠的情况，需要提炼需求，抽取共性</li><li>分解过程中可能出现相互矛盾的情况，这时需要平衡</li></ol><h3 id="需求建模">需求建模</h3><p>需求分析的主要方法和手段——需求建模<br>需求建模目的：帮助需求分析人员理清楚思路，帮助和客户达成一致</p><p><strong>建模的工具和方法论</strong>（个人觉得重点概念）</p><ol><li>结构化方法（Structrue Analysis）</li><li>面向对象方法<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240614002425.png" alt="Pasted image 20240614002425"></li></ol><h3 id="需求分析方法——结构化方法">需求分析方法——结构化方法</h3><p>面相数据流进行需求分析，适合于数据处理类型的软件的需求分析</p><h4 id="需求分析基本目标">需求分析基本目标</h4><ol><li>描述用户对软件系统的需求</li><li>为软件设计奠定一个良好的基础</li><li>定义一组需求，并且可以作为软件产品验收的标准</li></ol><h4 id="需求分析模型的内容">需求分析模型的内容</h4><ol><li>数据字典</li><li>数据模型（用实体联系图表达）</li><li>功能模型（用数据流图表达）</li><li>行为模型（状态转换图表达）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240614001627.png" alt="Pasted image 20240614001627"></li></ol><h4 id="功能建模——数据流图的绘制（多层次数据流图）">功能建模——数据流图的绘制（多层次数据流图）</h4><p>数据流图的定义：<br>描述<strong>数据处理过程</strong>的工具，通过图形的方法，从<strong>数据传输和数据处理</strong>的角度，刻画数据流从输入到输出的移动变换过程。</p><p>核心思想是自顶向下的分析方法，先抽象再具体，逐层分解！</p><p>绘制思路方法：<br><strong>注意一个原则：分解前后的外部输入输出的数据流一致</strong><br>一、画顶层（只有一个处理，即一个圆框）：</p><ol><li>画出系统的输入和输出——确定起点和最终输出终点，一般起点和最终输出终点都是数据流之外的元素，比如考试管理系统的考生、考试中心；这部分识别出来的体用方框表示<br>二、画中间层（可以有多层）：</li><li>在第上一层的基础上进行分解<br>三、画底层：</li><li>底层图由一些不能再分解的加工组成，这些加工已经足够简单，称为<strong>基本加工</strong></li></ol><p>绘制数据流图技巧个人经验：</p><ol><li>先抽象出顶层，一个处理，然后确定输入输出</li><li>对处理进行分解，主要抓住动词、动作，作为数据处理部分</li><li>根据抓住的数据处理部分，分析需要什么数据流输入输出</li><li>时刻记得子图与父图的平衡</li></ol><p>绘制数据流图的原则：</p><ol><li>数据流的命名一定都是名词（数据应该都是名词，比如学号、申请单等等）</li><li>每一个加工都是一个动作</li><li>每一个加工都必须至少有一个输入流和一个输出流</li><li>数据不能从外部直接流入数据存储，即数据存储的直接输入输出对象都必须是加工</li><li>数据流要保持守恒，加工输出的数据要有对应的数据来源</li><li>保持父图与子图的平衡</li><li>除了顶层数据流图，每个加工都要有标号，并且遵守标号的规则，标号不表示功能的执行顺序</li><li>下层数据流图应该与上层数据流图等价</li><li>一个加工的输入数据流和输出数据流不能同名（加工之后还是自己，不就是没加工）</li><li>每一个文件应该至少有一个加工读它，至少有一个加工写它</li><li>尽量避免数据流图的交叉</li></ol><p>练习题以及解答：</p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=603176382&bvid=BV1gB4y1H7MR&cid=838366587&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:640px; height: 430px; max-width: 100%;"></iframe><h4 id="数据建模-——-实体联系图（E-R图）">数据建模 —— 实体联系图（E-R图）</h4><ol><li>实体： 描述数据对象</li><li>属性： 描述数据对象的性质</li><li>联系： 描述数据对象之间的交互方式<ul><li>1对1</li><li>1对多</li><li>多对多<br>数据库学过，这里不赘述</li></ul></li></ol><h4 id="行为建模-——-状态转换图">行为建模 —— 状态转换图</h4><p><strong>定义</strong>：状态转换图是一种描述系统对内部或外部事件响应的行为模型<br><strong>状态</strong>：系统的行为模式，包括初态、终态、中间状态<br><strong>事件</strong>：是指在某个特定时刻发生的事情，即对系统从一个状态转换到另一个状态的事件抽象，状态转移通常由事件触发</p><p>表示方式：</p><ol><li>初态：实心圆</li><li>终态：同心圆，内为实心</li><li>中间状态：圆角矩形<br><strong>一张状态图中只能有一个初态，而终态可以有0个或者多个</strong><br>例图：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616155312.png" alt="Pasted image 20240616155312"><br>各个状态的表达结构：</li><li>中间状态：可以用两条水平线分为上中下三部分<br>上部：状态名称<br>中部：状态变量的名字和值，可选<br>下部：活动表，可选</li><li>中间状态的活动表的语法格式：<br>事件名（参数）/动作表达式<br>常用的3种标准事件：<ul><li>entry，指事件指定进入该状态的动作；</li><li>exit，指事件指定退出该状态的动作；</li><li>do，指事件在该状态下的动作；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616155733.png" alt="Pasted image 20240616155733"></li></ul></li><li>事件表达式语法：<br>事件说明[守卫条件]/动作表达式<br>事件说明：事件名（参数表）<br>守卫条件：布尔表达式；如果同时使用事件说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态才发生转换<br>动作表达式：过程表达式，当状态转换开始时执行该表达式</li></ol><p>例题以及答案：<br>假设航空订票系统的航班状态有无预定、部分预定、预定关闭和预定完成四个状态，请绘制出状态转换图。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616160819.png" alt="Pasted image 20240616160819"></p><h4 id="数据字典">数据字典</h4><p>数据字典是对<strong>数据流图中包含的所有元素的定义的集合</strong>，使得每一个图形元素的名字都有一个精确的、严格的定义。</p><blockquote><p>数据字典可以把不同的需求文档和分析模型紧紧结合在一起，如果所有开发人员在数据字典上去的一致意见，那么可以缓和集成性的问题。为了避免<strong>冗余和不一致性</strong>，应该在项目中创建一个<strong>独立的数据字典</strong></p></blockquote><p>数据字典的构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">数据字典的四类条目 --&gt; 数据流 &amp; 数据存储 &amp; 数据元素 &amp; 加工处理</span><br><span class="line">数据元素 --&gt; 1[&quot;数据的最小单位&lt;/br&gt;主要内容包括编号、别名、取值范围和&lt;/br&gt;取值含义、备注&quot;]</span><br><span class="line">数据流 --&gt; 2[&quot;数据流名称、编号、别名&lt;/br&gt;数据流来源&lt;/br&gt;数据流去向&lt;/br&gt;数据流组成&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>工业上，数据字典的每一类条目都用一张表表示并编号，做成卡片，方便查询</strong></p><h5 id="数据结构">数据结构</h5><p>由若干个数据项或数据结构组成，把关系密切的数据组合在一起<br>主要内容：名称、编号、数据结构的组成<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616163502.png" alt="Pasted image 20240616163502"></p><h5 id="数据元素-数据项">数据元素/数据项</h5><pre><code>数据项的名称、编号、别名、取值范围和取值含义、备注</code></pre><p>例：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616163610.png" alt="Pasted image 20240616163610"></p><h5 id="数据流">数据流</h5><p>数据流图中，数据以数据流为单位进行传输<br>主要内容：</p><ul><li>数据流名称、编号、别名</li><li>数据流来源</li><li>数据流去向</li><li>数据流组成<br>例子：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616163828.png" alt="Pasted image 20240616163828"></li></ul><h5 id="数据存储">数据存储</h5><p>保留或者保存数据的地方<br>内容：<br>数据存储名称、编号、数据存储的组成（包括数据项或数据结构）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616163908.png" alt="Pasted image 20240616163908"></p><h5 id="加工逻辑">加工逻辑</h5><p>主要内容：<br>名称、编号、加工逻辑的输入和输出、加工逻辑的说明<br><strong>对基本加工的逻辑要做明确的描述</strong><br>基本加工是指底层数据流图中，不能再拆分的加工<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616164031.png" alt="Pasted image 20240616164031"></p><h6 id="判定树、判定表">判定树、判定表</h6><p>在结构化分析中，对于组合条件，如果使用结构化语言进行描述（分支结构），会显得不清晰，混乱。为了解决这个问题，我们采用判定树的方法来解决组合条件问题。</p><ol><li>判定树是从左往右的分支判定<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902161030.png" alt="Pasted image 20240902161030"></li><li>判定表结构：左上是条件，左下是所有操作，右上是是否满足某个条件，右下是是否执行某个操作<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240902161132.png" alt="Pasted image 20240902161132"></li></ol><h5 id="数据字典常用符号">数据字典常用符号</h5><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240616164102.png" alt="Pasted image 20240616164102"></p><h2 id="验证软件需求">验证软件需求</h2><h3 id="需求的质量属性">需求的质量属性</h3><ol><li>正确性：需求规格说明对系统功能、行为、性能等的描述必须与用户期望相符合，代表了用户真正的需求；</li><li>完整性：需求规格说明应该包含软件要完成的全部任务，不能遗漏任何必要的需求信息；</li><li>一致性：需求规格说明对各种需求不能存在矛盾，如术语使用冲突、功能和行为特性方面的矛盾等等；</li><li>无歧义性：需求规格说明中的描述对于所有人都只能有一种明确的解释；</li><li>可验证性：需求规格说明中描述的需求都可以运用一些可行的手段对齐进行验证和确认；<br>比如：不能存在不可验证的陈述，如“用户界面友好”；描述需要可测量，比如系统将在20秒内响应所有请求；</li><li>可跟踪性：每一项需求都能与其对应的来源、设计、源代码和测试用例联系起来；</li></ol><h3 id="需求验证的技术">需求验证的技术</h3><p><strong>需求验证主要围绕需求规格说明书的质量特性展开</strong></p><ul><li>需求评审：由不同代表（如分析员、客户、设计人员、测试人员）组成的评审小组以会议形式对需求进行系统性分析；</li><li>原型评价：客户和用户在一个可运行的系统模型上实际检验系统是否符合他们的真正需要；</li><li>测试用例生成：通过设计具体的测试方法，发现需求中的许多问题；</li><li>形式化分析和验证</li></ul><h2 id="需求规格说明书">需求规格说明书</h2><p>需求规格说明书按照需求分析设计方法不同而不同，PPT上只涉及到<strong>结构化设计</strong>的需求规格说明书；<br>结构化需求规格设计书是按照<strong>用例</strong>组织的需求规格说明书；<br><strong>例子</strong>（以后如果要写文档可能参考用得到）：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240614092729.png" alt="Pasted image 20240614092729"></p><h3 id="软件需求规格说明书（SRS）">软件需求规格说明书（SRS）</h3><h4 id="主要目的">主要目的</h4><ul><li>便于用户、分析人员和软件设计人员进行理解和交流</li><li>目标软件系统的最终验收和确认的标准</li></ul><h4 id="组成部分">组成部分</h4><ol><li>总体描述部分<ul><li>系统给谁用的？使用目的是什么？</li><li>系统的使用场景是什么？整体性的流程是什么？（可用UML活动图或系统流程图来表示）</li><li>使用者需求列表与说明</li></ul></li><li>详细需求：对于每一个需求至少描述4个部分：功能、性能、设计约束和接口<ul><li>功能的描述：<br>描述系统中输入域输出之间的关系（类似于数据流图中的数据处理部分），描述清楚给定什么输入产生什么输出；<br>描述为了得到输出而在输入数据上做的相关操作；<br>描述系统在异常情况下的行为，如非法输入（有多种情况出现）或者计算中的错误；<br><strong>多用ER图、DFD图、IPO图等来描述功能需求</strong></li></ul></li><li>外部接口：所有<strong>软件与人、硬件和其他软件的交互</strong>都得明确描述，包括用户操作命名、屏幕显示格式、打印格式、系统如何呈现给用户的解反馈和错误消息等；</li></ol><h4 id="应对需求变化（扫一眼就行）">应对需求变化（扫一眼就行）</h4><p>在软件开发中唯一不变的是需求变化。<br><strong>应对需求变化的措施</strong>：</p><ol><li>控制需求变化：<ul><li>让变化按照严格定义好的变更流程来进行</li><li>让所有人明白需求变化带来的影响</li></ul></li><li>设计良好的软件架构以应对需求变化</li></ol><p>考试透露：</p><ol><li>类图（肯定有！）</li><li>活动图<br>用例图（图形编辑）<br>用例图：用户使用功能的例子的说明图！！！</li><li><strong>测试</strong>（占比较大）！！！  PPT以及讲课有涉及到<br>源于教材和PPT的测试用例</li><li>设计案例！！！  PPT和讲课有涉及到<br>数据流图、XXX图</li><li>项目估算（要知道有什么估算方法）：<br>代码行<br>功能点（好写）<br>投入人员（好写，投入多少人，做多少天）<br>…</li><li><strong>等价分类测试</strong>，重点！占比很大！</li><li>做界面，第三类的倒数第四点：参考图书管理系统和人事系统</li><li>实体图、类图<br>实体图和类图要考虑细节一些，不要太简单</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】5. 自顶而下的分析方法</title>
      <link href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%915.%20%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
      <url>/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%915.%20%E8%87%AA%E9%A1%B6%E8%80%8C%E4%B8%8B%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>自顶而下的文法分析方法</h1><h2 id="基本内容">基本内容</h2><p>定义：从文法开始符号开始，不断利用文法规则进行推导，直到推导出所需要分析出来的符号串为止；<br>假设给定一个文法规则如下，写出对应的词法分析程序：</p><p>\displaylines{G[S]=\{S \to aA|bB \\A \to cdA | d\\B \to efB | f\}}</p><p>算法构造过程：</p><ol><li>每一个非终结符号就对应一个分析函数；</li><li>对于非终结符号S，其对应的分析函数为：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">S</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(token==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">B</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(token==<span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(token==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="built_in">B</span>();</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(token==<span class="string">&#x27;f&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>match()函数的实现：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">match</span><span class="params">(expectedToken)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(token==expectedToken)&#123;</span><br><span class="line"><span class="built_in">getToken</span>();  <span class="comment">//  或下一个字符</span></span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line"><span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：递归下降分析方法">小结：递归下降分析方法</h3><p>自上而下的分析方法，也称递归子程序下降的分析方法解决问题；</p><ol><li>把问题的核心用文法规则的方式表达出来；</li><li>然后利用递归下降的算法设计方法，也就是递归子程序的方法组织实现；<ul><li>一个非终结符号就是一个函数</li><li>遇到终结符号作匹配，非终结符号作函数调用</li></ul></li></ol><h2 id="递归则程序的问题分析">递归则程序的问题分析</h2><p>递归子程序的方法固然好用，但是针对不同特殊类型的文法规则仍然会出现一些问题，所以接下来我们分享不同的经典的文法规则，用递归子程序的方法实现其功能，纠正不同的问题，使得递归下降的分析方法更加完善；</p><h3 id="左工因子问题">左工因子问题</h3><p>例子：写出下面的文法的递归子程序$$\displaylines{if-stmt\ \to\ if\ (exp)\  statement\ |\ if\ (exp)\ statement\ else\ statement}$$<strong>问题分析</strong>：</p><ol><li>由于该文法规则的推导有两种情况，所以需要分支语句；</li><li>但是由于两种情况的开头第一个符号都是相同的，都是if（非终结符号），所以对应着同一个函数或者终结符号，那么用前面的方法进行匹配，无法区分什么时候选第一条规则，什么时候选择第二条规则；</li></ol><p><strong>解决方法</strong>：</p><ol><li>方法一：提公因式，把规则进行改写：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>ϵ</mi><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ (\epsilon |\ else\ statement)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">ϵ</span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></li><li>方法二：用扩充的BNF改造原来的文法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>m</mi><mi>t</mi><mtext> </mtext><mo>→</mo><mtext> </mtext><mi>i</mi><mi>f</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mtext> </mtext><mo stretchy="false">[</mo><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">if-stmt\ \to \ if\ (exp) \ statement\ [else\ statement]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mopen">[</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mclose">]</span></span></span></span><br>改写之后的递归子程序：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ifStmt</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;if&#x27;</span>);</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"><span class="built_in">exp</span>();</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="built_in">statement</span>();</span><br><span class="line"><span class="keyword">if</span>(token==<span class="string">&#x27;else&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;else&#x27;</span>);</span><br><span class="line"><span class="built_in">statement</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题归纳</strong>：左公因子问题<br>当两个或多个文法规则共享一个通用的公共前缀时，如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mi>β</mi><mi mathvariant="normal">∣</mi><mi>α</mi><mi>γ</mi><mi mathvariant="normal">∣</mi><mi>α</mi><mi>β</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">A\to \alpha\beta|\alpha\gamma|\alpha\beta1|...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">1∣...</span></span></span></span>等<br>我们需要将公共的前缀，也就是左公因子提取出来；<br><strong>比如</strong>：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mtext> </mtext><mi>α</mi><mi>β</mi><mi mathvariant="normal">∣</mi><mi>α</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">A \to \ \alpha\beta|\alpha\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>可以进行公因子提取；<br>结果为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mo stretchy="false">(</mo><mi>β</mi><mi mathvariant="normal">∣</mi><mi>γ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \alpha(\beta|\gamma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span></span></span></span><br>或者可以在分解后，<strong>将该规则分解为两个规则</strong>(==一般在提取公因子后，非公因子部分很长的时候采用这种方法==)：</p><p>\displaylines{A \to \alpha A^,\\A^, \to \beta|\gamma}</p><h3 id="左递归问题">左递归问题</h3><h5 id="直接左递归">直接左递归</h5><p>例题：写出下面文法的递归子程序$$\displaylines{G[S]={S \to SaAB | \epsilon\<br>A \to cdA \<br>B \to efB|f<br>}}$$<br><strong>问题分析</strong>：<br>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">S\to Sa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">a</span></span></span></span>为例，对含有左递归的表达式，在用递归下降子程序实现时，会出现函数调用死递归；</p><p><strong>解决方法</strong>：<br>经过归约分析，我们对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mi>a</mi><mi>A</mi><mi>B</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to SaAB|\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">a</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathnormal">ϵ</span></span></span></span>这个表达式的功能进行分析，实际上就是可以实现aAB的重复出现；于是我们采用扩充的BNF改写文法规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mo stretchy="false">{</mo><mi>a</mi><mi>A</mi><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S \to \{aAB\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span></span></span></span><br><strong>分析程序</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">S</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(token==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">match</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">A</span>();</span><br><span class="line"><span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果不用扩充BNF的做法如何实现呢？</strong><br>也可以改为右递归，来避免死递归的出现；<br>由于该文法实现的是aAB重复出现的功能，我们使用右递归也能实现，我们如何将该表达式转化为右递归呢？</p><p>\displaylines{S\to SaAB|\epsilon\\\therefore S \to T^,\\T^, \to aABT|\epsilon \ \ \\这一步实现了aAB的重复 \\\therefore S \to aABS|\epsilon \\这一步进行合并，原文法变为右递归的形式}</p><p><strong>问题归纳</strong>：解决直接左递归问题<br>方法一：改为右递归</p><ol><li>先解决左公因子问题</li><li>改为右递归</li></ol><p>方法二：使用扩充的BNF改造文法的书写形式，消除左递归的表达</p><h5 id="间接左递归">间接左递归</h5><p>例子：研究下面的文法$$\displaylines{A \to Aa|Bb|Cc \<br>B \to Ab|Bb\<br>C \to Ac|Cb<br>}$$<br><strong>问题分析</strong>：上面的例子中，如果把B带入第一条文法，又会出现A的左递归，这种形式的文法称为间接左递归；</p><p><strong>解决方法</strong>：</p><p>\displaylines{A \to Aa|Bb|Cc \\\therefore A \to (Bb|Cc)A^, \to BbA^,|CcA^,,\\A^, \to aA^,|\epsilon \\处理完A的左递归之后，解决B的时候带入A的结果即可\\B \to Ab|Bb\\B \to BbA^,b|CcA^,b|Bb \\于是这时候B从间接左递归变成了直接左递归\\\therefore B \to B(bA^,b|b)|CcA^,b \\...}</p><p><strong>问题归纳</strong>：解决间接左递归</p><ol><li>将文法的非终结符号按任意一种方式排序</li><li>逐个逐个非终结符号进行消除直接左递归，得到干净的非终结符号</li><li>将干净非终结符号带入未解决的非终结符中，并将其消除干净</li><li>重述上述过程</li></ol><h4 id="消除算法">==消除算法==</h4><p>递归下降分析2，视频末尾有算法总结；37分50秒左右</p><h3 id="First集合的求解">First集合的求解</h3><p>在递归下降程序中，为了提高分析效率，往往要求出每一条文法规则的开头的非终结符号的所有打头的终结符号，也称为First集合。这样可以避免回溯性。<br>不过需要注意的是First集合不一定只有非终结元素，还有可能有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>空串。<br>例题：现有文法$$\displaylines{S \to ABC | D\<br>A \to aB | \epsilon \<br>B \to cC|\epsilon \<br>C \to eC | \epsilon\<br>D \to i|j<br>}$$<br>求First(D)、First(A)、First(S)。</p><p>小结：</p><ol><li>求First集合元素是为了避免递归下降子程序的回溯导致效率低，所以我们在==求First集合元素之前，应该将文法规则进行处理，消除左递归、提左公因子等操作==！</li><li>若文法规则多条，分别求first集合元素</li><li>如果first元素是非终结符号，求其终结符号first元素</li><li>如果first元素是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，求下一个符号的first集合</li><li>如果某条文法规则全部都含有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，类似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>A</mi><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">S \to ABC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">BC</span></span></span></span>，于是可以将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>加入first集合</li></ol><h4 id="求First集合算法归纳">求First集合算法归纳</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240606090458.png" alt="Pasted image 20240606090458"></p><p><strong>伪代码</strong><br>对于规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X \to X_1X_2...X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，first(X)集合的计算算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">First</span>(X) = &#123;&#125;;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(X_k为终结符号或epsilon) <span class="built_in">first</span>(X_k) = X_k;</span><br><span class="line"><span class="built_in">First</span>(X) = <span class="built_in">First</span>(X) + <span class="built_in">first</span>(x_k) - &#123;epsilin&#125;; <span class="comment">// 注意，这里是集合的并和减</span></span><br><span class="line"><span class="keyword">if</span>(epsilon <span class="keyword">not</span> in <span class="built_in">first</span>(X_k)) <span class="keyword">break</span>; <span class="comment">// 如果打头符号无空串，求完就可以得到first集合了</span></span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k == n+<span class="number">1</span>) <span class="built_in">First</span>(X) = <span class="built_in">First</span>(X) + &#123;epsilon&#125;; <span class="comment">// 如果每个非终结符的first都含有epsilon，则打头符号含有epsilon</span></span><br></pre></td></tr></table></figure><p>例题：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240606092014.png" alt="Pasted image 20240606092014"><br>这个文法规则不能求first集合，需要先消除左递归、提左公因子！</p><p>例题：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240606092434.png" alt="Pasted image 20240606092434"></p><h3 id="Follow集合的求解">Follow集合的求解</h3><p>==同样记得先把文法规则进行提取左公因子和消除左递归==<br>为了避免带有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>的文法规则有多余的函数调用（视频26的36分50秒的分析解释了求Follow的原因），我们可以求非终结符号的Follow集合元素来决定是否要调用该非终结符号的函数。</p><p>Follow集合的运算可能遇到的情况如下：</p><ol><li>若A是开始符号，Follow(A) = ?</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，Follow(B) = ?</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)中，则Follow(A) = ?</li></ol><p>定义：给出一个非终结符号A，那么集合Follow(A)则是由终结符或结束符号$组成。<br>集合Follow(A)定义如下：</p><ol><li>若A是开始符号，则$就在Follow(A)中</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>γ</mi><mo stretchy="false">)</mo><mo>−</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">First(\gamma)-{\epsilon}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Follow(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">ll</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>中</li><li>若存在规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>γ</mi></mrow><annotation encoding="application/x-tex">B \to \alpha A \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在First(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>)集合中，则Follow(A)包括Follow(B)</li></ol><h4 id="求Follow集合算法归纳">求Follow集合算法归纳</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240606100008.png" alt="Pasted image 20240606100008"></p><p>例题：<br>解答在视频27的37分。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240606100936.png" alt="Pasted image 20240606100936"></p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】6. 自底向上的分析方法</title>
      <link href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%916.%20%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
      <url>/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%916.%20%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>LR0的方法</h1><h1>SLR1的方法</h1><p>在LR0的基础上，在每个规约移进冲突 上，求其Follow集合元素，以确定是否需要规约。<br>一旦文法出现规约移进冲突，则无法用LR0的方法进行分析！需要通过求规约项的Follow集合元素来区分是要规约还是要移进。</p><h3 id="SLR-1-的新问题1">SLR(1)的新问题1</h3><p>移进规约冲突，当移进项和规约项的Follow集合有交集时，同样无法决定是移进还是规约。<br>这时候根据最长串匹配原则，只做移进不做规约！<br><strong>（视频37的0分到25分）</strong></p><h3 id="SLR-1-新问题2">SLR(1)新问题2</h3><p><strong>视频37的30分</strong><br>SLR(K)的方法由此诞生，也是移进规约冲突！</p><h1>LR(1)的方法</h1><p><strong>视频37的47分！</strong></p><h3 id="LR1习题">LR1习题</h3><p>视频38  整个视频，受益匪浅哈！</p><h1>LALR1的方法</h1><p>LR(1)的DFA图状态数明显多余LR(0)，而状态数增加的原因实际上就是先行符号不同。<br>我们将仅先行符号不同，但是文法相同的规则，则合并压缩，状态数就能变成LR(0)那么多了，这个过程称为合并同心项！<br>这就是LALR1的方法！</p><p>压缩状态数——数目与LR(0)相仿<br>核心项的概念（core）：<br>由状态中的所有LR(1)项目的第1个成分组成的LR(0)项目的集合<br>压缩方法：<br>核心项一样就合并</p><h3 id="LALR-1-和LR-1-的区别">LALR(1)和LR(1)的区别</h3><p>LALR(1)的弊端  <strong>视频39  17分</strong><br>LALR(1)出错不够及时，LR(1)出错及时</p><h2 id="文法规则书写技巧">文法规则书写技巧</h2><p>例题在视频40中</p><ol><li>符号串重复出现，可以使用递归实现<br>引入一个非终结符，非终结符递归，即可实现重复出现</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】7. 语义分析和中间代码生成</title>
      <link href="/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%917.%20%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2024/06/02/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%917.%20%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="语义分析和中间代码生成">语义分析和中间代码生成</h2><ol><li>分析与综合<ul><li>词法、语法、语义分析是对源程序的分析</li><li>中间代码生成、代码优化、目标代码生成则属于对源程序的综合</li></ul></li><li>语法分析结构存储——符号表、语法树</li><li>语义分析是如何实现含义的理解？</li></ol><h3 id="语义分析的过程">语义分析的过程</h3><ol><li>先进行形式化的描述——文法规则</li><li>递归下降分析程序/或者其他分析方法（LR，LALR1，LL）</li><li>根据问题的含义或要求在递归下降分析程序中增加相应的处理功能——<strong>语义动作</strong></li></ol><h3 id="语法分析基本思想">语法分析基本思想</h3><p>在语法分析过程中，根据语言的语义定义随时分析并翻译已经识别的那部分语法成分的全部含义。</p><ul><li>翻译：通过调用为该语法成分事先编好的语义动作实现<br>常用的语法翻译方法：</li></ul><ol><li>方法一：在确定的<strong>递归下降分析程序</strong>中，利用隐含堆栈存储个递归下降函数内的局部变量表示语义信息。</li><li>方法二：在<strong>自底向上的语法分析程序</strong>中使用和语法分析栈同步操作的语义栈进行语法分析翻译。</li><li>方法三：在<strong>LL（1）语法分析程序</strong>中，利用翻译文法实施语法分析翻译。<br>由于方法二和方法三都是在原来文法规则的基础上，加上对应的语义动作，每一个语义动作都与一条文法规则联系，所以又称为<strong>属性文法</strong>。属性文法的方法，语义和语法是统一分析的。<br>方法一是先做语法分析，再做语义分析，语法和语义的分析是分开的。</li></ol><h2 id="语义分析的基本概念">语义分析的基本概念</h2><h3 id="语义分析的实施方式">语义分析的实施方式</h3><ul><li>语法分析程序通过直接调用语义分析函数进行语义分析（属性文法）</li><li>先生成相应的语法树，再做语义分析（方法1）</li></ul><h3 id="语义分析的功能（2方面）">语义分析的功能（2方面）</h3><ol><li>检查语法结构的静态语义，即分析句子的含义是否有意义，实际工作多为作用域分析、类型分析。</li><li>将合乎语义的句子进行翻译，并生成某一种中间形式。</li></ol><h4 id="句子的种类">句子的种类</h4><ol><li>说明语句：用于定义各种名字的属性（比如定义变量）</li><li>可执行语句：用于完成指定功能</li></ol><h4 id="语义分析的任务种类">语义分析的任务种类</h4><ol><li>分析说明语句：需要把定义名字的各种属性登记到**==符号表==**，以便在分析可执行语句时使用</li><li>分析可执行语句：首先根据个语句的语法结构和语义设计出相应的目标代码结构，然后再给出从源语法结构到翻译过程图示的变换方法，语义分析程序则根据这些变换方法进行分析并<strong>生成==中间代码==</strong><br>例子：视频42的7分钟开始</li></ol><h4 id="常见中间代码的形式">常见中间代码的形式</h4><p>在语义分析函数设计中，一方面要依赖于相应语法结构中相应规则的各个量的语义，另一方面也要取决于产生什么形式的中间代码。<br>常见的中间代码：</p><ul><li>树，语法树</li><li>后缀表达式，逆波兰表达</li><li>三元组，三个变元组成，没有存结果的分量，结果存在对应的序号（就是行号）</li><li>四元组，四个变元组成，多了一个存结构的分量</li><li>P代码，可移植性代码（比如汇编，可以用其他解释器进行解释，具有跨平台的特点）</li></ul><h3 id="运算表达式">运算表达式</h3><p>根据运算符在运算中的位置不同，将运算表达式分为前缀、中缀、后缀表达式。<br>日常我们使用的是中缀表达式，但在代码编制过程中，我们发现中缀表达难以编程，于是转而采用中缀表达式（符号在后，参数在前），这样就不用考虑运算符的优先级别了，于是括号也不需要了，因为括号的产生是为了提升优先级的，而后缀表达根据运算符号出现的先后就能判断优先级。</p><h4 id="后缀表示-——-逆波兰表示">后缀表示 —— 逆波兰表示</h4><ul><li>将运算符放在运算对象后面，如 ab +</li><li>表达式中个运算符出现的顺序决定其计算的先后顺序，因此无括号</li><li>后缀表达式与相应的中缀表达式中的运算对象出现的顺序是一致的</li></ul><h4 id="如何将中缀表示转化为相应的后缀表示">如何将中缀表示转化为相应的后缀表示</h4><ol><li>将问题数学化，第一步将中缀表达式的文法符号写出来</li><li>然后再通过递归下降/自底向上等方法进行分析</li><li>产生相应的语义动作</li></ol><h3 id="扩充的后缀表示">扩充的后缀表示</h3><h4 id="赋值表达式的后缀表达">赋值表达式的后缀表达</h4><h4 id="if表达式的后缀表达">if表达式的后缀表达</h4><p>视频44的15分！讲的很好<br>==理解的时候抓住后缀表达的实质：参数在前，符号在后，一遇到符号就拿前面的参数进行开始做动作！==<br>比如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo>&gt;</mo><mi>n</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>k</mi><mo>=</mo><mn>1</mn><mo separator="true">;</mo><mtext> </mtext><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mtext> </mtext><mi>m</mi><mo>=</mo><mn>0</mn><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">if(m&gt;n)\ k = 1;\ else\ m=0;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">;</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">;</span></span></span></span><br>转化为后缀表达则为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mtext> </mtext><mi>n</mi><mtext> </mtext><mo>&gt;</mo><mtext> </mtext><mi>L</mi><mn>1</mn><mtext> </mtext><mi>B</mi><mi>Z</mi><mtext>  </mtext><mi>k</mi><mtext> </mtext><mn>1</mn><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>L</mi><mn>2</mn><mtext> </mtext><mi>B</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">m\ n\ &gt;\ L1\ BZ\ \ k\ 1\ =\ L2\ BR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.07153em;">BZ</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">2</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.00773em;">BR</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn><mo>:</mo><mi>m</mi><mtext> </mtext><mn>0</mn><mtext> </mtext><mo>=</mo></mrow><annotation encoding="application/x-tex">L1: m\ 0\ =</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mord">0</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn><mo>:</mo><mi>i</mi><mi>f</mi><mtext>语句结束之后的语句</mtext></mrow><annotation encoding="application/x-tex">L2: if语句结束之后的语句</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord cjk_fallback">语句结束之后的语句</span></span></span></span><br>分析：</p><ol><li>扫描m和n，则记录数据，扫描到&gt;，则开始对比m和n，对比的结果result存下来</li><li>扫描L1，记录地址L1，扫描到BZ，将reslut传入BZ，如果满足BZ，程序跳转到L1执行，不用继续扫描</li><li>如果不满足BZ，继续扫描，扫描到k，1则将数据存起来，扫描到=，则进行赋值动作</li><li>继续扫描L2，地址存起来，扫描到BR，则程序跳转到L2</li></ol><h4 id="while语句的后缀表达">while语句的后缀表达</h4><p>注意循环的地址问题！！<br>视频43的17分22秒！</p><h4 id="四元组的表示方法">四元组的表示方法</h4><p>（OP，P1，P2，T）<br>其中OP为运算符，P1和P2为运算对象，T为计算结果的临时存储变量，或者地址。<br>注意：</p><ul><li>在按语法制导翻译实际产生的四元组中，OP用一个整数码表示，它除了标识符运算的种类之外，还附带地表示其他一些语义特性。</li><li>P1、P2、T可以代表的含义：<br>可以是表示一个指向符号表某一登记的入口位置<br>可以是表示一个临时变量的整数码</li><li>在产生中间代码的过程中，也<strong>相应地进行查找符号表的工作</strong></li></ul><h4 id="三元组的表达">三元组的表达</h4><p>（OP，P1，P2）<br>其中OP为运算符，P1，P2为运算对象。</p><ul><li>用元组编号来代表结果保存的位置</li><li>对于a*（b+c）的三元组为：<br>1: （+，b，c）<br>2:（*，a，1）</li></ul><h4 id="关系比较语句的后缀表达">关系比较语句的后缀表达</h4><p>a rop b  （rop表示&gt;, &lt;, &gt;=, &lt;&gt;, &lt;=…等比较关系运算符）</p><ul><li>由于关系运算通常都会作为<strong>条件语句或循环语句的条件</strong>，因此通常将关系运算<strong>转化为减法运算</strong>，后面跟着<strong>条件成立与否转移的四元组</strong><br>比如：a&gt;b表示的四元组，有两种表示方法。<br>视频44的25分讲解到。</li></ul><ol><li>（-，a，b，T）<br>（BMZ，？，，T）<br>第一步是进行a-b，结果存入T<br>第二步看T的结果，BMZ表示布尔值小于0，如果成立则跳转到？，暂时未知（==这里的第二步都是因不同表达式而不一样，主要是第二步是要指明条件如果不成立跳转到哪里，如果成立就顺序执行，所以第二步下面的一定是条件成立的四元组部分了！启发来源：视频45的1分钟==）</li><li>（J&gt;，a，b，？）<br>（J，，，？）<br>第一步看a是否大于b，如果条件成立跳到？（真出口）<br>第二步是条件不成立，无条件跳到？（假出口）</li></ol><h5 id="假出口、真出口链的形成">假出口、真出口链的形成</h5><p>视频44的38分</p><p>做完例题后的小结：</p><ol><li>当遇到或运算的时候，要形成真出口链！</li><li>当遇到与运算的时候，要形成假出口链！</li></ol><h4 id="三元组的扩充表示（与四元组表示的差别）">三元组的扩充表示（与四元组表示的差别）</h4><p>三元组也可以像四元组一样表示前面的if与、while语句等。原理本质上一样，只是形式上有些许差别，这里指出三元组表示与四元组表示的差别。（从PPT中抄出来，老师也没讲更多了）</p><p>三元组表示类似于四元组的相应部分。<br>注意：BMZ、BZ、BR、BLZ等跳转三元组的表示格式：</p><ul><li>方式一：（BMZ/BZ/…，转移入口位置的编号，判断值）</li><li>方式二：（BR，，转移的入口位置编号）</li></ul><h4 id="三地址（四元组）的存储结构">三地址（四元组）的存储结构</h4><p>视频45，11分</p><h4 id="P代码">P代码</h4><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldc 2   ； load constant 2</span><br><span class="line">lod a   ;  load value of variable a</span><br><span class="line">mpi    ;   interger mulltiplication</span><br><span class="line">lob b</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="说明语句的翻译方法">说明语句的翻译方法</h3><h4 id="定义几个常用的函数——与符号表有关的函数">定义几个常用的函数——与符号表有关的函数</h4><ol><li><p>LOOKUP(NAME)：以符号名NAME查找符号表，若表已经存在该标识符，则返回其在表中的位置（序号）。否则返回NULL。</p></li><li><p>ENTER(NAME)：在符号表中新登记一名字为NAME的项，并返回该项在表中的位置（序号）。</p></li><li><p>ENTRY(NAME)：查、填符号表的语义函数：</p><pre><code class="language-C++">Poniter ENTRY(NAME)&#123;    ENTRYNo = LOOKUP(NAME);    if(ENTRYNo == NULL) return(ENTRY(NAME));&#125;</code></pre></li><li><p>FILL(符号表位置，类型)   属性填写函数</p></li></ol><h4 id="赋值语句的翻译方法">赋值语句的翻译方法</h4><h4 id="逻辑表达式的翻译">逻辑表达式的翻译</h4><h4 id="朴素翻译方法">朴素翻译方法</h4><p>视频45的30分介绍<br>缺点：有些文法在规约的时候没有必要的信息，导致无法立即填好表项，造成后续回填的麻烦，增加了复杂度</p><h4 id="改进的翻译方法">改进的翻译方法</h4><p>主要的改进方式是：改进文法规则，使得每一个规约都保持必要的信息，避免后续的回填工作，极大地降低了实现的复杂度。（数据类型永远跟变量一起规约！）<br><strong>思路历程</strong>：视频45的40分</p><h2 id="小结">小结</h2><p>本章主要讲语义分析：</p><ul><li>翻译可执行语句实际上就是把字符串进行语义翻译的过程，实际上就是将对应的语句翻译成四元组、三元组、生成代码的过程。</li><li>翻译说明语句实际上就是产生把类型信息填入符号表的语义动作的过程<br>几种常见的语句翻译：</li></ul><ol><li>算数表达式</li><li>说明语句</li><li>赋值语句</li><li>循环语句</li><li>逻辑表达式</li><li>条件判断语句</li></ol><h4 id="语句或语法成分的翻译的基本方法">语句或语法成分的翻译的基本方法</h4><ol><li>研究各种语句的代码结构（实际上就是造个样例，用手工方式生成四元组序列，体会执行过程！）</li><li>根据<strong>代码结构的特点</strong>和<strong>只有在规约时才能调用语义动作</strong>这一关系，对原文法进行适当改造，使得在翻译时能及时调用相应的语义动作，执行某些重要的语义操作。</li></ol><h2 id="讲稿例题汇总">讲稿例题汇总</h2><h1>中间代码生成</h1><h2 id="自顶向下的分析方法（LL1）">自顶向下的分析方法（LL1）</h2><ol><li>先写文法规则</li><li>写递归下降程序</li><li>改造递归下降程序，将生成代码功能逻辑放入其中</li></ol><p><strong>TIPS：语法树、算数表达式计算等递归下降构建过程的归纳总结，视频41的30分钟处</strong></p><h2 id="复习课">复习课</h2><h3 id="题型介绍">题型介绍</h3><ol><li>基础知识；</li><li>正则表达式转化为NFA，NFA转化为DFA，DFA最小化，并且写出源程序；<strong>实验二内容</strong></li><li>自定而下的分析方法</li><li>LR分析题</li><li>语义分析题</li><li>综合分析题（需要转弯，转弯很小）</li></ol><h3 id="如何复习">如何复习</h3><p>考试重点：讲稿，特别是讲稿的例题当成考试题目 + 实验，</p><ol><li>看讲稿，视频，熟悉讲稿知识</li><li>实验的每个功能当成考试题目<br>都是上课讲过的，实验做过的题<br>现在的考试没难度</li></ol><h3 id="第一章">第一章</h3><ol><li>程序的分类？<br>低级语言：机器语言、汇编语言，可以直接控制硬件<br>高级语言：C++，java，python</li><li>程序翻译的方式有哪几种方式？有何不同？<br>词法、语法、语义分析</li></ol><h3 id="第二章">第二章</h3><ol><li><strong>正则表达式运算以及构建方法</strong>（一定要看讲稿）</li><li><strong>正则表达式到NFA到DFA到==DFA最小化==</strong></li><li><strong>==词法分析程序的生成方法==</strong>（生成源程序的也要，有点提示的意思）</li><li>实验一与<strong>实验二</strong></li></ol><h3 id="第三章">第三章</h3><ol><li><p>语言是什么？文法是什么？</p></li><li><p>文法的分类以及他们之间的关系？<br>0型文法：无限制<br>1型文法：上下文有关<br>2型文法：上下文无文法<br>3型文法：线性的，左线性或右线性<br>关系：包含关系，3型文法包含的文法最少…</p></li><li><p>推导、规约、语法树、文法的二义性？<br>推导：“像珠帘一样的分析穿”，讲稿<br>规约：讲稿<br>语法树（要知道存储结构）：保留有用的东西<br>二义性：多于两个语法树</p></li><li><p>如何画语法树？<br>赋值语句、条件判断…TINY所有语句的语法树，要看TINY的参考书第几页，讲稿有</p></li><li><p>文法二义性的消除方法有多少种？都是什么？<br>方法：</p><ul><li>加条件备注</li><li>修改文法规则（讲稿例子，好几个，算数表达式举例了很多内容）</li><li>扩充BNF</li><li>第五章又有一个二义性方法：SLR(1)+最长串匹配原则</li><li>第四章又补充了一个消除二义性的方法：<br>若有二义性，构建LL1分析表一定有两个文法规则，可以弹出对话框让用户选择<br>使得LL1分析表每个格子唯一</li></ul></li><li><p><strong>文法规则构建问题</strong>，杀鸡不用牛刀（正则 vs 文法）<br>算术表达式文法规则构建、第四第五章、第六章也特别多构造文法规则的例子，都要复习</p></li><li><p>自定而下分析法的问题：左工因子、左递归</p></li><li><p>文法的化简：不会用到的文法，不会到终结的文法，都去掉</p></li><li><p>First集合与follow集合的求解</p></li></ol><h3 id="第四章">第四章</h3><p>重点</p><ol><li>递归下降的分析方法</li><li>LL(1)的分析方法（计算执行路线塞到表格里面去了）</li><li>实验三</li></ol><h3 id="第五章">第五章</h3><p>重点：实验4<br>算法设计的时候，数据存储是很重要的，尽量做编码、编号</p><ol><li>LR(0)DFA、LR(1)DFA、LALR(1)的DFA？<br>SLR(1)是没有自己的DFA图的，用的就是LR(0)的<br>要熟悉讲稿的例子</li><li>LR(0)分析表、LR(1)分析表、SLR(1)分析表、LALR(1)分析表？</li><li>LR(0)分析表、LR(1)分析表、SLR(1)分析表、LALR(1)分析表？</li></ol><h3 id="第六章">第六章</h3><p>手工方法一定要会做，内容较多</p><ol><li>语法制导翻译的方法有多少种？（4个）<br>递归下降方法、LR分析方法（也叫属性文法的方法，语义动作+规约）</li><li>中间代码？表现形式如何？</li><li>如何将一个算数表达式转化为逆波兰表示（就是转为后缀表达式），四元组表示、三元组表示？<br>要掌握手工方法和算法伪代码<br>==后缀表达式值的计算（属性文法的方法，讲稿有例子）==</li><li>如何将一段代码翻译为中间代码（四元组、后缀、三元组）？</li><li>几种常见语句的翻译——需要能写出语义函数或语义动作<ul><li>要写好文法，文法写不好算法可能难以开展</li><li>分拆文法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用指南</title>
      <link href="/2024/06/02/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Git%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/06/02/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Git%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1>基本操作</h1><h1>协作</h1><h2 id="处理项目PR（Pull-Request）">处理项目PR（Pull Request）</h2><h3 id="GitHub官网提示做法">GitHub官网提示做法</h3><p><strong>Step 1:</strong> From your project repository, check out a new branch and test the changes.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git pull git@github.com:Cloudy-Man/SoftwareEngineering.git main</span><br></pre></td></tr></table></figure><p><strong>Step 2:</strong> Merge the changes and update on GitHub.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge --no-ff Cloudy-Man-main</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure><h3 id="个人做法">个人做法</h3><p>官方做法的一个缺点是，不能完全命令行操作，因为在终端，你无法直接知道别人的仓库名和仓库地址；个人做法是纯命令行操作；</p><h4 id="如果还没有拉取别人的分支">如果还没有拉取别人的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git ls-remote origin  <span class="comment"># 查看该项目在所有远程仓库的提交，找到别人提交的那个仓库名，比如是refs/pull/1/head:weiChen</span></span><br><span class="line">git fetch origin refs/pull/1/head:weiChen  <span class="comment"># 从远程仓库获取最新的分支和提交信息</span></span><br><span class="line">git branch <span class="comment"># 查看现有分支, 你会发现多了一个别人的分支</span></span><br><span class="line">git checkout weiChen  <span class="comment"># 切换到别人分支</span></span><br><span class="line">git diff main  <span class="comment"># 检查一下有没有冲突, 别人做了什么改进</span></span><br><span class="line">git checkout main <span class="comment"># 切换到要合并到的分支</span></span><br><span class="line">git merge weiChen <span class="comment"># 合并分支</span></span><br><span class="line">git push <span class="comment"># 提交上传到远程仓库</span></span><br></pre></td></tr></table></figure><h4 id="查看提交者信息">查看提交者信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git ls-remote origin <span class="comment"># 显示远程仓库origin中的引用（包括分支、标签、拉取请求等）和对应的哈希值</span></span><br><span class="line">git fetch origin pull/2/head:pr-2  <span class="comment"># 把远程的拉取请求分支检出到本地分支，然后在本地查看这些分支的提交记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提交信息</span></span><br><span class="line">git show pr-2</span><br><span class="line">或者</span><br><span class="line">git <span class="built_in">log</span> pr-2</span><br><span class="line"><span class="comment"># 这样能看到提交的pr的作者信息、邮箱等等，然后再决定要不要合并</span></span><br></pre></td></tr></table></figure><h4 id="已经拉取别人分支后">已经拉取别人分支后</h4><p>传统做法：git fetch + git merge</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin xx <span class="comment"># 更新xx分支的提交</span></span><br><span class="line">git checkout yy <span class="comment"># 切换到本地分支yy</span></span><br><span class="line">git merge xx</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>简单做法：git pull</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将远程origin仓库的xx分支合并到本地的yy分支</span></span><br><span class="line">git checkout yy</span><br><span class="line">git pull origin xx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程】2. 可行性研究</title>
      <link href="/2024/06/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%912.%20%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/06/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%912.%20%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1>可行性研究</h1><h2 id="可行性研究的任务">可行性研究的任务</h2><h3 id="可行性研究的目的">可行性研究的目的</h3><p>用最小的代价在最少的时间内确定问题是否能解决。<br>（可行性研究一般占预期工程的5%-10%）</p><p><strong>可行性研究的实质：一次简化的系统分析和设计，是系统分析和设计过程的大大压缩和简化，在较高层次上以较为抽象的方式进行系统的分析和设计过程</strong></p><h4 id="任务">任务</h4><ol><li>对软件的功能特征进行细化，初步确定项目的规模、目标、约束和限制</li><li>进行简要的需求分析，抽象出项目的逻辑结构，建立逻辑模型</li><li>从逻辑模型出发，经过简化设计，提出若干种可行的解决方法</li><li>如果有多重方法，每种方法都要进行可行性分析，并选择其中一种</li></ol><p><strong>可行性研究的根本任务：对以后的行动方案提出建议</strong></p><h3 id="可行性研究任务的三个方面（关键词：技术、经济、社会）">可行性研究任务的三个方面（关键词：技术、经济、社会）</h3><ol><li>技术可行性：<br>主要考虑：项目实现内容（是否合理）、项目实现方案（技术路线）是否符合最新的技术要求、<strong>现行的技术条件是否可行</strong></li><li>经济可行性：<br>该系统经济效益能超过其开发成本吗？</li><li>社会因素可行性：<br>法律可行性、政策可行性、市场可行性</li></ol><h2 id="可行性研究的过程">可行性研究的过程</h2><p><strong>8个步骤</strong></p><ol><li>复查问题定义的规模和目标，明确目标系统的限制和约束</li><li>研究正在使用的系统(现状)，分析存在的问题，根据目标明确新系统需要建设的功能</li><li>导出高层次逻辑模型：需求模型（数据流图+数据字典）<br>需求模型应该告诉用户做什么而不是怎么做</li><li>重新定义问题（前四个步骤是一个循环，直到问题定义满足用户需求）</li><li>导出评价方案</li><li>推荐行动方案</li><li>草拟开发计划：<ul><li>任务分解，确定负责人</li><li>大致进度规划</li><li>财务预算</li><li>风险分析以及对策</li><li>下阶段需求分析</li></ul></li><li>编写可行性报告提交审查</li></ol><h3 id="可行性报告功能">可行性报告功能</h3><p>说明<strong>软件项目的实现</strong>在<strong>技术上、经济上、社会因素</strong>上的可行性，评述为合理达到开发目标可供选择的各种可能的实现方案，说明并论述所选定方案的理由。</p><p>观摩一下可行性报告国标：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601092806.png" alt="Pasted image 20240601092806"></p><h2 id="技术可行性分析">技术可行性分析</h2><p>技术可行性分析需要对项目需求进行建模，并对技术可行性从两方面进行评价：</p><ol><li>建设内容：需求是否合理、可行、安全</li><li>建设方案（系统设计）是否符合最新的技术要求，现有技术条件下是否可行</li></ol><h3 id="系统流程图">系统流程图</h3><p>是一种描绘物理系统的图，用图形符号以黑盒子形式描绘物理系统各个部件，表达数据在系统各部件之间的流动情况，而不是对数据进行加工处理的控制过程。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601104018.png" alt="Pasted image 20240601104018"></p><h3 id="数据流图和数据字典（重点）">数据流图和数据字典（重点）</h3><h4 id="数据流图（DFD）">数据流图（DFD）</h4><p>描述信息流和数据从输入到输出过程所经受的变换，没有任何具体物理部件，只是描绘数据在软件中的流动和被处理的逻辑过程。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601104158.png" alt="Pasted image 20240601104158"></p><h5 id="画法">画法</h5><ol><li>确定系统输入输出、源点以及终点</li><li>画系统顶层数据流图<br>用加工将输入输出数据连接起来，给加工、数据等命名</li><li>自顶向下分解，画出分层数据流图<br>将加工细分，细分为几个数据流图的表示</li></ol><h5 id="例题以及解答">例题以及解答</h5><p>视频1分35秒至6分30秒</p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=761170596&bvid=BV1t64y1r7o2&cid=801483664&p=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width:100%"></iframe><h4 id="数据字典">数据字典</h4><p>数据字典是关于数据的信息集合，即对数据流图中包含所有元素定义的集合。</p><p>数据字典的内容：数据流、数据流分量（数据元素）、数据存储、处理</p><p>定义数据的方法：<br>由数据元素组成数据的方式：顺序、选择、重复、可选<br><strong>符号表示必须得会</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601110911.png" alt="Pasted image 20240601110911"></p><h5 id="例题">例题</h5><p>见上面视频7分28秒<br>重点关注<strong>重复</strong>的写法：比如数字3重复1到5次，则写1{3}5</p><h5 id="数据字典的作用">数据字典的作用</h5><p>在软件分析和设计过程中给人提供关于数据的描述信息。</p><ol><li>作为分析阶段的工具</li><li>估计改变一个数据将产生的影响</li><li>是数据库开发的第一步</li></ol><h2 id="经济可行性分析——成本效益分析">经济可行性分析——成本效益分析</h2><p>目的：从经济角度分析新系统开发是否盈利，帮助使用部门正确做出是否投资的决定。</p><h3 id="成本估计">成本估计</h3><p>一共四个方法：</p><ol><li>代码行技术：<br>软件成本 = 每行代码的平均成本 * 源代码行数</li><li>任务分解技术/功能点方法：按开发阶段将系统划分成任务<br>每个成本的任务 = 人力 * 人平均工资<br>软件成本 = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo><mtext>独立任务的成本</mtext></mrow><annotation encoding="application/x-tex">\sum 独立任务的成本</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">独立任务的成本</span></span></span></span><br><strong>注意：功能点事一个计量单位，而不是有多少功能</strong></li><li>用例点方法</li><li>故事点方法（敏捷方法适用）</li></ol><h3 id="分析步骤">分析步骤</h3><ol><li>估计开发成本、运行费用和新系统带来的经济效益</li><li>比较新系统的开发成本和经济效益</li></ol><h4 id="成本效益分析方法">成本效益分析方法</h4><ol><li>货币的时间价值，净现值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>i</mi><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">F = P(1+i)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>，<strong>n年后得到的F元钱等价于今天的P元钱</strong></li><li>投资回收期<br>需要多少时间才能使盈利的总金额大于或等于投资的总金额</li><li>纯收入</li><li>投资回报率（ROI，Return on Investment）<br>公式: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>O</mi><mi>I</mi><mo>=</mo><mfrac><mrow><mtext>总收益</mtext><mo>−</mo><mtext>总成本</mtext></mrow><mtext>总成本</mtext></mfrac></mrow><annotation encoding="application/x-tex">ROI = \frac{总收益-总成本}{总成本}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">RO</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总成本</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总收益</span><span class="mbin mtight">−</span><span class="mord cjk_fallback mtight">总成本</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><strong>例题</strong>：PPT第二章33页</li></ol><h2 id="其他可行性分析">其他可行性分析</h2><h3 id="社会可行性分析">社会可行性分析</h3><ol><li>法律可行性<br>如是否违反法律要求（特别是跨国企业要充分研究国外目标市场的法律要求）、专利权、知识产权保护等</li><li>政策可行性<br>分析国家政策/地方政策是否有支持或者限制</li></ol><h3 id="市场可行性">市场可行性</h3><p><strong>可行性分析中，市场可行性分析是必要的并且一般单独占一个章节</strong></p><ol><li>主要客户群体及其特点分析</li><li>国内外该领域发展现状</li><li>国内市场（国外、行业）前景预测</li><li>价格现状与预测，并说明销售策略</li><li>市场竞争对手分析</li><li>市场风险分析</li></ol><h4 id="SWOT模型">SWOT模型</h4><p>市场可行性分析中的第五点和第六点可以合并使用SWOT分析法：</p><ol><li>S，优势，Strengths</li><li>W，劣势，Weakness</li><li>O，竞争市场上的机会，Opportunities</li><li>T，威胁，Threats</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件工程】1. 软件工程学概述</title>
      <link href="/2024/05/31/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%911.%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/05/31/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%911.%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>导言</h1><p>软件工程学的概念：<br>软件工程即用工程、科学和数学的原则和方法研制、维护计算机软件的有关技术及方法，其优点是以较小的代价开发高质量的软件并有效地维护它。</p><h1>软件工程学概述</h1><h2 id="软件">软件</h2><p>概念：软件是计算机系统中与硬件相互依存的另一部分，包括程序、数据及其相关文档的完整集合。软件=程序+数据+文档</p><ul><li>数据：程序能够适当处理信息的数据结构</li><li>程序：能够完成预定功能和性能的可执行指令序列</li><li>文档：开发、使用和维护过程程序所需要的图文资料</li></ul><h2 id="软件危机（软件失效）">软件危机（软件失效）</h2><p>软件危机、软件工程产生的原因？</p><h3 id="概念">概念</h3><p>软件危机指在计算机软件开发和维护过程中，所遇到的一系列严重的问题；</p><h4 id="软件危机的典型表现">软件危机的典型表现</h4><ol><li>软件开发的预算和时间不可预测（不可控）</li><li>软件质量得不到保证（不可用）</li><li>维护非常困难（不可维护）</li></ol><h3 id="软件危机产生的原因">软件危机产生的原因</h3><ol><li><p>与软件本身的特点有关</p><ul><li>软件规模庞大，程序复杂性随规模增加指数上升</li><li>软件是一种逻辑实体，缺乏可见性，管理和控制困难</li><li>软件无磨损性，软件维护意味着修改原来的设计，维护困难</li></ul></li><li><p>与软件开发和维护的方法不恰当有（主观原因）</p><ul><li>忽视需求</li><li>轻视软件维护</li><li>没有认识到程序只是软件的一部分</li><li>没有认识到软件开始只是漫长的软件生命周期中一个比较次要的阶段</li><li>越到后期引入变动付出的代价越高昂</li></ul></li></ol><h3 id="消除软件危机的途径">消除软件危机的途径</h3><p>管理+技术</p><ol><li>更正软件就是程序的概念，对计算机软件应该有正确的认识</li><li>认识到软件开发是分工不同的人员之间协同配合、共同完成的工程项目，不是个人独立的劳动</li><li>推广和使用在实践中总结出来的软件开发的成功技术（理论）和方法（设计方法、设计原则、设计模式）</li><li>积极开发和应用更好的软件工具</li><li><strong>按照工程化的原则和方法组织软件开发工作是有效摆脱软件危机的一个主要方法</strong>，对软件进行建模，探索更好更有效的管理措施和手段对开发过程进行控制和管理</li></ol><p>概念：</p><ol><li>工程：将科学及数学原理运用于实际用途的应用手段，如：设计、制造、机器操纵、构架等。</li></ol><p>软件工程的出现就来源于软件危机</p><h2 id="软件工程">软件工程</h2><h3 id="定义">定义</h3><p>目前普遍认可的对软件工程的定义：<br>软件工程是研究和应用以系统化、规范化的、可定量的过程化方法去<strong>开发和维护软件</strong>，以及如何把经过实践验证而证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来</p><p>软件工程包括两方面内容：</p><ol><li>技术</li><li>管理</li></ol><h3 id="软件工程本质特征">软件工程本质特征</h3><ul><li>关注大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发效率很重要</li><li>开发人员的和谐协作是关键</li><li>软件需要有效支持用户</li><li>软件开发者替代其他领域人员创造产品</li></ul><h3 id="软件工程的基本原理">软件工程的基本原理</h3><ul><li>按软件生存期分阶段指定计划并认真实施</li><li>坚持进行阶段评审</li><li>坚持严格的产品控制</li><li>使用现代程序设计技术</li><li>用人少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h3 id="软件工程方法学（重点）">软件工程方法学（重点）</h3><p>软件工程方法学概念：在软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为范型</p><h4 id="三要素（重点）">三要素（重点）</h4><ol><li>过程：规定了完成各项任务的工作步骤，是为了获取高质量软件所需要完成的一系列任务框架</li><li>方法：完成软件开发的各项任务的技术方法，为软件开发提供了“如何做”的技术</li><li>工具：计算机辅助软件工具</li></ol><h4 id="软件工程方法学的分类（主要看前两种）">软件工程方法学的分类（主要看前两种）</h4><ol><li>结构化方法（生命周期方法学），又称为传统方法学<ul><li>把软件生命周期划分为多个阶段，采用结构化技术完成各个阶段的任务</li><li>每个阶段开始和结束有严格标准；（面对任意两个相邻阶段而言，前一阶段的结束标准就是后一阶段的开始标准）</li><li>每一个阶段结束之前都必须进行正是严格的技术审查和管理复审<br>优点：<br>分解任务、分工合作，降低整个软件开发工程的复杂度<br>采用科学的管理技术和良好的技术方法对每个阶段成果都进行严格审查，保证了软件质量<br>缺点：<br>要尽早确定需求<br>对分析和设计人员要求较高</li></ul></li><li>面向对象方法<br>模拟人类习惯的思维方式，使软件开发的方法与过程尽可能接近人们认识世界解决问题的方法与过程，从而使得问题空间与解空间在结构上尽可能一致<br><strong>要点</strong>：</li></ol><ul><li><strong>把对象作为</strong>融合了数据以及在数据上的操作行为的统一的<strong>软件构件</strong></li><li>所有对象划分成类</li><li>按照父类（基类）与子类（派生类）的关系，把若干相关类组成一个层次结构系统</li><li>对象彼此间<strong>仅能</strong>通过发送消息相互联系，完成系统的功能和行为</li></ul><ol start="3"><li>面向构建方法</li><li>敏捷方法</li></ol><p>面向对象方法与传统方法学的区别：</p><ol><li>传统方法学：强调自顶向下顺序完成软件开发各阶段任务</li><li>面相对象方法学：时主动地多次反复迭代的演化过程</li></ol><h2 id="软件的生命周期">软件的生命周期</h2><p>软件工程过程和生命周期？<br>生命周期模型？</p><h3 id="概览图">概览图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1[&quot;`软</span><br><span class="line">件</span><br><span class="line">的</span><br><span class="line">生</span><br><span class="line">命</span><br><span class="line">周</span><br><span class="line">期`&quot;]</span><br><span class="line">1 --&gt; 软件定义 &amp; 软件开发 &amp; 软件维护</span><br><span class="line">软件定义 --&gt; 2[&quot;`问题定义：弄清楚用户要解决的什么问题`&quot;] &amp; 3[&quot;`可行性研究：上阶段确定问题是否可行`&quot;] &amp; 4[&quot;`需求分析：为解决这个问题，系统需要具备什么功能`&quot;]</span><br><span class="line">软件开发 --&gt; 5[&quot;`总体设计：设计软件结构，确定程序是由哪些模块组成以及模块间的关系`&quot;] &amp; 6[&quot;`详细设计：针对每个模块，设计详细的规格说明，确定算法和数据结构`&quot;] &amp; 7[&quot;`编码和单元测试：将详细设计内容用语言实现，并测试每个模块`&quot;] &amp; 8[&quot;系统测试：通过各种类型的测试使软件达到预定要求&quot;]</span><br><span class="line"></span><br><span class="line">软件维护 --&gt; 改正性维护 &amp; 适应性维护 &amp; 完善性维护 &amp; 预防性维护</span><br></pre></td></tr></table></figure><h3 id="概念-2">概念</h3><p>软件生命周期：软件孕育、诞生、成长、成熟、衰亡的生存过程；</p><h3 id="软件生命周期的各个阶段">软件生命周期的各个阶段</h3><h4 id="软件定义">软件定义</h4><p>任务：</p><ol><li>确定软件开发工程必须完成的总目标</li><li>确定工程的可行性</li><li>导出实现工程目标应该采用的策略以及系统必须完成的功能</li><li>估计完成该项目工程需要的资源和成本，并制定工程进度表</li></ol><h4 id="软件开发">软件开发</h4><p>具体设计和实现前一个时期定义的软件，通常分为4个阶段：</p><ol><li>总体设计（概要设计）<br>根据需求分析，设计软件的体系结构；定义结构中的组成模块</li><li>详细设计（模块设计）<br>对每个模块要完成的工作进行具体描述，确定算法和数据结构，编写设计说明书</li><li>程序编写</li><li>软件测试<br>包括单元测试和系统测试</li></ol><h4 id="软件维护">软件维护</h4><p>使软件持戒的满足用户的需要；具体的维护包括：</p><ol><li>改正性维护：运行过程中发现了软件中的错误需要改正</li><li>适应性维护：为了适应变化了的软件工作环境，需要做适当变换</li><li>完善性维护：当用户有了新的要求时，应当及时改进软件以满足用户的需求</li><li>预防性维护：修改软件为将来的维护活动作预先准备</li></ol><h2 id="软件过程">软件过程</h2><h3 id="概念-3">概念</h3><p>为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤；<br>（过程是软件工程的三要素之一，通常用软件生命周期模型来描述）</p><h3 id="软件生命周期模型">软件生命周期模型</h3><p>概念：指软件项目从<strong>概念形成</strong>直至<strong>软件废弃</strong>为止，跨越整个生命周期的系统开发、运作和维护所实施的全部过程、活动和任务的<strong>结构框架</strong></p><p>软件周期模型又称：软件开发模型/软件过程模型/软件工程范型</p><p>常见的模型有：<strong>瀑布模型</strong>、<strong>快速原型模型</strong>、<strong>增量模型</strong>、<strong>迭代模型</strong>、<strong>螺旋模型</strong>、<strong>喷泉模型</strong>、<strong>RUP</strong>、<strong>敏捷过程</strong>等<br><strong>常见的模型可以看看第一章PPT的P87页往后</strong></p><h4 id="瀑布模型（文档驱动）">瀑布模型（文档驱动）</h4><p>将软件生存周期的各项活动规定为依照固定顺序连接的若干阶段工作，最终得到软件产品</p><h5 id="特点："><strong>特点</strong>：</h5><ol><li>阶段间具有顺序性和依赖性</li><li>推迟实现：首先考虑逻辑模型</li><li>质量保证：<br>每个阶段必须完成规定的文档，每个阶段结束前完成文档的审查</li></ol><h5 id="优点">优点</h5><ol><li>强迫开发人员采用规范的方法</li><li>严格规定了每个阶段必须提交的文档</li><li>要求每个阶段交出的所有产品都必须经过指令保证小组的仔细验证</li></ol><h5 id="缺点">缺点</h5><ol><li>在软件开发初期就要做出正确、全面、完整的需求分析对许多应用来说是极其困难的</li><li>需求分析阶段，当需求确定后，无法及时验证需求是否正确、完整</li><li>不支持产品的演化，缺乏灵活性，开发过程中难以发现错误，只有在最终产品中才能显示出来，产品难以维护</li></ol><h5 id="改进的瀑布模型">改进的瀑布模型</h5><p>实际上就是在瀑布的每个阶段加上验证回溯的过程<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601102148.png" alt="Pasted image 20240601102148"></p><h4 id="快速原型模型">快速原型模型</h4><p>快速建立可运行的程序，它完成的功能往往是最终产品的一个子集</p><h5 id="优点-2">优点</h5><ol><li>开发的软件产品通常满足用户需求</li><li>产品开发基本是现行过程</li></ol><h5 id="缺点-2">缺点</h5><ol><li>准确原型设计困难</li><li>原型理解可能不同</li><li>不利于开发人员创新</li></ol><h4 id="增量模型">增量模型</h4><p>把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。<br>使用增量模型时，第一个阶段的增量构件往往实现软件的基本需求，提供最核心的功能；后面的增量构架逐渐添加系统的功能。</p><p>概念：<br>先完成一个系统子集的开发，再按照通用的开发步骤增加功能（系统子集），如此递增下去知道满足全部系统需求</p><h5 id="优点-3">优点</h5><ol><li>软时间内可提交完成部分功能</li><li>逐渐增加产品功能，用户适应快</li></ol><h5 id="缺点-3">缺点</h5><ol><li>增量构建划分以及集成困难</li><li>容易退化为边做边改模型</li></ol><h4 id="螺旋模型">螺旋模型</h4><p>在每个阶段之前都增加了风险分析的<strong>快速原型模型</strong>。可以看作是增加了风险分析的快速原型模型。</p><h5 id="优点-4">优点</h5><ol><li>利于把软件质量作为开发目标</li><li>有利于软件重用</li><li>减少测试</li><li>维护和开发不分开</li></ol><h5 id="缺点-4">缺点</h5><ol><li>风险估计困难</li></ol><h4 id="喷泉模型">喷泉模型</h4><p>典型的面向对象的软件过程模型，体现了<strong>迭代和无缝</strong>的特性。</p><h3 id="选择模型时应该考虑的因素">选择模型时应该考虑的因素</h3><ol><li>软件自身的性质：规模、复杂度</li><li>软件整体开发进度要求</li><li>模型应能控制并消除软件开发风险</li><li>模型应有可用的计算机辅助工具（如快速原型工具）的支持</li><li>模型与软件开发人员的知识和技能应相匹配</li><li>模型应有利于软件开发的管理和控制</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】4. 数据库设计和E-R模型</title>
      <link href="/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE-R%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8CE-R%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>E-R模型的基本元素</h1><p><strong>三种基本元素</strong></p><ol><li>实体<br>客观存在并可以与其它相区分的某一物体；<br>例如：特定的（一个）人、公司、事件、植物</li><li>属性<ul><li>实体具有属性；</li><li>实体集中每个实体都拥有的，起描述作用的性质；<br>例如，一个人作为实体具有这些性质：名字、年龄和地址。这些都是人的属性</li><li>域：属性肯呢个取值的集合；</li></ul></li><li>联系</li></ol><p><strong>其他相关元素</strong></p><ol><li>参与</li><li>角色</li><li>映射基数</li><li>码</li></ol><h2 id="E-R图的表示">E-R图的表示</h2><p>ER图是不包含外部码的，因为ER图反映联系，外部码也是反映联系；所以外部码隐含在ER图的联系中；<br>所以ER图中的实体是不可能有两个实体的主码的；</p><h3 id="图的画法">图的画法</h3><h4 id="属性">属性</h4><ul><li>矩形表示实体集</li><li>椭圆代表属性</li><li>直线把实体集和他们的属性联系起来</li><li><strong>双线椭圆</strong>表示多值属性</li><li><strong>虚线椭圆</strong>表示派生属性</li><li><strong>下划线</strong>表示主码属性<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514193605.png" alt="Pasted image 20240514193605"></li></ul><h4 id="联系">联系</h4><ul><li>菱形表示联系集</li><li>同样用用直线把联系集和它们的属性椭圆连起来</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514195432.png" alt="Pasted image 20240514195432"></p><h4 id="参与">参与</h4><ul><li>实体集E和联系集R间的一条连线表示E参与了R一次</li><li>实体集E和联系集R间的两条连线表示E参与了R两次</li><li></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514195847.png" alt="Pasted image 20240514195847"></p><h4 id="角色">角色</h4><ul><li>如果某实体集和某联系集间有多于一条的连线，这些连线必须用角色标注</li><li>如果某实体集和某联系集间只有一条连线，那么建议不标注角色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514200812.png" alt="Pasted image 20240514200812"></p><h4 id="映射基数">映射基数</h4><ul><li>从联系集到 “一”方实体集，画一条有向线: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> ；<br>箭头指向“一”方（实体集）</li><li>从联系集到 “多”方实体集，画一条无向线: —；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514201453.png" alt="Pasted image 20240514201453"></li></ul><h3 id="类视图的写法">类视图的写法</h3><h4 id="属性-2">属性</h4><ul><li>复合属性后以缩进表示它的成分属性</li><li>用大括号表示多值属性</li><li>用小括号表示派生属性</li><li>下划线表示主码属性<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514193548.png" alt="Pasted image 20240514193548"></li></ul><h4 id="联系-2">联系</h4><ul><li>菱形表示联系集。</li><li>若联系集有属性，则用（不分割的）矩形表示，并用虚线与联系集相连。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514195542.png" alt="Pasted image 20240514195542"></li></ul><h4 id="参与-2">参与</h4><ul><li>实体集E和联系集R间的连线表示E参与了R</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514195958.png" alt="Pasted image 20240514195958"></p><h3 id="属性-3">属性</h3><p><strong>基本概念</strong>：实体集中每个实体都拥有的，起描述作用的性质；<br><strong>域</strong>：属性可能取值的集合；例如，属性“sex”的域是{女，男}；属性“age”的域是区间[0, 200]</p><h4 id="特殊属性">特殊属性</h4><p><strong>符合属性</strong>：可以划分为其它更小的属性(成分属性)；例如，“Parents”就是一个复合属性，它可以划分为更小的属性：“Father” + “Mother”；<br><strong>多值属性</strong>：可有 (分解为) 不止一个值的属性。分解后的个数不定。例如，人的phone-numbers属性是多值的，因为phone-numbers = phone-number1 + phone-number2 + …<br><strong>派生属性</strong>：可以从其它属性(基属性)计算得来；例如：tax = salary * 0.05</p><h4 id="角色-2">角色</h4><p>实体集参与联系集时发挥的作用；</p><ul><li>如果实体集仅参与联系集一次，那么它只有一个角色且隐含在名字中，不用特别说明</li><li>如果实体集参与联系集两次或以上，那么相应地，它有两个或以上的角色。这时单靠实体的名字无法区分这些角色，需要单独说明每次以什么角色参与；<br>例如，考虑联系集 work-for = customer (manager) : customer (worker)</li></ul><h3 id="联系-3">联系</h3><p><strong>基本概念</strong>：联系就是n( 2)个实体间的相互关联；例如，联系 (Jones, L-17)表示顾客Jones和贷款L-17之间的联系 ，即Jones借了这笔贷款；<br><strong>联系集</strong>：一个联系集就是相同类型的联系的集合。相同类型，意味着这些联系涉及相同数量的实体，且来自同一序列的实体集。</p><h4 id="实体集内部的联系">实体集内部的联系</h4><p>联系可能发生在同类型的实体之间，即一个实体集内部彼此间有联系。<br>同类实体参与联系时，发挥的作用（角色）可能不同；<br>work-for   = { (Jones, Curry), (Jones, Smith), ……}<br>= customer : customer<br>= customer (manager) : customer (worker)</p><h4 id="联系集的属性">联系集的属性</h4><p>联系集也可以有起描述作用的属性；例如，borrower 联系集可以有“borrow-date”的属性；</p><h4 id="联系的度">联系的度</h4><p><strong>基本概念</strong>：指的是参与联系集的实体集个数（次数）<br>度为2的联系集，称为二元联系集。常见的联系集多是二元的。<br>三元以上的联系集，即三个或以上实体集间的联系较少见。<br><strong>例子</strong>：假设在大学里，一个学生可以参加多个项目，每个项目都有指定给他的指导教师，那么在三个实体集： 『学生』 ， 『项目』， 『教师』间就存在一个联系集『指导』，这个『指导』联系集的度为3，或者说是三元的；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514200428.png" alt="Pasted image 20240514200428"></p><h3 id="参与-3">参与</h3><p><strong>基本概念</strong>：参与是指实体集与联系集间的关联。也就是说，如果联系集R 涉及到实体集E1, E2, …, En，那么等于说实体集E1, E2, …, En参与了联系集R；</p><ul><li>例如，实体集『 customer 』和 『 loan 』 参与了联系集“borrower”<br>实体集『 customer 』和 『 loan 』参与联系集“borrower”多少次？<br>一个 实体集能够两次参与同个联系集：考虑 work-for = customer : customer 这一联系集</li></ul><h4 id="参与的类型">参与的类型</h4><ol><li>完全参与<br>如果E中全部实体都参与R中的联系，那么E对R的参与就是完全的；<br>例如，实体集『 loan 』完全参与联系集『 borrower 』，因为每笔贷款都是被（某个用户）借出的，参与了 “借贷”联系；</li><li>部分参与<br>如果实体集E中的某些实体不参与联系集R中的任何联系，那么这种参与就是部分的；<br>例如，实体集『 customer 』部分参与联系集『 borrower 』；<br>因为某些客户不一定向银行借钱，不参与borrower联系</li></ol><h3 id="映射基数-2">映射基数</h3><p><strong>基本概念</strong>：</p><ul><li>表示<strong>某一实体</strong>通过联系集能够和几个<strong>其它实体</strong>关联</li><li>在描述二元联系集时特别有用</li></ul><p>假设在实体集A和B之间有二元的联系集R，它的映射基数必是以下之一：</p><ol><li>一对一联系：<br>A的每个实体，最多和B的一个实体相联系（可能是1个，也可能是0个，即没有联系）。<br>例如，丈夫:妻子</li><li>一对多联系<br>A的每个实体，和B的任意多个（0,1,2…) 实体相联系。<br>例如，公司:部门</li><li>多对一联系<br>一对多联系反过来</li><li>多对多联系<br>A的每个实体，和B的任意多个实体相联系。<br>反过来，B的每个实体，也和A的任意多个实体相联系。<br>例如，学生:课程</li></ol><h4 id="判断多元联系的映射基数">判断多元联系的映射基数</h4><p>设实体集E1, E2, ……, En(n&gt;2)间存在多元联系。<br>E1 : E2 : …… : En  = ? : ? : …… ?</p><ul><li>Ei是“一”方的条件：对每个非Ei的实体集Ej (j≠i) , Ej 的每个实体最多对应Ei的一个实体；</li><li>Ei是“多”方的条件：对某个非Ei的实体集Ej (j≠i) , Ej 的每个实体可对应Ei的任意多个实体；<br><strong>例子：</strong><br>教师用参考书上某门课，故存在三元联系。假设一门课程可有多个教师上课，有多本参考书；但是每个教师只能上一门课程，每本参考书只能供一门课程使用。则：<br>课程 : 教师 : 参考书=  ? : ? : ?</li></ul><h3 id="实体的码">实体的码</h3><ol><li>超码：特殊的单个属性或属性集合，它的值可以唯一标识实体集里的每个实体。</li><li>候选码：最小的超码；</li><li>主码：虽然在一个实体集里可能存在几个候选码，但是只选出一个作为主码；</li></ol><h1>E-R模型转化为关系模型</h1><ol><li>E-R模型<br>基本元素：实体、属性、联系</li><li>关系模型<br>基本元素：关系、属性<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240514204822.png" alt="Pasted image 20240514204822"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】5. 关系数据理论</title>
      <link href="/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/"/>
      <url>/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>为什么要学习关系数据理论</h1><h3 id="“坏”的关系模式的问题">“坏”的关系模式的问题</h3><ol><li>冗余</li><li>三种异常（增删改）<ul><li>插入异常</li><li>更新异常</li><li>删除异常<br><strong>不良的数据依赖导致“坏”的关系模式</strong></li></ul></li></ol><h1>函数依赖</h1><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集，若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X”，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span><br>若Y不函数依赖于X，则记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span></p><p><strong>注意</strong>：函数依赖不是指关系模式R的某个或者某些关系实例r满足的约束条件，而是指R的所有关系实例r均要满足的约束条件；<strong>函数依赖是指关系模式R在任何时刻的关系实例均要满足的约束条件</strong></p><h3 id="平凡函数依赖与非平凡函数依赖">平凡函数依赖与非平凡函数依赖</h3><p><strong>非平凡函数依赖</strong><br>概念：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是非平凡的函数依赖<br><strong>平凡函数依赖</strong><br>概念：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是平凡的函数依赖</p><p><strong>例如</strong>：<br>SC(Sno,Cno,Grade)中，<br>非平凡的函数依赖有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>n</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">(Sno, Cno) \to Grade</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span></span></span></span><br>平凡的函数依赖有：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>n</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">(Sno, Cno) \to Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>n</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">(Sno, Cno) \to Cno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span></span></span></span></p><h3 id="完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖</h3><p>在关系模式R(U)中，如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，并且X的任意一个真子集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mi mathvariant="normal">‘</mi></msup></mrow><annotation encoding="application/x-tex">X^`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span></span></span></span>都有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mi mathvariant="normal">‘</mi></msup><mo>↛</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X^` \nrightarrow Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，则Y完全函数依赖于X，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mtext> </mtext><mo><mover><mo><mo>→</mo></mo><mi>F</mi></mover></mo><mtext> </mtext><mi>Y</mi></mrow><annotation encoding="application/x-tex">X\  \overset{F}{\to} \ Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>； 若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，但Y不完全函数依赖于X，则Y部分函数依赖于X，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo><mover><mo><mo>→</mo></mo><mi>P</mi></mover></mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \overset{P}{\to} Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>。<br><strong>例如：</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601160242.png" alt="Pasted image 20240601160242"></p><h3 id="传递函数依赖">传递函数依赖</h3><p>在R(U)中，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>↛</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \nrightarrow X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">↛</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">Y \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>，则称Z对X传递函数依赖。记作 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo><mover><mo><mo>→</mo></mo><mtext>传递</mtext></mover></mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X \overset{传递}{\to} Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传递</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>；Z通过Y函数传递依赖于X。<br><strong>注意</strong>：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mtext>且</mtext><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">X \to Y 且 Y \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，则Z直接函数依赖于X</p><h4 id="为什么又要求Y-nsubseteq-X">为什么又要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>?</h4><p>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \subseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，则Y平凡函数依赖于X，并且有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，这样将导出Z直接函数依赖于X<br><strong>举例</strong>：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>S</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>n</mi><mi>o</mi><mo stretchy="false">)</mo><mo>→</mo><mi>C</mi><mi>n</mi><mi>o</mi><mtext>，</mtext><mi>C</mi><mi>n</mi><mi>o</mi><mo>→</mo><mi>C</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">(Sno, Cno) \to Cno，Cno \to Cname</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span></span></span></span>，则可以得出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>n</mi><mi>o</mi><mo>→</mo><mo stretchy="false">(</mo><mi>S</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mi>C</mi><mi>n</mi><mi>o</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cno \to (Sno, Cno)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mclose">)</span></span></span></span>，不能得出传递函数依赖关系。</p><h2 id="确定函数依赖的方法">确定函数依赖的方法</h2><p>函数依赖是语义范畴的概念，只能根据数据的语义来确定函数依赖。</p><ul><li>如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>→</mo><mi>S</mi><mi>n</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">Sname \to Sno</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span></span></span></span>函数依赖只有在“学生不允许有重名”的条件下成立</li></ul><h2 id="码">码</h2><h3 id="候选码、超码、全码、外码">候选码、超码、全码、外码</h3><p>设K为关系模式R&lt;U,F&gt;中的属性或者属性组合，即K为U的子集。若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo><mover><mo><mo>→</mo></mo><mi>F</mi></mover></mo><mi>U</mi></mrow><annotation encoding="application/x-tex">K \overset{F}{\to} U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，则称K为R的一个<strong>候选码</strong>。</p><ul><li>若U部分函数依赖于K，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo><mover><mo><mo>→</mo></mo><mi>P</mi></mover></mo><mi>U</mi></mrow><annotation encoding="application/x-tex">K \overset{P}{\to} U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>（即K的真子集即可函数确定U），则K是R的一个<strong>超码</strong></li><li>候选码是最小的超码，即K的任意一个真子集都不是候选码<br>若关系模式R中有多个候选码，则选定其中一个作为主码。</li></ul><p>整个属性组是候选码，则称为<strong>全码</strong>。（即R中只有U函数确定U）</p><h4 id="候选码求解">候选码求解</h4><ol><li>先求最小函数依赖集，候选码的求解基于最小函数依赖集</li><li>将所有属性分类：<ul><li>L类：只出现在函数依赖左侧</li><li>R类：只出现在函数依赖右侧</li><li>LR类：既出现在左侧又出现在右侧</li><li>NLR类：既不出现在左侧又不出现在右侧</li></ul></li><li>根据以下定理球候选码：<ul><li>L类：一定是主属性，即码的一部分（个人理解：只有它自己才能推出自己，码需要推出所有属性，所以必须包含它）</li><li>R类：一定不是主属性</li><li>LR类：可以和L类属性以及NLR类属性组合，求闭包，如果闭包可以推出所有属性U，则为候选码</li><li>NLR类：一定在任意候选码中<br>例题解答：<br>可以观看以下视频跟着走一遍</li></ul></li></ol><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=295480510&bvid=BV1gF411v7UT&cid=476693505&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width: 100%;"></iframe><h4 id="外码">外码</h4><p>关系模式R&lt;U,F&gt;，U中属性或属性组X并非R的码，但X是另外一个关系模式的码，则称X是R的<strong>外部码，也称外码</strong>。</p><ul><li>外码体现的是关系之间的联系性，主码与外部码一起提供了表示关系间联系的手段</li></ul><h3 id="主属性于非主属性">主属性于非主属性</h3><p>包含在任何一个<strong>候选码</strong>中的属性称为主属性；否则称为非主属性/或非码属性。</p><h1>范式</h1><p>概念：范式是符合某一种级别的关系模式的集合<br>关系数据库中的关系必须满足一定的要求，满足不同程度要求的关系称为不同的范式</p><p><strong>范式的种类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">范式 --&gt; 1[&quot;`第一范式（1NF）`&quot;] &amp; 2[&quot;`第二范式（2NF）`&quot;] &amp; 3[&quot;`第三范式（3NF）`&quot;] &amp; 4[&quot;`BC范式`&quot;] &amp; 第四范式 &amp; 第五范式 &amp; ...</span><br></pre></td></tr></table></figure><p>各个范式之间的关系：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>2</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>3</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mi>B</mi><mi>C</mi><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>4</mn><mi>N</mi><mi>F</mi><mo>⊃</mo><mn>5</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BCNF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span><br>某一关系模式R为第n范式，则可以简记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mi>n</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in nNF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601165232.png" alt="Pasted image 20240601165232"></p><h2 id="规范化">规范化</h2><p>一个低一级范式的关系模式，通过模式分解可以转化为若干个高一级范式的关系模式的集合，这个过程叫做<strong>规范化</strong>。</p><h3 id="第一范式">第一范式</h3><p>若一个关系模式R中的所有属性都是不可分的基本数据项（原子性），则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>1</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 1NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span><br><strong>第一范式是对关系模式最起码得要求，不满足第一范式的数据库模式不能称为关系数据模式</strong></p><h3 id="第二范式">第二范式</h3><p>满足第一范式的关系模式，不一定是一个好的关系模式。<br>比如以下例子：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601165623.png" alt="Pasted image 20240601165623"><br><strong>分析关系S-L-C</strong>：</p><ol><li>满足第一范式1NF</li><li>码（候选码）为(Sno, Cno)，主属性为Sno, Cno，非主属性为Grade, Sdept和Sloc</li><li>非主属性Sdept和Sloc部分函数依赖于码(Sno, Cno)</li></ol><h4 id="第二范式的定义">第二范式的定义</h4><p>若关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>1</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 1NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>，并且<strong>每一个非主属性都完全依赖于R的码</strong>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>2</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 2NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span><br>显然上述的例子中S-L-C关系并不是第二范式</p><p>一个关系模式R不属于2NF存在的问题：</p><ol><li>插入异常：如果想插入一个没有成绩的学生，则产生插入异常，因为成绩是主码不能为空</li><li>删除异常：如果想删除一个学生的某一个课程，这个学生的其他信息，比如宿舍楼Sloc等也会被删除</li><li>数据冗余量大：如果一个学生选了8门课，那么他的Sdept和Sloc就要重复存储8次</li><li>修改复杂性：如果一个学生要转系，还可能要修改Sloc，并且由于数据冗余大，需要修改多个信息</li></ol><p>产生这些问题的原因：Sdept，Sloc部分函数依赖于码，SLC的码为(Sno, Cno)</p><p><strong>解决方法</strong>：投影分解<br>把S-L-C分解成两个关系模式，使得每一个关系模式都满足2NF。<br>于是S-L-C分解为SC(Sno, Cno, Grade)和SL(Sno, Sdept, Sloc)</p><h3 id="第三范式">第三范式</h3><p>一个关系模式即使满足2NF，依然可能会出现数据冗余等问题。<br>继续上述的例子，现在我们有满足2NF的关系SL(Sno, Sdept, Sloc)，即对于关系模式SL，每一个非主属性都不完全依赖于码。<br>但是我们观察到，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi><mo>→</mo><mi>S</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo separator="true">,</mo><mi>S</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mo>→</mo><mi>S</mi><mi>l</mi><mi>o</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">Sno \to Sdept, Sdept \to Sloc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">pt</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal">pt</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal">oc</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>n</mi><mi>o</mi><mo><mover><mo><mo>→</mo></mo><mtext>传递</mtext></mover></mo><mi>S</mi><mi>l</mi><mi>o</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">Sno \overset{传递}{\to} Sloc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1452em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1452em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">→</span></span></span><span style="top:-3.5669em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">传递</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">Sl</span><span class="mord mathnormal">oc</span></span></span></span>，这样会产生什么问题呢？</p><ol><li>插入异常：如果某个系因为种种原因，目前暂时没有在校的学生，我们就无法把这个<strong>系的信息</strong>录入到数据库，比如这个系的名称、这个系所对应的宿舍楼。</li><li>删除异常：如果某个系的学生全部毕业了，我们在删除该系的学生信息的同时，把这个系的信息（比如系名、宿舍楼等）也删掉了。</li><li>数据冗余：每一个系的学生住在同一栋楼，所以对于一个系的学生，在宿舍楼、系名这两个属性下的值会重复出现。</li><li>修改复杂：数据冗余导致的修改复杂。</li></ol><p>产生问题的原因：S-L中Sloc传递函数依赖于Sno，即非主属性传递函数依赖于码</p><p><strong>解决方法</strong>：投影分解<br>将2NF的关系模式SL(Sno, Sdept, Sloc)分解为SD(Sno, Sdept)和DL(Sdept, Sloc)</p><h4 id="第三范式的定义">第三范式的定义</h4><p>若关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>1</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 1NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>，若R中不存在<strong>非主属性传递依赖于码</strong>，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>3</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 3NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>。<br>3NF的性质：</p><ol><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>3</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 3NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>2</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 2NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span></li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>3</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R\in 3NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>，R中每一个非主属性既不依赖也不传递依赖于码</li></ol><h3 id="BC范式">BC范式</h3><p>满足第三范式的关系模式，也存在一些问题，可以看以下的例子；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601184406.png" alt="Pasted image 20240601184406"><br>上面的例子中，STJ满足第三范式，因为STJ是的码是全码，不存在非主属性，因此也不存在非主属性部分或者传递函数依赖于码的函数依赖。</p><p><strong>出现的问题</strong>：仍然存在增删改异常</p><ol><li>插入异常：如果一个教师开设了某门课，但是尚未有学生选修，那么有关信息无法存入数据库</li><li>删除异常：如果选修某门课的学生全部毕业了，在删除这些学生元组的同时，相应的教师开设的该门课程的信息也同时丢失了</li><li>数据冗余度大：虽然一个教师只教一门课，但是每个选修该教师的学生元组都要记录这个教师以及课程的信息。造成数据冗余</li><li>修改复杂：比如某个教师教的课程改名，那么每个选择了这个教师的学生的元组都要修改</li></ol><p><strong>出现问题的原因</strong>：主属性J部分函数依赖于T，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>→</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \to J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>，教师只教一门课程</p><p><strong>解决方法</strong>：投影分解<br>将STJ分解为两个关系模式：SJ(S, J), TJ(T, J)<br>分解后的关系模式中<strong>没有任何属性对码的部分函数依赖和传递函数依赖</strong></p><h4 id="BC范式的定义">BC范式的定义</h4><p>设关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>1</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 1NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span>，如果对于R的每一个函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊈</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">Y \nsubseteq X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0966em;vertical-align:-0.3027em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⊈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>，且X必含码，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mi>B</mi><mi>C</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in BCNF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BCNF</span></span></span></span>。<br>即：在关系模式R中，如果<strong>每一个函数依赖的决定因素都包含码，则满足BCNF</strong>。</p><h4 id="具有BCNF的关系模式的性质">具有BCNF的关系模式的性质</h4><ol><li>所有非主码属性对每一个码都是完全函数依赖</li><li>所有主码属性对每一个不包括它的码都是完全函数依赖</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ol><ul><li>如果关系模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mi>B</mi><mi>C</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in BCNF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">BCNF</span></span></span></span>，必有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mn>3</mn><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">R \in 3NF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">3</span><span class="mord mathnormal" style="margin-right:0.13889em;">NF</span></span></span></span></li><li>如果一个关系数据库中所有关系都属于BCNF，那么<strong>在函数依赖的范围内，它已经实现了模式的彻底分解，达到了高度规范化程度，消除了操作异常等诸多问题</strong></li></ul><p>注意：在<strong>函数依赖</strong>的范围内，关系模式除了函数依赖还有其他依赖，比如多值依赖、连接依赖等等</p><h3 id="规范化小结">规范化小结</h3><ol><li>一个关系模式只要其分量都是不可分的数据项，它就是规范化的模型，但这只是最基本的规范化1NF；</li><li>规范化程度低的关系模式不一定能很好地描述现实世界，可能会存在插入异常、删除异常、修改复杂、数据冗余等问题，解决方法就是对关系模式进行规范化，转换成高级范式；</li><li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这个过程就是<strong>关系模式的规范化</strong>；</li><li>关系数据库的规范化理论是数据库逻辑设计的工具；</li></ol><h3 id="关系模式规范化的基本步骤">关系模式规范化的基本步骤</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240601201917.png" alt="Pasted image 20240601201917"></p><h3 id="判断关系模式的范式级别">判断关系模式的范式级别</h3><h4 id="1NF判定">1NF判定</h4><p>所有属性不可再分</p><h4 id="2NF判定">2NF判定</h4><p>检查右侧为非主属性的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，若X是候选码的一部分，则存在非主属性部分函数依赖于码（即码的一部分函数确定某个非主属性），违反2NF</p><h4 id="3NF判断">3NF判断</h4><p>检查非主属性的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，若X不包含码，则违反3NF</p><h4 id="BCNF判断">BCNF判断</h4><p>对于每一个非平凡函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，X必须包含码，否则违反BCNF</p><h1>数据依赖的公理系统</h1><p><strong>数据依赖</strong>的公理系统是模式分解算法的理论基础<br><strong>函数依赖</strong>的一个有效而完备的公理系统——Armstrong公理系统，是一套推理规则，是模式分解算法的理论基础</p><p>Armstrong公理系统的作用：</p><ol><li>从一组函数依赖求得<strong>蕴含的函数依赖</strong></li><li>求给定关系模式的码</li></ol><h3 id="逻辑蕴含">逻辑蕴含</h3><p>对于满足一组<strong>函数依赖F</strong>的关系模式R，其<strong>任何一个关系r</strong>，若<strong>函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>都成立</strong>（即r中任意两个元组t和s，若t[X] = s[X]，那么t[Y] = s[Y]），则称F逻辑蕴含<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>。</p><h3 id="Armstrong公理系统">Armstrong公理系统</h3><p>设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R，对R&lt;U, F&gt;来说有以下的规则：</p><p>推理规则：</p><ol><li>自反律：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>X</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Y \subseteq X \subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>为F所蕴含（这一条决定了所有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>K</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">XK \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>成立）</li><li>增广律：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>为F所蕴含，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>⊆</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">Z \subseteq U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>Z</mi><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">XZ \to YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">XZ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>为F所蕴含</li><li>传递率：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">Y \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>为F所蕴含，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>为F所蕴含<br>导出规则：</li><li>合并规则/结合律：由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mtext>有</mtext><mi>X</mi><mo>→</mo><mi>Y</mi><mi>Z</mi></mrow><annotation encoding="application/x-tex">X \to Y, X \to Z, 有X \to YZ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">有</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></li><li>伪传递规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>由</mtext><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>W</mi><mi>Y</mi><mo>→</mo><mi>Z</mi><mo separator="true">,</mo><mtext>有</mtext><mi>X</mi><mi>W</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">由X \to Y, WY \to Z, 有XW \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">由</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">WY</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">有</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></li><li>分解规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>若</mtext><mi>X</mi><mo>→</mo><mi>Y</mi><mi>Z</mi><mo separator="true">,</mo><mtext>则</mtext><mi>X</mi><mo>→</mo><mi>Y</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">若X \to YZ, 则X \to Y, X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">若</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span></li></ol><p>引理：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mi>A</mi><mn>1</mn></msub><msub><mi>A</mi><mn>2</mn></msub><msub><mi>A</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">X \to A_1A_2A_3...A_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>成立的充分必要条件是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to A_i(i = 1, 2, 3, ..., k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>成立</p><h4 id="Armstrong公理系统的有效性和完备性">Armstrong公理系统的有效性和完备性</h4><ol><li>有效性：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中</li><li>完备性：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来</li></ol><h2 id="函数依赖闭包">函数依赖闭包</h2><p><strong>闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>概念</strong>：在关系模式R&lt;U, F&gt;中<strong>为F所逻辑蕴含的函数依赖的全体</strong>叫做F的闭包，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>。</p><p><strong>X关于函数依赖集F的闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>的定义</strong>：<br>设F为关系模式R&lt;U, F&gt;上的一组函数依赖，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>⊆</mo><mi>U</mi><mo separator="true">,</mo><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>→</mo><mi>A</mi><mtext>能由</mtext><mi>F</mi><mtext>根据</mtext><mi>A</mi><mi>r</mi><mi>m</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>g</mi><mtext>公理导出</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X \subseteq U, X_F^+ =\{A | X \to A能由F根据Armstrong公理导出\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">能由</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord cjk_fallback">根据</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">公理导出</span><span class="mclose">}</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>称为属性集X关于函数依赖集F的闭包。<br><strong>注意：</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>是函数依赖的集合</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>X</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">X^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>是属性的集合</li></ul><h3 id="关于闭包的引理">关于闭包的引理</h3><p>设F为属性集U上的一组函数依赖，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo>⊆</mo><mi>U</mi><mo separator="true">,</mo><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X, Y \subseteq U, X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>能由F根据Armstring公理导出的充分必要条件是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>⊆</mo><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">Y \subseteq X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>。<br><strong>用途</strong>：</p><ol><li>将判定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X \to Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>是否能由F根据Armstrong公理导出的问题，转化为求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>，然后判定Y是否为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>的子集的问题</li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup><mo>=</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">X_F^+=U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>，则X是R&lt;U, F&gt;的候选码</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>可以由算法求得</li></ol><h4 id="求X-F-的方法">求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>的方法</h4><p><strong>例题：</strong> 求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X_F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span>，即求X关于函数依赖集F的闭包<br>以下视频<strong>13分52秒到16分16秒</strong>例题做题过程</p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142744595&p=43" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width:100%"></iframe><h2 id="最小依赖集">最小依赖集</h2><p>最小依赖集也称极小函数依赖集，最小覆盖。<br>如果函数依赖集F满足下列条件，则称F为一个最小依赖集：</p><ol><li>F中任意一个函数依赖的<strong>右部仅含有一个属性</strong></li><li>F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，使得F与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>−</mo><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F-\{X \to A\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span></span></span></span>等价（<strong>即F中的函数依赖均不能由F中其他函数依赖导出</strong>）</li><li>F中不存在这样的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>，X有真子集Z使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>−</mo><mo stretchy="false">{</mo><mi>X</mi><mo>→</mo><mi>A</mi><mo stretchy="false">}</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>Z</mi><mo>→</mo><mi>A</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F-\{X \to A\}\cup \{Z \to A\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">}</span></span></span></span>与F等价（<strong>即F中个函数依赖左部均为最小属性集，不存在冗余属性</strong>）<br>这里有点抽象，视频中的例题看完了就明白了</li></ol><h4 id="求F的最小函数依赖集">求F的最小函数依赖集</h4><p><strong>视频22分34秒到26分54秒</strong>：两个例题，尤其第二个例题需要自己好好做一做<br>方法：</p><ol><li>将F中所有函数依赖的右边化为单一属性</li><li>去掉F中所有函数依赖左边的冗余属性</li><li>去掉F中所有冗余的函数依赖</li></ol><p><strong>注意：</strong><br>F的最小依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">F_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>不一定是唯一的，它与个函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">FD_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">X \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>中X各个属性的初值顺序有关。</p><h1>模式的分解</h1><h2 id="定义">定义</h2><p>关系模式的规范化过程是通过对关系模式的分解来实现的<br><strong>什么是模式分解？</strong><br>R的一个分解指的是：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>R</mi><mn>1</mn><mo>&lt;</mo><mi>U</mi><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mn>1</mn><mo>&gt;</mo><mo separator="true">,</mo><mi>R</mi><mn>2</mn><mo>&lt;</mo><mi>U</mi><mn>2</mn><mo separator="true">,</mo><mi>F</mi><mn>2</mn><mo>&gt;</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>R</mi><mi>n</mi><mo>&lt;</mo><mi>U</mi><mi>n</mi><mo separator="true">,</mo><mi>F</mi><mi>n</mi><mo>&gt;</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho = \{R1&lt;U1,F1&gt;, R2&lt;U2, F2&gt;, ..., Rn&lt;Un,Fn&gt;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><mi>U</mi><mn>1</mn><mo>∪</mo><mi>U</mi><mn>2</mn><mo>∪</mo><mi>U</mi><mn>3</mn><mo>∪</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>U</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">U=U1\cup U2 \cup U3 \cup ... Un</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">...</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span></span></span></span>，并且没有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>⊆</mo><msub><mi>U</mi><mi>j</mi></msub><mtext>，</mtext><mn>1</mn><mo>≤</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">U_i \subseteq U_j， 1 \leq i, j \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是F在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的投影</p><p>模式规范化需要注意的点：</p><ul><li>把低一级的关系模式分解为若干个高一级的关系模式并不是唯一的</li><li>在这些分解方法中，只有能够保证分解后的关系模式与原来的关系模式等价的方法才有意义</li><li>从不同的角度去观察问题，对“等价”的概念形成三种不同的定义：<ol><li>分解具有<strong>无损连接性</strong>（即分解后的关系进行自然连接得到的表，和未分解之前的表数据没有丢失也没有增加）</li><li>分解要<strong>保持函数依赖</strong></li><li>分解要既要有无损连接性又要保持函数依赖<br><strong>这三个定义是实行模式分解的三条准则</strong></li></ol></li></ul><p>我们通过例子来理解上面的模式分解准则以及为什么要遵守这些模式分解准则：<br>定位到视频的<strong>5分14秒到12分30秒</strong></p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=83450228&bvid=BV13J411J7Vu&cid=142741787&p=44" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height: 430px; max-width: 100%"></iframe><h3 id="具有无损连接性的模式分解">具有无损连接性的模式分解</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>R</mi><mn>1</mn><mo>&lt;</mo><mi>U</mi><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mn>1</mn><mo>&gt;</mo><mo separator="true">,</mo><mi>R</mi><mn>2</mn><mo>&lt;</mo><mi>U</mi><mn>2</mn><mo separator="true">,</mo><mi>F</mi><mn>2</mn><mo>&gt;</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>R</mi><mi>n</mi><mo>&lt;</mo><mi>U</mi><mi>n</mi><mo separator="true">,</mo><mi>F</mi><mi>n</mi><mo>&gt;</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho = \{R1&lt;U1,F1&gt;, R2&lt;U2, F2&gt;, ..., Rn&lt;Un,Fn&gt;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span>是R的一个分解，若对R的任何一个关系r，均有r=r在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中各种关系模式上的投影的自然连接成立，则称分解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>具有无损连接性。简称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>为无损分解。</p><ul><li>只有具有无损连接性的分解才能够保证不丢失信息</li><li>具有无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题</li></ul><h4 id="判断分解是否具有无损连接性">判断分解是否具有无损连接性</h4><p>两种方法，一种方法是表格法，一种方法是函数依赖法，表格法操作复杂，理解简单，函数依赖法写起来十分简单。考试推荐函数依赖法。</p><h5 id="函数依赖法">函数依赖法</h5><p>将关系r分解为r1和r2，如果这种分解是无损的，则以下两个函数依赖之一成立：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>r</mi><mn>2</mn></msub><mo>→</mo><msub><mi>r</mi><mn>1</mn></msub><mo>−</mo><msub><mi>r</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">r_1 \cap r_2 \to r_1 - r_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>r</mi><mn>2</mn></msub><mo>→</mo><msub><mi>r</mi><mn>2</mn></msub><mo>−</mo><msub><mi>r</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">r_1 \cap r_2 \to r_2 - r_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>例题理解：<br>假设存在关系r (C, T, H, L, S)，函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">{</mo><mi>C</mi><mo>→</mo><mi>T</mi><mo separator="true">,</mo><mi>H</mi><mi>L</mi><mo>→</mo><mi>C</mi><mo separator="true">,</mo><mi>H</mi><mi>T</mi><mo>→</mo><mi>L</mi><mo separator="true">,</mo><mi>H</mi><mi>S</mi><mo>→</mo><mi>L</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">F = \{C\to T, HL\to C, HT\to L, HS\to L\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">}</span></span></span></span>。<br>现将关系r规范化为BCNF级别，分解过程如下：</li></ul><ol><li>r(HSLC), r1(CT)</li><li>r(HSL), r1(CT), r2(HLC)<br>请证明该分解为无损连接分解。<br>解：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603000733.png" alt="Pasted image 20240603000733"></li></ol><h5 id="表格法">表格法</h5><p>下面视频讲的非常清楚，跟着来一遍即可</p><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=417091446&bvid=BV1jV411Y7Cx&cid=308976884&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:640px; height:430px; max-width: 100%;"></iframe><h3 id="保持函数依赖的模式分解">保持函数依赖的模式分解</h3><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>R</mi><mn>1</mn><mo>&lt;</mo><mi>U</mi><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mn>1</mn><mo>&gt;</mo><mo separator="true">,</mo><mi>R</mi><mn>2</mn><mo>&lt;</mo><mi>U</mi><mn>2</mn><mo separator="true">,</mo><mi>F</mi><mn>2</mn><mo>&gt;</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>R</mi><mi>n</mi><mo>&lt;</mo><mi>U</mi><mi>n</mi><mo separator="true">,</mo><mi>F</mi><mi>n</mi><mo>&gt;</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\rho = \{R1&lt;U1,F1&gt;, R2&lt;U2, F2&gt;, ..., Rn&lt;Un,Fn&gt;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span>是R的一个分解，若F所逻辑蕴含的函数依赖一定也为分解后的所有关系模式中的函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>所逻辑蕴含，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup><mo>=</mo><mo stretchy="false">(</mo><msub><mi>F</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>F</mi><mn>2</mn></msub><mo>∪</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>F</mi><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+=(F_1 \cup F_2 \cup ... F_n)^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.25em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>，则称关系模式R的这个分解是保持函数依赖的。</p><p><strong>注意</strong>：</p><ul><li>如果一个分解具有无损连接线，则它能保证不丢失信息</li><li>如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况</li><li><strong>分解具有无损连接性和分解保持函数依赖是两个相互独立的标准</strong><br>具有无损连接性的分解不一定能够保持函数依赖<br>保持函数依赖的分解也不一定具有无损连接性</li></ul><h2 id="模式分解的算法">模式分解的算法</h2><p>一共有三种：</p><ol><li>规范化到1NF</li><li>规范化到3NF</li><li>规范化到BCNF</li></ol><h3 id="规范化到1NF">规范化到1NF</h3><p>方法：将关系r中每一个非原子属性转化为原子属性</p><ul><li>复合属性的处理：转化为若干个的原子属性</li><li>多值属性的处理：移出去形成一个新的关系，同时包含原来的主码</li></ul><h3 id="1NF规范化到3NF">1NF规范化到3NF</h3><p>方法步骤：</p><ol><li><strong>先求出最小函数依赖集<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">F_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong></li><li>求候选码<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603002339.png" alt="Pasted image 20240603002339"></li></ol><p><strong>例题</strong>：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603002350.png" alt="Pasted image 20240603002350"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603002404.png" alt="Pasted image 20240603002404"></p><h3 id="规范化到BCNF">规范化到BCNF</h3><p>分解成BCNF并且无损连接的算法<br>给定关系模式R&lt;U , F&gt; ，<br>⒈令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span> = {R&lt;U , F&gt;}<br>⒉检查<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中各关系模式是否属于BCNF，若是，则算法终止。<br>⒊设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>中Ri&lt;Ui , Fi&gt;不属于BCNF，<br>则存在函数依赖<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi><mo>∈</mo><msubsup><mi>F</mi><mi>i</mi><mo>+</mo></msubsup></mrow><annotation encoding="application/x-tex">X\to A \in F_i^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4231em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span></span>，且X不是Ri的码，<br>XA是Ri的真子集，将Ri分解为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>={S1，S2}，<br>其中US1  = XA， US2  = Ui - {A}<br>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span>代替Ri ，返回到⒉</p><p>证明无损连接性：</p><p>\displaylines{\because U_{S1} = XA,\ \ U_{S2} = U_i - {A} \\ \therefore U_{S1} \cap U_{S2} = X \\U_{S1} - U_{S2} = A \\\therefore U_{S1} \cap U_{S2} \to U_{S1} - U_{S2} \\得证}</p><p>例题：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603091647.png" alt="Pasted image 20240603091647"></p><h2 id="疑问">疑问</h2><ul><li>[ ] 3NF的例二</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】5. 设备管理</title>
      <link href="/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
      <url>/2024/04/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%915.%20%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>IO设备基本概念</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">IO设备 --&gt; 机械部件 &amp; 1[&quot;电子部件(IO控制器、设备控制器)&quot;]</span><br></pre></td></tr></table></figure><p>IO设备的机械部件主要是用来执行具体的IO操作，比如鼠标、键盘的按钮，显示器的LED屏等等；</p><p>IO设备的电子部件主要是一块插入主板充槽的印刷版电路：CPU无法直接控制IO设备的机械部件，因此设备还需要有一个电子部件作为CPU和IO设备机械部件之间的“中介”，又称设备控制器。CPU可以控制IO控制器，IO控制器来控制机械部件；</p><h3 id="IO控制器的功能">IO控制器的功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">IO控制器的功能 --&gt; 1[&quot;接受和识别CPU发出的指令&quot;] &amp; 2[&quot;向CPU报告设备状态&quot;] &amp; 3[&quot;数据交换&quot;] &amp; 4[&quot;地址识别&quot;]</span><br><span class="line">1 --&gt; 5[&quot;控制寄存器存放&lt;/br&gt;相应指令的命令和参数&quot;]</span><br><span class="line">2 --&gt; 6[&quot;状态寄存器来记录IO设备当前状态&quot;]</span><br><span class="line">3 --&gt; 7[&quot;数据寄存器暂时存放&lt;/br&gt;CPU或者IO设备传来的数据&quot;]</span><br><span class="line">4 --&gt; 8[&quot;给IO设备中各个寄存器编址&quot;]</span><br><span class="line">%%  %%1 --&gt; 5[&quot;比如CPU发来的read/write指令&lt;/br&gt;，IO控制器&lt;/br&gt;中会有相应的控制寄存器来&lt;/br&gt;存放命令和参数&quot;]</span><br><span class="line">%%  %%2 --&gt; 6[&quot;IO控制器中会有相应的状态寄存器，用于记录&lt;/br&gt;IO设备当前状态，比如空闲和忙碌&quot;]</span><br><span class="line">%%  %%3 --&gt; 7[&quot;IO控制器中会设置相应的数据寄存器，&lt;/br&gt;输出时，数据寄存器&lt;/br&gt;用于暂存CPU发来的数据，之后再由控制器传送设备。&lt;/br&gt;输入时，数据寄存器用于暂存设备发来的数据，&lt;/br&gt;之后CPU从数据寄存器中取走数据&quot;]</span><br><span class="line">%%  %%4 --&gt; 8[&quot;类似于内存地址，为了区分设备控&lt;/br&gt;制器中的各个寄存器，&lt;/br&gt;也需要给各个寄存器设置&lt;/br&gt;一个特定的地址，IO控制器&lt;/br&gt;通过CPU提供的地址来判断CPU要读写&lt;/br&gt;哪个寄存器&quot;]</span><br></pre></td></tr></table></figure><h3 id="IO控制器的组成">IO控制器的组成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">IO控制器的功能 --&gt; 1[&quot;CPU与控制器之间的接口(实现控制器与CPU之间的通信)&quot;] &amp; 2[&quot;IO逻辑(负责识别CPU发送的指令，并向设备发出命令)&quot;] &amp; 3[&quot;控制器与设备之间的接口(实现控制器与设备之间的通信)&quot;]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527132110.png" alt="Pasted image 20240527132110"><br>CPU、IO控制器、设备的通信：</p><ol><li>CPU通过<strong>控制线</strong>向IO控制器发送指令</li><li>CPU通过<strong>地址线</strong>找到对应需要操作的设备</li><li>如果需要传输数据，CPU将数据暂存至数据寄存器，IO逻辑从数据寄存器取出输出，通过地址线找到对应的控制器与设备的接口，输出到对应的设备上</li><li>同时，IO逻辑应该从各个设备读取各个设备的状态寄存器的值，将各个设备的状态传送到IO控制器的状态寄存器，CPU从状态寄存器中读取数据得到各个设备的状态<br>细节：</li><li>一个IO控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、状态寄存器可能会有多个，且这些寄存器都要有相应的</li></ol><h3 id="IO控制器的组成-2">IO控制器的组成</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527132110.png" alt="Pasted image 20240527132110"><br>￼<br>CPU、IO控制器、设备的通信：</p><ol><li>CPU通过<strong>控制线</strong>向IO控制器发送指令</li><li>CPU通过<strong>地址线</strong>找到对应需要操作的设备</li><li>如果需要传输数据，CPU将数据暂存至数据寄存器，IO逻辑从数据寄存器取出输出，通过地址线找到对应的控制器与设备的接口，输出到对应的设备上</li><li>同时，IO逻辑应该从各个设备读取各个设备的状态寄存器的值，将各个设备的状态传送到IO控制器的状态寄存器，CPU从状态寄存器中读取数据得到各个设备的状态<br>细节：</li><li>一个IO控制器可能会对应多个设备</li><li>数据寄存器、控制寄存器、状态寄存器可能会有多个，<strong>且这些寄存器都要有相应的地址</strong>，才能方便CPU操作地址，才能方便CPU操作</li><li>寄存器的编址方式：<br>内存映像IO：寄存器地址占用内存地址的一部分<br>IO专用地址：寄存器独立编址</li></ol><h3 id="寄存器编址方式">寄存器编址方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">寄存器编址方式 --&gt; 内存映射IO --&gt; 控制器中的寄存器与内存统一编址 &amp; 1[&quot;可以采用对内存进行操作的指令&lt;/br&gt;来对控制器进行操作&quot;]</span><br><span class="line">寄存器编址方式 --&gt; 寄存器独立编址 --&gt; 控制器中的寄存器独立编址 &amp; 需要设置专门的指令来操作控制器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527133720.png" alt="Pasted image 20240527133720"></p><h1>IO控制方式</h1><p>IO控制方式是指用什么样的方式来控制IO设备的数据读写；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">IO控制方式 --&gt; 程序直接控制方式 &amp; 中断驱动方式 &amp; DMA方式 &amp; 通道控制方式</span><br></pre></td></tr></table></figure><h4 id="程序直接控制方式（轮询）">程序直接控制方式（轮询）</h4><p>轮询检查状态寄存器，等待设备就绪后才执行相关指令，这个过程是串行的；<br><strong>以读操作为例子</strong></p><p>注意的指标：</p><ol><li>CPU干预频率：很平凡，IO操作开始之前、完成之后需要CPU介入，并且在等待IO完成的过程中CPU需要不断地轮询检查</li><li>数据传送的单位：每次读/写一个字</li><li>数据的流向：<br>读操作：IO设备 ——&gt; CPU ——&gt; 内存<br>写操作：内存 ——&gt; CPU ——&gt; IO设备<br>每个字数据的传输都需要经过CPU</li><li>主要缺点和优点：<br>优点：实现简单，通过程序的循环代码即可实现；<br>缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率很低</li></ol><h4 id="中断驱动方式">中断驱动方式</h4><p>引入中断机制，由于IO设备速度很慢，因此在CPU发出读/写命令后，可将等待IO的进程阻塞，先切换别的进程执行。<br><strong>当IO完成后</strong>，控制器会向CPU发送一个中断信号，CPU检测到中断信号后，会<strong>保存当前进程的运行环境信息</strong>，转去执行中断处理程序处理该中断。<br>处理中断的过程中，CPU从IO控制器读一个字的数据传送到CPU寄存器，再写入主存。<br>接着，CPU恢复等待IO的进程的运行环境，然后继续执行。</p><p>注意：</p><ol><li><p>CPU会在每个指令周期的末尾检查中断</p></li><li><p>中断处理过程中需要保存、恢复进行的运行环境</p></li><li><p>处理中断也需要一定的时间开销，中断发生频率不宜太高</p></li><li><p>CPU干预频率：每次IO操作开始前、完成后都需要CPU介入；等待IO完成的过程中CPU可以切换到别的进程执行</p></li><li><p>数据传送的单位：每次读写一个字</p></li><li><p>数据流向：<br>读操作：IO设备 ——&gt; CPU ——&gt; 内存<br>写操作：内存 ——&gt; CPU ——&gt; IO设备</p></li><li><p>主要缺点和主要优点<br>优点：CPU无需轮询，可以和IO设备并行工作，CPU利用率明显提升<br>缺点：<strong>每个字</strong>在IO设备与内存之间的传输都需要经过CPU，所以传输数据时可能会频繁的中断，频繁的中断处理会消耗较多的CPU时间</p></li></ol><h4 id="DMA方式">DMA方式</h4><p>与“中断驱动方式”相比，DMA(Direct Memory Access, 直接存储器存取，主要用于块设备的IO控制)有这样几个改进：</p><ol><li>数据的传送单位是“块”，不再是一个字一个字传送；</li><li>数据的流向是从设备直接放入内存，或者从内存直接到设备，不需要经过CPU</li></ol><p>工作流程：</p><ol><li>CPU给IO模块发送读块指令<br>CPU指明此次要执行的操作的指令<br>CPU指明要读入多少数据，数据存放位置，数据在外部设备的地址</li><li>控制器根据CPU提出的要求完成数据的读写，整块数据传输完成后才向CPU发送中断信号</li></ol><h5 id="DMA控制器">DMA控制器</h5><p>DMA控制器是一种特殊的IO控制器，它的出现减少了CPU对IO操作的频繁干预，代替CPU执行了块数据的读写；<br>DMA控制器的结构如下：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527152240.png" alt="Pasted image 20240527152240"><br>DR：暂存从设备到内存，或从内存到设备的数据；<br>MAR（Memory Address Register，内存地址寄存器）：在输入时，MAR表示数据应该放在内存的什么位置(<strong>目标内存地址</strong>)；输出时MAR存放由主存到设备的主存源地址；<br>DC（Data Counter，数据计数器）：存放本次CPU需要读写的字节数或字数；<br>CR（Command Register, 命令/状态寄存器）：用于存放CPU发来的IO命令，或设备的状态信息；<br><strong>值得注意的是DMA也是一个字一个字传输数据的，只不过传输完数据块后才发生中断</strong></p><p>注意的指标：</p><ol><li>CPU干预频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li><li>数据传送的单位：每次读写一个或多个块（<strong>注意：每次读写的只能是连续的多个块，并且这些块读入内存后在内存中也必须是连续的</strong>）</li><li>数据的流向（不需要经过CPU）<br>读操作：IO设备 ——&gt; 内存<br>写操作：内存 ——&gt; IO设备</li><li>主要缺点和主要优点：<br>优点：数据以“块”为单位，CPU频率进一步降低；CPU和IO设备的并行性得到提升<br>缺点：CPU每发出一条IO指令，只能读写一个或多个连续的数据块</li></ol><h4 id="通道控制方式">通道控制方式</h4><p>通道：一种硬件，可以理解为“阉割版CPU”。通道可以识别并执行一系列 <strong>通道指令</strong>；由于通道只能识别一些很简单的指令，所以称为阉割版CPU，通道和CPU是共享内存的，通道执行的指令存放在内存中；<br>通道的工作原理：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527153623.png" alt="Pasted image 20240527153623"></p><p>注意的指标：</p><ol><li>CPU的干预频率：极低<br>通道会根据CPU的指示执行的相应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU干预；</li><li>数据传送单位<br>每次读写<strong>一组数据块</strong></li><li>数据的流向：<br>IO到内存，内存到IO</li><li>主要优点和主要缺点：<br>缺点：实现复杂，需要专门的通道硬件支持<br>优点：CPU、通道、IO设备可以并行工作，资源利用率很高</li></ol><h1>IO软件层次结构</h1><p>硬件层：包括机械部件和电子部件，在之前的章节里讲过；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527154210.png" alt="Pasted image 20240527154210"></p><h2 id="各个层次的功能">各个层次的功能</h2><ol><li>用户层：用户层软件实现了与用户交互的接口，用户可以直接使用该层提供的、与<strong>IO操作相关的库函数</strong>对设备进行操作；<br>用户层软件将用户请求翻译成格式化的IO请求，并通过“系统调用”请求操作系统内核服务；</li><li>设备独立性软件/设备无关项软件：与设备的硬件特性无关的功能几乎都在这一层实现<br>功能1：向用户层提供统一的调用接口，如read/write操作<br>功能2：设备保护，原理类似于文件保护；不同用户对设备的访问权限不同<br>功能3：差错处理<br>功能4：设备的分配与回收，比如临界资源的分配与回收<br>功能5：数据缓冲区管理<br>功能6：<br>建立逻辑设备名到物理设备名的映射关系；根据设备类型选择<strong>调用相应的驱动程序</strong>；（不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动成程序，<strong>驱动程序一般会以一个独立进程形式存在</strong>）<br>用户或用户软件发出IO操作相关系统调用时，需指明此次要操作的IO设备的逻辑设备名（比如打印机，选择打印机1，其中打印机1就是逻辑设备名）<br>设备独立性软件需要通过“逻辑设备表”(LUT, Logical Unit Table)来确定逻辑设备对应的物理设备，并找到该设备的设备驱动程序<br>逻辑设备表的管理：<br>a. 整个系统只设置一张LUT<br>b. 为每个用户设置一张LUT<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527155256.png" alt="Pasted image 20240527155256"></li><li>设备驱动程序：<br>不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家必须提供与设备相对应的驱动成程序，<strong>驱动程序一般会以一个独立进程形式存在</strong><br>主要负责：<br>a. 将上层发出的一系列指令转化成对特定设备的操作，包括设置寄存器、检查设备状态等；<br>b. 设备独立性软件无法直接操控硬件</li><li>中断处理程序：<br>当IO任务完成时，IO控制器会发送一个中断信号，系统会根据中断信号类型找到对应的中断处理程序并执行；<br>以读操作为例，中断处理程序执行流程：<br>a. 从IO控制器读出设备状态<br>b. 查询IO是否正常结束，如果结束则从设备读入一个字的数据并经由CPU放入内存缓冲区；否则根据异常原因作其他处理</li></ol><h4 id="功能概览">功能概览</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240527160653.png" alt="Pasted image 20240527160653"><br>区分设备独立性软件和设备驱动这两层：</p><ol><li>直接设计硬件具体细节且与中断无关的操作肯定是在设备驱动程序层完成；</li><li>没有涉及硬件、对各种设备都需要进行的管理工作在设备独立性软件层完成；</li></ol><h4 id="IO核心子系统">IO核心子系统</h4><p>IO核心子系统指的是IO软件层次的内核层，即：设备独立性软件、设备驱动程序、中断处理程序</p><h1>假脱机技术</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">假脱机技术 --&gt; 什么是脱机技术 --&gt; 脱机技术解决什么问题</span><br><span class="line">假脱机技术 --&gt; 假脱机技术的实现原理 --&gt; 输入井和输出井 &amp; 输入进程和输出进程 &amp; 输入缓冲区和输出缓冲区</span><br><span class="line">假脱机技术 --&gt; 共享打印机的原理分析</span><br></pre></td></tr></table></figure><h2 id="假脱机技术概念">假脱机技术概念</h2><h3 id="脱机技术">脱机技术</h3><p>批处理阶段引入了脱机输入输出技术（用磁带完成），摆脱了手工操作阶段人工的慢速IO和CPU的高速计算之间的矛盾；<br>脱机是指脱离主机的控制进行的输入输出操作；<br>原理：引入输入外围控制机和输出外围控制机，引入磁带（相当于内存了），手工将纸带输入到输入外围控制机，输入外围控制机将数据传送给磁带（速度比纸带机快很多），CPU从磁带读取数据进行操作，操作完成后CPU将结果输出到磁带，磁带通过输出外围控制机输出到纸带<br>优点：</p><ol><li>CPU在忙碌时，仍然可以进行输入输出IO</li><li>缓解了CPU与慢速IO设备的速度矛盾</li></ol><h3 id="假脱机技术">假脱机技术</h3><p>又称“SPOOLing技术”，是用软件的方式模拟脱机技术；<br>原理：</p><ol><li>输入数据时，输入进程从输入设备获取数据传入内存中的输入缓冲区，然后再把输入缓冲区的数据放入磁盘中的输入井中；</li><li>输出数据时，输出进程从输出井获取数据传入内存中的输出缓冲区，然后再把输出缓冲区的数据输出到输出设备；<br>注意：</li><li>实现假脱机技术的操作系统必须支持多道程序；因为输出进程和输入进程是同时存在的；</li></ol><h4 id="假脱机技术的应用——共享打印机">假脱机技术的应用——共享打印机</h4><p>概念：</p><ul><li>独占式设备：只允许各个进程串行使用的设备，一段时间内只能满足一个进程的请求；</li><li>共享设备：允许多个进程同时使用的设备（宏观上同时使用，微观上可能是交替使用）可以同时满足多个进程的使用请求；</li></ul><p>应用：使用SPOOLing技术实现“独占式设备”改造成“共享式设备”</p><p>打印机——独占式设备<br>当多个用户进程提出打印请求时，系统会答应它们的请求，但并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上<br>当打印机空闲时，输出进程会从文件队列取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务；<br>虽然系统中只有一个打印机，但每个进程提出打印请求时，系统都会在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使得每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享；<br>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备；</li></ol><h1>设备的分配与回收</h1><p>设备独立性软件的功能之一是实现设备的分配与回收，大纲如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">设备的分配与回收 --&gt; 设备分配时应考虑的因素 &amp; 静态分配与动态分配 &amp; 设备分配管理中的数据结构 &amp; 设备分配的步骤 &amp; 设备分配步骤的改进方案</span><br></pre></td></tr></table></figure><h2 id="设备分配时应该考虑的因素">设备分配时应该考虑的因素</h2><ol><li><p>设备的固有属性：独占设备、共享设备、虚拟设备</p></li><li><p>设备的分配算法：先来先服务、短作业优先…</p></li><li><p>设备分配中的安全性：<br>安全分配方式：<br>为进程分配一个设备后就将进程阻塞，本次IO完成后才将进程唤醒（一个时间段内只能使用一个设备）<br>优点：破坏了“请求和保持”条件，不会产生死锁；<br>缺点：对于一个进程来说，CPU和IO设备只能串行工作</p><p>不安全分配方式：<br>进程发出IO请求后，系统为其分配IO设备，进程可以继续执行，之后还能接受新的IO请求。只有某个IO请求得不到满足时才将进程阻塞。（一个进程可以同时使用多个设备）<br>优点：进程的计算任务和IO任务可以并行处理，使进程迅速推进<br>缺点：有可能发生死锁</p></li></ol><h2 id="静态分配和动态分配">静态分配和动态分配</h2><p>静态分配：进程运行前为其分配全部所需要的资源，运行结束后归还资源；（破坏了“请求和保持”条件，不会发生死锁）<br>动态分配：进程运行过程中动态申请资源；</p><h2 id="设备分配管理中的数据结构">设备分配管理中的数据结构</h2><p>设备、控制器、通道之间的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">通道 --&gt; 控制器1 &amp; 控制器2 &amp; ...</span><br><span class="line">控制器1 --&gt; 设备1 &amp; 设备2 &amp; ....</span><br><span class="line">控制器2 --&gt; 设备3 &amp; 设备4 &amp; .....</span><br></pre></td></tr></table></figure><p>一个通道可以控制多个设备控制器，每个设备控制器可以控制多个设备，他们之间是树形的关系；</p><h3 id="设备控制表">设备控制表</h3><p>系统会为每个设备配置一张设备控制表（DCT），用于记录设备的使用情况；<br>设备控制表常用字段：</p><table><thead><tr><th>设备控制表（DCT）</th></tr></thead><tbody><tr><td>设备类型（打印机/键盘）</td></tr><tr><td>设备标识符（唯一ID）</td></tr><tr><td>设备状态（忙碌/空闲/故障）</td></tr><tr><td>指向控制器表的指针（每个设备由一个控制器控制，该指针可以找到相应的控制器信息）</td></tr><tr><td>重复执行次数或时间（当重复执行多次IO操作仍然不成功，才认为此次IO失败）</td></tr><tr><td>设备队列的队首指针（指向正在等待该设备的进程队列，由PCB组成的队列）</td></tr></tbody></table><h2 id="控制器控制表">控制器控制表</h2><p>每个设备控制器会对应一张控制器控制表COCT。操作系统会根据COCT的信息进行操作和管理；</p><table><thead><tr><th>控制器控制表（COCT）</th></tr></thead><tbody><tr><td>控制器标识符</td></tr><tr><td>控制器状态</td></tr><tr><td>指向通道表的指针</td></tr><tr><td>控制器队列的队首指针</td></tr><tr><td>控制器队列的队尾指针</td></tr></tbody></table><h2 id="通道控制表">通道控制表</h2><p>每个通道会对应一张通道控制表CHCT。操作系统根据CHCT的信息对通道进行操作和管理；</p><table><thead><tr><th>通道控制表（CHCT）</th></tr></thead><tbody><tr><td>通道标识符</td></tr><tr><td>通道状态</td></tr><tr><td>与通道相连的控制器表首地址（一个通道对应多个控制器）</td></tr><tr><td>通道队列的队首指针</td></tr><tr><td>通道队列的队尾指针</td></tr></tbody></table><h2 id="系统设备表">系统设备表</h2><p>系统设备表（SDT）记录了系统中全部设备的情况，每个设备对应一个表目；</p><table><thead><tr><th>系统设备表</th></tr></thead><tbody><tr><td>表目1</td></tr><tr><td>表目2</td></tr><tr><td>…</td></tr></tbody></table><table><thead><tr><th>表目i</th></tr></thead><tbody><tr><td>设备类型</td></tr><tr><td>设备标识符</td></tr><tr><td>DCT（设备控制表）</td></tr><tr><td>驱动程序入口</td></tr></tbody></table><h2 id="设备分配步骤">设备分配步骤</h2><ol><li>根据进程请求的物理设备名查找SDT（物理设备名是进程请求分配设备时提供的参数）</li><li>根据SDT找到DCT，查DCT表，若设备忙碌则将进程PCB挂到<strong>设备等待队列</strong>；否则将设备分配给进程；</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到<strong>控制器等待队列</strong>，不忙碌则将控制器分配给进程；</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到<strong>通道等待队列</strong>，否则将控制器分配给进程；<br>只有当设备、控制器、通道都分配给进程，这次设备分配才算成功，之后便启动IO设备进行数据传输</li></ol><p>缺点：</p><ol><li>用户编程时必须使用“物理设备名”</li><li>若换一个物理设备，程序无法运行</li><li>若进程请求的物理设备忙碌，则即使系统中还有同类型设备，进程也必须阻塞等待</li></ol><p>改进方法：<br>建立逻辑设备名与物理设备名的映射机制，用户编程只需要提供逻辑设备名</p><h3 id="设备分配步骤的改进">设备分配步骤的改进</h3><ol><li>根据进程请求的逻辑设备名，在SDT查找（逻辑设备名实际上就是  设备类型）</li><li>在SDT中找到用户指定的、并且空闲的设备，将其分配给该进程。操作系统在<strong>逻辑设备表（LUT）中新增一个表项</strong></li><li>根据DCT查找COCT，若控制器忙碌则将进程PCB挂到控制器等待队列，否则将控制器分配给进程</li><li>根据COCT查找CHCT，若通道忙碌则将进程PCB挂到通道等待队列，否则将通道分配给进程</li></ol><h3 id="逻辑设备表">逻辑设备表</h3><p>逻辑设备表LUT建立了逻辑设备名与物理设备名之间的映射关系；<br>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加对应表项；<br>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪一个设备，并且也能知道该设备的驱动程序入口地址；</p><h4 id="逻辑设备表设置问题">逻辑设备表设置问题</h4><p>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统<br>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</p><h1>缓冲区管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">缓冲区管理 --&gt; 缓冲区的概念和作用 &amp; 单缓冲 &amp; 双缓冲 &amp; 循环缓冲 &amp; 缓冲池</span><br></pre></td></tr></table></figure><h2 id="缓冲区概念">缓冲区概念</h2><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区；<br>硬件作为缓冲区的成本高，容量小，一般仅用于对速度要求非常高的场合（比如存储器管理中的联想寄存器）<br>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织好这些缓冲区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">缓冲区作用 --&gt; 缓解CPU和UI设备之间速度不匹配的矛盾 &amp; 减少CPU中断频率 &amp; 解决数据粒度不匹配的问题 &amp; 提高CPU和IO设备之间的并行性</span><br></pre></td></tr></table></figure><ol><li>缓解CPU和IO设备速度不匹配矛盾<br>CPU读写数据到缓冲区（很快），然后IO设备从缓冲区拿数据或放数据（比较慢）<br>设置了缓冲区后，CPU可以将要进行IO的数据放入缓冲区后就执行其他任务，如果不设置缓冲区则CPU需要等待IO设备完成IO才能执行其他任务</li><li>减少CPU中断频率<br>仅当缓冲区满或者空时才发生中断</li><li>解决数据粒度不匹配问题<br>比如：输出进程每次可以生成一块数据，但IO设备每次只能输出一个字符</li></ol><h2 id="缓冲区管理策略">缓冲区管理策略</h2><p>缓冲区特点：<br>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；<br>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满后才能从缓冲区把数据传出；</p><h3 id="单缓冲">单缓冲</h3><p>假设用户进程请求某种块设备读入若干块的数据，若采用单缓冲策略，操作系统会在主存为其分配一个缓冲区（若题目没有特别说明，一个缓冲区大小就是一个块）；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528104439.png" alt="Pasted image 20240528104439"><br>在“单缓冲”中，一般假设初始状态为工作区满，缓冲区空；</p><p><strong>采用单缓冲策略，处理一块数据平均耗时 Max(C, T) + M</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528104644.png" alt="Pasted image 20240528104644"></p><h3 id="双缓冲">双缓冲</h3><p>假设用户进程请求某种块设备读入若干块数据，若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区；<br>双缓冲题目中，假设初始状态为：一个缓冲区为空，一个缓冲区为满，工作区为空<br><strong>当T &lt; C + M:</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528105212.png" alt="Pasted image 20240528105212"></p><p><strong>当T &gt; C + M:</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528105314.png" alt="Pasted image 20240528105314"></p><p><strong>结论：</strong><br>采用双缓冲策略，处理一个数据块的平均耗时为Max(T, C+M)</p><h3 id="循环缓冲区">循环缓冲区</h3><p>将多个大小相等的缓冲区链接成一个循环队列；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528105810.png" alt="Pasted image 20240528105810"></p><h3 id="缓冲池">缓冲池</h3><p>缓冲池实际上是由一系列缓冲区组成的；<br>缓冲池中的缓冲区可以按使用状况分为：</p><ol><li>空缓冲队列</li><li>装满输入数据的缓冲队列（输入队列）</li><li>装满输出数据的缓冲队列（输出队列）<br>根据一个缓冲区在实际运算扮演的角色功能不同，又设置了四种工作缓冲区：</li><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区<br><strong>缓冲池工作过程见视频19:55-末尾</strong></li></ol><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=70156862&bvid=BV1YE411D7nH&cid=1103550498&p=79" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height:430px; max-width:100%"></iframe><h2 id="单-双缓冲在通信时的区别">单/双缓冲在通信时的区别</h2><h3 id="两个通信机器只设置单缓冲区">两个通信机器只设置单缓冲区</h3><p>任何时刻只能实现数据的单向传输<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528105633.png" alt="Pasted image 20240528105633"></p><h3 id="两个通信机器设置双缓冲区">两个通信机器设置双缓冲区</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528105711.png" alt="Pasted image 20240528105711"></p><h1>磁盘的结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">磁盘的结构 --&gt; 1[&quot;磁盘、磁道、扇区 的概念&quot;] &amp; 如何在磁盘中读写数据 &amp; 2[&quot;盘面、柱面的概念&quot;] &amp; 磁盘的物理地址 &amp; 磁盘的分类</span><br></pre></td></tr></table></figure><h2 id="磁盘、磁道、扇区">磁盘、磁道、扇区</h2><p>磁盘的盘面被划分成一个个磁道，这样的一个圈就是一个磁道；一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量是相同的；<br>最内侧磁道上的扇区面积最小，但是同时各个扇区存放的数据量是一样的，所以最内侧扇区的数据密度是最大的；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528230426.png" alt="Pasted image 20240528230426"></p><h3 id="如何在磁盘中读写数据">如何在磁盘中读写数据</h3><p>需要把“磁头”移动到想要读写的扇区所在的磁道，磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读写操作；</p><h3 id="磁盘的物理地址">磁盘的物理地址</h3><p>可以用（柱面号、盘面号、扇区号）来定位任意一个“磁盘块”。<br>为什么是这样一个三元组顺序呢？为什么柱面号一定要在前，盘面号一定要在后呢？<br>后面减少磁盘等待时间会说明这个问题；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240528230958.png" alt="Pasted image 20240528230958"><br>读取数据的步骤：</p><ol><li>根据“柱面号”移动磁臂，让磁头指向指定柱面；</li><li>激活指定盘面对应的磁头；</li><li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读写；</li></ol><h3 id="一次磁盘读写操作需要的时间">一次磁盘读写操作需要的时间</h3><ol><li>寻找时间Ts：在读写数据前，将磁头移动到指定磁道所花的时间<br>移动磁头臂式需要时间的，假设为s<br>移动磁头也需要时间，假设磁头匀速移动，每跨越一个磁道耗时m，总共需要跨越n条磁道<br>则<strong>寻道时间</strong>：Ts = s + m*n</li><li>延迟时间Tr：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位：转/秒或转/分），则平均所需要的延迟时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>R</mi></msub><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>r</mi></mrow><annotation encoding="application/x-tex">T_R = \frac{1}{2} r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mi>r</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 就是转一圈需要的时间，找到目标扇区平均需要转半圈，因此再乘以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>传输时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从磁盘读取出或者向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读写的字节数为b，每个磁道上的字节数为N，则传输时间为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>r</mi></mfrac><mo>∗</mo><mfrac><mi>b</mi><mi>N</mi></mfrac><mo>=</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_t = \frac{1}{r} * \frac{b}{N} = \frac{b}{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br>每个磁道可以存N个字节数据，因此b个字节数据需要b/N个磁道才能存储；而读写一个磁道所需要的时间刚好是转一圈所需要的时间1/r；</li><li>总的平均存取时间：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub><mo>=</mo><msub><mi>T</mi><mi>s</mi></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>r</mi><mo>+</mo><mfrac><mi>b</mi><mrow><mi>r</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">T_a = T_s + \frac{1}{2}r + \frac{b}{rN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><strong>由于延迟时间和传输时间都是硬件相关的，无法从软件上进行改善，所以我们主要通过软件来减少寻道时间，提高读写效率</strong></li></ol><h3 id="磁盘调度算法">磁盘调度算法</h3><ol><li>先来先服务算法<br>优点：公平，如果请求访问的磁道比较集中的话，算法性能还算过得去<br>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间很长；</li><li>最短寻找时间优先算法<br>SSTF算法会优先处理磁道是与当前磁头最近的磁道，可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短；<br>优点：性能较好，平均寻道时间短<br>缺点：可能产生“饥饿”现象</li><li>扫描算法/电梯算法<br>SSTF算法产生饥饿的主要原因在于：磁头有可能在一个小区域内来回地移动，为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才往外移动。<br>这就是扫描算法，由于磁头移动的方式很像电梯，因此也叫电梯算法。<br>优点：性能好，平均寻道时间短，不会产生饥饿现象<br>缺点：只有到达最边上的磁道时才能改变磁头移动的方向；对于各个位置的磁道响应频率不平均</li><li>LOOK调度算法（改善扫描算法的“磁头一路向北”的缺点）<br>扫描算法中，只有到达最边上的磁道时才能改变磁头的移动方向，事实上处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK调度算法解决了这个问题，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头的移动方向；</li><li>C-SCAN循环扫描算法（改善扫描算法的磁道响应不均的问题）<br>SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题，规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而<strong>返回时直接快速移动至起始端而不处理任何请求</strong>；</li><li>C-LOOK算法（同时优化扫描算法的两个缺点）<br>综合LOOK和C-SCAN算法的特点；</li></ol><p>如果没有特别说明，SCAN算法就是LOOK算法，CSCAN算法指的是CLOOK算法</p><h3 id="减少磁盘延迟时间的方法">减少磁盘延迟时间的方法</h3><p>由于磁头读取一个扇区数据后需要一小段的处理时间，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区可能需要很长的“延迟时间”；</p><h4 id="交替编号策略">交替编号策略</h4><p>可以采用交替编号的策略，让逻辑相邻的扇区在物理上有一定的间隔时间；</p><h4 id="磁盘的地址结构">磁盘的地址结构</h4><p>磁盘的物理地址是按照（柱面号、盘面号、扇区号）来编址的，而不是（盘面号、柱面号、扇区号）<br>原因：<br>假设是（盘面号、柱面号、扇区号），当读完扇区内容后，需要去到下一个柱面读取数据，由于是不同柱面，所以需要移动磁头；<br>假设是（柱面号、盘面号、扇区号），当读完扇区内容后，只需要激活不同盘面的磁头即可；</p><h4 id="错位命名">错位命名</h4><p>这里主要指的是不同盘面对应位置的扇区编号应该错位；<br>原因：读取完一个扇区后，需要激活下一个盘面的磁头继续读取数据，但是我们知道读完扇区后还需要一段时间处理数据，并不能马上读取内容，所以此时及时激活了下一个盘面的磁头，也无法读取那个扇区的数据，只能等到闪盘再转一圈；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240529001946.png" alt="Pasted image 20240529001946"></p><h2 id="磁盘管理">磁盘管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">磁盘管理 --&gt; 磁盘初始化 &amp; 引导块 &amp; 坏块的管理</span><br></pre></td></tr></table></figure><h3 id="磁盘初始化">磁盘初始化</h3><p>下面介绍磁盘初始化的过程：</p><ol><li>进行低级格式化（物理格式化），将磁盘各个磁道划分为扇区；一个扇区可以分为头、数据区域（如512B大小）、尾三个部分；管理扇区所需要的各种数据结构一般存在头、尾两个部分，包括扇区校验码（奇偶校验、CRC循环冗余校验等）</li><li>将磁盘分区，每个分区由若干个柱面组成（windows操作系统中则分区为C盘、D盘、E盘）</li><li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间所用的数据结构（位示图、空闲分区表）</li></ol><h3 id="磁盘引导块">磁盘引导块</h3><p>计算机开机的时候需要进行一系列初始化的工作，这些初始化工作是通过初始化程序（自举程序）完成的；<br>初始化程序可以放在ROM当中（只读存储器），ROM中的数据子啊出厂时就写入了，并且以后不能再修改，ROM一般是出厂时就集成在主板上的；<br>万一自举程序需要更新的话将会很不方便，因为ROM的数据无法更改；</p><p>解决方案：<br>在ROM中存放很小的“自举装入程序”，完成的自举程序会放在磁盘的启动快（或者交引导块/启动分区上），启动块位于磁盘的固定位置；<br><strong>拥有启动分区的磁盘被称为启动磁盘或系统磁盘</strong>。</p><h3 id="坏块管理">坏块管理</h3><p>对于简单的磁盘，可以在逻辑格式化的时候对整个磁盘进行坏块检查，表明哪些扇区使坏扇区，比如在FAT表上表明（这种方式，坏块对操作系统不透明）</p><p>扇区备用：<br>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表，磁盘出厂前会进行低级格式化（物理格式化）时就将坏块链表进行初始化；会保留一些“备用扇区”，用于替换坏块；</p><h1>期末题型</h1><p>填空 2*10<br>选择 2*10<br>简答题 4*8<br>应用题 3道题，28分</p><h3 id="重点">重点</h3><h4 id="第一章">第一章</h4><ol><li>1.2操作系统的形成和发展</li><li>进程的概念，进程状态的概念、转换条件</li></ol><h4 id="第二章">第二章</h4><p>重点是2.6和2.7，进程互斥和同步，2.8不考，2.9进程通信概念要掌握</p><ol><li>线程的定义</li><li>PV操作，信号量机制</li></ol><h4 id="第三章">第三章</h4><p>作业管理调度算法<br>周转时间、平均周转时间的计算<br>3.2.4不考</p><p>3.4操作系统跟用户的接口：接口类型是什么？等概念性的内容</p><h4 id="第四章（重点）">第四章（重点）</h4><p>4.7 虚拟存储是重点：<br>什么是虚拟存储？虚拟存储的扩展。<br>页面置换算法P146<br>缺页中断率，缺页中断P140-153<br>4.2 全部都是重点<br>4.3.3 可变分区存储管理，重点<br>4.4 页式存储管理，4.4.1重点<br>4.5 段式存储管理，4.5.1重点</p><p>作业一定要复习</p><h4 id="第五章">第五章</h4><p>5.2.2 IO控制方式是重点<br>5.5 磁盘管理是重点！</p><p>作业：</p><ol><li>第五章第八第九题</li></ol><h4 id="第六章">第六章</h4><p>6.3 目录管理</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试技巧</title>
      <link href="/2024/04/29/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2024/04/29/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>UNIX、like-UNIX调试器；</p><h2 id="gdb的使用和退出">gdb的使用和退出</h2><h3 id="gdb的启动">gdb的启动</h3><table><thead><tr><th>操作</th><th>意义</th></tr></thead><tbody><tr><td>gdb filename(可执行程序) ==程序无参数==</td><td>gdb装载filename启动调试</td></tr><tr><td>gdb --args filename args ==程序带参数==</td><td>需要调试带参数的文件时使用</td></tr><tr><td>gdb进入，然后set args</td><td>需要参数的文件的gdb调试第二种使用方式</td></tr><tr><td>gdb -p PID</td><td>gdb进入已经在运行的系统中的程序 （一旦连上正在运行的程序，就会把先把该程序停止）</td></tr><tr><td>quit</td><td>退出当前gdb调试</td></tr></tbody></table><h3 id="断点">断点</h3><table><thead><tr><th>操作</th><th>意义</th></tr></thead><tbody><tr><td>b main</td><td>在main函数打断点</td></tr><tr><td>b function</td><td>在某个函数打个断点（==C++程序要在fucntion前面加上类域==）</td></tr><tr><td>b file_Path:13</td><td>在file_Path(文件有效路径)文件的13行打断点</td></tr><tr><td>l/list</td><td>终端展示当前断点前后部分代码</td></tr><tr><td>l/list n/-n</td><td>终端展示当前断点后n行/前n行代码（多次按list会继续往下展示） 如：list -3、list 3</td></tr><tr><td>info breakpoint</td><td>查看断点位置</td></tr><tr><td>delete n</td><td>删除指定断点（要先info查看一下编号） 比如 delete 3</td></tr><tr><td>delete</td><td>删除全部断点（会有确认删除提示）</td></tr></tbody></table><h3 id="运行-单步执行-跳跃执行">运行/单步执行/跳跃执行</h3><p>record可以反向调试，但是每一步都会被压入堆栈，有时候会浪费堆栈空间；所以一般不用了要赶紧stop掉，否则调试可能会非常慢；</p><table><thead><tr><th>操作</th><th>意义</th></tr></thead><tbody><tr><td>run/r ==tips: run &lt; data.txt==</td><td>运行程序，也可以输入文件debug，超好用</td></tr><tr><td>n</td><td>next的意思，不进入函数的单步执行</td></tr><tr><td>ni</td><td>按机器指令单步执行（不进入函数） （有时候对于自己代码的优劣也可以看执行单个语句机器指令用了多少次）</td></tr><tr><td>s</td><td>step的意思，单步执行，会进入函数debug</td></tr><tr><td>si</td><td>机器指令单步执行（进入函数）</td></tr><tr><td>c</td><td>continue的意思，继续执行</td></tr><tr><td>==record==</td><td>在当前执行完位置开始标记，便于后续一步一步回来 （但是对于堆栈较大等情况用不了）==record允许我们逆向调试==</td></tr><tr><td>==record stop==</td><td>停止标记</td></tr><tr><td>==reverse-next==</td><td>与record联合使用，返回上一步</td></tr><tr><td>==reverse-任何命令(任何正向调试命令，比如list、ni、s)==</td><td>反向的效果，回到离当前最近的之前那个操作</td></tr><tr><td>set exec-direction reverse</td><td>设置程序方向、告诉gdb，下面都是反向执行 于是后面n代表reverse-n</td></tr><tr><td>finish</td><td>进入一个函数之后，看完部分内容想跳出去继续调试 finish会执行完当前堆栈剩余部分并达到跳出函数的效果</td></tr></tbody></table><h3 id="堆栈">堆栈</h3><table><thead><tr><th>操作</th><th>意义</th></tr></thead><tbody><tr><td>bt</td><td>查看堆栈</td></tr><tr><td>f n</td><td>f 1表示跳到第1个堆栈，这样可以跳到对应的堆栈</td></tr></tbody></table><h3 id="变量">变量</h3><table><thead><tr><th>操作</th><th>意义</th></tr></thead><tbody><tr><td>p varname</td><td>打印当前堆栈中变量名为varname的值 打印结果：地址 + 值</td></tr><tr><td>info locals</td><td>打印本地变量（当前堆栈）</td></tr><tr><td>info variables</td><td>查看全局变量</td></tr><tr><td>watch var</td><td>监视变量，如果该变量改变了会通知</td></tr><tr><td>x &amp;varname</td><td>查看某个变量的内存地址（16进制显示）</td></tr><tr><td>info watchpoints</td><td>查看当前正在监视的变量</td></tr></tbody></table><h2 id="进阶使用">进阶使用</h2><p>反向编译调试、更改系统动态库、调试系统正在运行的程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -x <span class="comment">#查看当前进程  </span></span><br><span class="line"> gdb -p PID  <span class="comment">#可链接当前运行序号为PID的程序  </span></span><br><span class="line"> •   <span class="comment">#可以sudo权限进行调试</span></span><br></pre></td></tr></table></figure><p></p><p>==函数退出的时候先退出gdb，否则无法退出==</p><p>多线程调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread apply all bt <span class="comment">#查看多线程的堆栈（会打印当前进程的所有线程的堆栈打印出来）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】6. CLIP模型</title>
      <link href="/2024/04/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%916.%20CLIP%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/04/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%916.%20CLIP%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>CLIP模型</h1><p>Contrastive Language-Image Pre-Training（利用文本的监督信号训练一个迁移能力强的视觉模型）</p><h2 id="模型训练方法">模型训练方法</h2><h3 id="数据类型">数据类型</h3><p>图文对：每个图片有对应的文本</p><ul><li>图像</li><li>对应文本</li></ul><h3 id="训练模型">训练模型</h3><h4 id="特征提取-Encoder">特征提取(Encoder)</h4><ol><li>图像特征提取（CNN、ResNet…）<br>把图像转化成向量，这个向量就是这个图像的对应的特征（特征个数一般与像素点个数相关吧？）</li><li>文本特征提取（Transformer等）——&gt; 词向量维度：50-300维<br>词向量的每一维度是有空间意义的，但是难以解释每一个维度的意义，只是相当于计算机可识别的编码。<br>以个人的理解来看：<ul><li>我们需要识别一段文本，我们虽然不知道他的具体特征是什么，但是我们可以设置这段文本是用多少维特征编码唯一识别。每一个维度上的值共同决定了该文本的唯一性，该唯一性由计算机来识别，所以我们并不需要知道每一个维度是什么。</li><li>所以文本的向量化也可以说是文本的编码化，而由于文本的上下文性质，文本的编码有位置上的相关关系，所以可以通过空间相似的思维（KNN）来计算文本匹配概率，从而达到泛化的效果。</li><li>我们基于文本编码的模型，可以以神经网络的算法思路，训练出一个文本输入，特征向量输出的神经网络模型。训练出的模型，输入任意一段文本，都可以得到对应的特征输出，唯一标识这段文本。</li><li>文本的负采样一般是5个；（Gensim的默认参数，可能是大量实验得出来的）</li></ul></li><li>训练策略——对比学习<br>预测相似度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】3. SQL语言</title>
      <link href="/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%913.%20SQL%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%913.%20SQL%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>SQL语言概览</h1><p>SQL语言有以下几部分：</p><ol><li>DDL（Data-definition language）数据定义语言</li><li>DML（Data-mainpulation Language）数据操作语言</li><li>DCL（Data-control Language）数据控制语言</li></ol><h2 id="基本类型">基本类型</h2><p>char (n)      ：长度固定为n的字符串<br>varchar (n)：长度可变，最大长度为n的字符串，<br>int：整数<br>smallint：短整数<br>numeric (p, q)：总共不多于p位，小数点右边不多于q位的定点数<br>real：浮点数<br>float(n)：精度至少为n位的浮点数<br>date：日期 (年, 月, 日)<br>time：时间 (小时, 分, 秒)<br>timetamp：日期+时间<br>null：每种类型都可以包含一个特殊值，即空值。可以申明属性值不为空，即禁止加入空值</p><h1>SQL语法</h1><h2 id="SQL语法框架">SQL语法框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">SQL功能和语句 --&gt; 数据定义功能 &amp; 数据查询功能 &amp; 数据修改功能 &amp; 数据控制功能</span><br><span class="line">数据定义功能 --&gt; Create &amp; Alter &amp; Drop</span><br><span class="line">数据查询功能 --&gt; Select</span><br><span class="line">数据修改功能 --&gt; Insert &amp; Delete &amp; Update</span><br></pre></td></tr></table></figure><h2 id="SQL查询">SQL查询</h2><h3 id="SQL查询的基本结构">SQL查询的基本结构</h3><p>注意：SQL语言不区分字母大小写，因此可以使用大写或者小写字母命名表、属性等；<br>SQL查询由3个子句构成：select，from，where<br>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">FROM</span> r1,r2,...,rm</span><br><span class="line"><span class="keyword">WHERE</span> P</span><br></pre></td></tr></table></figure><p>该查询语句等价于关系代数表达式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mo>∏</mo><msub><mtext> </mtext><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>σ</mi><mi>P</mi></msub><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo>×</mo><msub><mi>r</mi><mn>2</mn></msub><mo>×</mo><msub><mi>r</mi><mn>3</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>r</mi><mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\prod \ _{A_1,A_2,...,A_n}(\sigma_{P}(r_1 \times r_2 \times r_3 \times ... \times r_m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></p><h3 id="三件套子句">三件套子句</h3><p>select，where, from子句的执行顺序：</p><ol><li>from</li><li>where</li><li>select</li></ol><h3 id="select子句">select子句</h3><p>例如：找出所有教师的名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ol><li>SQL允许在关系以及SQL表达式结果中出现重复的元组，<strong>默认情况下就是all</strong><ul><li>若要强行去除重复，可以在select后面加入关键字<strong>distinct</strong></li><li>例如，查询instructor关系中所有的系名，并去除重复行/元组</li></ul></li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ol start="2"><li>SQL也允许我们使用关键字all来显式致命不去除重复行/元组</li><li>表示“所有属性”，使用*表示所有属性</li><li>可以带含有加减乘除等运算符的算数表达式，运算对象可以是常熟或者元组的属性；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID,name,salary<span class="operator">*</span><span class="number">1.05</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><h3 id="where子句">where子句</h3><p>where子句允许我们只选出那些在from子句的结果关系中满足特定谓词的元组；<br>例如：找出所有在Computer Science系且工资超过7000美元的教师的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name<span class="operator">=</span><span class="string">&#x27;Comp.Sci.&#x27;</span> <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">7000</span>;</span><br></pre></td></tr></table></figure><p>where子句使用的运算符：<br>逻辑运算：</p><ul><li>and</li><li>or</li><li>not<br>比较运算：</li><li><blockquote></blockquote></li><li>&lt;</li><li>=</li><li>&lt;&gt;  不等于</li><li><blockquote><p>=</p></blockquote></li><li>&lt;=<br>范围运算：</li><li>between 下界 and 上界<br>集合运算：</li><li>in 集合</li><li>not in 集合<br>匹配运算：<br>匹配串种，%和_是通配符，\是转义字符；</li><li>like 匹配串(一个可能含特殊字符的字符串)</li><li>%，匹配任意子串</li><li>_，匹配任意一个字符</li></ul><h3 id="from子句">from子句</h3><p>from子句式一个查询求值中需要访问的关系列表，通过from子句定义了一个在该句子中所列出关系上的笛卡尔积；<br>例如：找出关系instructor和teaches的笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor,teaches;</span><br></pre></td></tr></table></figure><p>from子句的命名：<br>由于先执行from子句，所以关系重命名后，后面子句的前缀要用心的关系命名；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240429001422.png" alt="Pasted image 20240429001422"></p><h3 id="更名运算">更名运算</h3><p>SQL提供可为关系和属性重命名的机制，即使用as子句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">old_name <span class="keyword">as</span> new_name</span><br></pre></td></tr></table></figure><h3 id="排列元组的显示次序">排列元组的显示次序</h3><p>SQL为用户提供了一些对关系中元组显式次序的控制。<br>order by子句就是可以让查询结果中元组按排列顺序显示；<br>例：按字母顺序列出在Physics系的所有教师</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name<span class="operator">=</span><span class="string">&#x27;Physics&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name;</span><br></pre></td></tr></table></figure><ul><li>降序，用desc参数；升序，用asc表示；(默认情况下，升序)<br>例：按照salary的降序列出整个instructor关系，如果有几位教师的工资相同，就将他们的姓名升序排序；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>, name <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h3 id="集合运算">集合运算</h3><p>SQL作用在关系上的union、intersect和except运算对应于数学集合论中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo><mo>∩</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">\cup \cap -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>运算；<br>SQL的集合运算会自动去除重复；<br>如果想保留重复，必须用union all、intersect all和except all；<br>假设一个元组在关系R中重复出现了m次，在关系S中重复出现了n次，那么这个元组将会重复出现：</p><ul><li>R union all S中，重复m+n</li><li>R intersect all S中，重复min(m, n)</li><li>R except all S中，重复max(0,m-n)<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240429003227.png" alt="Pasted image 20240429003227"></li></ul><h3 id="聚集函数">聚集函数</h3><p>聚集函数是以值的一个集合（集或者多重集）为输入，返回单个值的函数。<br>SQL提供了五个固有聚集函数：</p><ul><li>平均值：avg</li><li>最小值：min</li><li>最大值：max</li><li>总和：sum</li><li>计数：count<br>其中sum和avg的输入必须是数字集合，但其他运算符还可以作用在非数字数据类型的集合上，如字符串；<br>==<strong>出现统计词的where一定错的，一定要放在having里面？</strong>==</li></ul><h3 id="group-by子句和having子句">group by子句和having子句</h3><h4 id="group-by子句">group by子句</h4><p>对集合按属性进行分组；<br>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1,A1,...,An</span><br><span class="line"><span class="keyword">from</span> R1,R2,...,Rm</span><br><span class="line">[<span class="keyword">where</span> P]</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 属性<span class="number">1</span>,属性<span class="number">2</span>,...</span><br></pre></td></tr></table></figure><p>对where子句筛选之后的集合按照属性1，属性2…分组；</p><ul><li><strong>此时select子句的作用发生变化：统计分组</strong><ul><li>把group by分好的每一个分组，统计为结果中的一个元组</li><li>有group by，则在select子句中出现的属性只能是：<br><strong>分组属性；</strong><br><strong>聚集属性（任意属性）；</strong><br>以上两种属性组成的表达式（构造新属性）；</li></ul></li></ul><h4 id="Group-by子句的总结">Group by子句的总结</h4><p>出现统计词（平均、最高、…）的问题，就要考虑Group By</p><ul><li>如果还有“每…”等分组词，那么需要Group By相应的属性</li><li>如果没有，那么Group By无属性，这样的Group By不用写，但要在select中统计出来；</li></ul><h4 id="having子句">having子句</h4><p>作用：group by分好组后，筛选满足条件的分组；<br>筛选条件只能是：</p><ul><li>分组属性，也就是group by后面的属性</li><li>聚集函数（任意函数）<br>==having子句只能配合group by子句使用，不能单独出现==</li></ul><h4 id="比较having和where">比较having和where</h4><p>如果有多个条件，带统计词的都放在having，不带统计词的都放在where子句；</p><table><thead><tr><th>Having条件</th><th>WHERE条件</th></tr></thead><tbody><tr><td>带统计词，比如“平均，最高，总和…</td><td>不带统计词，且不能出现统计词</td></tr><tr><td>例:  平均成绩大于85</td><td>例：成绩大于85</td></tr><tr><td>Having avg(成绩)&gt;85</td><td>Where 成绩&gt;85</td></tr><tr><td>分组后才能统计，所以必须跟在Group by后面。</td><td>不用分组，直接单个元组就可判断。</td></tr></tbody></table><h3 id="Order-By子句">Order By子句</h3><p>作用：在select子句得出结果之后，对结果中的元组进行排序<br>先按属性1进行排序。升序（asc）或者降序（desc），缺省是升序；属性1相等时，再按照属性2的值升序或降序…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> A1,A2,A3,...</span><br><span class="line"><span class="keyword">FROM</span> R1,R2,R3,...</span><br><span class="line"><span class="keyword">WHERE</span> P</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 属性<span class="number">1</span>，属性<span class="number">2</span>，...</span><br><span class="line"><span class="keyword">HAVING</span> 分组限定条件Q</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 属性<span class="number">1</span>[<span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>]</span><br><span class="line"> 属性<span class="number">2</span>[<span class="keyword">asc</span> <span class="operator">|</span> <span class="keyword">desc</span>]</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h3 id="总结SQL语句中的运算“次序”">总结SQL语句中的运算“次序”</h3><p>From (笛卡儿积) → [Where (选择)] → [Group By (分组)] → [Having (筛选分组)] → Select (投影, 或统计) → [Order By (结果排序)]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span>　  A1 , A2 , … , An</span><br><span class="line"><span class="keyword">From</span>　　R1 , R2 , … , Rm</span><br><span class="line">[<span class="keyword">Where</span>　  P  ]</span><br><span class="line">[<span class="keyword">Group</span>  <span class="keyword">By</span>  属性<span class="number">1</span>, 属性<span class="number">2</span>, …</span><br><span class="line">  [ <span class="keyword">Having</span>  分组限定条件Q ] ]</span><br><span class="line">[<span class="keyword">Order</span>  <span class="keyword">By</span>  属性<span class="number">1</span> [<span class="keyword">asc</span>｜<span class="keyword">desc</span>],</span><br><span class="line">属性<span class="number">2</span> [<span class="keyword">asc</span>｜<span class="keyword">desc</span>], …  ]</span><br></pre></td></tr></table></figure><h3 id="SQL语句中的嵌套子查询">SQL语句中的嵌套子查询</h3><p>两种类型：</p><ol><li>出现在父查询的From子句中：用来构造一个新关系，又叫派生关系</li><li>出现在父查询的Where子句中：用来构造条件（的一部分)<br>格式：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span>   … ,  (<span class="keyword">Select</span>子查询)  (<span class="keyword">as</span>) 关系名… , </span><br><span class="line"><span class="keyword">From</span>   … ,  (<span class="keyword">Select</span>子查询)  (<span class="keyword">as</span>) 关系名(属性<span class="number">1</span>, 属性<span class="number">2</span>…)</span><br></pre></td></tr></table></figure><p><strong>新关系必须命名，其属性也可以重命名。</strong></p><h4 id="where子句中用子查询构造条件">where子句中用子查询构造条件</h4><p><strong>条件1：</strong> 判定一个值(比如属性值)是否在查询结果中<br>格式（in 运算符）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A [<span class="keyword">not</span>] <span class="keyword">in</span> 子查询</span><br></pre></td></tr></table></figure><p>意义</p><ul><li>A是否出现在子查询的结果(多个值)中? (出现为真,否则为假)<br>要求</li><li>A往往是一个(属性或表达式)值，此时子查询要相当于一个值的集合。即子查询可以有多个元组，但只能有一个属性</li><li>元组只有一个属性时，相当于一个单值，子查询的结果是一个这样的元组集合，即多个单值的集合</li></ul><p><strong>条件2：</strong> 将一个值（比如属性）与查询结果作比较<br>格式：some | all 运算</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A   (比较运算, <span class="operator">&gt;</span>, <span class="operator">&lt;</span>, <span class="operator">=</span>,…)  <span class="keyword">some</span><span class="operator">|</span><span class="keyword">all</span> (子查询)</span><br></pre></td></tr></table></figure><p>意义</p><ul><li>some:  A与子查询结果中的一个值满足比较时为真</li><li>all     :  A与子查询结果中的所有值都满足比较时为真<br>要求</li><li>A是一个值，而后面的子查询也要相当于一个值的集合。即子查询可以有多个元组，但只能有一个属性</li></ul><p><strong>条件3:</strong> 判定子查询结果是否存在(至少一条)记录，如果子查询结果为空则返回false<br>格式（exist运算符）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">not</span>] <span class="keyword">exists</span> (子查询)</span><br></pre></td></tr></table></figure><p>意义</p><ul><li>子查询结果存在 (至少一条)记录<br>要点</li><li>子查询的结果关系，不要求只有一个属性，可多个（exists是对记录数的判断，和属性无关）</li><li>子查询可引用父查询关系的属性(此时最好标明关系前缀)，作为子查询的“参数”。这一点对于其它类型（in, some, all）的子查询也是适用的</li></ul><h3 id="连接语句">连接语句</h3><p><strong>连接关系：</strong><br>在From子句中的两个相邻关系之间，可以是一个逗号 —— 表示做笛卡尔积运算，无条件的连接; 也可以是一个连接运算 —— 表示按指定条件进行连接。<br><strong>连接运算的类型：</strong></p><ol><li>内连接：<br>格式：A  [inner] join B on 条件 （A, B是关系）<br>内连接的结果不包含失配元组：因不满足连接条件，无法和其它元组相连接的元组。</li><li>左外连接<br>格式： A  left  [outer]  join B on 条件<br>结果包含左边关系的失配元组</li><li>右外连接<br>格式： A  right  [outer]  join B on 条件<br>结果包含右边关系的失配元组</li><li>全外连接<br>格式： A  full  [outer]  join B on 条件<br>结果包含两边关系的失配元组<br>注: 通常在From中用逗号分隔关系，然后在Where中列出连接关系的条件。这样的做法相当于内连接运算，即不含失配</li></ol><p>例题：<br>下面的例子，如果存在一个学生宿舍只有自己，则会失配；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240429173510.png" alt="Pasted image 20240429173510"></p><h4 id="多个表的连接">多个表的连接</h4><p>框架：关系A  ？ join B on 条件1<br>？ join C on 条件2<br>表示A和B按条件1链接后，得到的结果关系再与C连接。</p><h2 id="空值NULL">空值NULL</h2><p>元组的某些属性可以取空值，空值表示两种情况：不存在或值未知；<br><strong>注意：数学上为永真的逻辑，在数据库中不一定永真</strong><br>比如这个就不能筛选出王小明和黄大鹏。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240416195738.png" alt="Pasted image 20240416195738"></p><h3 id="聚集函数忽略空值">聚集函数忽略空值</h3><p>这里计算年龄的平均值的时候，就忽略了王小明的年龄<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240416195902.png" alt="Pasted image 20240416195902"></p><h3 id="统计函数">统计函数</h3><p>统计函数忽略空值，并且需要注意的一点就是：有distinct和无distinct的区别！！<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240416200933.png" alt="Pasted image 20240416200933"></p><h3 id="判断空值">判断空值</h3><p>A is Null是判断是否为空值；<br>如果写成A=Null，不能判断为空值，因为NULL = NULL为unkown；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240416201419.png" alt="Pasted image 20240416201419"></p><h2 id="SQL操作（增删查改）">SQL操作（增删查改）</h2><h3 id="插入操作">插入操作</h3><p>两种语法：</p><ul><li>insert into 表名 [字段1， 字段2， …] values (值1，值2，…)  ——&gt; 插入一条新纪录</li><li>insert into 表名 [字段1， 字段2， …] select 字段S1，字段S2，…  ——&gt; 插入多条记录</li></ul><h4 id="举例">举例</h4><p>插入<strong>一个</strong>新职工；<br>insert into 职员表（职工号，姓名，年龄） values(‘E05’, ‘张明’, 30)<br><strong>未指定的字段按照NULL处理</strong></p><h3 id="删除语句">删除语句</h3><p>语法：delete from 关系 [where 条件]<br>说明：</p><ul><li>从表中删除符合条件的元组，如果不写where条件语句，则删除全部元组（但表的结构、字段、主码等保留，只是删除元组而已）</li><li>一次只能删除一个关系中的元组，即使写多个关系，也只删除第一个关系</li><li>删除过程是等到所有满足条件的元组，然后作标记，然后再把所有带标记的元组删掉</li></ul><h3 id="更新操作">更新操作</h3><p>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 表达式<span class="number">1</span></span><br><span class="line">字段<span class="number">2</span> <span class="operator">=</span> 表达式<span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">where</span> 条件</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>在表中找到满足Where条件的 (没有就是全部)记录，然后更新 —— Set子句说明怎么更新记录：更新哪些字段，以及更新后的值（表达式的结果）</li><li>同样是全部找到符合条件的记录后，再一起更新。</li></ul><h1>视图</h1><p>视图的概念：一个命名，用查询从基本表中导出的虚拟表；<br>视图的本质：命名查询，真正存在，存储在数据库里的视图的名字和对应的查询（视图的定义）<br>视图的表象：“虚拟表”，这样的表逻辑上存在——对用户而言，与基本表无差别；但是物理上不存在——表中的数据平时并没有存储在数据库里，而是用到的时候才算出来；</p><h2 id="定义视图">定义视图</h2><h3 id="新建视图">新建视图</h3><p>代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>   <span class="keyword">view</span>   视图名          [( 属性名 &#123;, 属性名&#125; )] </span><br><span class="line"><span class="keyword">as</span>   ( <span class="keyword">Select</span>查询 )   [<span class="keyword">with</span>  <span class="keyword">check</span>  option]</span><br></pre></td></tr></table></figure><p>说明</p><ul><li>视图的属性可以显式命名，也可缺省取查询结果中的属性名（这个更推荐，要更名在select查询中更名）</li><li>with check option: 当对视图进行插入，更新时，要检查新元组是否满足视图对应查询的条件（出现在哪个子句?），否则拒绝</li></ul><h3 id="查询视图">查询视图</h3><p>用户可以像基本表一样(写Select语句)查询视图。</p><ul><li>系统收到这样的select查询后，必须转化(Why?)成对基本表的查询，方法是展开视图——用定义中的查询取代视图本身</li><li>如果展开一个视图后，（它定义中的）查询又还出现了其它视图，那么继续展开，直到没有任何视图为止<br><strong>转化的原因是视图物理上是不存在的，无法查询，所以要根据视图的逻辑去物理存储表中查询</strong></li></ul><h3 id="修改视图">修改视图</h3><p>用户可以像基本表一样(写Insert, Update, Delete语句)修改视图。</p><ul><li>系统收到这样的修改后，必须转化成对基本表修改。</li><li>这种转化有时能成功——视图可修改，有时失败——视图不可修改。因此我们说对视图的修改是受限的。</li><li>能否修改，取决于是否能够通过视图逆映射到基本表中的唯一元组！</li></ul><h4 id="不可修改的视图">不可修改的视图</h4><ol><li><strong>Select子句选出的属性不包含候选码</strong><br>基本表一条记录(有候选码) → 视图一条记录(无候选码)<br>因为缺少候选码，所以在逆映射时无法唯一定位原来的记录</li><li>select子句中使用distinct关码字<br>基本表多条记录 → 视图一条记录</li><li>有group by子句或出现聚集函数<br>基本表多条记录 → 视图一条记录</li><li>包含用表达式构造的新属性<br>F(基本表字段) → 视图字段（逆映射?）</li><li>From子句中列出多个关系<br>多个基本表的多条记录 → 视图的一条记录</li></ol><h3 id="物化视图">物化视图</h3><p>概念：在某些数据库系统中，允许将视图某一时刻的内容（当时的查询结果关系）真正存储起来，这样的“快照” 称为物化视图。</p><p><strong>物化视图 (vs 普通视图)</strong><br>优点：访问快，避免了每次计算(查询结果)的过程。<br>缺点：只反映基本表当时的查询结果，所以<strong>基本表变化后要考虑同步问题</strong>。</p><p><strong>适用场合：读多于写</strong><br>经常访问视图，每次重新计算的开销大。但基本表少变化，或者允许“滞后”更新视图的场合。</p><h2 id="疑问汇总">疑问汇总</h2><ul><li>[x] PPT第93页：所给答案的意思是王武参加了但他没参加</li><li>[ ] PPT第113页：是不是算错了平均数</li><li>[ ]</li></ul><h1>数据安全性和完整性</h1><p>三种非法：</p><ol><li>非法用户：黑客，未授权用户，进入数据库系统；</li><li>非法操作：已授权用户，执行超过权限的操作；</li><li>非法数据：合法用户合法操作，但是操作错误数据，比如负的年龄；</li></ol><p>安全性问题的提出的必要性：</p><ul><li>国家安全</li><li>金融安全</li><li>企业安全</li></ul><p>多层次的安全保护</p><ol><li>外部环境：防火防盗</li><li>网络</li><li>操作系统</li><li>数据库系统<br>基于课程重心，我们重点关注数据库系统安全层次的防护</li></ol><p>数据库安全保护技术</p><ol><li><p>基于视图的技术：<br>为了不同需求的用户打造不同的视图</p></li><li><p>基于访问控制的技术：<br>控制每一个用户对数据库的访问，都在实现允许的范围之内<br>实现：</p><ul><li>用户身份鉴别（口令、磁卡、指纹）</li><li><strong>用户权限管理</strong>（SQL，4.6）</li><li>用户权限管理（数据库运行时，安全性子系统完成）</li></ul></li><li><p>审计追踪技术<br>记录用户访问数据库的全过程（什么用户什么时间操作），以便回溯<br>比如，监控摄像</p></li><li><p>其他安全技术<br>数据库加密等等</p></li></ol><p>我们关注<strong>用户权限管理</strong>，第四章第六节；</p><h2 id="SQL用户权限管理">SQL用户权限管理</h2><h3 id="授予权限">授予权限</h3><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限[,,,...] <span class="keyword">on</span> 对象名(数据对象) <span class="keyword">to</span> 用户[,,,...] <span class="operator">|</span> public [<span class="keyword">with</span> <span class="keyword">grant</span> option]</span><br></pre></td></tr></table></figure><ul><li>public：所有用户都可以访问</li><li>with grant option：用户可以把自己获得的权限转授给他人</li></ul><p>权限类型<br>CREATE<br>SELECT<br>WHERE<br>INSERT<br>UPDATE<br>DELETE<br>以上都是执行同名SQL语句的权限<br>REFERENCE：<strong>针对表</strong>，表示可以引用该表的主码来定义（其他表）的外部码<br>ALL：所有权限</p><p><strong>数据对象</strong>类型：</p><ol><li><strong>SCHEMA</strong>：数据库模式，SQL的一个概念，和第一章的数据库模式概念不同，可以认为是一个小的数据库</li><li>TABLE：基本表</li><li>VIEW：视图</li><li>ATTRIBUTE：属性</li></ol><p>例子：<br>数据库系统管理人员DBA执行下面的语句，授权给教务员王；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">to</span> 教务员王 <span class="keyword">with</span> <span class="keyword">grant</span> option</span><br></pre></td></tr></table></figure><p>教务员王获得选修表的select, update权限，并且还可以<strong>把这个权限转授给其他用户</strong>（也就是可以执行上面的grant句子）；</p><p>用户教务员王执行如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>(姓名, 课程), <span class="keyword">update</span>(分数) <span class="keyword">on</span> 选修表 <span class="keyword">to</span> 辅导员李</span><br></pre></td></tr></table></figure><p>教务员王把对选修表上某些列的权限赋给用户辅导员李，但后者不能将这个权限转让给其他人；<br><strong>权限有大小之分，大的权限包含小的权限，拥有大的权限可以授予其中的部分权限</strong></p><h3 id="收回权限">收回权限</h3><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限[,,,...] <span class="keyword">on</span> 对象名 <span class="keyword">from</span> 用户[,,,...] <span class="operator">|</span> public [CASCADE<span class="operator">|</span>RESTRICT]</span><br></pre></td></tr></table></figure><p>CASCADE：级联式回收<br>RESTRICT：<strong>如果存在级联，则不收回权限</strong></p><p>例子：<br>DBA执行下面语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">update</span> <span class="keyword">on</span> 选修表 <span class="keyword">from</span> 教务员王 cascade</span><br></pre></td></tr></table></figure><p>则DBA用户收回用户教务员王堆选修表的更新权限，此前教务员王授予给辅导员李的相应权限也一并被收回；</p><p>如果把cascade改为restrict，则收回权限失败；</p><h3 id="禁止权限（难点）">禁止权限（难点）</h3><h4 id="对比">对比</h4><p>grant … to 用户</p><ul><li>授予正权限：使用户可以做相应的操作</li><li>特殊情况：A，B授予同一个用户同一个权限X，即该用户的权限有两个来源；此时该用户有两个X，当A收回该权限，此用户对应X消失，但他还拥有B给他的X，所以他仍然有权限；</li></ul><p>deny … to 用户</p><ul><li><strong>禁用（授予负）权限：使用户以后绝对不可以做相应的操作</strong></li><li>比如上面的例子，C禁止该用户的X权限，即给了用户一个-X，那么用户无法再做此权限的操作，即使之前A，B授予了“正权限X”；</li><li><strong>所以负权限大于正权限，只要有一个负权限，无论得到多少正权限都无法获得权限</strong></li></ul><p>revoke … from 用户</p><ul><li>收回，相当于取消此前授予的（正、负）权限；注意：取消禁止权限，也是通过revoke</li><li><strong>思考</strong>：如果B收回授予用户的正权限X，有什么效果？接下来C取消他授予的负权限（禁止权限）呢？<br>现在用户有两个X和一个-X，B收回后，用户有一个X和一个-X，仍然无法使用权限；<br>C撤销负权限后，用户有一个X，无-X，则拥有权限；</li></ul><p><strong>小结：一个用户无法使用权限的情况：1. 无权限；2. 被授予负权限；</strong></p><h2 id="角色机制">角色机制</h2><p>“角色”出现的必要性：<br>如果有一组用户，他们的权限相同或非常相近，那么设置一个角色代表这组用户，同意给角色授权，可以大大减少工作量；</p><p>角色的概念：</p><ol><li>角色就是一个用户集合</li><li>角色也是一个权限集合</li></ol><p>例子：<br>辅导员小王、小李、…想访问数据库里面的学生表；但只能允许他们查询和更新某些字段，比如年龄、宿舍。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role <span class="comment">--创建角色</span></span><br><span class="line"><span class="keyword">grant</span> 角色名 <span class="keyword">to</span> 用户 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--把用户拉入角色</span></span><br><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">to</span> 角色名 [<span class="keyword">with</span> <span class="keyword">grant</span> option] <span class="comment">--集合中每个用户以及以后得新用户都具有该权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--角色即可以出现在to前面，又可以出现在to后面，所以它即是权限集合，又是用户集合</span></span><br></pre></td></tr></table></figure><p><strong>角色即可以出现在to前面，又可以出现在to后面，所以它即是权限集合，又是用户集合</strong></p><p>思考：<br>如果所有辅导员权限不完全一致，比如某一个辅导员比其他辅导员权限<strong>多一点</strong>或<strong>少一点</strong>，那还可以应用角色吗？怎么处理？<br>多一点：按照用户赋给额外的权限<br>少一点：deny掉该用户的权限</p><h2 id="完整性约束">完整性约束</h2><p>概念：数据的正确性、有效性和相容性<br>正确的数据就是具有完整性的</p><p>完整性规则：</p><ul><li>为了保证完整性，数据所必须满足的约束条件；（又称完整性约束、完整性约束条件）</li><li>可以分为两类：<ol><li>静态条件：数据取值的条件；比如年龄大于等于0</li><li>动态约束：数据变化/修改数据的条件（新旧值的比较）<br>例如：工资.新值 &lt; 工资.旧值*1.2<br><strong>我们大多数讲完整性，都是在讲完整性规则</strong></li></ol></li></ul><p>完整性控制（实现完整性）：</p><ul><li>在数据库系统中，保证数据完整性，这一工作由<strong>DBMS完整性子系统完成</strong>（可能考选择题填空题）</li><li>围绕完整性规则进行，包括两方面：<ol><li>定义完整性规则（SQL，4.4）</li><li>检查完整性规则，并做处理<br>比如，在用户发出操作（insert、update等）后，检查修改数据后是否还满足完整性规则，如果不能则进行处理：报警、拒绝、调整</li></ol></li></ul><h3 id="关系模型的三种完整性概念">关系模型的三种完整性概念</h3><p>关系模型的三要素：</p><ul><li>关系</li><li>关系操作</li><li><strong>关系完整性</strong> ——&gt; 指的是完整性规则<ol><li>实体完整性规则</li><li>参照完整性规则</li><li>用户定义完整性规则</li></ol></li></ul><h4 id="实体完整性规则">实体完整性规则</h4><p>规则：关系中，元组的<strong>主码必须唯一不重复，且不能取空值</strong>；若主码由多个属性构成，每一个属性都不能取空值；<br>意义：现实世界实体可以相互区分，实体映射到元组后，通过主码来相互区分；</p><h4 id="参照完整性规则">参照完整性规则</h4><p>规则：<strong>外部码要么取空值，要么取一个存在的对应的主码值</strong>；<br>意义：外部码是用于反映联系；取空值，代表没有联系；取一个对应的主码值，表示外部码所在元组/实体和这个主码值所在元组/实体联系；</p><p>思考：创建表时，外部码中的属性应该设为什么类型？<br><strong>外部码的属性类型要严格等于主码字段类型</strong></p><h4 id="用户定义完整性">用户定义完整性</h4><p>规则：用户根据具体的应用环境定义<br>例如：</p><ol><li>分数的取值范围：0-100</li><li>性别只能：男、女、空</li><li>（上海）A股股东账号是“A+9位数字”<br>意义：</li><li>反映现实世界的真实属性取值</li><li>反映了程序编制的需求</li></ol><h4 id="什么会破坏完整性规则">什么会破坏完整性规则</h4><ol><li>显然查询操作不会破坏完整性，只有改变数据的修改操作才可能<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603185945.png" alt="Pasted image 20240603185945"></li></ol><h4 id="各种约束">各种约束</h4><h5 id="主码约束">主码约束</h5><ol><li>规则：主码值不允许为空，也不允许重复</li><li>定义：创建/修改表的语句中，用<strong>PRIMARY KEY</strong>声明主码的同时定义一个主码约束；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">读者编号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">借阅日期 <span class="type">date</span></span><br><span class="line"><span class="keyword">primary</span> key (书号, 借阅日期)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="外部码约束">外部码约束</h5><ol><li>规则：外部码要求取值要么空值要么取对应的主码值</li><li>定义：创建/修改表的语句中，用FOREIGN KEY声明外部码的同时，即定义一个外部码约束</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreign</span> key (外部码属性)</span><br><span class="line">refernce 被参照表名(主码属性) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="operator">&lt;</span>参照动作<span class="operator">&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>参照动作</strong>：说明当（被参照关系的）某个主码值被删除/更新时，如何处理自己表中对应的外部码值<br>RESTRCT方式（for server: no action）：仅当没有任何对应外部码值时才能删除/更新这个主码值，否则系统拒绝执行此操作<br>CASCADE方式：连带所有对应的外部码值一起删除/更新<br>SET NULL方式：将所有外部码值设为空<br>SET DEFALUT方式：将所有对应外部码值设置为默认值</li></ol><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Libroary</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">数名 <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key(书号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 借阅表</span><br><span class="line">&#123;</span><br><span class="line">书号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">读者编号 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">借阅日期 <span class="type">date</span></span><br><span class="line"><span class="keyword">primary</span> key (...),</span><br><span class="line"><span class="keyword">foreign</span> key (书号)</span><br><span class="line"><span class="keyword">references</span> 图书表(书号)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非空约束">非空约束</h5><p>规则：属性值不允许取空值<br>定义：创建/修改表的语句中，声明某个属性NOT NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认值约束">默认值约束</h5><p>规则：插入记录时，没有指定数据的属性值取默认值<br>定义：创建/修改表的语句中，声明某个属性时，用DEFAULT关键字引出其默认值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="唯一约束">唯一约束</h5><p>规则：制定属性或属性组，不能取重复值<br>定义：创建/修改表的语句中，用Unique关键字声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span>,</span><br><span class="line">e<span class="operator">-</span>mail <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">...</span><br><span class="line"><span class="keyword">unique</span>(e<span class="operator">-</span>mail)</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="检查约束">检查约束</h5><p>规则：每个元组内部一个或多个属性值，必须满足用户指定的条件<br>定义：创建/修改表的语句中，check关键字后说明条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line"><span class="keyword">check</span>(性别 <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">or</span> 性别 <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">or</span> 性别 <span class="keyword">is</span> <span class="keyword">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="域约束">域约束</h5><p>规则：域（数据类型）中的值要满足用户指定的条件<br>目的：间接地约束属性。因为如果把某个属性声明为这个域（数据类型），则该属性的取值也连带要满足这一条件。<br>定义：在创建域的语句中，在constraint关键字后面说明约束的名称和条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain 性别类型 <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">check</span>(<span class="keyword">value</span> <span class="keyword">in</span> (<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="keyword">Null</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 读者</span><br><span class="line">&#123;</span><br><span class="line">读者号 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">姓名 <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">性别 性别类型 <span class="keyword">default</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">primary</span> key (读者号)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="断言约束">断言约束</h5><p>断言就是一个谓词（条件），实施在较大的范围，例如整个数据库所有数据</p><ul><li>主码约束、检查约束等作用范围较小，一般是一个元组或者属性内部，可以看做是“小断言”</li><li>如果作用范围比较大，例如要求几个关系之间必须满足什么约束条件，就要断言约束<br><strong>创建断言</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion 断言名 <span class="keyword">check</span>(条件)</span><br></pre></td></tr></table></figure><ul><li>创建断言后，系统要对每个可能违反该断言条件的修改操作进行检查，这种检查会带来巨大的系统负载，因此应该谨慎使用断言</li><li>所以实际上很少数据库软件支持断言，而倾向于用其他的等价方法，比如触发器<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240603194811.png" alt="Pasted image 20240603194811"></li></ul><h5 id="触发器">触发器</h5><p>概念：自动执行的过程</p><ul><li>传统过程是用户调用才手动执行，否则不执行</li><li>在系统检测到某些事情发生时才会去主动执行相应（预先跟这些时间绑定的）触发器<br>构成：</li><li>Event ： 发生什么是？</li><li>Condition ： 检查什么条件？</li><li>Action：再执行什么动作（条件成立）？<br>作用：</li></ul><ol><li>保证数据完整性，例如在增删改记录时，验证一些复杂的条件是否满足</li><li>审计（例如把一个用户对数据库的操作和时间都记录下来）</li><li>满足特定条件自动执行某项任务（例如，商品库存不足时，自动生成一张订单）</li></ol><p>例子：当职工工资增幅超过10%，放弃修改（改回原值）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trig_SALARY_LIMIT</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">of</span> 工资 <span class="keyword">on</span> 职工表</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="keyword">as</span> newrow </span><br><span class="line"><span class="keyword">old</span> <span class="keyword">as</span> <span class="keyword">old</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (newrow.工资 <span class="operator">&gt;</span> <span class="number">1.1</span><span class="operator">*</span>oldrow.工资)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> 职工表</span><br><span class="line"><span class="keyword">set</span> 工资 <span class="operator">=</span> oldrow.工资</span><br><span class="line"><span class="keyword">where</span> 员工号 <span class="operator">=</span> oldrow.员工号</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><h3 id="安全性和完整性的对比">安全性和完整性的对比</h3><ul><li>安全性控制是为了防止“非法用户”和“非法操作”（用户合法但执行的操作超出权限范围）</li><li>完整性控制是为了防止“非法数据”，也就是不正确的数据。任何情况下，即使是合法用户以及合法操作，也会产生非法数据。</li></ul><h2 id="期中考复习">期中考复习</h2><p>==特别重要的题==<br><strong>注意依次执行</strong></p><p>PPT关于模型的东西</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】3. 内存管理</title>
      <link href="/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%913.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>内存的基本概念</h1><ol><li>存储单元：存储数据的基本单元。要看内存是如何编址的，如果是按字节，则为1B=8Bit，如果是按字的话，就要看具体PC的字长是多少。</li></ol><h2 id="指令的工作原理">指令的工作原理</h2><p>区分逻辑地址和物理地址！<br><strong>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址）</strong>，即：相对于进程的起始地址而言的地址；<br>观察下面的例子，第一条指令是往地址79号存储单元写入10，但是由于系统给他分配的物理地址是从100开始的，如果写入前面的79，则很有可能会写入其他进程的内存空间。这是很危险的行为。<br>而实际上，指令中的地址是逻辑地址，相对于进程的起始地址100偏移79个的存储单元写入10，所以会在物理地址179号寄存器写入数据。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417160405.png" alt="Pasted image 20240417160405"></p><h3 id="如何将指令中的逻辑地址转换为物理地址">如何将指令中的逻辑地址转换为物理地址</h3><h4 id="绝对装入">绝对装入</h4><p>在编译时，如果知道程序将放入内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<br>就如前面的例子，如果在可执行文件装入内存中之前，就知道该可执行程序装入内存的地址为100，则在装入之前就可以把逻辑地址转换为绝对地址装入。<br><strong>绝对装入只适用于单道程序</strong></p><h4 id="可重定位装入">可重定位装入</h4><p>又称可重定位装入。编译、链接后装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的合适为止，<strong>装入时对地址进行“重定位”</strong>， 将逻辑地址转变为物理地址（地址变换是在装入时一次完成的）<br><strong>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。在运行期间就不能再移动。</strong></p><h4 id="动态重定位">动态重定位</h4><p>动态运行时装入。编译、链接后的装入模块地址都是从0开始的。装入程序把装入模块装入内存之后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行的时候才进行</strong>。因此装入内存后的所有地址依然是逻辑地址。<br>这种方式需要一个<strong>重定位寄存器</strong>来支持。<br>比如下图，重定位寄存器存放装入模块的起始地址；当程序直行到指令0的时候，需要往逻辑地址79号存储单元写入数据10；则这时候才进行逻辑地址到物理地址的转换，即79+100=179，然后往物理地址179号存储单元写入数据10。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417161642.png" alt="Pasted image 20240417161642"><br>优点（学完虚拟内存之后可能会更加清楚）：</p><ol><li>允许程序在内存中发生移动（修改重定位寄存器的值就行）；</li><li>可以将程序分配到不连续的存储区中，在程序运行前只需要装入它的部分代码即可投入运行， 然后在程序运行期间，根据需要动态申请分配内存；</li><li>便于程序段的共享，可以向用户提供一个比存储空间大的多的地址空间；</li></ol><h3 id="从写程序到程序运行的流程">从写程序到程序运行的流程</h3><p>装入模块中存放的是完整的逻辑地址，存放到内存里之后，按照上面提到的三种装入策略装入，最后执行的时候访问的还是物理地址。</p><ul><li>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译成机器语言的过程）</li><li>链接：由链接程序将编译后形成的一组目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块</li><li>装载/装入：由装入程序将装入模块装入内存运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">subgraph *.c</span><br><span class="line">direction TB</span><br><span class="line">1[&quot;源代码文件1&quot;] &amp; 2[&quot;源代码文件2&quot;] &amp; 3[&quot;源代码文件3&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph *.o</span><br><span class="line">direction TB</span><br><span class="line">4[&quot;目标模块1&quot;] &amp; 5[&quot;目标模块2&quot;] &amp; 6[&quot;目标模块3&quot;]</span><br><span class="line">end</span><br><span class="line">subgraph *.exe</span><br><span class="line">direction TB</span><br><span class="line">7[&quot;装入模块&quot;]</span><br><span class="line">end</span><br><span class="line">程序员 --编辑--&gt; *.c --编译--&gt; *.o  --链接--&gt; *.exe --装入--&gt; 8[&quot;内存&quot;]</span><br></pre></td></tr></table></figure><h3 id="链接的三种方式">链接的三种方式</h3><h4 id="静态链接">静态链接</h4><p>在程序运行之前，先将各个目标模块以及他们所需要的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。<br>也就是说，在形成装入模块之后，逻辑地址已经形成，不再改变。</p><h4 id="装入时动态链接">装入时动态链接</h4><p><strong>将各个目标模块装入内存时</strong>，边装入边链接的方式；<br>这种方式的完整的逻辑地址是一边装入，一边形成的。</p><h4 id="运行时动态链接">运行时动态链接</h4><p><strong>在程序执行中需要该目标模块时</strong>，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。<br>用不到的模块不用装入内存。<br>这种方式内存利用率高，而且更灵活。</p><h1>内存管理的概念</h1><p>操作系统作为系统资源的管理者，需要对内存进行管理，需要进行管理什么呢？</p><ol><li>操作系统负责内存空间的分配与回收</li><li>需要提供某种技术，从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换（3种装入方式）</li><li>操作系统需要提供内存保护功能。保证各个进程在各自存储空间内运行，互不干扰<br>内存保护的两种方法：<ol><li>采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址，<strong>界地址寄存器中存放的是最大逻辑地址</strong>；</li><li>在CPU中设置一对上下限寄存器，存放进程的上限、下限地址。进程指令要访问某个地址时，CPU检查是否越界；<br>区别：<br>方法一：在进程想要访问某一内存单元时，CPU先将进程的逻辑地址与界地址寄存器的逻辑地址进行对比，如果不超过界地址寄存器的逻辑地址，则与基地址寄存器的地址进行相加得到物理地址，允许进程访问相应的内存空间；<br>方法二：在进程想要访问某一内存单元时，CPU会将进程的内存单元的逻辑地址先转换成物理地址，检查该物理地址是否在上下限地址寄存器之间，如果在上下限地址寄存器存放的物理地址之间，那么才允许进程访问内存空间；</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存管理的概念 --&gt; 内存的分配与回收 &amp; 内存空间的扩充 &amp; 地址转换 &amp; 存储保护</span><br><span class="line">内存的分配与回收 --&gt; 连续分配管理方式 &amp; 非连续分配管理方式</span><br><span class="line">内存空间的扩充 --&gt; 覆盖技术 &amp; 交换技术 &amp; 虚拟存储技术</span><br></pre></td></tr></table></figure><h2 id="内存的分配与回收">内存的分配与回收</h2><p>连续分配与非连续分配的区别是：是否为用户进程分配一段连续的内存空间；</p><h3 id="连续分配管理方式">连续分配管理方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">连续分配管理方式 --&gt; 单一连续分配 &amp; 固定连续分配 &amp; 动态连续分配</span><br></pre></td></tr></table></figure><h4 id="单一连续分配">单一连续分配</h4><p>在单一连续分配方式中，内存被分为系统区和用户区。<br>系统区通常位于内存的地地址部分，用于存放操作系统的相关数据；用户区用于存放用户进程相关数据。<br>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502171744.png" alt="Pasted image 20240502171744"></p><h4 id="固定分区分配">固定分区分配</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">固定分区分配 --&gt; 分区大小相同 &amp; 分区大小不同</span><br></pre></td></tr></table></figure><p>为了同时载入多道程序，后续发展出了固定分区分配的内存分配方式；<br>即把内存的用户区分层若干个固定的分区，根据分区大小是否相同又衍生出分区大小相同的固定分区分配方式和分区大小不同的固定分区分配方式；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502173400.png" alt="Pasted image 20240502173400"><br>分区大小相同：</p><ul><li>缺乏灵活性</li><li>适用于<strong>一个计算机控制多个相同的对象的场合</strong><br>分区大小不同：</li><li>增加灵活性</li><li>满足不同大小进程的需求</li></ul><h4 id="分区大小不同的内存管理">分区大小不同的内存管理</h4><p>建立一个分区说明表，记录不同分区大小的起始地址、终止地址、是否被分配等信息，便于操作系统对某一个进程进行载入时选择合适的分区进行载入；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502173643.png" alt="Pasted image 20240502173643"></p><h4 id="动态分区分配">动态分区分配</h4><p>这种分配方式不会预先把用户区内存分块，而是在进程需要载入的时候根据进程的大小为进程分配一块大小刚好合适的内存空间；<br><strong>动态分区分的内存管理</strong>：需要建立一个空闲分区表/空闲分区链，记录每一块空闲区的信息（分区号、起始地址、内存大小、分配状态等）来管理空闲区；<br><strong>内存分配方法</strong>：当多个空闲区都能满足进程的大小时，系统通过动态分区分配算法决定选择哪一块空闲区进行内存分配；<br><strong>分区的分配与回收操作</strong>：物理上执行分配，逻辑上在对应的空闲分配区/表记录新的空闲区的内容；</p><h4 id="碎片的概念">碎片的概念</h4><ol><li>内部碎片：<br>分配给某个进程的内存区域内，该进程并不需要用到这么多内存，所以这部分多出的内存没有被利用但是被分配给了该进程；这部分没被进程利用的内存称为内部碎片；</li><li>外部碎片：<br>内存中某些空闲区由于太小而难以利用；<br>有时可以通过紧凑的方式，将已经使用的内存区合并，增大空闲区的连续空间大小；</li></ol><h2 id="动态分区分配算法">动态分区分配算法</h2><p>在动态分区分配方式中，当有很多个空闲区满足进程的内存分配要求时，操作系统应该如何选择空闲区进行内存分配？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">动态分区分配算法 --&gt; 1(&quot;`首次适应算法（First Fit）`&quot;) &amp; 2(&quot;`最佳适应算法（Best Fit）`&quot;) &amp; 3(&quot;`最坏适应算法（Worst Fit）`&quot;) &amp; 4(&quot;`邻近适应算法（Next Fit）`&quot;)</span><br></pre></td></tr></table></figure><h4 id="不同分配算法的对比介绍">不同分配算法的对比介绍</h4><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应算法</td><td>每次从低地址开始查找空闲区，一旦找到合适的空闲区，则把该空闲区分配给进程；</td><td>以<strong>地址</strong>递增的次序排列</td><td>综合性能最好，<strong>算法开销小</strong>，回收分区后一般不需要对空闲分区进行重新排序</td><td></td></tr><tr><td>最佳适应算法</td><td>将所有空闲分区按从小到大排序，每次分配从头到尾查找匹配的空闲区，遇到<strong>能够满足进程空间的最小空闲区</strong>就进行分配；（<strong>优先使用更小的分区，以保留更大的分区</strong>）</td><td>按照<strong>空闲区容量</strong>从小到大排序</td><td>会有更大的空闲区被保留下来，能够满足大进程的需求</td><td>1. 算法开销大；<br>2. <strong>会产生很多太小的、难以利用的空间</strong></td></tr><tr><td>最坏适应算法</td><td>将所有空闲分区从大到小排序，每次分配从最大的空闲区开始分配，这样能避免产生<strong>外部碎片</strong>；</td><td>按照空闲区容量从大到校排序</td><td>减少外部碎片的产生</td><td>1. 算法开销大；<br>2. 会导致大分区很快被利用完，不利于大进程；</td></tr><tr><td>邻近适应算法</td><td>由首次适应算法演变而来，每次从上次查找结束为止开始查找；</td><td>以地址递增的次序排列（可以排列成循环链表）</td><td>算法开销小；<br>不用每次都从低地址空间开始检索；</td><td>会使高地址的大分区也会被用完；</td></tr></tbody></table><h2 id="非连续分配管理方式">非连续分配管理方式</h2><p>与连续分配方式不同的是，非连续分配方式为用户进程分配的是分散的内存空间；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">非连续分配管理方式 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 段页式存储管理</span><br></pre></td></tr></table></figure><h3 id="基本分页存储管理">基本分页存储管理</h3><h4 id="分页存储">分页存储</h4><p>把内存分成一个个大小相等的分区（比如每个分区4KB），每个分区就是一个页框(Page Frame)（页框=页帧=内存块=物理块=物理页面）；<br>系统会将内存的每一个物理区域分成一个个大小相等的页框，每个页框有一个编号，也称为“页框号”（页框号=页帧号=内存块号=物理页号）；页框号从0开始；<br><strong>如何基于这样的内存存储结构对一个用户进程进行内存分配？</strong><br>在每一个用户进程创建时，在PCB（进程控制块）中建立一个页表；<br>在页表中，对用户进程所需要的空间（逻辑地址空间）按照页框大小进行分组，假设分为n块，每一块称为一个页面/页，每个页/页面都有一个页号/页面号，页表中记录0~n-1个页面号到页框号的映射关系；<br>由于用户进程的逻辑地址在每一个组中都是连续存放的，所以页面号是隐含的，所以每一个页表项实际上就是记录页框号；<br><strong>例子</strong>：假设有4GB的内存，页框大小为4KB，则每个页表项至少应该是多少个字节？<br>解：$$\displaylines{\because 页框=4KB\<br>\therefore 内存块数n=4GB/4KB=2^{32}B/2^{12}B=2^{20}个 \<br>\therefore 内存块编号范围/页框号范围:0-2^{20}-1 \<br>\because 每一个页表项只用存放的是页框号，页号隐含 \<br>\therefore 每一个页表项至少为20个比特，至少需要3个字节，也就是3B \<br>\therefore 进一步地，该页表需要3*(n+1)B来存放<br>}$$<br><strong>例子进阶</strong>：如何找到每一个页表项对应的页号？<br>解：$$\displaylines{首先我们需要知道页表项的第一项页框号是什么（由于在页内是连续存放的）\<br>假设页表项第一项的页框号是X，则X对应的是0页号;\<br>于是页号i对应的页框号为X+3*i}$$<br><strong>注意：</strong></p><ol><li>页表中存放的是页框号J，而不是页框的物理起始地址adr；</li><li>要计算该页框号对应的物理起始地址，应该为adr = J*页框大小</li></ol><h4 id="确定进程逻辑地址到内存物理地址的转换">确定进程逻辑地址到内存物理地址的转换</h4><p><strong>例题</strong>：某计算机系统中，页面大小是50B，某进程逻辑地址空间大小为200B，则逻辑地址110对应的页号、页内偏移量是多少？内存地址起始地址是多少？内存实际地址是多少？<br>解：$$\displaylines{依据题意，页号范围为0-200B/50B，即0-4，每一个页号存一个页框号\<br>\therefore 逻辑地址为110的页号为110/50=2（取整，因为页号从0开始）\<br>页内偏移量为110%50=10 \<br>\therefore 可以根据页号3查询对应的页框号，根据页框号计算该页框的内存起始地址\<br>然后再加上页内偏移量，即可算出该逻辑地址对应的内存物理地址\<br>\therefore 物理地址=页框号对应的内存起始地址+页内偏移地址}$$<br><strong>小结</strong>：</p><ol><li>页号=逻辑地址/页面长度（取整）</li><li>页内偏移量=逻辑地址%页面长度</li><li>如果页面大小设计为2的整数幂，则可以快速把逻辑地址拆成页号和页内偏移量<ul><li>如果每个页面大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，则用二进制表示逻辑地址，低k位表示页内偏移量，其余位数表示页号；</li><li>页表中记录的页号与页内偏移量进行二进制拼接即可得到物理地址，不需要再页号*页面大小来得到起始地址，因为刚好一致；（看下面第二个例子）<br>具体看下面两个例子：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240502235407.png" alt="Pasted image 20240502235407"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240503000409.png" alt="Pasted image 20240503000409"></li></ul></li></ol><h4 id="基本地址变换机构">基本地址变换机构</h4><p>在基本分页存储管理的内存分配方式中，通过基本地址变换机构来实现逻辑地址到物理地址的转换；<br>基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构；<br><strong>工作原理</strong>：<br>回顾程序的从编辑到执行的过程，程序写好后会被编译、链接，形成机器指令，机器指令中所涉及到的地址（比如将某个常数写入某个内存地址）都是逻辑地址；<br>所以程序需要执行的时候，会对该程序建立一个进程载入内存（进程由程序段、数据段和PCB组成），在进程的程序段中，所涉及到的机器指令是逻辑地址，所以当程序执行到某个机器指令时，需要把其中涉及到的逻辑地址转换成物理地址进行访存操作；</p><ol><li>从进程中获取待访问的内存的逻辑地址；（进程在内存中，所以这一步操作是访问内存的）</li><li>根据进程中记录的逻辑地址，计算出页号和页内偏移量；</li><li>在进程的PCB中，有一个页表寄存器（PTR），记录该进程的页表的起始地址（第一个存放的内存块号）以及页表长度；</li><li>根据页号与页表长度进行对比，如果页号小于或者等于<strong>页表长度-1</strong>（页表长度从1开始），则没有越界，否则发生越界中断；</li><li>根据页表始址和页号，计算页表中该页号存放的页框号（内存块号）；<br>计算公式：页框号=页表始址+页号*页框大小</li><li>根据页框号*页框大小+页内偏移量得到对应的内存物理地址；<br><strong>注意</strong>：</li></ol><ul><li>页式管理中，地址是一维的，只要给出一个逻辑地址，就能计算出页号和页内偏移量；</li><li>页内偏移量占多少位，等价于页框大小占多少位</li></ul><h4 id="具有快表的地址变换机构">具有快表的地址变换机构</h4><p>快表，又称联想寄存器（TLB，translation lookaside buffer），是一种访问速度比内存块很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加快地址变换的速度。与此对应，内存中的页表常称为慢表。<br><strong>快表的作用</strong>：<br>基于<strong>局部性原理</strong>，将最近在内存中访问的内存块号（页框号）存入缓存区的快表中；提高快表命中要访问的内存块号的概率，一般来说快表的命中率可以达到90%以上；<br>快表的访问要比访问内存要快很多，这样就可以使得平均访存速度大大提升！<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240503191123.png" alt="Pasted image 20240503191123"><br><strong>引入快表后地址变换过程</strong>：</p><ol><li>CPU给出逻辑地址，由某个硬件计算出页号、页内偏移量，根据页表寄存器中的页表长度与页号对比，检查是否越界，越界则产生越界中断；</li><li>没有越界则将页号与快表中所有页号进行比较查找；如果找到匹配的页号，说明要访问的页表项在快表中有副本，直接从快表中取出内存块号，再将内存块号和页内偏移量拼接成物理地址，然后根据物理地址对内存进行访问；（<strong>这个过程只需要一次内存访问</strong>）</li><li>如果没有找到匹配的页号，则说明快表中没有存放要访问的页号的副本；于是需要访问存储在该进程PCB中的页表（在内存中），找到对应的页号取出内存块号，拼接计算出物理地址再进行访存；（<strong>这个过程需要两次内存访问</strong>）<br><strong>注意</strong>：在找到页表项之后，应该同时将页表项的副本载入快表中，以便后续可能再次访问该页表项；若快表已满，则需要按照一定的算法对快表中的页表项进行替换；</li></ol><h4 id="局部性原理">局部性原理</h4><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久后该数据很有可能再次被访问。（因为程序中存在大量的循环）<br><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><h3 id="两级页表">两级页表</h3><h4 id="单级页表存在的问题">单级页表存在的问题</h4><p>假设某计算机系统按字节寻址，支持32位逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B；试分析如果采用单级页表存储会有什么不足之处？<br>分析：$$\displaylines{因为页面大小是4KB，所以页内偏移地址是12位的\<br>因为内存是2^{32}大小的，所以一个页表最多有2^{32}/2^{12}=2^{20}个页面\<br>也就是会有2^{20}个页表项\<br>所以一个页表的存储空间为4B*2^{20}=2^{22}B的连续内存空间存放\<br>由于内存空间是分页存储，一个页框大小为4KB \<br>所以一个页表需要占用连续的2^{22}B/2^{12}=2^{10}个页框<br>}$$<br>由上述分析可见，采用<strong>单级页表的两个问题</strong>：</p><ol><li>一个进程的创建，光页表就需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个连续的页框存放，这意味着系统需要提供很多个连续的页框以满足多个进程的需要，这显然已经丧失了离散式存储管理的优点；（多级页表解决）</li><li>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没必要让整个页表都常驻内存；（虚拟存储技术解决）<br><strong>注意</strong>：<br>页表项的长度为什么是4B？<br>分析：$$\displaylines{4B是4个字节的意思\<br>页表项需要存储页框号，页框号的个数决定了页表项的长度\<br>由上面分析可知页框号的个数是2^{20}个，所以需要20位的数据来表示\<br>所以页表项长度应该是20位比特，但是由于该计算机按照字节编址\<br>1字节=8位，所以至少需要3个字节来存储，所以页表项长度最小为3B\<br>为了计算机计算方便，我们应该把页表项表示为2的整数幂大小\<br>所以设置页表项长度为4个字节<br>}$$</li></ol><h4 id="多级页表">多级页表</h4><p>参照解决连续型存储管理的思路，我们也将页表进行分组，使得每一个内存块刚好可以放入一个分组；（这里对比单级页表，每一个页表项存储的是内存块号而不是内存块）<br>比如：<br>按照上面的例子，一个页表有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>个页表项（每个页表项存储的是内存块号），一个页面/内存块/页框大小/页内偏移量/页面大小是4KB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{12}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，一个页表项大小是4B，所以一个页面存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页表项；(页面号是隐含的)<br>我们将页表按照页面大小分组（每一个页面刚好能放下一个内存块），然后将每一个分组离散地存储在内存中即可，这样就避免了页表过大的问题；<br>为了实现页表逻辑上的连续，为离散分配的页面再建立一张页表，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>/<strong>顶层页表</strong>；<br>我们每一个页面建立一个二级页表，离散的存放在内存中，二级页表中存放对应的内存块号；<br>分组之后，一个<strong>页目录表</strong>存放<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个<strong>二级页表所存放的内存号</strong>（页面号隐含），相比于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span>就大大减少了对连续空间的需求；</p><h4 id="多级页表的地址结构">多级页表的地址结构</h4><p>由于在多级页表中，页表结构发生变化，所以页表地址结构也相应发生变化；<br>比如上面的例子：<br>二级页表（页面页表）需要记录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个页表项（内存块号），所以需要10位的地址；<br>顶层页表（一级页表）需要记录<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>个二级页表存放的内存块号，所以需要10位地址；<br>每一个内存块被分为4KB，也就是页框大小为4KB，需要12位地址；<br>于是在32位机中，地址结构如下：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504000908.png" alt="Pasted image 20240504000908"></p><h4 id="多级页表的地址变换">多级页表的地址变换</h4><p>例题：将逻辑地址（0000000000, 0000000001, 111111111111）转换为物理地址（十进制表示）</p><ol><li>按照地址结构将逻辑地址拆分为三部分；</li><li>第一部分（一级页号）：0，表示二级页表存放在内存块号0的地方；<br>于是从内存块号0访问出相应的二级页表；</li><li>第二部分（二级页号）：1，表示二级页表中的1号页表项，于是得到二级页表的1号页表项存放的内存块号；</li><li>第三部分（页内偏移量）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{12}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，根据二级页表的内存块号，以及页内偏移量，拼接成相应的内存的物理地址，然后根据该物理地址在内存中访问存储的数据；</li></ol><h4 id="需要注意的细节">需要注意的细节</h4><ol><li>若采用多级页表机制，则各级页表的大小不能超过一个页面：<br><strong>例题：</strong> 若某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，假设采用纯页式存储，则需要采用多少级页表？页内偏移量是多少？<br>分析： $$\displaylines{由于一个页面大小为4KB，所以页内偏移量为2^{12}个，即12位\<br>由于是40位逻辑地址，低12位用于表示页内偏移量，所以剩余28位可以用于表示页号\<br>\because 各级页表大小不能超过一个页面  \<br>在这个例子中，一个页面大小为2^{12}B/2^2B=2^{10} \<br>\therefore 一个页面为10位，各级页表最多为10位 \<br>\therefore 40位的逻辑地址，可以分为：1级页号8位，2级页号10位，3级页号10位\<br>剩余12位为页内偏移量<br>}$$</li><li>两级页表的访存次数分析（假设没有快表机制）：<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ol><h3 id="基本分段存储管理方式">基本分段存储管理方式</h3><p>基本分段存储管理方式，是按照程序自身的逻辑将逻辑地址划分为若干个连续的地址，对应不同的连续的内存空间；每个段都有一个段名（低级语言中，程序员使用段名来编程），每段从0开始编址。<br><strong>内存分配原则</strong>：以段为单位进行分配，每个段在内存中占据着连续的空间，但各个段之间可以不相邻；<br><strong>分段优点</strong>：按照程序的逻辑功能划分，用户编程更加方便，程序可读性更高；</p><h4 id="分段系统的逻辑地址结构">分段系统的逻辑地址结构</h4><p>段号的位数决定了每个进程最多分几个段，段内地址的位数决定了每个段的最大长度是多少；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504182127.png" alt="Pasted image 20240504182127"></p><h4 id="段表">段表</h4><p>进程如何访问各个段实现程序逻辑上的连续？和页式存储的方式一致，建立一个段表。段表记录了每一个段的段号（隐含），以及每一个<strong>段在内存中的起始地址</strong>，并且还需要记录每一个<strong>段的长度</strong>（因为段长不固定）；<br>由于每一个段表项使用相同大小的内存空间存储，所以段号隐含，只需要知道段表存放在内存中的起始地址M以及段号K，就可以计算出对应的段表项地址：M+K*size，其中size指的是存储一个段表项所用的大小；<br><strong>如何计算size</strong>：<br>继续上面的例子，假设段内地址16位，则16位可以表示最大段长；物理内存大小为4GB，即32位；<br>所以要用段表记录整个内存空间，则需要16+32位来唯一标识一个内存空间；也就是48位的数据，所以一个段表项的大小的6B；也就是size=6B；</p><h4 id="分段存储管理地址变换过程">分段存储管理地址变换过程</h4><p>当进程要上处理机运行之前，进程切换的相关程序负责恢复进程的运行环境，其中就包括恢复进程PCB中的段表寄存器的值，段表寄存器记录了段表的起始地址和段表长度；</p><ol><li>当进程环境恢复之后，进行开始运行，在进程运行的过程中可能要访问一些逻辑地址；</li><li>当进程要访问一个逻辑地址adr的时候，逻辑地址首先被分为两部分，包括段号S和段内偏移量/段内地址W；</li><li>段号和返表长度进行对比检查越界，如果段号大于段表长度，则发生越界中断（内中断，程序执行过程中产生的中断）；</li><li>如果没有越界，则根据段表起始地址访问内存找到段表，并结合段号计算出段表项内存位置访问对应的段表项（段表项存储段长度和段起始地址）；<strong>计算公式：段表项地址=段表起始地址+段号*段表项大小</strong></li><li>于是<strong>再一次进行越界检查</strong>，对比段长度和段内地址，如果段内地址大于段长度则发生越界中断；</li><li>段内地址不大于段长度，则继续进行地址转换；</li><li>通过段起始地址和段长度，访问内存中相应的物理内存空间，即访问目标内存块；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504202417.png" alt="Pasted image 20240504202417"></li></ol><h4 id="分段、分页管理的对比">分段、分页管理的对比</h4><p>页是信息的物理单位，分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的；<br>段时信息的逻辑单位，分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名；<br>页的大小固定且有系统决定，段的长度却不固定，决定于用户编写的程序；<br>分页的用户进程地址空间是1维的，而分段的用户进程地址空间是二维的；</p><h4 id="分段存储管理的优缺点分析">分段存储管理的优缺点分析</h4><p>分段比分页更容易实现信息的共享和保护；</p><ol><li>信息的共享<br>对于不能被修改的代码称为纯代码或可重入代码（不属于临界资源，可以并发访问），这样的代码段是可以共享的；<br>可修改的代码是不能共享的，比如一个代码段中有多个变量，各个进程并发地执行可能会导致变量数据的不一致错误；</li><li>信息的保护<br>可以很轻松地给每一个代码段标记为是否可访问，即可实现对于各个段的保护；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504203544.png" alt="Pasted image 20240504203544"><br><strong>由于分页存储管理并不是按照逻辑来对代码进行划分，所以可能导致某一个页框存储多个逻辑的代码，这将难以对某一个页框进行信息保护（比如标记为是否可访问）</strong></li></ol><p><strong>访问内存的次数</strong>：<br>分段管理中，访问内存的次数也是2次；<br>分段管理也可以通过快表提高内存分配效率；</p><h3 id="段页式存储管理方式">段页式存储管理方式</h3><p>段页式管理是结合段式管理和页式管理对内存进行管理的方式，结合了两种管理方式的优点；</p><h4 id="分页、分段管理的优缺点分析">分页、分段管理的优缺点分析</h4><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的内部碎片</td><td>不方便按照逻辑模块实现信息的共享与保护</td></tr><tr><td>分段管理</td><td>很方便地按照逻辑模块实现信息的共享与保护</td><td>如果段长过大，为其分配连续的内存空间会很大；<br>段式管理会产生外部碎片；</td></tr></tbody></table><h4 id="段页式管理的逻辑地址结构">段页式管理的逻辑地址结构</h4><p>段页式系统的逻辑地址结构由段号、页号、页内偏移量构成；实际上就是段式管理结构中对每一个段的存储采用页式管理的方式来管理；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504220234.png" alt="Pasted image 20240504220234"></p><ul><li>段号位数决定了一个进程最多可以分为几个段</li><li>页号的位数决定了每个段可以有多少个页</li><li>页内偏移量决定了页面大小，也就是内存块大小</li></ul><h4 id="段表、页表">段表、页表</h4><p>系统会为每一个进程建立一个段表，每个段表项记录着页表所在内存块，每个页表记录目标内存单元所在内存块；</p><h4 id="段页式管理的地址变换">段页式管理的地址变换</h4><p>当进程进入处理机时，相关的内核会恢复进行的运行环境，其中包括在PCB的段表寄存器记录该进程的段表始址F和段表长度M；<br>进程执行过程中，会遇到要访问逻辑地址的需求；</p><ol><li>假设需要访问逻辑地址adr，首先将adr分为3段，分别是段号S、页号P、页内偏移量W；</li><li>然后段号与段表寄存器的段表长度M进行比较，如果越界产生越界中断，如果没越界则继续执行；</li><li>根据段表始址F和段号S，找到段表项存储的信息，首先对比段表项中存储的页表大小与页号，如果页号大于页面大小，则发生越界中断；如果没有发生越界中断，则通过公式：页表内存块地址Padr=F+S*size计算得到段表中该段号存储的页表地址，并进行访问；</li><li>根据前面的公式找到页表存放的内存块，访问对应的页表，对应页号存储的内存块号，然后结合逻辑地址中的页内偏移量W得到目标内存单元的物理地址并进行访问；<br>整个过程进行了3次访存。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240504222312.png" alt="Pasted image 20240504222312"></li></ol><h2 id="内存空间的扩充">内存空间的扩充</h2><p>在传统的存储管理方式上引入交换技术、覆盖技术、虚拟存储技术，可以在逻辑上实现对内存空间的扩充，提高内存的利用效率；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存空间的扩充 --&gt; 覆盖技术 &amp; 交换技术 &amp; 虚拟存储技术</span><br></pre></td></tr></table></figure><h3 id="交换与覆盖">交换与覆盖</h3><h4 id="覆盖技术">覆盖技术</h4><p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要的时候才需要调入内存。内存中分为一个“固定区”和若干个“覆盖区”；<br>需要常驻内存的段放在“固定区”中，调入之后就不在调出（除非运行结束）<br>不常用的段放在“覆盖区”，需要用的时候调入内存，用不到的时候调出内存；<br>缺点：对用户不透明，增加了程序员的编程负担。因为要提前编程指明需要常驻内存的代码段之类的信息；</p><h4 id="交换技术">交换技术</h4><p>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存（保留PCB），把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）；</p><h5 id="在外存的什么位置保存被换出的进程？">在外存的什么位置保存被换出的进程？</h5><p>在具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；<br>对换区空间只占用磁盘小部分空间，被换出的进程数据存放在对换区，由于对换速度直接影响系统的整体速度，因此对换区空间管理主要<strong>追求换出换入速度</strong>，因此对换区采用连续分配方式；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240417173330.png" alt="Pasted image 20240417173330"></p><h4 id="什么时候交换？">什么时候交换？</h4><p>交换通常在需要进程运行且内存吃紧的时候进行，而系统符合降低就暂停。例如：在发现许多进程运行时进程发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p><h4 id="应该换出什么进程？">应该换出什么进程？</h4><p>优先换出阻塞进程；<br>可换出优先级低的进程；<br><strong>PCB需要常驻内存，不会被换出</strong></p><h3 id="虚拟存储">虚拟存储</h3><h4 id="传统存储管理的缺点">传统存储管理的缺点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">传统存储管理 --&gt; 连续分配 &amp; 非连续分配</span><br><span class="line">连续分配 --&gt; 单一连续分配 &amp; 固定分区连续分配 &amp; 动态分区连续分配</span><br><span class="line">非连续分配 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 基本段页式存储管理</span><br></pre></td></tr></table></figure><ol><li>一次性：作业必须一次性全部装入内存后才能开始运行，这将会导致大作业无法运行；当大量作业要求运行时，由于内存无法同时容纳那么多作业，导致系统作业运行的并发度下降；</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，可是实际上每个作业只有一小部分数据即可正常运行，这就导致内存中会驻留许多暂时用不到的数据，浪费了宝贵的内存空间；<br>虚拟存储管理实际上是基于<strong>局部性原理</strong>而产生的：<br><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久后该数据很有可能再次被访问。（因为程序中存在大量的循环）<br><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</li></ol><h4 id="虚拟内存的定义和特征">虚拟内存的定义和特征</h4><p>基于不局限原理，程序在装入时，可以将程序中很快会用到的部分装入内存，暂时不用的部分暂时留在外存，就可以让程序开始执行；<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需的信息从外存调入内存，然后继续执行程序；<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出外存；<br>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是<strong>虚拟内存</strong>；</p><p><strong>特征</strong>：</p><ol><li>多次性：允许一个作业分多次调入内存；</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中将作业换入换出；</li><li>从逻辑上扩充了内存的容量，使得用户看到的内存容量，远大于实际的内存容量；</li></ol><h4 id="实现虚拟存储技术">实现虚拟存储技术</h4><p>虚拟内存技术，允许一个作业分多次调入内存；如果采用连续的分配方式，当下一次调入该作业的其他部分数据时还要与上一部分的数据保持连续，造成极大的不便；<br>所以虚拟内存技术是建立在非连续性存储管理之上的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">传统非连续性存储管理 --&gt; 基本分页存储管理 &amp; 基本分段存储管理 &amp; 基本段页式存储管理</span><br><span class="line">虚拟内存的实现 --&gt; 请求分页存储管理 &amp; 请求分段存储管理 &amp; 请求段页式存储管理</span><br></pre></td></tr></table></figure><p>虚拟内存管理和传统非连续性存储管理的区别：</p><ol><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需要的信息调入内存；</li><li>当内存空间不够时，由操作系统负责将内存中暂时用不到的信息调出到外存；</li></ol><h4 id="请求分页管理方式">请求分页管理方式</h4><h5 id="页表机制">页表机制</h5><p><strong>需求分析</strong>：</p><ul><li>与基本的页表机制相比，请求分页管理方式中需要知道某个页面是否被调入内存；</li><li>当内存空间不够的时候，需要知道将哪一个页面调出内存；由于操作系统需要根据一些额外的信息来决策选择将哪个页面放入外存，所以页表机制中应该记录这些信息来帮助操作系统来决策；（比如某个页面在内存中停留的时间）<br>基于上述需求，可以将页表设计如下：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240505134633.png" alt="Pasted image 20240505134633"><br><strong>修改位的意义</strong>：<br>如果某个页面没被修改过，则该页面无需在外存重写，因为外存中的数据和内存中数据一致；<br>如果某个页面被修改过，则该页面调出外存时需要覆盖重写原外存数据；</li></ul><h5 id="缺页中断机构">缺页中断机构</h5><p>为了实现请求调页功能，系统需要引入缺页中断机构，当检查到需要访问的页面不存在于内存中时引发中断，同时该缺页的进程进入阻塞态，放入阻塞队列，由操作系统在缺页中断函数中实现调页到内存，调页完成后再次将该进程唤醒，放回就绪队列；</p><h5 id="地址变换过程">地址变换过程</h5><ol><li>当进程执行过程中，要访问某个逻辑地址adr，首先将逻辑地址分为页号和页内偏移量；</li><li>然后页号和页表寄存器的页表长度进行比较，检查是否发生越界，如果发生越界则产生缺页中断；</li><li>如果未发生越界则去快表查询是否有该页号，如果有则直接访问快表对应的页表项，与页内偏移量相加计算出目标内存单元的物理地址并访问；</li><li>如果快表中没有对应的页号则根据页表寄存器的页表始址访问内存中的页表，查询对应页表中的页号的状态位，<strong>检查该内存单元是否被调入内存，如果状态显示未调入内存则发生缺页中断</strong>；等待系统调页，然后往页表写入该页面调入的内存块号并将状态为置1；</li><li>访问该页号对应的内存块号，结合页内偏移量计算出目标内存单元的物理地址，访问目标内存单元；<br><strong>注意</strong>：快表中有的页面一定是在内存中的，若某个页面调出外存，则快表中相应的页面也要删除；<br><strong>细节</strong>：</li><li>只有“写指令”才需要修改页表项的“修改位”；<br>一般来说，只需要修改快表中的表项，只有当快表中的表项将要被删除时，才将快表项的修改写会慢表，减少访存次数；</li><li>和普通中断处理程序一样，缺页中断也需要保存CPU现场；</li><li>需要采用某种“页面置换算法”来决定一个换出页面</li><li>换入换出页面都需要访问外存，访问外存的速度是很慢的，需要尽量避免换入换出；</li><li>页面调入内存后需要修改慢表，同时也需要将表项复制到快表中；</li></ol><h4 id="页面置换算法">页面置换算法</h4><p>在请求分页存储管理中，当需要调页进入内存但内存空间已经满的时候，需要进行页面置换，即把内存中暂时用不到的信息换出外存；<br>由于页面的换入换出需要磁盘IO操作，会有较大的时间开销，所以我们的页面置换算法应该追求更少的<strong>缺页率</strong>；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">页面置换算法 --&gt; 1(&quot;`最佳置换算法（OPT）`&quot;) &amp; 2(&quot;`先进先出置换算法（FIFO）`&quot;) &amp; 3(&quot;`最近最久未使用置换算法(LRU)`&quot;) &amp; 4(&quot;`时钟置换算法(CLOCK)`&quot;) &amp; 5(&quot;`改进型的时钟置换算法`&quot;)</span><br></pre></td></tr></table></figure><h5 id="最佳置换算法">最佳置换算法</h5><p>每次选择淘汰的页面将是以后永不使用，或者是在最长时间内不再被访问的页面，这样可以保证最低的缺页率；<br>先检查目前每个内存块存放的页面号，然后向后搜索将要访问的页面号，在后续访问的页面号中，最后一个被访问到的已存在于当前内存块的页面将是后续最长时间内不被访问的页面，因此需要被换掉；<br><strong>注意</strong>：</p><ol><li>缺页中断是指需要访问的页面没有被调入内存中；</li><li>页面置换是指内存已经满了，如果需要调入页面进入内存，需要将内存中暂时不需要用到的页面换出；</li><li>缺页中断并不一定会引发页面置换，因为当内存有空闲区域时，可以直接将页面调入内存而无需发生页面置换；<br><strong>缺页率</strong>：<br>缺页率 = 缺页中断发生的次数/总共访问内存的次数<br><strong>缺点</strong>：</li><li>最佳置换算法需要知道后续需要访问什么页面；</li><li>但实际上操作系统无法提前预判需要访问的页面序列，只有在进程执行到相应过程才能实现，所以最佳置换算法在实际应用中无法实现，只是一种理想的算法；</li><li>但是最佳置换算法可以作为衡量其他置换算法效率的参考；</li></ol><h5 id="先进先出置换算法（FIFO）">先进先出置换算法（FIFO）</h5><p>每次选择淘汰的页面是最早进入内存的页面；<br>实现方法：将进入内存的页面根据调入的先后顺序组织成一个队列，每次需要发生页面置换的时候，只需要把队头的页面换出即可；<br>FIFO算法虽然实现简单，但是该算法与进程的实际运行规律不使用，因为先进入页面的也有可能进程被访问，因此有可能产生Belady异常，算法效率低；<br><strong>Belady异常</strong>：<br>当进程分配的物理块数增大时，缺页次数不减反增的现象称为Belady异常；</p><h5 id="最近最久未使用算法（LRU）">最近最久未使用算法（LRU）</h5><p>最近最久未使用置换算法（Least recently used）：每次淘汰的页面是最近最久未使用的页面；<br>实现方法：在页表中增加一个访问字段，该字段记录某个页面自上次访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t最大的置换出去即可；<br><strong>缺点</strong>：该算法需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大；<br><strong>优点</strong>：性能好，最接近最佳置换算法；</p><h5 id="时钟置换算法（CLOCK）">时钟置换算法（CLOCK）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">时钟置换算法 --&gt; 简单时钟置换算法 &amp; 改进时钟置换算法</span><br></pre></td></tr></table></figure><p>时钟置换算法是一种性能和开销比较均衡的算法，又称CLOCK算法，或最近未用算法。（NRU，Not Recently Used）</p><p><strong>简单时钟算法实现方式</strong>：<br>为每个页面设置一个访问位，将内存中的页面组织成一个循环队列；<br>每次需要置换时，从当前队列位置开始扫描，检查页面的标志位是否为0，如果为1则将该页面标志位置0，然后扫描下一个，碰到第一个标志位为0的页面即可将该页面换出；（因为该页面最先被访问过，所以是最近未被用）<br>如果第一轮扫描没有发现标志位为0的页面，进行第二轮扫描，由于第一轮扫描会将所有标志位为1的页面置0，所以第二轮扫描一定会找到标志位为0的页面；<br><strong>因此，简单时钟算法最多扫描两次</strong></p><h5 id="改进的时钟置换算法">改进的时钟置换算法</h5><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问，但是没有考虑该页面是否被修改；如果一个页面没有被修改过，该页面应该优先调出，因为未修改过的数据调出外存不需要进行IO操作写回外存；<strong>只有被修改过的页面被淘汰，才会进行IO读写。</strong><br>所以，当两个页面其他条件都相同时，未被修改过的页面应该优先被置换，避免IO操作；</p><p><strong>改进的时钟置换算法实现方式</strong>：</p><ol><li>给每个页面增加一个访问位和一个修改位；访问位为1表示访问过，修改位为1表示修改过；</li><li>优先级：<br>（0，0）未访问且未修改<br>（0，1）未访问但被修改<br>（1，0）访问但未被修改<br>（1，1）访问且被修改</li><li>将所有的页面组织成一个循环队列；</li><li>第一次扫描：扫描队列中所有（0，0）的页面，如果该页面不满足（0，0）不对页面状态作任何修改；如果第一轮扫描中找到（0，0）的页面，则将其置换；否则进行第二轮扫描；</li><li>第二次扫描：由于第一轮扫描未发现（0，0）的页面，所以当前内存中不存在即未被访问又未被修改的页面，所以第二轮扫描实际上要找出第二优先级的状态，即未被访问过但是被修改过的页面（0，1）；<br>所以第二轮扫描中扫描所有（0，1），同时对不满足状态要求的页面的访问状态位置0；<br>如果第二轮扫描中遇到（0，1）则将其置换；否则进行第三轮扫描；</li><li>第三次扫描：由于第二轮扫描也失败，所以当前内存中不存在未被访问过的页面，同时第二次扫描将所有页面的访问状态位置0；<br>所以第三次扫描实际上需要找到访问过但是没有被修改过的页面（0，0）；本次扫描不修改任何标志位；</li><li>第四次扫描：由于第三轮扫描失败，证明该内存中仅存在被访问过也被修改过的页面；经过第二轮的修改和第三轮的排除，当前内存中所有页面的状态都为（0，1）；所以第四轮扫描则扫描（0，1）的页面即可，且一定能找到对应页面；<br><strong>改进的时钟置换算法最多扫描4次</strong></li></ol><h5 id="例题">例题</h5><h6 id="简单时钟置换算法">简单时钟置换算法</h6><p>要点：</p><ul><li>当一页装入内存，访问位置1</li><li>当页面在物理块中，且被访问，访问位置1</li><li>页面替换后，指针指向被替换页面的下一页</li><li>页面在物理块中，且被访问，指针指向被访问页的下一页<ul><li>从指针处开始，遇到第一个访问位为0的，进行置换；遇到访问位为1的，将其访问位置0</li></ul></li></ul><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=464060423&bvid=BV1sL411u7rn&cid=437950541&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640; height: 430px; max-width: 100%;"></iframe>###### 改进时钟置换算法<h4 id="页面分配策略">页面分配策略</h4><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合；（采用虚拟存储技术的系统中，驻留集大小一般小于进程的总大小）<br><strong>固定分配</strong>：操作系统为每个进程分配统一固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变；<br><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或者减少，即，驻留集大小可变；<br><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换；<br><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">页面分配策略 --&gt; 1(&quot;`固定分配，局部置换`&quot;) &amp; 2(&quot;`可变分配，局部置换`&quot;) &amp; 3(&quot;`可变分配，全局置换`&quot;)</span><br></pre></td></tr></table></figure><h5 id="固定分配，局部置换">固定分配，局部置换</h5><p>每个进程分配固定大小的物理内存块（即驻留集大小固定），当进程发生缺页时，只能从该进程的驻留集中分配内存空间调页，如果驻留集已满，则需要对驻留集采用页面置换算法调出暂时不用的页面；<br><strong>缺点</strong>：难以一开始就选择合适的驻留集大小；</p><h5 id="可变分配，全局置换">可变分配，全局置换</h5><p>刚开始为每个进程分配一定数量的物理块，操作系统会保持一个空闲的物理块队列；当进程发生缺页时，从空闲物理块取出一块分配给该进程；若已无空闲物理块，则可以选择系统中任意一个进程的任意一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程；<br><strong>锁定</strong>：操作系统会将进程中比较重要的页面进行锁定，比如一些内核数据；<br><strong>特点</strong>：每次发生缺页都会分配一块新的物理内存，仅当空闲物理块用完才会发生页面置换；被置换的页面可能是系统中任意一个进程的页面，因此这个被选中的进程的物理块会减少，缺页率可能会增加；</p><h5 id="可变分配，局部置换">可变分配，局部置换</h5><p>刚开始为每个进程分配一定数量的物理块，当某些进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存；<br>如果一个进程频繁地缺页，系统则会为该进程分配多一些物理块，直到该进程缺页率趋于适当程度；反之，如果进程在运行时缺页率特别低，系统会适当减少该进程的物理块；</p><p><strong>可变分配全局置换</strong>：只要缺页就分配新的物理块<br><strong>可变分配局部置换</strong>：根据进程的缺页率来动态增加或减少进程物理块</p><h5 id="何时调入页面">何时调入页面</h5><p>什么时候调入页面进入内存，主要有两种方式：</p><ol><li>预调页策略：根据局部性原理，一次调入若干个相邻的页面进入内存；（主要应用与程序的首次调入，由程序员指出应该先调入哪些部分）</li><li>请求调页策略：进程在运行期间发现缺页才将所缺页面调入内存；（IO开销较大）</li></ol><h5 id="何处调入页面">何处调入页面</h5><p>页面一般是存储在外存的文件区的，所以一般是从外存调入页面；<br>但是外存不仅分为文件区，还有对换区：</p><ul><li>对换区：连续分配方式，访问速度快</li><li>文件区：离散分配方式，访问速度慢</li></ul><ol><li>当系统有足够的对换区空间：页面的调入调出应该都在对换区于内存中进行，这样会加快页面调入调出速度；<br>在程序运行前，需要将进程相关的数据从文件区复制到对换区；</li><li>若系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，因为这部分数据不会被修改，换出时不会被写回外存，直接覆盖，需要的时候再次从外存调入即可；<br>对于需要被修改的数据，换出时需要写入对换区，下次需要的时候再从对换区调入；</li><li>UNIX文件系统：运行前将所有数据放入文件区，未使用过的页面都可以从文件区调用；若被使用的页面需要换出，则将页面调出到交换区，需要的时候再从交换区调入；</li></ol><h5 id="抖动-颠簸现象">抖动/颠簸现象</h5><p>刚刚换出的页面马上要换入内存，刚刚换入内存的页面又要换出外存；这种现象称为抖动/颠婆现象；<br>出现这种现象的根本原因是：该进程工作时需要的页面数量大于系统分配给该进程的物理块数量；<br>为了给每个进程分配合适数量的物理块，引入进程的<strong>工作集</strong>的概念；<br><strong>驻留集</strong>：操作系统为进程分配的内存块集合；<br><strong>工作集</strong>：在某段时间间隔里，进程实际访问页面的集合；</p><p>操作系统会根据“窗口尺寸”算出工作集；根据工作集的大小确定驻留集的大小，一般驻留集大小大于工作集大小；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240506164320.png" alt="Pasted image 20240506164320"></p><h4 id="内存映射文件">内存映射文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内存映射文件 --&gt; 特性 &amp; 优点</span><br><span class="line">特性 --&gt; 1(&quot;`进程可以使用系统调用，请求操作系统将文件映射到虚拟地址空间（就是放到内存块中并通过编号的形式实现逻辑上的连续）`&quot;) &amp; 以访问内存的方式读写文件 &amp; 2(&quot;`进程关闭文件时，操作系统负责将文件数据写回磁盘并解除内存映射`&quot;) &amp; 3(&quot;`多个进程可以映射到同一个文件，方便共享（就是映射到同样的内存块）`&quot;)</span><br><span class="line"></span><br><span class="line">优点 --&gt; 4(&quot;`编程简单，只需要按照访问内存的方式读写`&quot;) &amp; 5(&quot;`文件数据的读写完全由操作系统负责，IO效率可以由操作系统负责优化`&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】4. 文件系统</title>
      <link href="/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/01/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%914.%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>文件系统</h1><h2 id="概览">概览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">操作系统为文件管理提供的基本功能 --&gt; 1[&quot;创建文件（create系统调用）&quot;] &amp; 2[&quot;删除文件（delete系统调用）&quot;] &amp; 3[&quot;读文件（read系统调用）&quot;] &amp; 4[&quot;写文件（write系统调用）&quot;] &amp; 5[&quot;打开文件（open系统调用）&quot;] &amp; 6[&quot;关闭文件（close系统调用）&quot;]</span><br></pre></td></tr></table></figure><h2 id="文件的逻辑结构">文件的逻辑结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">文件的逻辑结构 --&gt; 1[&quot;无结构文件&quot;] &amp; 2[&quot;有结构文件&quot;]</span><br></pre></td></tr></table></figure><h3 id="有结构文件">有结构文件</h3><p>由一组组相似的记录组成，又称“记录式”文件。每条记录又由若干个数据项组成，比如数据库表文件。</p><h4 id="逻辑结构">逻辑结构</h4><ol><li>顺序文件<ul><li>链式存储（不可随机存取，链式结构要遍历查找）</li><li>顺序存储（可变长记录无法随机存取，定长记录可随机存取）</li></ul></li><li>索引文件<ul><li>每个文件都有一个索引，然后建立一张索引表（定长记录的随机文件），存放文件的索引和文件地址；</li></ul></li><li>索引顺序文件<br>索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</li></ol><h2 id="文件目录">文件目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">文件目录 --&gt; 1[&quot;文件控制块FCB（实现文件目录的关键数据结构）&quot;] &amp; 2[&quot;目录结构&quot;] &amp; 3[&quot;索引节点（对文件控制块的优化）&quot;]</span><br></pre></td></tr></table></figure><ol><li>文件控制块FCB<br>FCB的有序集合称为“文件目录”，一个FCB就是一个文件的目录项。<br>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读可写，禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等等）</li><li>目录结构<ul><li>单级目录结构（整个系统只有一个目录表）——&gt; 不支持文件重名</li><li>两级目录结构（早期）：主文件目录和用户文件目录</li><li>多级目录结构（树形目录结构）</li><li>无环图目录结构<br>用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下所有内容）<br>需要为每个共享节点设置一个共享计数器，用于记录此时有多少个用户在共享该节点；<br>当用户请求删除节点时，只是删除该用户的FCB，并使共享计数器减一；</li></ul></li><li>索引节点<ul><li>传统FCB包含了文件的基本信息、存取控制信息等，但是我们在索引文件的时候只需要索引文件名，其他信息都不需要；</li><li>于是可以将文件名和索引节点指针作为项的数据形成表存入存储空间，这样一块存储空间可以存放更多的表和文件索引，查找的时候就可以减少存储空间的IO次数，加快索引速度；这就是索引节点。</li></ul></li></ol><h2 id="文件的物理结构">文件的物理结构</h2><h3 id="文件的分配方式">文件的分配方式</h3><ol><li><p>连续分配<br>连续分配方式要求每个文件在磁盘上占有一组连续的块。<br>连续分配方式的文件目录中记录存放文件的起始块号和长度，所以可以直接算出对应文件的物理块号。支持顺序访问和随机访问。</p><p>优点：</p><ul><li>支持随机访问</li><li>由于是连续存储，磁头移动时间短，顺序读写时间最快<br>缺点：</li><li>扩展性差，因为要确保连续</li><li>存储空间利用率低，会产生难以利用的磁盘碎片</li></ul></li><li><p>链接分配——隐式链接<br>这种方式是类似链表的存储结构，目录项只包含起始块号和结束块号（相当于链头和尾）<br>每次访问都从链头开始向后访问其他内容；<br>所以这种方式只支持顺序访问，不支持随机访问；<br>优点是拓展性好，利用率高；</p></li><li><p>链接分配——显示分配<br>目录项FCB中只记录起始块号；然后在文件分配表FAT中显示记录该文件每一个物理块号对应的块地址；支持随机访问。<br>优点：文件拓展方便，外存利用率高，支持随机访问，不会产生碎片；<br>缺点：FAT文件分配表需要一定存储空间；<br><strong>注意：</strong></p><ul><li>一个磁盘只设置一张FAT。开机时，将FAT读入内存，并常驻内存。</li><li>FAT的各个表项在物理上连续存储，且每个表项长度相同，支持随机存取（可以直接算出在哪一行）</li></ul></li><li><p>索引分配<br>系统为每个文件建立一个索引表，索引表记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘称为索引块，文件数据存放的磁盘块称为数据块。（和显示链式分配很像）<br>优点：文件拓展性好，支持随机访问<br>缺点：索引块占用空间</p></li><li><p>混合索引<br>多种索引方式的结合；</p></li></ol><h2 id="文件的存储管理">文件的存储管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">文件的存储管理 --&gt; 存储空间的划分与初始化 --&gt; 1[&quot;文件卷（逻辑卷）的概念&quot;] &amp; 目录区与文件区</span><br><span class="line">几种管理方法 --&gt; 空闲表法 &amp; 空闲链表法 &amp; 位示图法 &amp; 成组链接法</span><br><span class="line">空闲链表法 --&gt; 空闲盘块链 &amp; 空闲盘区链</span><br></pre></td></tr></table></figure><ol><li>存储空间的划分与初始化<br>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷/逻辑盘）<br>存储空间的初始化：将各个文件卷划分为目录区、文件区<br>1. 目录区存放文件目录信息（FCB），用于磁盘存储空间的管理信息（空闲表，位示图，超级块）<br>2. 文件区就是存放具体的存储数据</li></ol><h3 id="存储空间管理">存储空间管理</h3><ol><li>空闲表法<br>建立一个空闲表，记录每个空闲盘的起始地址和盘块数；（适用于连续分配方式）<br>如何分配连续的存储空间：首次使用算法、最佳适应算法、最坏适应算法<br>如何回收磁盘块：回收时需要注意表项合并的问题（就是空闲区合并）</li><li>空闲链表法（适用于离散分布的物理结构）<br>分配存储空间：若某文件申请K个盘块/盘区，则从链头开始依次摘下K个盘块，并修改空闲链的链头指针；<br>回收存储空间：回收的盘块/盘区（盘区注意合并）依次挂到链尾，并修改空闲链得链尾指针；<ol><li>空闲盘块链：以盘块为单位组成一条空闲链<br>空闲盘块中存储着下一个空闲盘块的地址</li><li>空闲盘区链：以盘区为单位组成一条空闲链（连续的空闲盘块组成一个空闲盘区）<br>空闲盘区中的第一个盘块记录了盘区的长度、下一个盘区的指针</li></ol></li><li>位示图法<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240415204717.png" alt="Pasted image 20240415204717"><br>位示图：每个二进制位对应一个盘块。用0或1代表空闲或已被分配；<br>分配（类似将二维矩阵映射到1维）：<ol><li>顺序扫描图，找到K个相邻或不相邻的“0”（代表空闲盘块）；</li><li>根据字号，块号算出对应的盘块号，将相应的盘块分配给文件；</li><li>将相应位置设为1；<br>回收过程：</li><li>根据回收的盘块号计算出对应的字号，位号；</li><li>将相应的位设置为0；</li></ol></li><li>成组链接法（UNIX系统）：<br>空闲表法、空闲链表法不适用于大型文件系统；因为空闲表或者空闲链表可能过大；因此出现了成组链接法。<br>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。<br>空间分配：<br>将空闲盘块分组，每组的第一个块记录当前空闲盘块的中的块数，第二个块记录下一组空闲盘块的首块号（链式结构），此后每一块记录存放具体数据的块号；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240415211940.png" alt="Pasted image 20240415211940"></li></ol><h2 id="文件的基本操作">文件的基本操作</h2><ol><li>创建文件<br>需要提供的参数：<ol><li>所需要的外存大小</li><li>文件存放路径</li><li>文件名<br>create系统调用：</li><li>在外存中找文件所需的空间（找空闲块）</li><li>根据文件存放路径找到该目录对应的目录文件夹，在目录中创建该文件对应的<strong>目录项</strong>，目录项中包含了文件名、文件在外存中存放位置等信息</li></ol></li><li>删除文件<br>delete系统调用：<ol><li>找到文件名对应的目录项</li><li>根据目录项记录文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块<br>需要提供的参数：</li><li>文件存放路径</li><li>文件名</li></ol></li><li>打开文件<br>需要的参数：<ol><li>文件存放路径</li><li>文件名</li><li>需要对文件的操作类型（r, wr…）<br>open系统调用：</li><li>根据文件存放路径找到目录项，<strong>并检查该用户是否有指定的操作权限；</strong></li><li><strong>将目录项复制到内存中的“打开文件表”中</strong>，并将表中的索引号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件；（避免多次从外存中访问<strong>目录项</strong>）</li><li>打开文件表：<br>系统有一张打开文件表（有打开计数器）<br>每一个进程也有对应的打开文件表，并且有读写指针、访问类型等字段</li></ol></li><li>关键文件<br>close系统调用：<ol><li>将进程的打开文件表对应的表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器-1，如果该文件的打开计数器位0，则删除对应表项</li></ol></li><li>读文件<br>读文件之前一定要先打开文件，此时该进程已经有表项了；<br>需要的参数：<ol><li>指明打开哪个文件</li><li>要读入多少数据</li><li>数据存放在内存的什么位置<br>read系统调用：<br>1.从打开文件表对应表项的度指针指向的外存开始，将用户指定大小的数据读入用户指定的内存区域</li></ol></li><li>写文件（读文件的逆过程）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim的使用</title>
      <link href="/2024/04/01/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Vim%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/04/01/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>Vim的模式</h1><h2 id="概览">概览</h2><p>vim有四种模式：</p><ol><li><p>普通模式</p></li><li><p>插入模式</p></li><li><p>可视模式</p></li><li><p>命令模式</p></li></ol><h2 id="各种模式之间的转换">各种模式之间的转换</h2><h2 id="Vim的基本操作">Vim的基本操作</h2><h3 id="光标的移动">光标的移动</h3><h4 id="普通模式下">普通模式下</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>h-j-k-l</td><td>上下左右</td></tr><tr><td>w</td><td>跳到下一个单词开头</td></tr><tr><td>b</td><td>跳到本单词或上一个单词开头</td></tr><tr><td>e</td><td>跳到本单词或下一个单词结尾</td></tr><tr><td>ge</td><td>跳到上一个单词结尾</td></tr><tr><td>0</td><td>跳到行首</td></tr><tr><td>^</td><td>跳到从行首开始的第一个非空字符</td></tr><tr><td>$</td><td>跳到行尾</td></tr><tr><td>gg</td><td>跳到第一行</td></tr><tr><td>G</td><td>跳到最后一行</td></tr><tr><td>f{char}</td><td>光标跳到下一个{char}位置</td></tr><tr><td>F{char}</td><td>反向移动到上一个{char}位置</td></tr><tr><td>t{char}</td><td>光标跳到下一个{char}的位置</td></tr><tr><td>T{char}</td><td>光标反向移动到上一个{char}的最后一个字符的位置</td></tr><tr><td>;</td><td>重复上次的字符查找操作</td></tr><tr><td>,</td><td>反向查找上次的查找操作</td></tr></tbody></table><h3 id="动作-motion">动作 motion</h3><ol><li><p>i(inner)和a(around)的区别</p><p>一个是选中当符号里面的单词，一个是选中包括符号的整个单词；</p><table><thead><tr><th>操作</th><th>操作符</th><th>操作符</th><th>操作</th></tr></thead><tbody><tr><td>i&quot;</td><td>“<strong>foo</strong>”</td><td><strong>“foo”</strong></td><td>a&quot;</td></tr><tr><td>iw</td><td><strong>foo</strong></td><td><strong>_foo</strong></td><td>aw</td></tr><tr><td>i(</td><td>(<strong>foo</strong>)</td><td><strong>(foo)</strong></td><td>a(</td></tr></tbody></table></li><li><p>常用的动作</p><table><thead><tr><th>motion</th><th>意义</th></tr></thead><tbody><tr><td>iw/aw</td><td>选中里面单词/外面的单词</td></tr><tr><td>i( / a( / ib/ ab</td><td>选中()里面或者包括()的单词</td></tr><tr><td>i{ / a{ / iB / aB</td><td>选中{或者包括{的单词</td></tr><tr><td>i&quot; / a&quot;</td><td>选中&quot;“里面或者包括”&quot;的单词</td></tr><tr><td>i’ / a’</td><td>选中’‘里面或者包括’'的单词</td></tr><tr><td>i<code> / a</code> | 选中<code>里面或者包括</code>的单词</td><td></td></tr><tr><td>i&lt; / a&lt;</td><td>&lt;是行首，意思是选中当前到行首内/包括行首的单词</td></tr><tr><td>i[ / a[</td><td>选中[]里面或者包括[]的单词</td></tr><tr><td>it / at</td><td>选中tag里面的代码或者包括tag的代码(在html标签中常见使用)</td></tr><tr><td>is / as</td><td>选中里面的句子或者包括外围的句子，s是sentence的意思</td></tr><tr><td>ip / ap</td><td>p是段落的意思</td></tr></tbody></table></li></ol><h3 id="操作符-operator">操作符 operator</h3><p>NORMAL模式下</p><table><thead><tr><th>操作符</th><th>意义</th></tr></thead><tbody><tr><td>d(delete)</td><td>删除</td></tr><tr><td>c(change)</td><td>修改</td></tr><tr><td>y(yank)</td><td>复制</td></tr><tr><td>v(visual)</td><td>可视化（便于选中多行，注意：不用同时按shift键）</td></tr></tbody></table><h3 id="operator-motion组合实现基本操作">operator+motion组合实现基本操作</h3><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>diw/daw</td><td>删除里面/包含外面的单词</td></tr><tr><td>yi’/ya’</td><td>复制’‘里面/包含’'的单词</td></tr><tr><td>die/dae</td><td>这里的e是entire的意思，删除整个文件的代码</td></tr><tr><td>ci&quot;/ca&quot;</td><td>删除&quot;“里面/包括”&quot;的单词并进入编辑模式</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="切换大小写">切换大小写</h3><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>~</td><td>将光标下的字母改变大小写</td></tr><tr><td>3~</td><td>将光标开始的3个字母改变其大小写</td></tr><tr><td>g~~</td><td>改变当前行字母的大小写</td></tr><tr><td>gUU</td><td>将当前行的字母改成大写</td></tr><tr><td>guu</td><td>将当前行的字母改成小写</td></tr><tr><td>gUaw/gUiw</td><td>将光标下的单词改成大写</td></tr><tr><td>guaw/guiw</td><td>将光标下的单词改成小写</td></tr></tbody></table><h3 id="日常使用小tips">日常使用小tips</h3><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>gd</td><td>go to definition跳转到定义（想看一个函数或者类的实现的使用可以用）</td></tr><tr><td>gh</td><td>hover，悬浮；可以把该函数或者类的参数信息什么的显示在上面</td></tr><tr><td>gt/gT</td><td>切换后面标签页/前面标签页</td></tr><tr><td>ctrl0</td><td>c+0，跳转到侧边栏</td></tr><tr><td>s</td><td>space展开侧边栏文件夹</td></tr><tr><td>l</td><td>光标定位到对应文件编辑器位置</td></tr><tr><td>[][]s+字母（比如n）</td><td>[][]sn，意思是leader_leader_search_n，寻找n所在位置（特别好用！） 【】表示空格</td></tr></tbody></table><h3 id="多光标模式-切换tab">多光标模式/切换tab</h3><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>gb</td><td>选择下一个相同的东西</td></tr><tr><td>:tab n/p</td><td>n表示切换到下一个标签页，p表示切换到上一个标签页</td></tr><tr><td>gt</td><td>往后一个标签页（另外，4gt，还可以跳到第四个标签页）</td></tr><tr><td>gT</td><td>往前一个标签页（另外，5gT还可以跳到第五个标签页）</td></tr></tbody></table><h3 id="配置键位映射">配置键位映射</h3><ol><li><p>快捷键win+,呼出设置</p></li><li><p>找到vim设置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】4. 语言和文法的形式定义</title>
      <link href="/2024/03/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%914.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2024/03/29/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%914.%20%E8%AF%AD%E8%A8%80%E5%92%8C%E6%96%87%E6%B3%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1>语言的描述/定义</h1><h2 id="铺垫">铺垫</h2><h3 id="句子分析过程">句子分析过程</h3><ul><li>推导：用“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">⇒</span></span></span></span>”符号表示<br>即：用某条规则的右部替换该规则的左部</li><li>规约：推导的反过程</li></ul><h3 id="基本概念">基本概念</h3><ul><li>非终结符号集VN：规则中用尖括号括起来的那些符号<br>例如：<br>VN = {&lt;句子&gt;，&lt;主语&gt;，&lt;谓语&gt;，&lt;宾语&gt;，&lt;动词&gt;，&lt;名词&gt;，&lt;冠词&gt;}</li><li>终结符号集VT：规则中的英文单词符号，是组成句子的最基本符号<br>例如：<br>VT={The，student，reads，a，book}</li><li>开始符号或识别符号：语言中的句子只能从它开始推导。如&lt;句子&gt;</li><li>规则（产生式）：用来产生句子的组成描述<br>每一条规则都是用符号&quot;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>&quot;链接起来的有序对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo><mo>:</mo><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">(\alpha, \beta): \alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>是一个由终结符号和非终结符号所组成的符号串且<strong>至少包含一个非终结符号</strong><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>是一个由终结符号和（或）非终结符号所组成的符号串<br>通常被描述为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><msup><mi>V</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \in V^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>且至少包含一个非终结符，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">\beta \in V^*, V = VN \cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8831em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span></li></ul><h3 id="规则的作用">规则的作用</h3><ol><li>用于定义或描述语言中的语法成分</li><li>常用于产生（即推导）出语言中的句子，故一般也将规则称为产生式</li><li>箭头“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>”可以用“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mo>:</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">::=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel">::=</span></span></span></span>”来表示</li></ol><h4 id="注意">注意</h4><ul><li>规则右部的运算符有：选择 |，并置，括号</li><li>无重复(*)运算符，用递归实现重复</li><li>规则右部都可以使用元符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>：为了能产生空串</li></ul><h3 id="文法的定义">文法的定义</h3><p>文法：用来描述语言的语法结构 ——&gt; 四元组表示<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mi>N</mi><mo separator="true">,</mo><mi>V</mi><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (VN, VT, P, S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p><ul><li>VN是非终结符</li><li>VT是终结符</li><li>S是开始符号</li><li>P是产生式集，形式为： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span></li></ul><h4 id="表示文法时，通常有以下的习惯用法：">表示文法时，通常有以下的习惯用法：</h4><ul><li>大写字母A~Z表示非终结符，或者用尖括号把非终结符括起来；</li><li>前面的小写字母a，b，c…表示单个终结符号；</li><li>后面的小写字母u, v, w, x, y, z以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mtext>、</mtext><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha 、\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>等符号表示V=VN<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∪</mo></mrow><annotation encoding="application/x-tex">\cup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∪</span></span></span></span>VT上的符号串；</li></ul><h4 id="文法与正则表达式的异同">文法与正则表达式的异同</h4><ul><li>文法：反映句子的组成</li><li>正则表达式：反映单词的组成</li><li>采用类似的命名惯例和运算</li></ul><h3 id="文法相关概念">文法相关概念</h3><ol><li>句型：如果符号串u是从开始符号s推导出来的，即有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow^*u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>，则称u是一个句型<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&quot;</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">&quot;\Rightarrow^*&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">&quot;</span></span></span></span>表示经过0步或多部推导<br>S=u称为0步推导<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⇒</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>称为1步推导<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>⇒</mo><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\Rightarrow^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>称为1步或多步推导</li><li>句子：仅含终结符的句型, 从开始符号推导出来的仅含有终结符的符号串；</li></ol><h2 id="语言的形式化定义">语言的形式化定义</h2><p>文法G所描述的语言用L(G)表示，它由文法G所产生的全部句子组成，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo>∈</mo><mi>V</mi><msup><mi>T</mi><mo>+</mo></msup><mtext>且</mtext><mi>S</mi><msup><mo>⇒</mo><mo>+</mo></msup><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(G) = \{w | w \in VT^+ 且 S \Rightarrow^+ w \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8213em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">且</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span></span></p><ul><li>符号串w是从开始符号s推导出来的</li><li>w仅由终结符号组成</li><li>W称为该语言的句子</li><li>L(G)是由所有这样的句子构成的</li></ul><p>文法的关键描述在于<strong>开始符号</strong>和<strong>规则</strong><br>所以文法可以表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">[</mo><mtext>开始符号</mtext><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mtext>规则</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">G[开始符号]=\{规则\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">[</span><span class="mord cjk_fallback">开始符号</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord cjk_fallback">规则</span><span class="mclose">}</span></span></span></span></p><h3 id="语言-文法等价">语言/文法等价</h3><p>假设G1，G2为两个文法，若他们所产生的语言相等，即L(G1) = L(G2)，则称G1和G2等价；</p><h3 id="文法的递归">文法的递归</h3><h4 id="直接递归">直接递归</h4><p>设G是一种文法，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">U\to u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>是G的一个规则，如果u具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∪</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \cup \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的形式，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>不同时为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> ，则称产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">U \to u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>是直接递归的；</p><h4 id="递归">递归</h4><p>若存在推导<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>α</mi><mo>∪</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">U \to u \Rightarrow^* \alpha \cup \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> ，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">U \to u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>是直接递归的；</p><h4 id="直接左递归和左递归规则">直接左递归和左递归规则</h4><p>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha = \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\beta \neq \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>时，则将规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">U \to u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>分别称为直接左递归和左递归规则；即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>u</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">U \to u\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> ；</p><h4 id="递归文法">递归文法</h4><p>文法中至少含有一个递归的非终结符；</p><h3 id="文法的分类">文法的分类</h3><p>Chomsky按照规则的特点把文法分为4类：</p><ol><li>0型文法<br>特点：没有对规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>的边做限制，仅要求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>中至少含一个非终结符号。因此又称为无限制文法或短语文法；</li><li>1型文法（也称上下文有关的语法）<br>特点：限制P中的每个规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>都要满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>α</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>β</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\alpha| \leq |\beta|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">∣</span></span></span></span> 这里的||是取串的长度，而不是绝对值；<br>上下文有关是指对非终结符进行替换时，需要考虑该符号所处的上下文环境；<br>例如：<br>对于规则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mi>A</mi><mi>α</mi><mn>2</mn><mo>→</mo><mi>α</mi><mn>1</mn><mi>β</mi><mi>α</mi><mn>2</mn><mo stretchy="false">(</mo><mi>β</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi><mo separator="true">;</mo><mi>α</mi><mn>1</mn><mo separator="true">,</mo><mi>α</mi><mn>2</mn><mtext>不同时为</mtext><mi>ϵ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\alpha1 A \alpha2 \to \alpha1 \beta \alpha2(\beta \neq \epsilon; \alpha1, \alpha2不同时为\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϵ</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span><span class="mord cjk_fallback">不同时为</span><span class="mord mathnormal">ϵ</span><span class="mclose">)</span></span></span></span> , 当用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，只能在上下文为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mn>1</mn><mtext>和</mtext><mi>α</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha1 和 \alpha2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord">2</span></span></span></span>时才能进行；</li><li>2型文法<br>每个规则的特点限制为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A \to \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，其中A为单个非终结符，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>V</mi><mi>T</mi><mi>U</mi><mi>V</mi><mi>N</mi><mo stretchy="false">)</mo><mo>∗</mo></mrow><annotation encoding="application/x-tex">\beta \in (VTUVN)*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mord">∗</span></span></span></span>。也称上下文无关语法，即当使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>替换A时，与A的上下文环境无关；</li><li>3型文法<br>每个规则的特点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mtext>，</mtext><mi>A</mi><mo>∈</mo><mi>V</mi><mi>N</mi><mtext>，</mtext><mi>a</mi><mo>∈</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">B，A\in VN， a \in VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>, 他们都是单个符号，称为正规文法或者正则文法。<br>由于规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to aB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>中，B位于a的右边，所以也称为右线性文法。类似地，正规文法也可以是左线性的（即产生式的形式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \to Ba</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal">a</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A\to a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>）</li></ol><h2 id="句型分析">句型分析</h2><p>构造一种算法，用以判断所给的符号串是否为某一文法的句型（或句子）；</p><ul><li>自上而下（约定：最左推导 ）<br>最左推导<br>最右推导</li><li>自下而上</li></ul><h3 id="句子分析过程的存储结构">句子分析过程的存储结构</h3><p>句子分析过程的信息如果我们想保留下来作为后续的分析的基础，那么如何存储呢？<br>句子分析过程是递归的，所以我们需要用递归结构来存储分析过程——树型结构（分析树）</p><h4 id="分析树的定义">分析树的定义</h4><p>在文法G=(VN, VT, P, S)下的分析树具有以下特征：</p><ol><li>根节点标记为文法的开始符号S</li><li>每个结点上的标记都是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>V</mi><mi>N</mi><mo>∪</mo><mi>V</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">V = VN \cup VT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>中的一个符号</li><li>如果一棵子树的根标记为A，且其所有的直接后代节点从左向右排列的顺序为A1，A2…AK，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2...</mn><mi>A</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">A \to A1,A2...AK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord">2...</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是P中的一个<strong>规则</strong></li><li>如果T1是根节点的唯一子树，且其标记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，则有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \to \epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>在P中</li><li>如果树的所有叶子节点上的标记从左到右排列为字符串w，则w是G的<strong>句型</strong>，若w中仅含有终结字符，则它为G所产生的<strong>句子</strong></li></ol><h4 id="相关术语">相关术语</h4><ul><li>句型：从树根开始的子树</li><li>短语：子树的末端节点（叶子节点）所形成的符号串</li><li>简单短语：只有父子两代的子树的末端节点（叶子节点）形成的符号串</li><li>句柄：最左的简单短语</li></ul><h3 id="语法树题型">语法树题型</h3><p><strong>语法树画法</strong>：(1. 自底向上；2. 自顶向下；)</p><ol><li>从开始符号开始推导，作为树根</li><li>根据推导式一步一步向所求的表达式靠近<br><strong>例题</strong>：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509164723.png" alt="Pasted image 20240509164723"></li></ol><p>分析树把句子的所有分析过程都保留下来，但是有些过程实际上是不需要的，所以我们对分析树进行进一步抽象和压缩，只保留有用的信息，于是产生了语法树。<br>特点：</p><ul><li>分析树表示所有推导步骤</li><li>语法树只保留对后续分析有用的信息，因此无法还原记号序列，比分析树效率更高</li></ul><h4 id="如何用文法规则描述算数表达式">如何用文法规则描述算数表达式</h4><p>根本方法（归纳的方法）：从最基本的量出发开始分析<br>算数表达式的要素：</p><ul><li>量（运算数据）</li><li>运算符</li><li>运算优先级<br>优先级的处理：</li><li>拆除优先级高的，越高放右边</li><li>引入第三方推导代表右边，加深树的深度</li><li>语法树越深优先级越高</li></ul><h5 id="对任意表达式转化为文法规则的步骤-如何用文法规则描述算术表达式">对任意表达式转化为文法规则的步骤/如何用文法规则描述算术表达式</h5><ol><li>归纳分拆出当前表达式的最基本的量</li><li>根据基本量和运算进行组合运算，找到关于该表达式的所有操作和结合的情况，写出初步的文法规则</li><li>推导分析树，看看分析树是不是只有一个，如果不是就意味着有二义性，则需要改造</li></ol><h2 id="二义性文法以及解决方法">二义性文法以及解决方法</h2><h3 id="二义性文法">二义性文法</h3><p>定义：可生成带有两个不同分析树的串的文法称为二义性文法；<br><strong>判断文法是否有二义性的方法</strong>：<br>举反例，举出一个表达式，然后根据文法规则画语法分析树，如果能画出两棵不同的分析树，则证明该文法有二义性；</p><h3 id="二义性文法解决方法">二义性文法解决方法</h3><p>以if-else语句为例分析解决二义性具体做法：</p><ol><li>加上强制规则</li><li>重新构造语法（一定要出现else配对的情况）</li><li>使用一个与if匹配的关键字作为语句的结束，比如加个end if</li></ol><h4 id="解决二义性方法">解决二义性方法</h4><ol><li>设置一个限制规则，该规则可以在每个二义性情况下指出哪一个分析树（或语法树）是正确的。这样的规则称为<strong>消除二义性规则</strong>。<br>比如C语言中if else语句，else与if的搭配规则；</li><li>文法规则改造：将文法改为一个强制正确分析树的构造的格式<br>优点：解决问题彻底，使新文法适合于语法分析的自动生成；<br>缺点：改造过程复杂；</li><li>重新设计书写语法（最常用）</li></ol><h3 id="扩充BNF——NBNF">扩充BNF——NBNF</h3><p>前面讲到的文法的表示方法，常被称为BNF的表示方法<br>BNF表示方法的缺点：</p><ol><li>表达能力弱，符号不丰富</li><li>程序设计语言的控制结构有：顺序、重复和可选结构，而BNF的表示方法没有重复和可选的结构<br>引入两个新的运算符号，表达可选和重复，其实就类似于正则表达式中的可选和闭包。<br>EBNF中用{…}表示重复，用[…](中括号)表示闭包可选。</li></ol><h4 id="经典的BFA转换NBFA">经典的BFA转换NBFA</h4><p>\displaylines{A\to Aa|b(左递归)\\A \to aA|b(右递归)}</p><p>经过归约发现，左递归可以推导出这样一个句子集合/语言{b, ba, baa, baaa, …}，即右边b，左边a的闭包；<br>右递归可以推导出一个这样的句子集合/语言{ab,aab,aaab,…}；<br>用扩充的NBFA表示则为如下表示：</p><p>\displaylines{A \to b\{a\} \\ A \to \{a\}b}</p><p><strong>于是我们发现，使用扩充的BNF表达文法规则，可以消除一些递归表达</strong></p><h3 id="语法图">语法图</h3><p>用更直观的方式表达语法规则，类似于正则表达式的DFA。<br>每一个非终结符号的文法规则定义一个语法图：</p><ul><li>箭头：表示序列和选择</li><li>终结符：圆形框和椭圆形框</li><li>非终结符：方形框和矩形框</li></ul><h4 id="画语法图的步骤">画语法图的步骤</h4><ol><li>将文法规则转化为扩充的BNF表示形式，即EBNF的形式（可以消除递归表达）</li><li>再根据语法图的表示画图<br><strong>例子1</strong>：文法规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>→</mo><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">factor \to (exp) | number</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">mb</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span><br>语法图表示:<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509174243.png" alt="Pasted image 20240509174243"><br><strong>例子2</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mo stretchy="false">{</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A \to \{B\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span></span></span></span><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509174337.png" alt="Pasted image 20240509174337"><br><strong>例子3</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A \to [B]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span></span></span></span><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509174411.png" alt="Pasted image 20240509174411"><br>例题：画出下面两个的文法规则的语法图</li></ol><p>\displaylines{exp \to exp\ addop\ term | term\\term \to term\ mulop\ factor|factor}</p><p>经过实践发现，当含有文法中含有递归表达的时候，画语法图会出现死循环（具体可以看百度网盘18_二义性问题及语法图介绍），所以我们应该先将BNF转化为NBNF，所以扩充的BNF还有一个优点就是消除递归表达；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509175820.png" alt="Pasted image 20240509175820"><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240509175828.png" alt="Pasted image 20240509175828"></p><p>作业：</p><ol><li>云盘电子参考书P97 TINY语言语法树，用扩充BNF改写，特别是左递归；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】1. 基本概念</title>
      <link href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1>数据库系统的组成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">数据库系统 --&gt; 数据库DB &amp; 数据库管理系统DBMS &amp; 数据库应用 &amp; 用户</span><br></pre></td></tr></table></figure><h2 id="数据库管理系统和文件系统">数据库管理系统和文件系统</h2><p>对比传统的文件系统，数据库系统有如下优点：</p><ol><li>数据独立</li><li>减少开发时间（数据统一接口）</li><li>提供了对于大量数据的有效存取</li><li>多用户时保证数据的唯一性（订机票）</li><li>从灾难中恢复数据（停电等）</li><li>数据安全（对数据的访问权限）</li></ol><h2 id="数据库系统的三级模式结构">数据库系统的三级模式结构</h2><p>不同级别的用户对数据库形成不同的视图，不同级别的用户所“看到”的数据库是不同的。</p><ol><li>用户或应用程序员</li><li>建立和维护数据库人员</li><li>系统程序员</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">subgraph 用户或应用程序员</span><br><span class="line">direction TB</span><br><span class="line">应用1--&gt; 1(&quot;外模式1(视图定义)&quot;)</span><br><span class="line">应用2--&gt; 2(&quot;外模式2(视图定义)&quot;)</span><br><span class="line">应用3--&gt; 3(&quot;外模式3(视图定义)&quot;)</span><br><span class="line">end</span><br><span class="line">subgraph 建立和维护数据库人员</span><br><span class="line">4(&quot;概念模式(表结构)&quot;)</span><br><span class="line">end</span><br><span class="line">subgraph 系统程序员</span><br><span class="line">5(&quot;内模式(物理结构)&quot;)</span><br><span class="line">end</span><br><span class="line">用户或应用程序员 --&quot;外模式/概念模式映射&quot;--&gt; 建立和维护数据库人员</span><br><span class="line">建立和维护数据库人员 --&quot;概念模式/内模式映射&quot;--&gt; 系统程序员</span><br></pre></td></tr></table></figure><h3 id="举例说明三种模式的区别">举例说明三种模式的区别</h3><p>以学生成绩管理数据库系统为例；</p><h4 id="外模式（视图层）">外模式（视图层）</h4><p>应用程序能够隐藏数据类型的详细信息，视图也可以处于安全目的隐藏数据信息；<br>外模式是数据库信息的一个“视图”，不同的用户根据不同的需求展示不同的数据；<br>比如：数据结构老师看到的学生成绩，只包含学生的数据结构成绩和对应学生名单，这就是针对老师这个“用户”而呈现的数据库“视图”。而数据库老师的“视图”则是数据库成绩和对应学生的名单；</p><h4 id="概念模式（逻辑层）">概念模式（逻辑层）</h4><p>描述数据库中存储什么数据以及这些数据间存在什么关系；<br>实际在数据库中，只存放两张表保存数据：</p><ol><li>学生表，包含学生的学号、姓名、选课情况等等</li><li>成绩表，包含学号、课程名、相应分数<br>无论有多少种观察数据的需求，都是由这两张表的“切片”来组合出来呈现给用户的；</li></ol><h4 id="内模式（物理层）">内模式（物理层）</h4><p>系统程序员要考虑的是：如何将这两张表存储在文件中；所以系统程序员关心的是数据的存储结构，比如每条数据的记录结构组织成：控制信息+编号+姓名+…；每页数据以链表形式存储等等；</p><h4 id="三层架构">三层架构</h4><ul><li>对于一个数据库系统而言，只有物理级数据库是客观存在的，他是进行数据库操作的基础；</li><li>概念级数据库不过是物理机数据库的一种逻辑的、抽象的描述（<strong>即模式</strong>）；</li><li>用户级数据库则是用户与数据库的接口，它是概念级数据库的一个子集（<strong>即外模式</strong>）；</li></ul><h3 id="三级架构的优点">三级架构的优点</h3><ol><li>保证的数据的物理独立性：<br>数据的存储结构发生改变，不影响概念模式的变换，比如存储学生的学号从8位变为12位，不需要改变概念模式，所以概念模式到用户模式的映射也不会改变，应用程序也不用改变，保证了数据的物理独立性；</li><li>数据逻辑的独立性：<strong>外模式/概念模式映射就是逻辑独立性的关键</strong><br>当模式改变时，由数据库管理系统对各个外模式/模式映像作相应改变，可以使得外模式保持不变；<br>应用程序是依据数据库的外模式编写的，从而应用程序不必修改，保证了数据与程序的独立性，也就是数据的逻辑独立性；</li></ol><h3 id="三种模式的对比">三种模式的对比</h3><ol><li>内模式：在计算机物理结构中实际存储形式</li><li>概念模式：全体用户的公共数据视图</li><li>外模式：用户对数据的时机需求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据库系统】2. 关系代数</title>
      <link href="/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/2024/03/28/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="关系的定义">关系的定义</h3><p>关系代数有着坚实的数学基础；<br>先了解一下基本的数学概念：</p><ol><li>域：也是一个集合，代表着集合的数据范围；</li><li>笛卡尔积：一组域D1，D2，D3，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的笛卡尔积为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mn>1</mn><mo>×</mo><mi>D</mi><mn>2</mn><mo>×</mo><mi>D</mi><mn>3...</mn><mo>×</mo><msub><mi>D</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>d</mi><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mn>2</mn><mo separator="true">,</mo><mi>d</mi><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>D</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">D1 \times D2 \times D3 ... \times D_n = \{(d1,d2,d3,...,d_n) | d_i \in D_i, i = 1,...,n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord">3...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">d</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">}</span></span></span></span></li><li>关系：笛卡尔积的子集叫做在域D1，D2，…，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的关系，用R(D1, D2, D3, … <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)表示，关系是个<strong>多元组</strong>。<br>R是关系的名字，n是关系的元、度或目；</li><li>关系是笛卡尔积中<strong>有意义的子集</strong>，也可以表示为二维表；（例子：母亲集合与儿子集合的笛卡尔积）</li></ol><h3 id="关系的性质（6个）">关系的性质（6个）</h3><ol><li>列是同质的：即每一列的分量都来自同一域，是同一类型的数据；</li><li>不同的列可以来自同一域，每列必须有不同的属性名；（数学物理成绩，都是0-100的整数，来自同一域，但是不同列表明不同的成绩，必须要以属性名区分）</li><li>行的顺序无关紧要；</li><li>列的顺序无关紧要；</li><li>任意两个元组不能完全相同（集合内不能有两个相同的元素）；</li><li>每一分量必须是不可再分数据：满足这一条件的关系称为满足第一范式(1NF)的关系；（比如工资分为基本工资、职务工资、奖金，需要分为不同的列来表示）；<br><strong>第一范式是关系模式的基本条件</strong></li></ol><h2 id="关系的三种键-码">关系的三种键/码</h2><ol><li>候选键</li><li>主键</li><li>外部键</li></ol><h3 id="候选键">候选键</h3><ul><li>关系中的一个<strong>属性组</strong>，其值能够<strong>唯一标识一个元组</strong>。</li><li>若从属性组中去掉任何一个属性，它就不具备这一性质，这样的属性组称作候选键；（例如选课系统，学号、课程号、课程名，其中学号和课程名一起确定唯一一个同学的选课，这时学号和课程号一起称为候选键）</li><li>任何一个候选键里面的属性称作<strong>主属性</strong>。</li></ul><h3 id="主键">主键</h3><p>进行数据库设计时，从一个关系的多个候选键中选定一个作为主键。</p><h3 id="外键">外键</h3><p>关系R中的一个属性组，它不是R的主键，但它与另一个关系S的主键相对应，则称这个属性组为R的外部键；</p><h3 id="难点：找外键">难点：找外键</h3><p>外键与主键相关，所以要找外键先找主键，主键又是候选键的其中一个，所以先找候选键；<br>外键的四种情况：</p><ol><li>直接引用</li><li>改名引用</li><li>引用自己</li><li>作为主键的一部分引用</li></ol><h2 id="关系模型">关系模型</h2><h3 id="数据模型三要素">数据模型三要素</h3><ol><li>数据结构：描述数据模型的静态特征</li><li>数据操作：描述数据模型的动态特征</li><li>数据完整性：保证数据的正确性，完整性</li></ol><h3 id="关系模式">关系模式</h3><ul><li>关系的描述称为关系模式，包括关系名、关系中的属性名、属性—&gt;域的映象、属性间的数据依赖关系等等；<br>记作R(U,D,dom,F)，简记为R(U)或R(A1,A2,A3,…,An)</li><li>属性—&gt;域的映象一般直接说明为属性的类型、长度等</li><li>某一时刻对应某个关系模式的内容（元组的集合）称为关系</li><li>关系模式是型，是稳定的<br>关系是某一时刻的值，是动态变化的</li></ul><h3 id="关系数据库">关系数据库</h3><ul><li>其型是关系模式的集合，即数据库描述</li><li>其值是某一时刻关系的集合</li></ul><h3 id="关系操作">关系操作</h3><ul><li>关系操作是集合操作，操作对象及结果都是集合，试一次一集合的方式<br>而非关系型的数据操作方式是一次一记录</li><li>关系操作可以用关系代数和关系验算两种方式来表示，他们是相互等价的<br>用关系代数表示关系操作，可以有选择、投影、连接、除、交、差、并等等</li></ul><h3 id="关系模式的完整性">关系模式的完整性</h3><ol><li>实体完整性：<ul><li>关系的主键中的属性值不能为空值；</li><li>关系的主键值不能重复；</li><li>空值：不知道或无意义；</li></ul></li><li>参照完整性（引用完整性）<ul><li>如果关系R2的外键Fk与关系R1的主键Pk相对应，则R2中的每一个元组的Fk值或者等于R1中某个元组的Pk值，或者为空值；</li><li>外键不允许引用不存在的元组；</li></ul></li><li>用户定义完整性<ul><li>用户针对具体的应用环境定义的完整性约束条件（比如学号要求8位整数，性别必须是男或者女等等）</li></ul></li></ol><h1>关系代数</h1><p>关系代数是数据库操作的数学理论基础；<br>关系代数涉及到6种基本运算，4种附加运算；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">关系代数 --&gt; 基本运算 &amp; 附加运算</span><br><span class="line">基本运算 --&gt; 1(&quot;`Select 选择`&quot;) &amp; 2(&quot;Project 投影&quot;) &amp; 3(&quot;Union 并&quot;) &amp; 4(&quot;set difference 差(集合差)&quot;) &amp; 5(&quot;Cartesian product 笛卡尔积&quot;) &amp; 6(&quot;Rename 更名&quot;)</span><br><span class="line"></span><br><span class="line">附加运算 --&gt; 7(&quot;Set intersection 交&quot;) &amp; 8(&quot;Natural join 自然连接&quot;) &amp; 9(&quot;Division 除&quot;) &amp; 10(&quot;Assignment 赋值&quot;)</span><br></pre></td></tr></table></figure><h2 id="基本运算">基本运算</h2><h3 id="选择操作（从行的角度）">选择操作（从行的角度）</h3><p>符号简记：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span> 表示选择操作；<br>例如：选择A=B and D&gt;5的元组<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>D</mi><mo>&gt;</mo><mn>5</mn></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma _{A=B and D &gt; 5}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mord mathnormal mtight">an</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mrel mtight">&gt;</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></p><p>定义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>p</mi></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mtext> </mtext><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sigma _p(r) = \{t | t \in \ r \ and \  p(t)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)}</span></span></span></span>，其中p为选择谓词，由逻辑连词<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo><mtext>、</mtext><mo>∧</mo><mtext>、</mtext><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\vee 、\wedge 、\neg</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∨</span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">、</span><span class="mord">¬</span></span></span></span>连起来的公式。逻辑连词的运算对象可以是包含比较运算符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mtext>、</mtext><mo>&gt;</mo><mtext>、</mtext><mo>&lt;</mo><mtext>、</mtext><mo>≥</mo><mtext>、</mtext><mo>≤</mo></mrow><annotation encoding="application/x-tex">= 、&gt; 、&lt; 、\geq、\leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span></span></span>等；</p><h3 id="投影操作（从列的角度）">投影操作（从列的角度）</h3><p>投影可以提取属性，从关系R中取若干列组成新的关系；</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><mi>k</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod _{A_1,A_2,...,A_k}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∏</mo></mrow><annotation encoding="application/x-tex">\prod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span></span></span></span>读作pi，A是属性名，r为关系名；</li><li>其结果为保留k列的值，并<strong>删除重复的行</strong>；</li></ul><h3 id="广义笛卡尔积">广义笛卡尔积</h3><h4 id="元组的连串">元组的连串</h4><ul><li>若r = (r1，… ，rn)，s = (s1 ，… ，sm)，则定义r与s的连串为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mrow><mi>r</mi><mi>s</mi></mrow><mo stretchy="true">^</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>r</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>r</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>s</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\widehat{rs} = (r_1,r_2,...,r_n,s_1,s_2,...,s_m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7306em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">rs</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.3em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.3em' viewBox='0 0 2364 300' preserveAspectRatio='none'><path d='M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><h4 id="广义笛卡尔积-2">广义笛卡尔积</h4><ul><li>两个关系R，S，其度分别是n, m，则他们的笛卡尔积是所有这样元组的集合：元组的前n个分量是R中的一个元组，后m个分量是S中的一个元组；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的度为R与S的度之和（可能有重复名的度），元组个数为R和S的元组个数的乘积；<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mover accent="true"><mrow><mi>r</mi><mi>s</mi></mrow><mo stretchy="true">^</mo></mover><mtext> </mtext><mi mathvariant="normal">∣</mi><mi>r</mi><mo>∈</mo><mi>R</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>s</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \times S = \{ \widehat{rs} \ | r \in R \ and\ s \in S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">rs</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.3em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.3em' viewBox='0 0 2364 300' preserveAspectRatio='none'><path d='M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z'/></svg></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li></ul><h3 id="并运算">并运算</h3><ul><li>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∪</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>t</mi><mo>∈</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r \cup s = \{t | t\in r \ or\  t \in s\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∪</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>o</mi><mi>r</mi><mtext> </mtext><mi>t</mi><mo>∈</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r \cup s = \{t | t\in r\ or\ t \in s\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span>的条件：<ol><li>等目、同元，即他们的属性数目必须相同；</li><li>对于任意i，r的第i个属性域和第s个属性域相同；</li></ol></li></ul><h3 id="差运算">差运算</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>t</mi><mo mathvariant="normal">∉</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r - s = \{t | t \in r \ and \ t \notin s\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>−</mo><mi>s</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>t</mi><mo>∈</mo><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>t</mi><mo mathvariant="normal">∉</mo><mi>s</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">r - s = \{t \ | \ t \in r \ and \ t \notin s\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">}</span></span></span></span>的条件：<ol><li>等目，同元，即他们的属性数目必须相同；</li><li>对于任意i，r的第i个属性域和s的第i个属性域相同；</li></ol></li></ul><h3 id="更名运算">更名运算</h3><p>允许我们使用其他名字指代关系；<br>例如：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mo lspace="0em" rspace="0em">×</mo></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho_{\times}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2583em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">×</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>, 返回表达式E的结果，并把名字X赋给了它。<br>也可以对关系E以及其属性都重命名：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mrow><mo>×</mo><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\rho_{\times(A_1,A_2,...A_n)}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord mathnormal">ρ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">×</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>, 返回表达式E的结果并赋给它名字X，同时将属性重命名为A1，A2，A3，…,An；</p><h3 id="连接运算">连接运算</h3><p>当查询要求涉及到多个关系时，常用到连接运算；</p><h4 id="theta连接"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>连接</h4><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>连接：从两个关系的广义笛卡尔积中选取给定属性间满足一定条件的元组$$R \underset{A\theta B}{\Join} S = {\widehat{rs}| r \in R \wedge s \in S \wedge r[A] \theta s[B]} = \sigma_{r[A]\theta s[B]}(R \times S)$$<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>是模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\cup S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>属性上的谓词，A和B分别为R和S上度数相等且可比的属性列；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>连接是自然连接的扩展</li><li>当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>是等号的时候称为等值连接</li></ul><h4 id="自然连接">自然连接</h4><p>从两个关系的广义笛卡尔积中选取在相同属性列B上取值相等的元素组，并且去掉重复的列；</p><ul><li>定义：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mover accent="true"><mrow><mi>r</mi><mi>s</mi></mrow><mo stretchy="true">^</mo></mover><mi mathvariant="normal">∣</mi><mi>r</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>s</mi><mo>∈</mo><mi>S</mi><mo>∧</mo><mi>r</mi><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \Join S = \{\widehat{rs} | r \in R \wedge s \in S \wedge r[B]=s[B]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">rs</span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.3em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.3em' viewBox='0 0 2364 300' preserveAspectRatio='none'><path d='M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z'/></svg></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">]}</span></span></span></span></li><li>例如：R=(A, B, C, D), S=(E, B, D)<ul><li>关系r和s的自然连接结果模式为：(A, B, C, D, E)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>⋈</mo><mi>s</mi><mo>=</mo><msub><mo>∏</mo><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>A</mi><mo separator="true">,</mo><mi>r</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo separator="true">,</mo><mi>r</mi><mi mathvariant="normal">.</mi><mi>C</mi><mo separator="true">,</mo><mi>r</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>E</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>=</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>B</mi><mo>∧</mo><mi>r</mi><mi mathvariant="normal">.</mi><mi>D</mi><mo>=</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>D</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo>×</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \Join s = \prod_{r.A,r.B,r.C,r.D,s.E}(\sigma_{r.B = s.B \wedge r.D = s.D}(r \times s))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.51em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">A</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">s</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">s</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">∧</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">s</span><span class="mord mtight">.</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">))</span></span></span></span><br>自然连接与等值连接的不同：</li></ul></li></ul><ol><li>自然连接中相等的分量必须是相同的属性组，并且要在结果中去掉重复的属性；</li><li>等值连接相等的分量不要求是相同的属性组，只要求可比；</li><li>等值连接不去掉重复的属性；</li></ol><ul><li>当R与S无相同的属性时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi><mo>=</mo><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \Join S = R \times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li></ul><h3 id="除运算">除运算</h3><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>÷</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r \div s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>适用于包含了“<strong>对所有的</strong>”此类短语的查询，类似于“打包”的操作；</li><li>例如：查询选修了所有课程的学生的学号</li></ul><p>定义：设r和s分别代表模式R和S的关系</p><ul><li>R=(A1, A2, …, Am, B1,B2, …, Bn)</li><li>S=(B1, B2, …, Bn)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>÷</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r \div s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>的结果代表模式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R - S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>的关系：<ol><li>R-S=(A1, A2, …, Am)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>÷</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><msub><mo>∏</mo><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi mathvariant="normal">∀</mi><mi>u</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>t</mi><mi>u</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \div S = \{t | t \in \prod_{R-S}(R) \ and \ \forall u \in S(tu \in R) \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.108em;vertical-align:-0.358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord">∀</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)}</span></span></span></span></li></ol></li></ul><p>性质：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mo>÷</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">q=r\div s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，则q是满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>×</mo><mi>s</mi><mo>⊆</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">q \times s \subseteq r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 的最大关系；<br>用基本代数运算来定义除运算：</p><ul><li>设r®和s(S)已知，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>R</mi><mo>:</mo></mrow><annotation encoding="application/x-tex">S \subseteq R:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span></span></span></span><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mo>÷</mo><mi>s</mi><mo>=</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>−</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>×</mo><mi>s</mi><mo stretchy="false">)</mo><mo>−</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \div s = \prod \ _{R-S}(r) - \prod \ _{R-S}((\prod \ _{R-S}(r) \times s) - \prod \ _{R-S,S}(r))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">((</span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">))</span></span></span></span></span></p></li><li>原理：<ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_{R-S}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.108em;vertical-align:-0.358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>是候选的查询结果，需要减去不满足条件的结果；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∏</mo><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>×</mo><mi>S</mi><mo>−</mo><msub><mo>∏</mo><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_{R-S}(r) \times S - \prod_{R-S}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.108em;vertical-align:-0.358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.108em;vertical-align:-0.358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>表示的是不满足条件的结果；</li></ol></li></ul><iframe src="http://player.bilibili.com/player.html?aid=590586046&bvid=BV1zq4y1f7oL&cid=408800409&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 640px; height:430px; max-width:100%"> </iframe>**视频来源：B站up主[枫林骁蕊](https://space.bilibili.com/675441250)**如有侵权，请联系我删除<h3 id="赋值运算">赋值运算</h3><p>赋值运算(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\gets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>)可以使得复杂的查询表达变得简单</p><ul><li>使用赋值运算，可以把一个查询表达为一个顺序程序，该程序包括：<ol><li>一系列赋值</li><li>一个其值被作为查询结果显示的表达式</li></ol></li><li>对关系代数查询而言，赋值必须是赋值给一个<strong>临时关系变量</strong><br>例如：可以把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>÷</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r \div s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>写作：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mn>1</mn><mo>×</mo><mi>s</mi><mo>−</mo><mo>∏</mo><msub><mtext> </mtext><mrow><mi>R</mi><mo>−</mo><mi>S</mi><mo separator="true">,</mo><mi>S</mi></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>←</mo><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mn>1</mn><mo>−</mo><mi>t</mi><mi>e</mi><mi>m</mi><mi>p</mi><mn>2</mn></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} temp1 &amp;\gets \prod \ _{R-S}(r) \\ temp2 &amp;\gets \prod \ _{R-S}(temp1 \times s - \prod \ _{R-S,S}(r)\\ result &amp;\gets temp1 - temp2\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.3em;vertical-align:-2.4em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9em;"><span style="top:-4.9em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord">1</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord">2</span></span></span><span style="top:-1.31em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord mathnormal">res</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9em;"><span style="top:-4.9em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∏</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mspace"> </span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.00773em;">R</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span><span style="top:-1.31em;"><span class="pstrut" style="height:3.05em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">m</span><span class="mord mathnormal">p</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9em;"><span style="top:-4.9em;"><span class="pstrut" style="height:3.05em;"></span><span class="eqn-num"></span></span><span style="top:-3em;"><span class="pstrut" style="height:3.05em;"></span><span class="eqn-num"></span></span><span style="top:-1.31em;"><span class="pstrut" style="height:3.05em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4em;"><span></span></span></span></span></span></span></span></span></p><h3 id="外连接">外连接</h3><ul><li><p>外连接运算是连接运算的扩展，可以处理缺失信息；</p></li><li><p>保留一侧关系中所有与另一侧关系的任意元组都不匹配得元组，再把产生的元组加到自然连接的结构上</p></li><li><p>使用空值：</p><ul><li>空值表示不知道或者不存在</li></ul></li><li><p>外连接的符号表示：对于两个关系r和s<br>左外连接：r ⟕ s<br>右外连接：r ⟖ s<br>全外连接：r ⟗ s</p></li></ul><h3 id="关系代数的聚集运算">关系代数的聚集运算</h3><p>聚集运算的形式通常如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow></mrow><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>A</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{G_1,G_2,...,G_n}\mathcal{G}_{F_1(A_1),F_2(A_2),...,F_n(A_n)}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p><p>其中，E是关系代数表达式，也可以理解为一个未命名的关系，实际上也是元组集合；<br>F是聚集函数，A是E的属性；<br>G是用于分组的一系列属性；</p><p><strong>该运算的含义如下</strong>：<br>表达式E的结果中，元组以如下的方式分成若干组：</p><ul><li>同一个组中所有元组在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上的值都相同；</li><li>不同组中元组在这些属性上的值不同；<br>各组属性可以由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>G</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">G_1,G_2,G_3,...,G_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的值唯一标识；<br>对于每一个组来说，其结果都有且仅有一个结果（因为聚集函数接受一个元组集合，返回一个值）元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>（</mtext><msub><mi>g</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>g</mi><mn>3</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>g</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub><mtext>）</mtext></mrow><annotation encoding="application/x-tex">（g_1,g_2,g_3,...g_n,a_1,a_2,...,a_n）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span> ，其中每个a都是由聚集函数F作用于该组所有元素在A属性上的结果；</li></ul><p><strong>举例说明</strong>：求出每个系的平均工资<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow></mrow><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><msub><mi mathvariant="script">G</mi><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">_{dept\_name}\mathcal{G}_{avg(salary)}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">pt</span><span class="mord mtight" style="margin-right:0.02778em;">_</span><span class="mord mathnormal mtight">nam</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathcal" style="margin-right:0.0593em;">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0593em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">vg</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">ry</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">in</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mclose">)</span></span></span></span><br>上面的例子中，对instructor教师表，按照dept_name属性分成每个系的教书组，然后对每个系的教师求平均工资；</p><h2 id="关系运算优先级">关系运算优先级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">投影 --&gt; 选择 --&gt; 笛卡尔积 --&gt; 1(连接/除) --&gt; 交 --&gt; 2(并、差)</span><br></pre></td></tr></table></figure><h2 id="空值">空值</h2><p>元组的某些属性值是可以为空的，null表示未知值或值不存在</p><ul><li>涉及空的任何算术表达式的结果为空</li><li>涉及空的任何比较运算，结果是unknown(未知)，unknown相当于一个新的布尔值</li><li>为了消除重复和分组，空值和其他值同等对待<br>在数据库语言SQL中要判断某字段是否为空（不为空）要使用谓词：<strong>Is Null(Is not Null)</strong></li></ul><h3 id="空值——布尔运算">空值——布尔运算</h3><p>使用特殊值的三值逻辑：</p><ol><li>在或运算中，true的强度是最高的，只要有一个为true，则整个表达式为true；<br>unknown永远处于true和false中间；</li></ol><ul><li>OR：(unknown or true) = true<br>(unknown or false) = unknown<br>(unknown or unknown) = unknown</li></ul><ol start="2"><li>在与运算中，false的强度是最高的，只要有一个为false，则整个表达式为false；</li></ol><ul><li><p>AND：(unknown and true) = unknown<br>(unknown and false) = false<br>(unknown and unknown) = unknown</p></li><li><p>NOT：(not unknown) = unknown</p></li></ul><h4 id="例题">例题</h4><p><strong>注意：</strong> 如果最后只剩下unkown，就返回false，最后为null不能换成false，还是null</p><ol><li>(3*null&gt;0) or (null &lt; 15) = unkonwn = false</li><li>not((Null = Null)) and (Null &lt;&gt; Null) = not(unkonwn) and unkown = unkown and unkown= false</li></ol><h3 id="空值——聚合运算">空值——聚合运算</h3><p>聚合运算忽略空值，<strong>除了Count(*)以外</strong>；<br>聚合运算：求avg，count，mean等，接受一个集合，返回一个值；</p><h3 id="空值——Distinct和分组运算">空值——Distinct和分组运算</h3><p>Distinct和分组运算，所有null作为一个值(组)处理；<br>例如：<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240401161534.png" alt="Pasted image 20240401161534"></p><h3 id="空值——排序">空值——排序</h3><p>用ORDER BY子句对查询结果排序：</p><ul><li>如果按升序排序，则为控制的元组将最后展示；  order by salary asc</li><li>如果按降序排，则为控制的元组最先显示；</li></ul><h3 id="数据库的修改">数据库的修改</h3><ul><li>数据库的内容可以使用下面的操作来修改：<ul><li>删除  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>←</mo><mi>r</mi><mo>−</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">r \gets r - E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li><li>插入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>←</mo><mi>r</mi><mo>∪</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">r \gets r \cup E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></li><li>更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>←</mo><msub><mo>∏</mo><mrow><msub><mi>F</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>F</mi><mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r \gets \prod_{F_1,F_2,...,F_n}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1858em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1786em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.1389em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li></ul></li><li>所有这些操作都使用赋值操作表示</li></ul><h2 id="查询情况分类">查询情况分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">关系代数的查询类型 --&gt; 1(&quot;`**满足**什么条件`&quot;) &amp; 2(&quot;`**不满足**什么条件/**仅**、**只**满足什么条件`&quot;) &amp; 3(&quot;`**全部**、**所有**等`&quot;)</span><br><span class="line">1 --&gt; 连接运算</span><br><span class="line">2 --&gt; 差运算</span><br><span class="line">3 --&gt; 除运算</span><br></pre></td></tr></table></figure><h3 id="针对“满足什么条件”这一类应用的通用方法">针对“满足什么条件”这一类应用的通用方法</h3><ol><li>先根据条件和结论分析出涉及到的关系</li><li>先写连接，再给出所有条件（选择），最后列出所有属性（投影）<br>例题：查询选修数据库原理课程且成绩在90分以上的学生姓名以及成绩<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240508201815.png" alt="Pasted image 20240508201815"></li></ol><h3 id="针对“不满足什么条件”-“仅满足…运算”的应用——差运算">针对“不满足什么条件”/“仅满足…运算”的应用——差运算</h3><ol><li>用“所有的”减去“满足条件的”；<br>示例1：求未选修c1号课程的学生号<br>思路：用所有学生号减去所有选修了c1的学生号</li></ol><p>示例2：求仅选修了C01课程的学生号<br>思路：找出选择了C01课程的学生号-选了非C01课程的学生号（包括未选C01课程的学生）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240508202821.png" alt="Pasted image 20240508202821"></p><h3 id="针对“所有”类型的应用——除法运算">针对“所有”类型的应用——除法运算</h3><p>典例：<br>选择所有选择了课程号为“001”和“002”的学生姓名，这里把课程号当做课程来演示，对比一下两个表达式。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240508203329.png" alt="Pasted image 20240508203329"><br>启示：</p><ul><li>作除法时，<strong>把无关属性都先去掉（投影</strong>），否则可能会因为象集产生与预料不同的结果；<br>在下面第二个表达式，作除法运算中，两个关系SC和C的公共属性是课程，非公共属性是（姓名,成绩），所以（王红，86）和（王红，92）在“打包”的过程中，视为不同的“包裹”<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240331082948.png" alt="Pasted image 20240331082948"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】2. 处理器管理</title>
      <link href="/2024/03/21/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/21/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%912.%20%E5%A4%84%E7%90%86%E5%99%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1>进程的概念、组成、特征</h1><h3 id="感性认知">感性认知</h3><p>程序：是静态的，存放在硬盘里的可执行文件，就是一系列指令集合<br>进程：动态的，是程序的一次执行过程，同一个程序的多次执行会对应多个进程；当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证标识”——PID（Process ID）</p><h3 id="PCB-进程控制块">PCB 进程控制块</h3><p>在创建进程后，操作系统要记录进程号PID，进程所属用户ID（UID），还要记录给该进程分配了什么资源、多少资源，该进程的运行情况等等；<br>这些记录的信息都被保存在一个数据结构<strong>PCB（Process Control Block）中，即进程控制块。<br>操作系统需要对各个并发的进程进行管理，但凡管理时所需要的信息，都会被存放在PCB中</strong></p><p>概念：进程控制块是操作系统用于记录和描述进程状态以及有关信息的数据结构；<br>一般而言，进程控制块应该包含四类信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程控制块 --&gt; 1[标识信息, PID] &amp; 2[说明信息，说明本进程的状况] &amp; 3[现场信息] &amp; 4[管理信息, 对进程的管理和调度]</span><br></pre></td></tr></table></figure><h3 id="进程的概念和组成">进程的概念和组成</h3><p>概念：进程是可并发执行的程序在一个数据集上的一次执行过程，它是系统进行资源分配的基本单位；<br>程序段、数据段、PCB三部分组成了<strong>进程实体</strong>（进程映像/进程上下文）；<br><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的组成 --&gt; PCB &amp; 程序段 &amp; 数据段</span><br><span class="line">PCB --&gt; 进程描述信息 &amp; 进程控制和管理信息 &amp; 资源分配清单 &amp; 处理机相关信息</span><br><span class="line">程序段 --&gt; 程序代码</span><br><span class="line">数据段 --&gt; 运行过程中产生的各种数据</span><br></pre></td></tr></table></figure><h3 id="进程的特征">进程的特征</h3><p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的特征 --&gt; A(动态性, 最基本的特征) &amp; B(并发性) &amp; C(独立性) &amp; D(异步性) &amp; E(结构性)</span><br><span class="line">A --&gt; F(进程是程序的一次执行过程&lt;/br&gt;是动态地产生、变化和消亡的)</span><br><span class="line">B --&gt; G(内存中有多个进程实体&lt;/br&gt;各进程可以并发执行)</span><br><span class="line">C --&gt; H(进程是能独立运行&lt;/br&gt;独立获得资源&lt;/br&gt;独立接受调度的基本单位)</span><br><span class="line">D --&gt; I(各进程按各自独立的、不可预知的速度向前推进&lt;/br&gt;操作系统要提供“进程同步机制”&lt;/br&gt;来解决异步问题)</span><br><span class="line">E --&gt; J(每个进程都会配置一个PCB&lt;/br&gt;结构上看，进程由程序段、数据段、&lt;/br&gt;PCB组成)</span><br></pre></td></tr></table></figure><h1>进程的状态与转换、进程的组织</h1><h2 id="进程的状态-——-创建态，就绪态，运行态，阻塞态，终止态">进程的状态 —— 创建态，就绪态，运行态，阻塞态，终止态</h2><h3 id="进程的状态">进程的状态</h3><p><strong>进程PCB中，会有一个变量state表示进程的当前状态。</strong> 如：1表示创建态、2表示就绪态…；为了对同一个状态下的各个进行进行统一的管理，操作系统会将各个进程的PCB组织起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">三种基本状态 --&gt; 运行态 &amp; 就绪态 &amp; 阻塞态</span><br><span class="line">运行态 --&gt; 占有CPU且在CPU上运行</span><br><span class="line">就绪态 --&gt; A(已经具备运行条件但由于&lt;/br&gt;没有空闲的CPU，暂时不能运行, 比如进行IO操作)</span><br><span class="line">阻塞态 --&gt; 因等待某一事件而暂时不能运行</span><br><span class="line"></span><br><span class="line">另外两种状态 --&gt; 创建态 &amp; 终止态</span><br><span class="line">创建态 --&gt; B(进程正在被创建，操作系统&lt;/br&gt;为进程分配资源、初始化PCB)</span><br><span class="line">终止态 --&gt; C(进程正在从系统撤销，操作系统&lt;/br&gt;回收进程拥有的资源、撤销PCB)</span><br></pre></td></tr></table></figure><h3 id="进程状态的转换">进程状态的转换</h3><p><strong>注意</strong>：不能直接由阻塞态转为运行态，也不能直接由就绪态直接转换成阻塞态；因为进入阻塞态是主动请求的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">direction LR </span><br><span class="line">创建态 --&gt; 就绪态 : 系统完成创&lt;/br&gt;建进程的&lt;/br&gt;一系列工作</span><br><span class="line">就绪态 --&gt; 运行态 : 进程被调度</span><br><span class="line">运行态 --&gt; 就绪态 : 时间片到&lt;/br&gt;或处理机被抢占</span><br><span class="line">运行态 --&gt; 终止态 : 进程运行结束&lt;/br&gt;运行过程遇到&lt;/br&gt;不可修复错误</span><br><span class="line">运行态 --&gt; 阻塞态 : 进程用“系统调用”的方式&lt;/br&gt;申请某种系统&lt;/br&gt;资源，或者请求&lt;/br&gt;等待某个事情发生</span><br><span class="line">阻塞态 --&gt; 就绪态 : 申请的资源被分配&lt;/br&gt;等待的事件发生</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="进程的组织-——-链接方式，索引方式">进程的组织 —— 链接方式，索引方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程的组织方式 --&gt; A(&quot;`链接方式(**主要方式**)`&quot;) &amp; 索引方式</span><br><span class="line">A --&gt; B[&quot;`按照**进程状态**将PCB分为多个队列`&quot;] &amp; 操作系统持有指向各个队列的指针</span><br><span class="line">索引方式 --&gt; 根据进程状态不同建立不同索引表 &amp; 操作系统持有指向各个索引表的指针</span><br></pre></td></tr></table></figure><p><strong>链接方式</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240321181331.png" alt="Pasted image 20240321181331"><br><strong>索引方式</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240321181402.png" alt="Pasted image 20240321181402"></p><h1>进程控制</h1><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。<br>本质上：进程控制就是要实现进程状态的转换</p><p><strong>如何实现进程控制（用原语实现）</strong><br>原语是内核中的一种程序，它的执行具有原子性，运行必须一气呵成，不可被中断。<br><strong>如何实现原语的“原子性”</strong><br>用“关中断指令”和“开中断指令”这两个特权指令实现原子性。CPU执行了关终端指令后，就不会再例行检查中断信号，直到执行开中断指令才会再次进行例行检查。<br>原语的执行是屏蔽中断的；</p><h2 id="进程控制概览">进程控制概览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程控制 --&gt; 相关概念 &amp; 相关原语</span><br><span class="line">相关概念 --&gt; B(进程控制就是要&lt;/br&gt;实现进程状态的转换) &amp; C(进程控制要&lt;/br&gt;用原语实现)</span><br><span class="line">C --&gt; A(&quot;`原语用**开/关**中断实现`&quot;) &amp; 原语是一种特殊的程序 &amp; 原语的执行必须一气呵成</span><br><span class="line">相关原语 --&gt; 进程创建 &amp; 进程终止 &amp; 进程阻塞 &amp; 进程唤醒 &amp; 进程切换</span><br><span class="line">进程阻塞 &amp; 进程唤醒 --&gt; 成对出现</span><br></pre></td></tr></table></figure><h2 id="进程控制原语">进程控制原语</h2><p>无论哪个进程控制的原语，要做的都无非是这三类事情：</p><ol><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h1>进程通信</h1><p>进程间的通信（Inter-Process Communication, IPC）是指两个进程之间产生数据交互。<br>进程是分配系统资源的单位（包括内存地址空间），因此个进程拥有的内存地址空间相互独立。<strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间。为了进程之间能够通信，必须由操作系统参与实现。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程通信方式 --&gt; 共享存储 &amp; 消息传递 &amp; 管道通信</span><br></pre></td></tr></table></figure><h2 id="共享存储">共享存储</h2><p>开辟一个共享存储空间，其他进程都可以对这片空间进行读写。<br>但是为了避免出错，各个进程对共享空间的访问应该是互斥的，操作系统内核提供同步互斥工具（比如P，V操作）来实现互斥的访问。<br>共享存储有两种方式：</p><ol><li>基于存储区的共享：操作系统在内存中画出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种方式速度快，是一种高级的通信方式。</li><li>基于数据结构的共享：比如共享空间只能放一个长度为10的数组，这种共享方式速度慢、限制多，是一种低级的通信方式。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">共享存储 --&gt; 基于数据结构的共享 &amp; 基于存储区的共享</span><br></pre></td></tr></table></figure><h2 id="消息传递">消息传递</h2><p>进程间的数据交换以<strong>格式化的消息</strong>为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。<br>消息传递也有两种方式：</p><ol><li>直接通信方式（直达）：需要指明接收消息的ID，接收消息的进程也需要指明发生消息的进程ID</li><li>间接通信方式（邮箱）</li></ol><h2 id="管道通信">管道通信</h2><p>从一端写入数据，另一端接收数据，且数据的流通是单向的。<br>在操作系统中，“管道”是一个特殊的共享文件，又名pipe文件，其实就是在内存中开开辟一个<strong>大小固定的内存缓冲区</strong>，但是数据的读写是先进先出的（FIFO）。<br><strong>进程P只能写数据，进程Q只能读数据，先写的数据先被读出。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程P --&gt; 管道 --&gt; 进程Q</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>管道通信只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则需要设置两个管道。</li><li>各个进程要互斥地访问管道。</li><li><strong>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</strong></li><li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失，因此，当多个进程同时读写管道时，可能会出现错乱。<br>对此，通常有两种解决方案：<ul><li>一个管道允许多个写进程，一个读进程；</li><li>允许多个写进程，多个读进程，但是操作系统会让各个读进程轮流从管道读取数据（LINUX方案）</li></ul></li></ol><h1>线程</h1><h2 id="线程的概念">线程的概念</h2><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，==线程是可以独立参与调度的基本单位==！<br>引入线程之后，不仅使得进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发性，使得一个进程内部也可以并发处理各种任务（如QQ，视频，文字聊天等等）<br>引入线程之后，进程只作为除了CPU之外的系统资源的分配单元。</p><ul><li>进程是资源分配的基本单位</li><li>线程是cpu调度的最小单位</li></ul><h3 id="引入线程之后的变化">引入线程之后的变化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">变化 --&gt; A(资源分配) &amp; B(并发性) &amp; C(系统开销)</span><br><span class="line">A --&gt; D(传统进程机制中，进程是资源分配调度的基本单位) &amp; E(引入线程后，进程是资源分配&lt;/br&gt;的基本单位，线程是调度的基本单位)</span><br><span class="line">B --&gt; 1(传统进程机制中，只能进程间并发) &amp; 2(引入线程后，各线程间也能并发)</span><br><span class="line">C --&gt; 3(传统进程间的并发，需要切换进程的&lt;/br&gt;运行环境，系统开销很大) &amp; 4(线程并发，如果是同一进程内&lt;/br&gt;的线程切换，则不需要切换进程环境，系统开销小)</span><br></pre></td></tr></table></figure><h2 id="线程的实现方式和多线程模型">线程的实现方式和多线程模型</h2><h3 id="概览">概览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">线程 --&gt; 实现方式 &amp; 多线程模型</span><br><span class="line">实现方式 --&gt; 用户级线程 &amp; 内核级线程</span><br><span class="line">多线程模型 --&gt; 一对一 &amp; 多对一 &amp; 多对多</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用户级线程和内核级线程">用户级线程和内核级线程</h2><p>用户级线程下，操作系统并不能感知到线程的存在，还是以进程作为资源调度和分配的基本单位，只是程序员在程序中人为地设置不同进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">用户级线程 --&gt; 1(优点：线程在用户态切换，&lt;/br&gt;线程管理开销小，不需要切换到核心态) &amp; 2(缺点：当一个线程被阻塞，整个进程&lt;/br&gt;都会被阻塞，并发度不高)</span><br></pre></td></tr></table></figure><p>内核级线程是在操作系统层面的线程，内核级线程的管理工作由操作系统内核完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">内核级线程 --&gt; 1(优点：并发能力强，一个线程阻塞，别的线程还能执&lt;/br&gt;行。多线程可以在多核处理机上执行) &amp; 2(一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成&lt;/br&gt;线程管理成本高，开销大)</span><br></pre></td></tr></table></figure><h2 id="多线程模型">多线程模型</h2><h3 id="一对一模型">一对一模型</h3><p>一个用户级线程映射到一个内核级线程。</p><h3 id="多对一模型">多对一模型</h3><p>多个用户级线程映射到一个内核级线程。</p><h3 id="多对多模型">多对多模型</h3><p>n用户级线程映射到m个内核级线程(n&gt;=m)。</p><h2 id="线程的状态与转换">线程的状态与转换</h2><p>线程的状态与转换和进程的逻辑基本一致。<br>线程的组织与控制与进程的组织与控制也基本一致。<br>进程由PCB保存关键信息，线程由TCB保存关键信息。<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240325080217.png" alt="Pasted image 20240325080217"></p><h2 id="处理机调度">处理机调度</h2><p><strong>调度的基本概念：</strong><br>当有一堆任务要处理，由于资源有限，这些事情无法同时处理，这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”要解决的问题。</p><h3 id="调度的三个层次">调度的三个层次</h3><ol><li>高级调度（作业调度）<br>作业：一个具体的任务。</li><li>低级调度（进程调度/处理机调度）<br>进程调度频率很高，一般几十毫秒一次。</li><li>中级调度（内存调度）<br>内存不够时，可将某些进程的数据调出外村，等内存空闲或者进程需要运行时再重新调入内存。</li></ol><h2 id="进程调度的时机">进程调度的时机</h2><p>进程再操作系统<strong>内核程序临界区</strong>中不能进行调度与切换。<br>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源；<br>临界区：访问临界资源的那段代码；<br>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><h2 id="作业（补充）">作业（补充）</h2><h3 id="相关概念">相关概念</h3><p>概念：用户在一次解题过程中要求计算机所做的工作的集合；<br>作业运行的步骤：</p><ol><li>编辑：写源程序</li><li>编译：源程序被编译成机器指令，形成目标代码程序</li><li>链接装配：将目标代码以及调用的各种库代码链接装配成一个可执行程序</li><li>运行：可执行程序装入内存并提供程序运行时所需要的数据，运行程序并产生结果</li></ol><h1>调度算法</h1><h2 id="调度算法的评价指标">调度算法的评价指标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法的平均指标 --&gt; CPU利用率 &amp; 3[&quot;系统吞吐量, 单位时间内让更多进程完成工作&lt;/br&gt;提高单位时间的处理能力&quot;] &amp; 周转时间 &amp; 等待时间 &amp; 响应时间</span><br><span class="line">周转时间 --&gt; 1(周转时间、平均周转时间) &amp; 2(带权周转时间、平均带权周转时间)</span><br></pre></td></tr></table></figure><ol><li>CPU利用率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>利用率</mtext><mo>=</mo><mfrac><mtext>忙碌时间</mtext><mtext>总时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">利用率=\frac{忙碌时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">利用率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">忙碌时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>系统吞吐量  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>系统吞吐量</mtext><mo>=</mo><mfrac><mtext>总共完成了多少道作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">系统吞吐量=\frac{总共完成了多少道作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">系统吞吐量</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共花了多少时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">总共完成了多少道作业</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>周转时间：作业提交给系统开始，到作业完成为止。  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>作业周转时间</mtext><mo>=</mo><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><annotation encoding="application/x-tex">作业周转时间=作业完成时间-作业提交时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均周转时间</mtext><mo>=</mo><mfrac><mtext>各作业周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均周转时间=\frac{各作业周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>带权周转时间</mtext><mo>=</mo><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">带权周转时间=\frac{作业周转时间}{作业实际运行时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业实际运行时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业周转时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>平均带权周转时间</mtext><mo>=</mo><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mrow><annotation encoding="application/x-tex">平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">平均带权周转时间</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">作业数</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">各作业带权周转时间之和</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>等待时间  进程/作业处于等待处理机状态时间之和（在就绪态中的时间），等待时间越长，用户满意度越低；<br><strong>进程等待时间：</strong> 进程建立后等待被服务的时间之和；<br>作业等待时间：不仅要考虑进程建立后的等待时间，还要作业在外存后备队列中等待的时间；</li><li>响应时间：用户提交请求到首次产生响应所用的时间；</li></ol><h2 id="早期批处理调度算法">早期批处理调度算法</h2><h3 id="知识总览">知识总览</h3><p>早期的批处理系统采用的调度算法，这些算法对“响应时间”这个指标并不关心，也不区分任务紧急程度。考虑的是系统整体的性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法 --&gt; 1(&quot;先来先服务(FCFS)&quot;) &amp; 2(&quot;短作业优先(SJF)&quot;) &amp; 3(&quot;高响应比优先(HRRN)&quot;)</span><br></pre></td></tr></table></figure><h3 id="短作业优先">短作业优先</h3><p><strong>注意：</strong></p><ol><li>如果未特别说明，短作业优先算法都默认是“非抢占式”的；</li><li>所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转最少；或者说，在所有进程都几乎同时到达时，SJF调度算法的平均等待时间、平均周转时间最少；</li><li>抢占式的但作业/进程优先调度算法（SRNT）的平均等待时间、平均周转时间最少；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">短作业优先 --&gt; 1(&quot;非抢占式短作&lt;/br&gt;业优先(Shortest Job First)&quot;) &amp; 2(&quot;抢占式短作业&lt;/br&gt;优先，又称“最短剩余&lt;/br&gt;时间优先“&lt;/br&gt;算法(SRTN)&quot;)</span><br><span class="line">1 --&gt; 3(&quot;`算法：每次调度时选择**当前已到达**且**运行时间最短**的作业/进程`&quot;)</span><br><span class="line">2 --&gt; 4(&quot;算法：每当有进程加入就&lt;/br&gt;绪队列改变时就需要调度&lt;/br&gt;如果新到达的进程剩余时间比当&lt;/br&gt;前运行的进程剩余时间更短&lt;/br&gt;则由新进程抢占处理机, 当&lt;/br&gt;前运行进程重新回到就绪队列&lt;/br&gt;另外, 当一个进程完成时也需要调度&quot;)</span><br></pre></td></tr></table></figure><h3 id="高响应比优先算法">高响应比优先算法</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>响应比</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">响应比 = \frac{等待时间+要求服务时间}{要求服务时间} \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">响应比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">要求服务时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">等待时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><ol><li><strong>非抢占式</strong>调度算法：<br>只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进程调度，调度时<strong>计算所有就绪进程的响应比，选择响应比最高的</strong>进程上处理机。</li></ol><h2 id="调度算法">调度算法</h2><h3 id="知识总览-2">知识总览</h3><p>更关心&quot;响应时间&quot;，这几种算法更加适合交互式系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">调度算法 --&gt; 时间片轮转调度算法 &amp; 优先级调度算法 &amp; 多级反馈队列调度算法</span><br></pre></td></tr></table></figure><h3 id="时间片轮转">时间片轮转</h3><ol><li>算法思想：公平地、轮流地为各个进程服务，让每个进程再一定时间间隔内都可以得到响应；</li><li>算法规则：按照进程到达就绪队列的顺序，轮流地让各个进程执行一个时间片。若进程未再一个时间片执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。<br><strong>显然，这个是抢占式算法</strong><br><strong>注意：</strong></li></ol><ul><li>如果时间片太大，使得每个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li><li>时间片如果太小，由于进程切换过于频繁，会导致实际用于进程执行时间比例减少。</li><li>一般来说，设计时间片要让切换进程的开销占比不超过1%</li></ul><ol start="3"><li>优缺点：</li></ol><ul><li>优点：<ul><li>公平，响应快，适用于分时操作系统</li></ul></li><li>缺点：<ul><li>不区分任务紧急程度；</li><li>高频率的进程切换，有一定的开销；</li></ul></li></ul><h3 id="优先级调度算法">优先级调度算法</h3><ol><li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序；</li><li>算法规则：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>用于作业/进程调度：既可以用于作业调度，也可以用于进程调度；</li><li>可抢占性：抢占式、非抢占式都有；区别在于非抢占式只在进程主动放弃处理机时进行调度，抢占式还需要再就绪队列变化时检查是否会发生抢占；</li></ol><h4 id="动态优先级-静态优先级调度">动态优先级/静态优先级调度</h4><p>根据优先级是否可以动态改编，可以将优先级分为静态优先级和动态优先级两种；</p><ol><li>如何合理地设置各类进程的优先级？<ul><li>系统进程优先级   高于  用户进程</li><li>前台进程优先级   高于  后台进程</li><li>交互式进程优先级较高</li><li>批处理进程（比如AI训练模型，视频特效渲染）优先级较高</li><li>操作系统更偏好 <strong>IO型进程/IO繁忙型进程</strong>（与之相对的是  计算型进程，也称CPU繁忙型进程）</li></ul></li></ol><h4 id="优缺点">优缺点</h4><p>优点：</p><ol><li>适用于实时操作系统，用优先级区分紧急程度、重要程度，可以灵活地调整对各种作业/进程的偏好程度。<br>缺点：</li><li>若源源不断有高优先级的进程进入就绪队列，则可能导致饥饿。</li></ol><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3><p>设置多级的就绪队列，各级队列的优先级从高到低，时间片从小到大；</p><ol><li>算法思想：对其他调度算法的这种权衡</li><li>算法规则：<ul><li>设置多级就绪队列，各级就绪队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第一级队列，按照FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。若此时已经是在最下级队列，则重新放回该队列队尾</li><li>只有第k级队列为空时，才会为第k+1级队头的进程分配时间片</li></ul></li><li>抢占式算法</li><li>优缺点：<ol><li>优点：<ul><li>相对公平</li><li>新到达进程可以很快得到响应</li><li>短进程只用较少时间就可完成</li><li>不必事先估计进程运行时间（避免用户作假）</li><li>可以灵活调整各类进程的偏好程度</li></ul></li></ol></li><li>可能会导致饥饿</li></ol><h1>进程同步和进程互斥</h1><h2 id="进程互斥的四个原则">进程互斥的四个原则</h2><p>为了实现临界资源的互斥访问，保证系统整体性能，需要遵循以下原则：</p><ol><li>忙则等待<br>临界区被进入的时候，就让其他进程在外面等着</li><li>空闲让进<br>临界区空闲的时候，就让别人立即访问，别闲着</li><li>有限等待<br>对请求访问临界的进程，应该保证能在有限的时间可以进入临界区（保证不会饥饿）</li><li>让权等待<br>当进程被拒之门外，该进程不能一直等待，因为他占用着处理机资源，所以需要剥夺其cpu资源</li></ol><h2 id="进程同步">进程同步</h2><ol><li>进程异步性：进程具有异步性特征，异步性是指各并发执行的进程以各自独立的、不可预知的速度向前推进；</li><li>有时，各个进程的执行需要一定的顺序关系，这时需要操作系统提供“进程同步机制”来实现这种需求；</li></ol><h2 id="进程互斥">进程互斥</h2><ol><li>进程的“并发”需要“共享”的支持，各个并发执行的进程不可避免的需要共享一些系统资源（比如内存、打印机、摄像头等）</li><li>共享资源的两种方式：同时共享方式和互斥共享方式<ul><li>互斥共享方式：一个时间段只允许一个进程访问该程序</li><li>同时共享方式：允许一个时间段由多个进程“同时”对它们进行访问</li><li>我们把 <strong>一个时间段内只允许一个进程使用</strong>的资源称为 <strong>临界资源</strong>。<br>对临界资源的互斥访问逻辑：</li></ul></li></ol><ul><li>进入区：负责检查是否可以进入临界区，若可以进入，则应设置<strong>正在访问临界资源标志</strong>（可以理解为“上锁”），以阻止其他进程同时进入临界区；</li><li>临界区：访问临界资源的那段代码；</li><li>退出区：负责解除<strong>正在访问临界资源的标志</strong>（可以理解为“解锁”）</li><li>剩余区：做其他处理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"> entry section; <span class="comment">//进入区</span></span><br><span class="line"> critical section;  <span class="comment">//临界区</span></span><br><span class="line"> exit section;  <span class="comment">// 退出区</span></span><br><span class="line"> remainder section;  <span class="comment">// 剩余区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程互斥的软件实现方法（了解即可）">进程互斥的软件实现方法（了解即可）</h2><h3 id="知识概览">知识概览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">进程互斥的软件实现方法 --&gt; 单标志法 &amp; 双标志先检查 &amp; 双标志后检查 &amp; Peterson算法</span><br></pre></td></tr></table></figure><h3 id="单标志法">单标志法</h3><ol><li>算法思想：两个进程再访问完临界区后会把临界区的权限转交给另一个程序。也就是说，每个进程进入临界区的权限只能被另一个进程赋予。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;<span class="comment">//turn表示当前允许进入临界区的进程号</span></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><h3 id="双标志先检查法">双标志先检查法</h3><ol><li>算法思想：设置一个布尔数组flag[]， 数组中各个元素用于标记各进程进入临界区的意愿；比如<code>flag[0] = true</code>表示0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有无别的进程进入临界区，如果没有，则把自身对应的标志<code>flag[i] = true</code>，之后开始访问临界区。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);  <span class="comment">//  可以理解为上了锁</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><ol start="2"><li>缺点：<br>由于检查和上锁这两个处理在这里并不是一气呵成的，所以违反了“忙则等待”的原则；</li></ol><h3 id="双标志后检查法">双标志后检查法</h3><ol><li>算法思想：双标志检查法的改版，前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><ol start="2"><li>缺点：<br>违背了“空闲让进”和“有限等待”的原则，有可能会产生“饥饿”现象；</li></ol><h3 id="Peterson算法">Peterson算法</h3><ol><li>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进入意愿的数组</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;<span class="comment">//刚开始两个进程都不想进入临界区</span></span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P0进程</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P1进程</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><ol start="2"><li>缺点：<br>为遵循让权等待的原则；<br>但是遵循了空闲让进，忙则等待，有限等待的原则，是这三种算法中最优的一个，当然还有更优的算法；</li></ol><h2 id="进程互斥的硬件实现方法（了解即可）">进程互斥的硬件实现方法（了解即可）</h2><h3 id="中断屏蔽方法">中断屏蔽方法</h3><p>利用“开/关中断指令”实现（与原语的实现思想相同）<br>优点：简单、高效<br>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程</p><h3 id="TestAndSet指令">TestAndSet指令</h3><p>简称TS指令，也有地方称为TSL指令；<br>TSL指令（Test-and-Set Lock）是用硬件实现的，执行过程不允许被中断，只能一气呵成；<br>缺点：不满足让权等待原则；<br>优点：适合多处理机环境；</p><h3 id="Swap指令">Swap指令</h3><p>也叫Exchange指令，或简称为XCHG指令。Swap指令是用硬件实现的，执行的过程不允许被中断。<br>物理硬件实现上与TSL不同，但是逻辑基本相同，优缺点也相同；</p><h3 id="互斥锁">互斥锁</h3><ol><li>解决临界区最简单的工具就是互斥锁；互斥锁常用硬件机制实现；</li><li>互斥锁主要缺点：忙等待；</li><li>特性：等待期间不需要切换进程上下文，多处理器系统中，若上锁时间很短，则等待代价很低</li></ol><h1>信号量机制（重中之重）</h1><ol><li>信号量机制：用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</li><li><strong>信号量其实就是一个变量</strong>（可以是一个整数，也可以是更加复杂的记录型变量），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>；</li><li><strong>一对原语：</strong> <strong>wait(S)和signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。<br>wait、signal原语常简称为 P、V 操作（来自荷兰语）。因此，wait(S)和signal(S)两个操作分别写为<strong>P(S)和V(S)</strong>，它们是原语，有底层支持保证它们的执行不可中断。<ul><li>P：proberen 测试（荷兰语）</li><li>V：verhogen 增加（荷兰语）</li><li>==S信号量只能由PV操作访问！==</li></ul></li><li>一般而言，S无特别说明，都是记录型信号量；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">信号量机制 --&gt; 整型信号量 &amp; 1[结构型信号量/记录型信号量]</span><br></pre></td></tr></table></figure><h3 id="整型信号量">整型信号量</h3><p>用一个整数型的变量作为信号量，用于表示系统中某种资源的数量。</p><ol><li>存在的问题：不满足“让权等待”原则，会发生忙等；</li></ol><h3 id="结构型信号量（重点）">结构型信号量（重点）</h3><p>结构型信号量有效解决了忙等的问题；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量的定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">int</span> value; <span class="comment">//剩余资源数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">process</span> *L; <span class="comment">//等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*某进程需要使用资源时，通过wait 原语申请*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">S.value--;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">block</span>(S.L); <span class="comment">//如果剩余资源数不够，则使用block原语使进程从运行态变成阻塞态，并将之挂到信号量S的等待/阻塞队列中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程使用完成后，通过signal原语释放*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">S.value++;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">wakeup</span>(S.L); <span class="comment">//释放资源后，若还有别的程序在等待使用资源，则使用wakeup原语唤醒等待队列的进程；</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优点：<br>遵循了“让权等待”原则，不会出现忙等的现象；</li></ol><h2 id="信号量机制实现进程同步与互斥">信号量机制实现进程同步与互斥</h2><p>一个信号量对应了一种资源，信号量的值对应这种资源的剩余数量；</p><ul><li>P(S)，申请一个资源S，如果资源不够就阻塞等待</li><li>V(S)，释放一个资源S，如果有进程在等待，则<strong>唤醒一个进程</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">信号量机制实现 --&gt; 进程互斥 &amp; 进程同步 &amp; 进程的前驱关系</span><br></pre></td></tr></table></figure><h3 id="实现进程互斥">实现进程互斥</h3><p><strong>步骤</strong>：</p><ol><li>分析并发进程的关键活动</li><li>设置互斥信号量mutex，初值为1</li><li>在进入区 P 申请资源</li><li>在退出区 V 释放资源<br><strong>注意：</strong></li><li>对<strong>不同临界资源</strong>需要设置不同的互斥的信号量；</li><li>信号量的P，V操作必须成对出现；缺少P操作则不能保证临界资源的互斥访问，缺少V操作则会导致资源永不被释放，等待进程永不唤醒；</li></ol><h3 id="实现进程同步">实现进程同步</h3><p>进程同步：要让并发程序按要求有序地推进；（按照所需要的“顺序”并发执行）<br><strong>步骤：</strong></p><ol><li>分析什么地方需要实现“同步关系”，即找到必须保证“一前一后”执行的两个操作；</li><li>设置同步信号量S，初始值为0；</li><li>在“前操作”之后设置V(S)</li><li>在“后操作”之前设置P(S)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphora S = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">code1;</span><br><span class="line">code2;</span><br><span class="line"><span class="built_in">V</span>(S);</span><br><span class="line">code3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line"><span class="built_in">P</span>(S);</span><br><span class="line">code4;</span><br><span class="line">code5;</span><br><span class="line">code6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现前驱关系">实现前驱关系</h3><p>假设S1，S2，S3…代码需要按照如下前驱关系执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">S1 --&gt; S2</span><br><span class="line">S2 --&gt; S4</span><br><span class="line">S2 --&gt; S5</span><br><span class="line">S1 --&gt; S3</span><br><span class="line">S4 --&gt; S6</span><br><span class="line">S5 --&gt; S6</span><br><span class="line">S3 --&gt; S6</span><br></pre></td></tr></table></figure><p>用信号量机制实现前驱关系思路步骤：<br>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作），因此：</p><ol><li>要为每一对前驱关系各设置一个<strong>同步信号量</strong>；</li><li>前v后p</li></ol><h2 id="经典问题">经典问题</h2><h3 id="生产者——消费者问题">生产者——消费者问题</h3><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓存区，消费者进程每次从缓存区取出一个产品使用，初始时，生产者消费者共享一个初始为空，大小为n的缓存区；</p><ol><li>关系分析：找出题目中描述的各个进程，分析他们之间的同步互斥关系<br>同步关系（一前一后）：<br>只有缓存区没满时，生产者才可以放入产品；定义一种信号量资源empty=n<br>只有缓存区不空时，消费者才可以消费产品；定义一种信号量资源full=0<br>互斥关系：<br>缓冲区时临界资源，各个进程对缓冲区的访问必须是互斥的；</li><li>根据各进程的操作流程确定P、V操作的大致顺序：<br>生产者同步关系：在“放入产品”之前P empty，表示申请消耗一个empty资源；在“访入产品”之V full，表示已经生产一个full资源；<br>消费者同步关系：在“取出产品”之前P full，表示申请消耗full资源；在“取出产品”之后V empty，表示已经产生一个empty资源；</li><li>设置信号量：<br>互斥信号量初始值一般为1，同步信号量要看对应资源的初始值是多少；</li><li>代码实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥信号量</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">//同步信号量，表示产品数量</span></span><br><span class="line">semaphore empty = n; <span class="comment">//同步信号量，表示空闲缓冲区数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  生产一个产品;</span><br><span class="line">  <span class="built_in">P</span>(empty);<span class="comment">//空闲缓冲区-1</span></span><br><span class="line">  <span class="built_in">P</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  将产品放入缓冲区;</span><br><span class="line">  <span class="built_in">V</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">V</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">P</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line">  <span class="built_in">P</span>(mutex);</span><br><span class="line">  从缓冲区取出一个产品;</span><br><span class="line">  <span class="built_in">V</span>(mutex);</span><br><span class="line">  <span class="built_in">V</span>(empty);<span class="comment">//空闲缓冲区+1</span></span><br><span class="line">  消费一个产品;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="死锁">死锁</h4><p>思考一下上面的例子，如果先进行互斥资源的申请，再进行同步资源的申请会怎么样？<br>假设此时缓冲区已经放满产品，则empty=0, full=n；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  生产一个产品;</span><br><span class="line">  <span class="built_in">P</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">P</span>(empty);<span class="comment">//空闲缓冲区-1</span></span><br><span class="line">  将产品放入缓冲区;</span><br><span class="line">  <span class="built_in">V</span>(mutex);<span class="comment">//互斥访问临界区</span></span><br><span class="line">  <span class="built_in">V</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer</span>()&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="built_in">P</span>(mutex);</span><br><span class="line">  <span class="built_in">P</span>(full);<span class="comment">//产品数量-1</span></span><br><span class="line">  从缓冲区取出一个产品;</span><br><span class="line">  <span class="built_in">V</span>(mutex);</span><br><span class="line">  <span class="built_in">V</span>(empty);<span class="comment">//空闲缓冲区+1</span></span><br><span class="line">  消费一个产品;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，当进入生产者进程时，先申请临界区资源；然后申请empty资源，由于empty=0，即此时缓冲区已满而无法放产品，所以生产者进程由运行态转变为阻塞态；<br>然后发生进程调度，进入消费者进程，消费者进程中，第一步申请临界区资源，由于临界区资源已经被生产者使用，mutex=0，此时消费者进程也由运行态转为阻塞态；<br>于是发生了两个进程相互循环等待对方唤醒的情况！<br>这种情况称为“死锁”。<br><strong>提醒：实现互斥的P操作一定要在实现同步的P操作之后。</strong></p><h3 id="多生产者—多消费者问题">多生产者—多消费者问题</h3><ol><li>关系分析：<br>同步关系：<ol><li>只有盘子为空时，爸爸才能往盘子里放苹果；</li><li>只有盘子为空时，妈妈才能往盘子里放橘子；</li><li>只有盘子里放苹果时，女儿才能拿走盘子里的苹果；</li><li>只有盘子里放橘子时，儿子才能拿走盘子里的橘子；<br>互斥关系：</li><li>爸爸妈妈儿子女儿互斥访问盘子；</li></ol></li><li>确定P和V操作的大致顺序：<br>前v后p</li><li>代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//空闲盘子数量，互斥资源</span></span><br><span class="line">semaphore empty = <span class="number">1</span>;<span class="comment">//空闲盘子数量，同步资源</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子里的苹果数量，同步资源</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子里的橘子数量，同步资源</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dad</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">削一个苹果;</span><br><span class="line"><span class="built_in">P</span>(empty);</span><br><span class="line"><span class="built_in">P</span>(mutex);</span><br><span class="line">放一个苹果;</span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br><span class="line"><span class="built_in">V</span>(apple);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mom</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">剥一个橘子;</span><br><span class="line"><span class="built_in">P</span>(empty);</span><br><span class="line"><span class="built_in">P</span>(mutex);</span><br><span class="line">放一个橘子;</span><br><span class="line"><span class="built_in">V</span>(mutex);</span><br><span class="line"><span class="built_in">V</span>(orange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">P</span>(apple);</span><br><span class="line"><span class="comment">//P(mutex);</span></span><br><span class="line">拿走一个苹果;</span><br><span class="line"><span class="comment">//V(mutex);</span></span><br><span class="line"><span class="built_in">V</span>(empty);</span><br><span class="line">吃一个苹果;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">daughter</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">P</span>(orange);</span><br><span class="line"><span class="comment">//P(mutex);</span></span><br><span class="line">拿走一个橘子;</span><br><span class="line"><span class="comment">//V(mutex);</span></span><br><span class="line"><span class="built_in">V</span>(empty);</span><br><span class="line">吃一个橘子;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽烟者问题">抽烟者问题</h3><ol><li>关系分析：<br>同步关系：<ol><li>只有盘子上放的是纸和胶水的时候，1号抽烟者才能取走材料；</li><li>只有盘子上放的是烟草和胶水的时候，2号抽烟者才能取走材料；</li><li>只有盘子上放的是纸和烟草的时候，3号抽烟者才能取走材料；</li><li>只有其中一个抽烟者抽完烟通知生产者的时候，生产者才能放材料；<br>互斥关系：</li><li>无，因为是单生产者</li></ol></li><li>确定P和V的大致操作</li><li>代码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;<span class="comment">//1号需要的资源信息量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;<span class="comment">//2号需要的资源信息量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;<span class="comment">//3号需要的资源信息量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;<span class="comment">//生产者需要的资源信息量</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现“轮流抽烟”</span></span><br><span class="line"><span class="built_in">provider</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">放入offer1;</span><br><span class="line"><span class="built_in">V</span>(offer1);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">放入offer2;</span><br><span class="line"><span class="built_in">V</span>(offer2);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">放入offer3;</span><br><span class="line"><span class="built_in">V</span>(offer3);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">i = i%<span class="number">3</span>;</span><br><span class="line"><span class="built_in">P</span>(finish);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer1</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">P</span>(offer1);</span><br><span class="line">拿走offer1;</span><br><span class="line"><span class="built_in">V</span>(finish);</span><br><span class="line">消费offer1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer2</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">P</span>(offer2);</span><br><span class="line">拿走offer2;</span><br><span class="line"><span class="built_in">V</span>(finish);</span><br><span class="line">消费offer2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">comsumer3</span>()&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">P</span>(offer3);</span><br><span class="line">拿走offer3;</span><br><span class="line"><span class="built_in">V</span>(finish);</span><br><span class="line">消费offer3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读者—写者问题">读者—写者问题</h3><h3 id="哲学家进餐问题">哲学家进餐问题</h3><h1>死锁</h1><h2 id="相关概念-2">相关概念</h2><h3 id="概念辨析">概念辨析</h3><ol><li>死锁：<br>各进程互相等待对方手里的资源，导致各个进程都阻塞，无法向前推进的现象；<br>如果产生死锁现象，至少有两个或两个以上的进程同时发生死锁；</li><li>饥饿：<br>由于长期得不到想要的资源，某进程无法向前推进的现象；<br>可能只有一个进程发生饥饿；</li><li>死循环：<br>某程序执行过程中一直跳不出来某个循环的现象。有时是程序逻辑bug导致的；<br>死循环的进程是可以上处理机运行的（可以是运行态），死循环是程序员的问题，不是操作系统的问题；</li></ol><h3 id="死锁产生的必要条件">死锁产生的必要条件</h3><ol><li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</li><li>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走</li><li>请求和保持条件：进程已经保持了至少一个资源，但是又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li><li>循环等待条件：存在一种进程资源的循环等待链</li></ol><h3 id="死锁的处理策略">死锁的处理策略</h3><ol><li>预防死锁：破坏死锁产生的四个必要条件之一；</li><li><strong>避免死锁：用某种方法组织系统进入不安全状态，从而避免死锁（银行家算法）</strong>；</li><li>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出思索的发生，然后采取某种措施解除死锁；</li></ol><h2 id="死锁处理的策略——预防死锁">死锁处理的策略——预防死锁</h2><ol><li>互斥条件——SPOOLing法逻辑上将互斥资源改为逻辑上共享资源</li><li>不可剥夺条件——</li><li>请求和保持条件——静态分配方法，即在运行前一次申请完它所需要的资源</li><li>循环等待条件——顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完</li></ol><h2 id="死锁处理的策略——避免死锁">死锁处理的策略——避免死锁</h2><h3 id="银行家算法（重点）">银行家算法（重点）</h3><ul><li>[ ] TODO，代码实现</li></ul><h2 id="死锁处理的策略——检测死锁">死锁处理的策略——检测死锁</h2><p>资源分配图是否可完全简化</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【深度学习】1. 机器学习和深度学习综述</title>
      <link href="/2024/03/20/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%911.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/03/20/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%911.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="人工智能、机器学习、深度学习之间的关系">人工智能、机器学习、深度学习之间的关系</h2><p>人工智能：模拟、延展和扩展人的智能的理论、方法、技术及其应用系统的一门新的技术科学；<br>机器学习：一种实现人工智能的工具方法；<br>深度学习：是机器学习算法中的最热门的一个分支，取代了机器学习中的大部分传统算法；<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240320144852.png" alt="Pasted image 20240320144852"></p><h2 id="机器学习">机器学习</h2><h3 id="机器学习的实现原理">机器学习的实现原理</h3><p>机器学习的实现可以分为两步：训练和预测<br>机器学习的分类：有监督学习和无监督学习</p><h3 id="机器学习的过程">机器学习的过程</h3><ol><li>假设：模型假设</li><li>评价：评价函数</li><li>优化：优化算法</li></ol><h2 id="深度学习">深度学习</h2><p>深度学习与机器学习在理论结构上是一致的，即：模型假设、评价函数和优化算法，根本差别在于假设的复杂度，即模型的复杂度。</p><h3 id="神经网络的基本概念">神经网络的基本概念</h3><p>人工神经网络包括多个神经网络层，如：卷积层、全连接层、LSTM等，每一层又包括很多神经元，<strong>超过三层的非线性神经网络都可以被称为深度神经网络</strong>。通俗的讲，深度学习的模型可以视为是输入到输出的映射函数，足够深的神经网络理论上可以拟合任何复杂的函数。</p><ul><li><strong>神经元：</strong> 神经网络中每个节点称为神经元，由两部分组成：<ul><li>加权和：将所有输入加权求和。</li><li>非线性变换（激活函数）：加权和的结果经过一个非线性函数变换，让神经元计算具备非线性的能力。</li></ul></li><li><strong>多层连接：</strong> 大量这样的节点按照不同的层次排布，形成多层的结构连接起来，即称为神经网络。</li><li><strong>前向计算：</strong> 从输入计算输出的过程，顺序从网络前至后。</li><li><strong>计算图：</strong> 以图形化的方式展现神经网络的计算逻辑又称为计算图，也可以将神经网络的计算图以公式的方式表达；</li></ul><h2 id="波士顿房价预测项目实践记录">波士顿房价预测项目实践记录</h2><h3 id="梯度下降法参数调优">梯度下降法参数调优</h3><h5 id="传统梯度下降法">传统梯度下降法</h5><p>利用全量数据求梯度并进行梯度下降；<br>沿梯度反方向，选取适当步长移动，逐步降低损失函数；步长在这里又称为学习率。<br>特征归一化目的：保存各个特征步长统一</p><h5 id="随机梯度下降法">随机梯度下降法</h5><p>对于数据量较大的数据，由于每次只沿梯度反方向移动一点点，所以方向并不需要那么精细。于是我们可以每次从总的数据集随机抽取小部分数据代表整体，基于这部分数据计算梯度和损失函数，这种方法被称为随机梯度下降法（Stochastic Gradient Descent, SGD）。</p><ul><li>minibatch：每次迭代时抽取出来的一批数据被称为一个minibatch。</li><li>batch size：每个minibatch所包含的样本数目称为batch size。</li><li>Epoch：当程序迭代的时候，按minibatch逐渐抽取出样本，当把整个数据集都遍历到了的时候，则完成了一轮训练，也叫一个Epoch（轮次）。启动训练时，可以将训练的轮数<code>num_epochs</code>和<code>batch_size</code>作为参数传入。<br><strong>随机梯度下降减小了计算量，可以更快地收敛，但是由于每次基于少量样本来更新和计算损失函数，所以损失下降曲线会出现震荡现象。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】1. 操作系统概览</title>
      <link href="/2024/03/15/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/"/>
      <url>/2024/03/15/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%911.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1>操作系统的概念，功能</h1><h2 id="操作系统的概念（定义）">操作系统的概念（定义）</h2><p>操作系统是计算机系统的中的一个系统软件，统一管理计算机的软，硬件资源和控制程序的执行。</p><h2 id="操作系统的特征">操作系统的特征</h2><h3 id="并发">并发</h3><p>指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的。（宏观上，这个时间段内操作系统执行两个操作，但是在每一个时刻，操作系统都只执行一个操作）<br>操作系统就是伴随着“多道程序技术”而出现的，所以操作系统和程序并发是一起诞生的。<br><strong>与并行区分</strong>：并行是指两个或多个事件在同一时刻同时发生。<br><strong>注意</strong><br>单核CPU同一时刻只能执行一个程序，各个程序只能并发执行。<br>多核CPU统一时刻可以同时执行多个程序，多个程序可以并行执行。</p><h3 id="共享">共享</h3><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">A[两种资源共享方式] --&gt; B(互斥共享方式) &amp; C(同时共享方式)</span><br><span class="line"></span><br><span class="line">B --&gt; D(系统中某些资源可以提供给多个进程使用&lt;/br&gt;但一个时间段只能提供给一个进程)</span><br><span class="line"></span><br><span class="line">C --&gt; E(系统中某些资源允许同一时间段&lt;/br&gt;同一时刻允许多个进程访问)</span><br></pre></td></tr></table></figure><p>例子：微信视频，视频的时候不能发语音给别人；打游戏时可以同时输出游戏声音和音乐声音；<br><strong>共享性和并发性是相互依存的。</strong></p><h3 id="虚拟性">虚拟性</h3><p>虚拟是指把一个物理上的试题变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上的对应物（后者）是用户感受到的。<br>例子：虚拟内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">A[虚拟技术] --&gt; B(时分复用技术，如虚拟处理器) &amp; C(空分复用技术，如虚拟存储器)</span><br><span class="line"></span><br><span class="line">B --&gt; D(显然，如果失去并发性，则一个时间段内系统只能运行&lt;/br&gt;一个程序，那就失去虚拟性的意义)</span><br></pre></td></tr></table></figure><h3 id="异步性">异步性</h3><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停；这就是程序的异步性。<br><strong>只有系统有并发性，才有可能导致异步性；如果系统不是并发性，则系统的执行是串行的，不会产生异步。</strong></p><h2 id="操作系统的运行机制">操作系统的运行机制</h2><h3 id="概览">概览</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[操作系统运行机制] --&gt; B[两种指令] &amp; C[两种处理器状态] &amp; D[两种程序]</span><br><span class="line">B --&gt; E[特权指令] &amp; F[非特权指令]</span><br><span class="line">C --&gt; 核心态 &amp; 用户态</span><br><span class="line">D --&gt; 内核程序 &amp; 应用程序</span><br></pre></td></tr></table></figure><h3 id="内核程序-vs-应用程序">内核程序 vs  应用程序</h3><p><strong>内核</strong>是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>；<br>(docker仅需要linux内核就可以跑linux)<br>操作系统的功能未必都在内核中，比如linux的图形化界面GUI就不在内核中实现；</p><h3 id="内核态-管态-vs-用户态-目态">内核态/管态 vs 用户态/目态</h3><p>CPU有两种状态：内核态和用户态<br>处于内核态，说明此时正在运行内核程序，此时可以执行特权指令<br>处于用户态，说明此时正在运行应用程序，此时只能执行非特权指令<br><strong>拓展</strong>：CPU内部有一个寄存器叫 <strong>程序状态字寄存器（PSW）</strong>，其中有个二进制位，1表示内核态，0表示用户态；</p><h3 id="内核态与用户态的切换">内核态与用户态的切换</h3><ol><li>内核态——&gt;用户态：一条修改PSW状态标志的特权指令</li><li>用户态——&gt;内核态：由中断引起，硬件自动完成切换<br>“中断”是操作系统内核夺回CPU使用权的唯一途径</li></ol><h2 id="中断和异常">中断和异常</h2><h3 id="中断的类型">中断的类型</h3><p><strong>内中断和外中断的区别：</strong> 当前执行的指令是否与中断的发生有关，有关则内部中断，否则外部中断；</p><ol><li>内中断（<strong>异常</strong>）<ul><li>如果当前执行的指令是非法的则会引发中断</li><li>有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——<strong>陷入指令（不是特权指令）</strong>，该指令会引发一个内部中断信号（<strong>系统调用</strong>）</li></ul></li><li>外中断<br>外中断与当前执行的指令没有关系，中断信号来源于CPU外部，每一条指令结束后，CPU都会例行检查是否由外部中断信号。<ul><li>时钟中断——由时钟部件产生的中断信号（时钟部件每隔一个时间片会给CPU发生一个中断信号）</li><li>IO中断——打印机打完之后发送信号</li></ul></li></ol><h3 id="内中断（也叫异常）">内中断（也叫异常）</h3><ul><li>陷阱、陷入</li><li>故障：由错误条件引起，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让他继续执行。（如：缺页故障）</li><li>终止：由致命错误引起，内核程序无法修复该错误，因此一般不再将使用权还给引发中断的应用程序，而是直接终止应用程序。（如 除0，非法使用特权）</li></ul><h3 id="中断机制的基本原理">中断机制的基本原理</h3><p>不同的中断信号，需要不同的中断处理程序来处理，当CPU检测到中断后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置，再执行中断处理程序。<br>具体硬件实现是计组里的内容。</p><h2 id="系统调用">系统调用</h2><p>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统内核统一管理和调度，<strong>因此凡是与共享资源有关的操作（存储分配，IO，文件管理），都必须通过系统调用的方式向操作系统内核提出请求，由操作系统内核代为完成</strong>，这样可以保证系统的稳定性和安全性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">A[系统调用:按功能分类] --&gt; B(设备管理) &amp; C(文件管理) &amp; F(进程控制) &amp; G(进程通信) &amp; H(内存管理)</span><br><span class="line"></span><br><span class="line">B --&gt; D(完成设备的 请求/释放/启动 等)</span><br><span class="line"></span><br><span class="line">C --&gt; E(完成文件的 读/写/创建/删除 等)</span><br><span class="line"></span><br><span class="line">F --&gt; I(完成进程的 创建/撤销/阻塞/唤醒 等功能)</span><br><span class="line">G --&gt; J(完成进程之间的 消息传递/信号传递 等功能)</span><br><span class="line">H --&gt; K(完成内存的 分配/回收 等功能)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="系统调用的过程">系统调用的过程</h4><ol><li>传递系统调用参数</li><li>执行陷入指令（trap指令/访管指令） <strong>此时在用户态</strong></li><li>执行响应的内核请求程序处理系统调用   <strong>核心态</strong></li><li>返回应用程序<br><strong>注意：</strong></li><li><strong>陷入指令</strong>是在用户态执行的，执行后立即引发一个<strong>内中断</strong>，使CPU进入核心态</li><li>发出系统调用请求是在用户态，而<strong>对系统调用的相应处理</strong>是在<strong>核心态</strong>下进行的</li></ol><h2 id="操作系统的体系结构">操作系统的体系结构</h2><h3 id="操作系统引导">操作系统引导</h3><p>开机、BIOS（basic input/output systerm）等；</p><h4 id="过程">过程</h4><ol><li>CPU从一个特定的主存地址开始取指令执行ROM中的引导程序（先进行硬件的自检，再开机）</li><li>将磁盘的第一块——主引导记录，读入内存，执行磁盘引导程序，扫描分区表</li><li>从活动分区（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</li><li>从根目录下找到完整的操作系统初始化程序（即 启动资源管理器）并执行，完成“开机”的一系列操作</li></ol><h3 id="虚拟机">虚拟机</h3><p>使用虚拟化技术，将一台物理机虚拟化为多台虚拟机，每个虚拟机都可以独立运行一个操作系统；</p><h4 id="第一类虚拟机：直接运行在硬件上">第一类虚拟机：直接运行在硬件上</h4><p>类似双系统；<br>特点：运行在最高特权级，不宜迁移</p><h4 id="第二类虚拟机：运行在宿主操作系统上">第二类虚拟机：运行在宿主操作系统上</h4><p>比如在windows上用Virtual Box使用ubuntu；<br>特点：可以灵活迁移</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】1. 前导</title>
      <link href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%911.%20%E5%89%8D%E5%AF%BC/"/>
      <url>/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%911.%20%E5%89%8D%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1>如何设计一种高级语言？</h1><h2 id="任何语言包括两个方面">任何语言包括两个方面</h2><ol><li>词法</li><li>语法</li></ol><h2 id="外文资料的翻译过程">外文资料的翻译过程</h2><p>符号——&gt;单词——&gt;句子——&gt;书</p><ol><li>识别出字母，标点符号</li><li>识别出文中的各个单词</li><li>查字典</li><li>语法</li><li>具有目标语言的修饰能力</li></ol><h2 id="词法分析">词法分析</h2><p>从第一个符号开始，依次阅读原文中的各个符号，逐个识别出原文中的各个单词。</p><h2 id="语法分析">语法分析</h2><p>把一个个单词按照相应的规则拼装成句子，这就是语法分析。</p><h2 id="从外文翻译到源程序编译">从外文翻译到源程序编译</h2><table><thead><tr><th></th><th>翻译外文</th><th>编译源程序</th></tr></thead><tbody><tr><td>分析</td><td>阅读原文<br>识别单词<br>分析句子</td><td>输入并扫描源程序<br>词法分析<br>语法分析</td></tr><tr><td>综合</td><td>修饰加工<br>写出译文</td><td>修饰优化<br>目标代码生成</td></tr></tbody></table><h1>编译过程</h1><ol><li><p>扫描程序</p><ol><li>一行一行扫描，识别出符号/记号 ——&gt; token</li><li>扫描到每一个token，看它是否能组成标识符，如果能则继续扫描并拼装，拼装成标识符后，需要查找这个标识符是否为保留字 <strong>查找方法：哈希、顺序…</strong></li></ol></li><li><p>语法分析</p><ol><li>语法分析树（空间庞大，可以优化）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240316142559.png" alt="Pasted image 20240316142559"></li><li>语法树（只保留有用信息）<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240316142753.png" alt="Pasted image 20240316142753"></li></ol></li><li><p>语义分析程序</p><ol><li>分析程序的语义</li><li>还应该注意声明和类型检查，检查出语法错误</li><li>处理方法：<ol><li>在语法树上添加<strong>属性</strong> —— 比如数据类型</li><li>添加了数据类型等属性信息的语法树称为<strong>注释树</strong><br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240316143156.png" alt="Pasted image 20240316143156"></li></ol></li></ol></li><li><p>源代码优化程序</p><ol><li>即对代码进行改进或优化步骤（==与机器无关的优化==）——&gt; 草稿<br>举例： 表达式4+2，里面有加法运算，但是由于4和2都是常量，所以应该直接用6代替4+2，这样就是对源代码进行优化；</li><li>如果更好地优化<ol><li>多次扫描语句，优化完再次扫描优化</li><li>产生中间代码：位于源代码和目标代码之间的代码</li><li>中间代码IR：位于源代码和目标代码之间的表示形式（==第六章我们会重点讨论中间代码的存储结构==）</li></ol></li></ol></li><li><p>代码生成器</p><ol><li>代码生成器得到中间代码（IR），生成<strong>目标机器代码（二进制代码）</strong>。</li><li>中间代码一直是指一种位于源代码和目标代码之间的代码表示形式（主要有三元组、四元组、树型、伪代码、逆波兰等形式）</li></ol></li><li><p>目标代码优化程序</p><ol><li>与机器有关的优化，利用机器指令特征进行优化</li><li>优化目的：提高运行效率和节省内存空间</li></ol></li></ol><p>==源程序经过编译器编译成目标程序后，数据和工具库才调入进目标程序，然后才执行程序==</p><h1>编译原理基本概念</h1><ol><li>编译器<ul><li>将一种语言翻译成另一种语言的计算机程序</li></ul></li><li>汇编程序<ul><li>将汇编语言翻译成机器语言的程序称为汇编程序；他的源语言和目标语言分别对应的语言是汇编语言和机器语言</li></ul></li><li>编译程序/解释程序<ul><li>编译程序（书面翻译）：会生成目标程序  ——&gt;  优势：效率高</li><li>解释程序（即时翻译）——&gt; 优势：跨平台    劣势：暴露源码<br><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/Pasted%20image%2020240316144314.png" alt="Pasted image 20240316144314"></li></ul></li><li>自举与移植   自己发展自身 ——&gt; T图</li></ol><h1>高级语言的设计</h1><h2 id="步骤">步骤</h2><ol><li>单词分类（保留字，标识符，专用符号）</li><li>接近于数学定义以及数学运算</li><li>控制结构简单：顺序，分支，循环</li><li>支持输入输出</li><li>为了提高程序可读性：应该可以进行注释</li></ol><h2 id="Tiny语言">Tiny语言</h2><h3 id="Tiny编译器的编译过程">Tiny编译器的编译过程</h3><ol><li><p>扫描四遍程序：第一遍构造语法树</p></li><li><p>第二第三遍进行语义分析，其中第二遍构造符号表</p></li><li><p>第三遍完成类型检查</p></li><li><p>最后一遍代码生成</p></li><li><p><strong>任务</strong>：这几天先用Tiny语言对C语言程序进行编译，然后打断点，分析查看编译各个阶段（扫描、语法、语义、优化、生成、目标程序优化）</p></li><li><p>tm是命令行模式进行编译运行的</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】3. 有穷自动机</title>
      <link href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%913.%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%913.%20%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>有穷自动机</h1><h2 id="基本概念">基本概念</h2><h3 id="确定性有穷自动机的定义-——-DFA">确定性有穷自动机的定义 —— DFA</h3><p>==有穷自动机本质上是正则表达式所表达单词组成的识别算法。==<br>下一个状态由当前状态和当前输入字符唯一确定的自动机。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>s</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f(s_1,a) = s_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>组成要素：</p><ol><li>字母表 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span></li><li>状态集合 S</li><li>转换函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>:</mo><mi>S</mi><mo>×</mo><mo>∑</mo><mo>→</mo><mi>S</mi><mtext>   初始状态</mtext><msub><mi>S</mi><mn>0</mn></msub><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">T: S\times \sum \to S \ \ \ 初始状态S_0 \in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord cjk_fallback">初始状态</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li><li>接受状态集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">A \subset S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></li></ol><p>DFA图的基本要素：</p><ol><li>状态</li><li>初始状态</li><li>接受状态</li><li>转换<br>图示方法：DFA图</li></ol><h3 id="约定">约定</h3><p>将出错转换进行缺省：假设出错转换总是存在。</p><h2 id="正则表达式与DFA之间的关系">正则表达式与DFA之间的关系</h2><h3 id="相互转换">相互转换</h3><p>例1：正则表达式 ab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A((state1)) --a--&gt; B((state2)) --b--&gt; C(((state3)))</span><br></pre></td></tr></table></figure><p>例2：正则表达式 a|b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A((1)) --a--&gt; B(((2)))</span><br><span class="line">A --b--&gt; B</span><br></pre></td></tr></table></figure><p>例3：正则表达式 a*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A(((1))) --a--&gt; A </span><br></pre></td></tr></table></figure><p>例4：正则表达式 (ab)*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A(((1))) --a--&gt; B((2))</span><br><span class="line">B --b--&gt; A</span><br></pre></td></tr></table></figure><p>例5：正则表达式 (a|b)*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A(((1))) --a--&gt; A</span><br><span class="line">A --b--&gt; A</span><br></pre></td></tr></table></figure><p>例6：正则表达式 ab | ac</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A((1)) --a--&gt; B((2)) --b--&gt; C(((3)))</span><br><span class="line">B --c--&gt; C</span><br></pre></td></tr></table></figure><h3 id="练习">练习</h3><p><strong>练习1：串种仅有一个b的集合的正则表达式 (~b)*b(~b)*</strong>**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --~b--&gt; 1</span><br><span class="line">1 --b--&gt; 2((2))</span><br><span class="line">2(((2))) --~b--&gt; 2</span><br></pre></td></tr></table></figure><p><strong>练习2：Pascal注释{(~})*}对应的DFA是什么？</strong></p><ol><li>拆分来看：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --&#123;--&gt; 2(((2)))</span><br><span class="line">3(((3))) --~&#125;--&gt; 3</span><br><span class="line">4((4)) --&#125;--&gt; 5(((5)))</span><br></pre></td></tr></table></figure><ol start="2"><li>汇总来看：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --&#123;--&gt; 2((2)) --~&#125;--&gt; 2</span><br><span class="line">2 --&#125;--&gt; 3(((3)))</span><br></pre></td></tr></table></figure><p><strong>练习3：C语言的注释</strong><br>前面我们了解到C语言注释用正则表达式匹配非常麻烦，所以我们不采用正则匹配，而是使用DFA图。<br>/* …(*/不同时出现)…*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --/--&gt; 2((2)) --*--&gt; 3((3)) --~*--&gt; 3</span><br><span class="line">3 --*--&gt; 4((4)) --/--&gt; 5(((5)))</span><br><span class="line">4 --*--&gt; 4</span><br><span class="line">4 -- other --&gt; 3</span><br></pre></td></tr></table></figure><p><strong>DFA的表达能力强于正则表达式</strong></p><h2 id="NFA有穷自动机">NFA有穷自动机</h2><h3 id="DFA直接转换困难的原因分析">DFA直接转换困难的原因分析</h3><ol><li>我们需要对各个状态进行拆分</li><li>然后找到等价状态进行合并<br>解决方法：</li></ol><ul><li>允许1对多的转换</li><li>允许<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span>转换</li></ul><blockquote><blockquote><p>我们最终目的是要将正则表达式转化成DFA，但是直接转化存在困难，所以我们引入一个中间方法，<strong>先将正则表达式转换成NFA，再将NFA转化成DFA</strong></p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">正则表达式 --&gt; NFA --&gt; DFA --&gt; 程序</span><br></pre></td></tr></table></figure><h3 id="引入新的有穷自动机NFA（草图）">引入新的有穷自动机NFA（草图）</h3><p>NFA（nondeterministic finite automaton）非确定性有穷自动机；<br><strong>与DFA不同的地方在于引入了空串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></strong></p><h3 id="正则表达式转换成NFA">正则表达式转换成NFA</h3><p>例1： ab|a</p><ol><li>先拆分</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --a--&gt; 2(((2)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --b--&gt; 2(((2)))</span><br></pre></td></tr></table></figure><ol start="2"><li>连接运算，形成ab</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --a--&gt; 2((2)) --空串--&gt; 3((3)) --b--&gt; 4(((4)))</span><br></pre></td></tr></table></figure><ol start="3"><li>或运算，形成 ab | a</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --空串--&gt; 2((2)) --a--&gt; 3((3)) --空串--&gt; 4((4)) --b--&gt; 5((5)) --空串--&gt; 8(((8)))</span><br><span class="line">1 --空串--&gt; 6((6)) --a--&gt; 7((7)) --空串--&gt; 8</span><br></pre></td></tr></table></figure><ol start="4"><li>闭包运算，形成a*</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --a--&gt; 2(((2)))</span><br><span class="line">3((1)) --a--&gt; 4(((2))) --空串--&gt; 3</span><br><span class="line">5((1)) --空串--&gt; 6((2)) --a--&gt; 7((3)) --空串--&gt; 8(((4)))</span><br><span class="line">5 --空串--&gt; 8</span><br></pre></td></tr></table></figure><h3 id="根据NFA图编写代码表达正则表达式">根据NFA图编写代码表达正则表达式</h3><p>先考虑存储结构，显然，无论是DFA图还是NFA图，都是有向图，用邻接矩阵或者邻接表进行状态存储。状态转换的过程实际上就是矩阵赋值的过程。</p><h3 id="NFA转化为DFA（子集构造法）">NFA转化为DFA（子集构造法）</h3><ol><li>合并等价状态</li><li>分析NFA和DFA有何不同：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\epsilon-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">−</span></span></span></span>转换（合并等价状态）—— 消除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\epsilon-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">−</span></span></span></span>转换</li><li>多重转换（一对多转化为一对一）—— 消除多重转换<br>由于子集构造法得到的结果均是集合而不是单个状态，因此这个算法称为子集构造法；</li></ul></li><li>所以NFA转化为DFA的整体思想是：<ul><li>消除<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>转换</li><li>消除多重转换</li></ul></li></ol><h4 id="具体步骤">具体步骤</h4><ol><li>从初态开始，求初态的==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包==（即找到所有跟当前状态等价的状态组成一个集合），数学表示方法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mtext>初态</mtext><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\overline{初态}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">初态</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span><br>算法写法：bfs或者dfs，从当前位置出发，找到所有经过0个或若干个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>能达到的状态加入集合</li><li>对转换后的初态进行状态转换：<ol><li>找到NFA图中，除了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>转换之外的所有转换；</li><li>分别对初态进行除了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>−</mo></mrow><annotation encoding="application/x-tex">\epsilon-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">ϵ</span><span class="mord">−</span></span></span></span>的转换；数学表达式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mtext>初态</mtext><mo stretchy="true">‾</mo></mover><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\overline{初态}_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">初态</span></span></span><span style="top:-3.8033em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示初态集合在a转换上的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>闭包；</li><li>分别找到转化后的状态的等价状态，组成一个新的集合；</li></ol></li><li>重复1，2；直到转换结果不是产生新的集合为止；</li><li>如果转换的结果为空集：<ul><li>如果当前集合为不含终态的集合，则代表产生错误error；</li><li>如果当前集合为终态集合（即包含终态），则代表该集合为终态集合；</li></ul></li></ol><h4 id="例题">例题</h4><p>将下面的NFA图转化为DFA图；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --letter--&gt; 2((2)) --空串--&gt; 3((3)) --空串--&gt; 4((4)) --空串--&gt; 5((5)) --letter--&gt; 6((6)) --空串--&gt; 9((9)) --空串--&gt; 10(((10)))</span><br><span class="line">3 --空串--&gt; 10</span><br><span class="line">4 --空串--&gt; 7 --digit--&gt; 8((8)) --空串--&gt; 9</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((&quot;&#123;1&#125;&quot;)) --letter--&gt; 2(((&quot;&#123;2,3,4,5,7,10&#125;&quot;))) --letter--&gt; 3(((&quot;&#123;4,5,6,7,9,10&#125;&quot;)))</span><br><span class="line">2 --digit--&gt; 4(((&quot;&#123;4,5,7,8,9,10&#125;&quot;)))</span><br><span class="line">3 --digit--&gt; 4</span><br><span class="line">4 --letter--&gt; 3</span><br></pre></td></tr></table></figure><p><strong>表示方式</strong>：数学表达、DFA图、关联矩阵<br><strong>缺点</strong>：用这种方法得到的DFA图状态可能会比原来的直接DFA图多，可能会出现重复；</p><p>原先我们不通过NFA到DFA的转化，得到的结果如下，显然上述结果相对复杂，状态较多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">1((1)) --letter--&gt; 2(((2))) --letter--&gt; 2</span><br><span class="line">2 --digit--&gt; 2</span><br></pre></td></tr></table></figure><h3 id="DFA状态压缩-——-状态最小化">DFA状态压缩 —— 状态最小化</h3><p>状态压缩目标：状态数最少；<br>方法：</p><ol><li>将所有状态分为2类：终态集合和非终态集合</li><li>分析每个集合中的元素，分析他们的<strong>功能</strong>是否一致，如果不一致则拆出来<br>即接受相同的参数，产生的状态是否属于同一集合（终态集合与非终态集合）</li><li>重复1，2<br>状态的功能：接受参数，产生状态</li></ol><h3 id="用代码实现有穷自动机">用代码实现有穷自动机</h3><p>词法分析自动机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">正则表达式 --&gt; NFA --&gt; DFA --&gt; 最小化DFA --代码实现--&gt; 词法分析有穷自动机</span><br></pre></td></tr></table></figure><p>查询DFA最小化的表进行正则表达式分析；</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译原理】2. 词法分析与正则表达式</title>
      <link href="/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%912.%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/03/08/%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AD%A6%E4%B9%A0/%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%912.%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>词法分析</h1><h2 id="扫描工作">扫描工作</h2><ol><li>组织程序的输入：逐行读入/整个程序读入</li><li>主控代码： switch(ch):{case():…}</li></ol><h2 id="词法分析理论">词法分析理论</h2><h3 id="正则表达式">正则表达式</h3><p>用数学抽象的方法把字符串表达出来<br>缺点：抽象，不利于理解，也不利于代码编写<br>解决方法：用有穷状态机/有穷自动机表示出来（图示法），即正则表达式所表达单词组成的识别算法</p><h3 id="本章学习内容">本章学习内容</h3><ol><li><strong>正则表达式</strong></li><li><strong>有穷自动机</strong></li><li><strong>正则表达式——&gt;有穷自动机</strong></li><li><strong>有穷自动机——&gt;程序</strong></li><li>TINY语言词法分析程序的实现过程</li></ol><h1>正则表达式</h1><ul><li>正则表达式表示字符串的组成</li><li>正则表达式r由它所匹配的串集定义</li><li>语言L® —— “串的集合”</li><li>串的组成部分——字母表—— <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∑</mo></mrow><annotation encoding="application/x-tex">\sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span></span></span></span></li></ul><h2 id="正则表达式的定义">正则表达式的定义</h2><h3 id="基本正则表达式">基本正则表达式</h3><p><strong>运算：</strong></p><ol><li>选择，用 | 表示</li><li>连接，不用符号特定表示，ab匹配ab</li><li>重复或闭包，r*表示可以取0个或任意个r，用*表示<br><strong>运算符优先级</strong>：*的优先权最高，连接其次，| 最末</li></ol><h3 id="正则表达式的扩充">正则表达式的扩充</h3><p><strong>扩充运算</strong>：</p><ol><li>正闭包：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>r</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">r^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> 表示r的一个或多个重复</li><li>连字符：[[a-z]是指所有小写字母，[0-9]表示数字，==[abc]表示a|b|c===；[a-zA-Z]表示所有大小写字母；</li><li>可选：r？ 表示r出现一次或不出现；</li><li>任意字符：.  表示<strong>任意字符</strong>匹配的典型元字符；比如： .*b.*表示至少有一个b的串</li><li>取非：~a表示字母表中非a的字符；<br><strong>匹配原则：</strong></li><li>最长子串原理/最长匹配原则 ——&gt; 避免歧义<br>最长串匹配原则的内容：如果后面的符号还能继续匹配，则默认继续匹配</li></ol><h3 id="正则表达式表示注释">正则表达式表示注释</h3><p>==疑问（挖坑，等以后填）==<br>==C语言的注释如何正则匹配？==<br><strong>取非运算~在正则表达式中是单目运算，且只对一个字符有效。所以不能表达~(*/)</strong><br>如果基于已有的正则运算表达C语言的注释，会非常麻烦，所以目前我们并不打算使用正则表达式的匹配来表达C语言的注释。</p><blockquote><blockquote><p>本质上正则表达式只是一种简易化字符串匹配的表达工具，当我们需要表达的字符串趋于复杂时，也许就背离了正则表达式建立的初衷，它的创立是为了便于我们表达的，而不是使我们的表达更复杂。在C语言注释的表达上，也许使用正则表达式并不是一个好的选择，这时我们可以转变思路，换一个表达方式——有穷自动机/状态机。</p></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">注释 --&gt; pascal语言 &amp; C语言</span><br><span class="line">pascal语言 --&gt; A(&quot;&#123;this is a Pascal comment&#125;&quot;) --&gt; B(&quot;正则匹配：&#123;(~&#125;)*&#125;&quot;) --&gt; 正确</span><br><span class="line">C语言 --&gt; C(&quot;/*this is a C comment*/&quot;) --&gt; D(&quot;正则匹配:/* (~(*/))* */&quot;) --&gt; 错误</span><br></pre></td></tr></table></figure><h3 id="正则表达式的缺点">正则表达式的缺点</h3><ol><li>表达能力不够强，比较抽象，类数学语言，不利于理解和代码编制 ——&gt; 解决方法：<strong>有穷自动机</strong></li><li>二义性问题 ——&gt; 解决方法：<strong>最长子串原理</strong></li></ol><h1>小结</h1><p>本节我们介绍了词法分析过程，引出了词法分析理论，从而导出正则表达式。我们由浅入深地学习了正则表达式以及对其进行简单的扩充，发现其中的优点和不足。由于正则表达式表达能力不够强，距离真正的代码编制还有较为复杂的转换，所以我们用有穷自动机来解决这个问题，下一节将介绍有穷自动机的内容。</p><h3 id="问题升级：含变量的浮点数算数表达式的词法分析">问题升级：含变量的浮点数算数表达式的词法分析</h3><p>不要求科学计数法；<br>浮点数：a. 整数部分； b. 小数部分；<br>所以要在枚举数据类型那里加多浮点数类型，新建数字结构，包含小数部分和整数部分成员；<br>小数点前面部分，整数部分，小数点后面部分，小数部分；</p><h3 id="问题升级：条件判断语句的词法分析">问题升级：条件判断语句的词法分析</h3><p>单词分类：</p><ol><li>整数</li><li>小数</li><li>标识符  x,y,z</li><li>保留字 if</li><li>关系符号：+、-、&gt;…</li></ol><h2 id="查找方法">查找方法</h2><p>查找用于哪里？例如在单词种类的枚举中找到需要的类别；</p><ol><li>二分查找</li><li>二叉排序树</li><li>字典树</li><li>散列（Hash）</li><li>map（STL库的map，用二叉排序树实现的）</li></ol><h3 id="实验提交事项">实验提交事项</h3><ol><li>提交：励儒云课堂</li><li>完成时间：3月28日晚上23：59分前</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30分钟速通Latex</title>
      <link href="/2024/01/24/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90Latex%E5%85%A5%E9%97%A8%E3%80%9130%E5%88%86%E9%92%9F%E9%80%9F%E9%80%9ALatex/"/>
      <url>/2024/01/24/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87/%E3%80%90Latex%E5%85%A5%E9%97%A8%E3%80%9130%E5%88%86%E9%92%9F%E9%80%9F%E9%80%9ALatex/</url>
      
        <content type="html"><![CDATA[<h1>30分钟速通Latex</h1><h2 id="Latex模板介绍">Latex模板介绍</h2><h3 id="Latex模板内容概览">Latex模板内容概览</h3><ol><li>注释：%</li><li>命令或特殊符号: \</li><li>普通文本：标题、摘要、正文、图标标题等</li></ol><p>Latex中的特殊符号：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%</td><td>注释</td></tr><tr><td>&amp;</td><td>数学公式<strong>或表格</strong>中对齐</td></tr><tr><td>$</td><td>数学公式标记符</td></tr><tr><td>~</td><td>保留强制空格</td></tr><tr><td>^/_</td><td>上三角和下户线用作上下标标记</td></tr><tr><td>“{”，“}”</td><td>左右花括号表示将其中的内容作为一个整体对待</td></tr><tr><td>#</td><td>编写宏包时使用</td></tr></tbody></table><h2 id="正文">正文</h2><p>latex模板正文前一般有个设定区域，用于导入宏包、规定论文格式等等，正文区域用\begin,…\end括起来，所有论文可见的内容均在正文区域里面添加，包括文字、图片、表格、公式。</p><p><a href="https://zhuanlan.zhihu.com/p/43981639">latex常用宏包</a></p><h3 id="正文各级标题">正文各级标题</h3><ul><li>chapter    章</li><li>section     节</li><li>subsection    小节</li><li>subsubsection      小小节</li></ul><h3 id="换行、换段、换页、首行缩进等命令">换行、换段、换页、首行缩进等命令</h3><ul><li><p>\\或者\newline或者\linebreak    表示换行</p></li><li><p>\\[offset]  表示换行，行间距为offset</p></li><li><p>\par  分段</p></li><li><p>\newpage   分页命令</p></li><li><p>\setlength{\parindent}{长度}     首行缩进</p></li></ul><h3 id="数学公式以及公式引用">数学公式以及公式引用</h3><ol><li><p>正文中特殊字符以及短公式</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span> + <span class="keyword">\beta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></li><li><p>单行、多行<strong>带编号公式</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%多行公式需要导入依赖包\usepackage&#123;amsmath&#125;</span></span><br><span class="line"><span class="comment">%自动引用也需要在设定区导入依赖包\usepackage&#123;hyperref&#125;</span></span><br><span class="line"><span class="comment">%需要正文输出的部分使用\text&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%所有公式必须由下面这两个扩着</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125; <span class="keyword">\label</span>&#123;公式标签&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%多行公式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%多行公式——分情况讨论公式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">%自动引用</span></span><br><span class="line"><span class="keyword">\autoref</span>&#123;公式标签&#125;</span><br></pre></td></tr></table></figure></li><li><p>单行、多行<strong>不带编号公式</strong></p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">公式</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="comment">%或者</span></span><br><span class="line"><span class="keyword">\[</span></span><br><span class="line">公式</span><br><span class="line"><span class="keyword">\]</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="图片">图片</h2><ul><li><p>插入图片需要导入依赖包graphicx</p></li><li><p>htbp是用于控制浮动体（图片、表格、公式等）位置，当一页空间不太够时，浮动图自动去到更合适的位置防止页面大量留白；</p><p>其中：</p><p>h表示here，尽量将浮动体放在代码（插入图片的latex代码）所在位置</p><p>t表示top，放在页面顶部</p><p>b表示bottom，放在页面底部</p><p>p表示page，放在一个单独的页面</p><p><strong>所以htbp规定了浮动体放置位置的优先级</strong></p></li><li><p>图片大小使用height和width规定，单位是cm或者in(inch)，如果只规定长或者高一个，将保持长宽比插入，一般只需要规定图片宽度</p></li><li><p>图片路径是相对于tex文件的路径</p></li><li><p>常用模板</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%部分双栏显示模板如果需要跨栏显示，则把\begin&#123;figure&#125;...\end&#123;figure&#125;改为\begin&#123;figure*&#125;...\end&#123;figure*&#125;即可</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[图片大小][图片路径]</span><br><span class="line"><span class="keyword">\caption</span>&#123;图片标题、说明&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;图片标签&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="表格">表格</h2><ul><li><p><code>\begin&#123;table&#125;[htb]</code>表示table的参数</p><p>h: 表格latex代码位置</p><p>t：置顶</p><p>b：置底</p></li><li><p>|c|用于约束表格每列的属性</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>r</td><td>right</td></tr><tr><td>l</td><td>left</td></tr><tr><td>c</td><td>center</td></tr><tr><td>t</td><td>top</td></tr><tr><td>b</td><td>bottom</td></tr><tr><td>p{‘width’}</td><td>单元格内容向上置顶</td></tr><tr><td>m{‘width’}</td><td>单元格上下居中(requires array package)</td></tr><tr><td>b{‘width’}</td><td>单元格向下置底(requires array package)</td></tr></tbody></table></li><li><p><a href="https://www.latex-tables.com">傻瓜式在线生成latex表格网站</a></p></li></ul><h2 id="参考文献">参考文献</h2><h3 id="直接引用">直接引用</h3><p>当参考文献较少时可以使用；</p><ol><li><p>正文中引用格式<code>\cite&#123;label1&#125;,\cite&#123;label2&#125;</code></p></li><li><p>文末参考文献引用格式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;label1&#125; ....文献1引用</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;label2&#125; ....文献2引用</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="BiBTex来管理文献">BiBTex来管理文献</h3><ul><li>如果一次引用文献过多，可以使用BiBTex来管理，设定区域添加<code>\bibliographystyle&#123;unsrt&#125;</code></li><li>在tex文件同目录下建立一个.bib文件，将要引用的文件引用条目按格式复制粘贴进去即可</li><li>首先通过谷歌学术搜索文献，找到BiB格式的文献引用条目，然后添加至bib文件中</li></ul><p>举例说明：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%bib文件，谷歌学术复制的引用</span></span><br><span class="line">@article&#123;yu2019review,</span><br><span class="line">title=&#123;A review of ...&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">%latex文件设定区导入依赖包</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;unsrt&#125;</span><br><span class="line"><span class="comment">%latex文件正文引用</span></span><br><span class="line"><span class="keyword">\cite</span>&#123;yu2019review&#125;</span><br><span class="line"><span class="comment">%latex文件文末参考文献位置</span></span><br><span class="line"><span class="keyword">\bibliography</span>&#123;bib文件名&#125;</span><br></pre></td></tr></table></figure><h4 id="参考文献右上角引用">参考文献右上角引用</h4><ul><li>设定区域添加依赖包`\newcommand{\upcite}[1]{\textsuperscript{\cite</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 论文写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】19. 类和对象</title>
      <link href="/2023/12/31/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9119.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/12/31/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9119.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1>面向对象的Python程序设计</h1><h2 id="Python的类">Python的类</h2><h3 id="类的定义">类的定义</h3><p>类由三部分构成：</p><ul><li>类的名称：首字母必须大写</li><li>类的属性：成员数据</li><li>类的方法：成员函数、方法</li></ul><p>代码定义：</p><ul><li><p>使用class关键字来声明一个类，基本格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line">类的属性</span><br><span class="line">    类的方法</span><br></pre></td></tr></table></figure></li><li><p>根据类来创建对象，基本语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名 = 类名()</span><br></pre></td></tr></table></figure></li><li><p>如果想给对象临时地添加属性，可以通过如下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.新的属性名 = 值</span><br></pre></td></tr></table></figure></li><li><p>使用内置的方法isinstance()测试对象是否是某个类的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tiger = Animal()</span><br><span class="line">tiger.weight = <span class="number">100</span></span><br><span class="line"><span class="built_in">isinstance</span>(tiger,Animal)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"><span class="built_in">isinstance</span>(tiger,<span class="built_in">str</span>)</span><br><span class="line">&gt;&gt; <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>pass语句，类似于空语句，作为占位符</p><p>常用语类的定义、函数定义、选择结构</p><p>可以为软件升级、函数功能扩展预留空间</p></li><li><p>self参数</p><ol><li>在方法的列表中，<strong>第一个参数永远是self</strong>，表示的是对象自身</li><li>类的实例方法中，访问实例属性时需要以self为前缀</li><li><strong>当某个对象调用方法的时候，Python解释器会把这个对象作为第一个参数自动传给self，开发者只需要传递后面的参数即可</strong></li><li>如果在外部通过类名调用对象方法则需要显式为self参数传值</li></ol></li></ul><h2 id="Python类的成员">Python类的成员</h2><h3 id="基本定义">基本定义</h3><h4 id="类的属性成员">类的属性成员</h4><p>类属性</p><ul><li>类对象所拥有的属性，它被所有类对象的实例对象拥有，在内存中只存在一个副本；</li><li>属于类的数据成员是在类中所有方法之外定义的；</li></ul><p>实例属性</p><ul><li>实例对象所拥有的属性，以self.开头</li><li>属于对象实例的数据成员一般是指在构造函数_<em>init_</em>()中定义的，定义和使用时必须以self作为前缀</li></ul><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    price = <span class="number">1000</span> <span class="comment">#类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,c</span>):</span><br><span class="line">        self.color = c <span class="comment">#定义了实例属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">brake</span>(<span class="params">self</span>):</span><br><span class="line">        self.speed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">car1 = Car(<span class="string">&#x27;red&#x27;</span>) <span class="comment">#使用类</span></span><br><span class="line">car2 = Car(<span class="string">&#x27;blue&#x27;</span>) <span class="comment">#使用类</span></span><br><span class="line"></span><br><span class="line">Car.name = <span class="string">&#x27;QQ&#x27;</span> <span class="comment">#类属性（在类外增加了新的类属性，name）,类属性时共同的</span></span><br><span class="line"></span><br><span class="line">car2.babychair = <span class="string">&#x27;babydes&#x27;</span> <span class="comment">#为对象Car2增加新的属性，并且赋值</span></span><br><span class="line"></span><br><span class="line">car1.price = <span class="number">200000</span> <span class="comment">#不会改变类的属性，这只是为car1增加了一个新的实例化实现price，不影响类属性</span></span><br><span class="line"></span><br><span class="line">Car.price = <span class="number">200000</span> <span class="comment">#用类名来修改类属性，这样所有车都涨价了</span></span><br></pre></td></tr></table></figure><h4 id="类的方法成员">类的方法成员</h4><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setSpeed</span>(<span class="params">self,s</span>):</span><br><span class="line">    <span class="built_in">set</span>.speed = s</span><br><span class="line"><span class="comment">#用types.MethodType方法把在外部的方法绑定到具体的类对象实例    </span></span><br><span class="line">car1.setSpeed = types.MethodType(setSpeed,car1) <span class="comment">#动态增加对象的方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="property属性">property属性</h4><ul><li>property属性时一种特殊的属性，访问它时会执行一段功能（函数）然后返回值作为属性；property是方法属性，用方法的值作为类的属性。</li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,raduis</span>):</span><br><span class="line">        self.raduis=raduis</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  </span><span class="comment">#所以可以看到，property属性实际上是用装饰器来实现的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> math.pi * self.raduis**<span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*math.pi*self.raduis</span><br><span class="line">    </span><br><span class="line">c = Circle(<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(c.raduis) <span class="comment">#访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(c.area) <span class="comment">#通过函数名访问方法类属性，实际上就是类属性</span></span><br><span class="line"><span class="built_in">print</span>(c.perimeter)</span><br></pre></td></tr></table></figure><ul><li>property属性字段的创建<ol><li>通过装饰器创建<code>@property.getter()</code>、<code>@property.setter()</code>、<code>@property.deleter()</code>方法创建属性字段</li><li>通过<code>property()</code>创建对象的属性字段</li></ol></li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一：使用装饰器的方式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__original_price = <span class="number">200</span></span><br><span class="line">        self.__discount = <span class="number">0.7</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">@property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        new_price = self.__original_price*self.__discount</span><br><span class="line">        </span><br><span class="line"><span class="meta">@property.setter  </span><span class="comment">#用于修改属性，重置属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;%s must be int&#x27;</span>%value)</span><br><span class="line">        self.__original_price = value</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__original_price <span class="comment">#删除属性</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">cloth = Goods()</span><br><span class="line">cloth.price <span class="comment">#获取商品价格</span></span><br><span class="line">cloth.price = <span class="number">100</span> <span class="comment">#修改商品价格</span></span><br><span class="line"><span class="built_in">print</span>(cloth.price) </span><br><span class="line"><span class="keyword">del</span> cloth.price <span class="comment">#删除商品原价</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二：使用property函数的方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.__original_price = <span class="number">200</span></span><br><span class="line">        self.__discount = <span class="number">0.7</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        new_price = self.__original_price*self.__discount</span><br><span class="line">        </span><br><span class="line"><span class="comment">#用于修改属性，重置属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;%s must be int&#x27;</span>%value)</span><br><span class="line">        self.__original_price = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self.__original_price <span class="comment">#删除属性</span></span><br><span class="line">    </span><br><span class="line">    price = <span class="built_in">property</span>(get_price,set_price,del_price,<span class="string">&#x27;good price&#x27;</span>)<span class="comment">#最后一个参数是给这个属性一个标志</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">cloth = Goods()</span><br><span class="line">cloth.price <span class="comment">#获取商品价格</span></span><br><span class="line">cloth.price = <span class="number">100</span> <span class="comment">#修改商品价格</span></span><br><span class="line"><span class="built_in">print</span>(cloth.price) </span><br><span class="line"><span class="keyword">del</span> cloth.price <span class="comment">#删除商品原价</span></span><br></pre></td></tr></table></figure><h2 id="Python的方法成员">Python的方法成员</h2><h3 id="概览">概览</h3><p>Python类中的方法：</p><ol><li><p>普通方法/实例方法：</p><p>属于对象实例定义的，定义和使用时必须以self为前缀；</p><p>调用时的方法为：对象名.NormalMethod(), 类不能调用</p></li><li><p>类方法</p><p>使用@classmethod装饰，可以访问类属性，定义时第一个参数为cls，cls是类的标志</p><p>调用时的方法为：类名.类方法()，也可以通过  对象名.类方法</p></li><li><p>静态方法</p><p>使用@staticmethod装饰，使用于无参数的方法</p><p>调用时的方法为：类名.静态方法()或者对象名.静态方法()调用</p></li></ol><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    classAttribute  = <span class="string">&#x27;类属性&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#普通方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normalMethod</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.classAttribute) <span class="comment">#访问的是类的对象属性</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">id</span>(self.classAttribute)) </span><br><span class="line">        <span class="built_in">print</span>(A.classAttribute) <span class="comment">#访问的是类属性</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">id</span>(A.classAttribute))</span><br><span class="line">        A.classAttribute = <span class="string">&#x27;this is a new class Attribute&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(A.classAttribute)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">id</span>(A.classAttribute))</span><br><span class="line">     </span><br><span class="line">    <span class="comment">#静态方法,静态方法里面没有类的标志和属性，所以无法访问对象具体的方法和属性，只能通过类名来访问类的相关东西</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticMethod</span>():</span><br><span class="line">        <span class="built_in">print</span>(A.classAttribute) <span class="comment">#在方法内部只能用类名来访问</span></span><br><span class="line">        <span class="comment">#A.normalMethod(&#x27;abc&#x27;)    报错，无法访问到类的成员方法</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">staticMethod2</span>():</span><br><span class="line">        <span class="built_in">print</span>(A.staticMethod())<span class="comment">#可以</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">classMethod</span>(<span class="params">cls,classAttribute</span>):</span><br><span class="line">        <span class="built_in">print</span>(cls.classAttribute) <span class="comment">#在方法内部只能用cls或者类名访问</span></span><br><span class="line">        cls.classAttribute = classAttribute</span><br><span class="line">       </span><br><span class="line"><span class="comment">#普通调用方法（普通方法必须要通过对象调用）</span></span><br><span class="line">a = A()</span><br><span class="line">a.classAttribute = <span class="string">&#x27;this is instance atrribute&#x27;</span> <span class="comment">#动态增加对象属性并赋值</span></span><br><span class="line">a.normalMethod(<span class="string">&#x27;this is new&#x27;</span>)<span class="comment">#调用普通方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(A.normalMethod())这个语句是错误的，普通方法不能由类名调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#类方法调用</span></span><br><span class="line">a.classMethod(<span class="string">&#x27;new class attribute called by object name&#x27;</span>)</span><br><span class="line">A.classMethod(<span class="string">&#x27;new class attribute called by class name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#静态方法的调用，无参数</span></span><br><span class="line">a = A()</span><br><span class="line">a.staticMethod() <span class="comment">#对象调用</span></span><br><span class="line">A.staticMethod() <span class="comment">#类名调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Python中的继承">Python中的继承</h2><h3 id="简介">简介</h3><p>继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类；父类又可以称为基类或超类，新建的类称为派生类或子类；</p><p>继承是在继承原有类功能的基础上，增加新的功能（属性或方法），形成新功能模块；</p><h3 id="单重继承">单重继承</h3><p>举例：</p><p>车是抽象的父类，可以派生出卡车、公交车等派生类；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,color</span>):</span><br><span class="line">        self.licensenumber = no <span class="comment">#车牌号</span></span><br><span class="line">        self.color = color <span class="comment">#车身颜色</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;车启动&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;车停止&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">speedup</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;车加速&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">slowdown</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;车减速&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span>(<span class="title class_ inherited__">Car</span>):<span class="comment">#写公交车的扩充代码</span></span><br><span class="line">    passengerLimit = <span class="number">50</span> <span class="comment">#为子类增加了类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,color</span>):</span><br><span class="line">        self.totalpassenger = <span class="number">0</span>  <span class="comment">#为子类对象创建新的属性</span></span><br><span class="line">        Car.__init__(self,no,color)  <span class="comment">#借助父类的方法实现子类的构造</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">announce</span>(<span class="params">self,voice</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;报站&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Truck</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,color</span>):</span><br><span class="line">        self.loadweight = <span class="number">0</span></span><br><span class="line">        Car.__init__(self,no,color)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loading</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;装货&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unloading</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;卸货&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">#调用</span></span><br><span class="line">abus = Bus(<span class="string">&#x27;粤A99999&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">abus.start()</span><br><span class="line">abus.announce(<span class="string">&#x27;车辆启动，请坐稳扶好&#x27;</span>)</span><br><span class="line">abus.speedup()</span><br><span class="line">abus.announce(<span class="string">&#x27;车辆行驶，请注意安全&#x27;</span>)</span><br><span class="line">abus.slowdown()</span><br><span class="line">abus.stop()</span><br><span class="line"></span><br><span class="line">abus.announce(<span class="string">&#x27;车辆到站，请准备下车&#x27;</span>)</span><br><span class="line">Bus.passengerLimit = <span class="number">50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;公交车限员:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(Bus.passengerLimit))</span><br><span class="line"></span><br><span class="line">atruck = Truck(<span class="string">&#x27;粤A88888&#x27;</span>,<span class="string">&#x27;Yellow&#x27;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="多重继承">多重继承</h3><p>一个子类继承多个类；</p><p>消防车继承车，水枪两个类，并且有自己独立的属性；</p><p>下面举例消防车的多重继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#车的类上面写了，不赘述</span></span><br><span class="line"><span class="comment">#水枪的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaterPistol</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,flow,temp</span>):</span><br><span class="line">        self.flowspeed = flow</span><br><span class="line">        self.temporature = temp</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spur</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;水枪打开&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line"><span class="comment">#消防车类，多重继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FireTruck</span>(Car,WaterPistol):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,no,color,flow,temp</span>):</span><br><span class="line">        Car.__init__(self,no,color)</span><br><span class="line">        WaterPistol.__init__(self,flow,temp)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alarm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发出火警信号&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spur</span>(<span class="params">self</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正在灭火&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">putout</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在灭火，不要靠近&quot;</span>)</span><br><span class="line">        WaterPistol.spur(self) <span class="comment">#调用父类灭火方法</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#调用使用</span></span><br><span class="line">aft = FireTruck(<span class="string">&#x27;A88888&#x27;</span>,<span class="string">&#x27;red&#x27;</span>,<span class="number">20</span>,<span class="number">50</span>)</span><br><span class="line">aft.spur() <span class="comment">#调用对象的行为方法</span></span><br><span class="line">aft.putout() <span class="comment">#调用对象的行为方法</span></span><br><span class="line">aft.alarm() <span class="comment">#调用对象的行为方法</span></span><br></pre></td></tr></table></figure><h4 id="多重继承方法的执行次序问题">多重继承方法的执行次序问题</h4><p>多重基础过程中，如果存在同名的方法，如何确定执行的次序呢？</p><ol><li>Python的类可以继承多个类，Java和C#只能继承一个类</li><li>Python的类如果继承了多个类，那么其寻找方法的方式有两种：广度优先、深度优先<ul><li>当类是经典类时，多继承情况下，会按照深度优先查找</li><li>当类是新式类时，多继承情况下，会按照广度优先查找</li><li>经典类和新式类，从字面意思可以看出一个老一个新，新的必然包含了更多的功能，也是推荐的写法；从写法上区分，<strong>如果当前类或者父类继承了object类，那么该类是新式类，否则为经典类</strong></li></ul></li></ol><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;D.say&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;C.say&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">D</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B.say&#x27;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(B,C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.sayHello()</span><br><span class="line"><span class="comment">#执行sayhello方法时，首先去A类查找，如果没有，则去B类，如果B也没有，则去D类；如果找到就执行，没找到就报错；（广度优先）</span></span><br><span class="line">D</span><br><span class="line"> B     C</span><br><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="Python类的多态">Python类的多态</h2><p>根据传入对象的不同，执行不同类中的同名方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DOg</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;吃鱼&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Func</span>(<span class="params">obj</span>):</span><br><span class="line">    obj.eat()</span><br><span class="line">    </span><br><span class="line">obj = Cat()</span><br><span class="line">Func(obj) <span class="comment">#在Func函数中传入Cat类的对象obj，执行Cat中eat的方法</span></span><br><span class="line">obj = Dog()</span><br><span class="line">Func(obj)</span><br></pre></td></tr></table></figure><h2 id="类中的成员访问控制问题">类中的成员访问控制问题</h2><h3 id="类中不同的成员">类中不同的成员</h3><ul><li><p>私有成员和公有成员的定义不同：</p><p><strong>私有成员命名时，前两个字符是下划线</strong></p></li><li><p>私有成员和公有成员的访问限制不同：</p><p>公有成员，在任何地方都能访问</p><p>私有成员，只有在类的内部才能访问</p></li><li><p>特殊成员：<strong>特殊成员命名的前后都有两个下划线</strong></p><p>比如特殊方法：<code>__init__</code></p></li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    role = <span class="string">&#x27;公民&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age</span>): <span class="comment">#特殊方法</span></span><br><span class="line">        self.name = name <span class="comment">#实例公有属性</span></span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.__age = age <span class="comment">#实例私有属性</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__call_</span>(<span class="params">self,*args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象()时调用__call__&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__printinfo</span>(<span class="params">self</span>): <span class="comment">#私有方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;姓名：&quot;</span>+self.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;性别：&quot;</span>+self.sex)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;年龄：&quot;</span>+<span class="built_in">str</span>(self.__age)) <span class="comment">#类内部可访问私有属性</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enjoylift</span>(<span class="params">self</span>):</span><br><span class="line">        self.__printinfo() <span class="comment">#私有方法在内部可以使用</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;enjoylife&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name+self.sex+<span class="built_in">str</span>(self.__age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,sex,age,skill</span>):</span><br><span class="line">        Person.__init__(self,name,sex,age)</span><br><span class="line">        self.superskill = skill</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gatherPower</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;超人正在积累&#123;&#125;能量&quot;</span>.<span class="built_in">format</span>(self.superskill))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#对单个类Person的测试</span></span><br><span class="line">    stu = Person(<span class="string">&#x27;MIKE&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(stu.name)</span><br><span class="line">    <span class="built_in">print</span>(stu.sex)</span><br><span class="line">    <span class="comment">#print(stu.__age)  报错，类的外部不能访问私有属性</span></span><br><span class="line">    <span class="comment">#stu.__printinfo() 报错，类的外部不能访问私有方法</span></span><br><span class="line">    stu.enjoylife()</span><br><span class="line">    stu.name = <span class="string">&#x27;jacky&#x27;</span> <span class="comment">#修改对象的name属性</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">#对派生类的测试</span></span><br><span class="line">    superman = SuperMan(<span class="string">&#x27;小王&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;自我修炼&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(superman.name) <span class="comment">#SuperMan类中没有name属性，但是父类有，所以这里输出父类</span></span><br><span class="line">    <span class="built_in">print</span>(superman.sex) <span class="comment">#公有属性可访问</span></span><br><span class="line">    <span class="comment">#print(superman.__age) 报错</span></span><br><span class="line">    <span class="comment">#superman.__printinfo() 报错，不能在子类中访问父类的私有方法，所以私有方法不会继承到SuperMan中</span></span><br><span class="line">    superman.enjoylife()</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="访问限制">访问限制</h3><ul><li>公有字段、方法：在派生类中可以访问</li><li>私有字段、方法：在派生类中不能访问</li></ul><p>属性的定义和使用</p><ul><li>Python3.x中，属性得到了很好的保护，我们可以使用装饰器来使得某些属性只读从而进行保护</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.__value = value</span><br><span class="line">        </span><br><span class="line"><span class="meta">@property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">self</span>):  <span class="comment">#只读，无法修改和删除</span></span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line">    </span><br><span class="line"><span class="comment">#也可以使用property函数的方法实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.__value = value</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set</span>(<span class="params">self,v</span>):</span><br><span class="line">        self.__value = v</span><br><span class="line">        </span><br><span class="line">value = <span class="built_in">property</span>(__get,__<span class="built_in">set</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.__value)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">t = test(<span class="number">3</span>)</span><br><span class="line">t.value</span><br><span class="line">&gt;&gt; <span class="number">3</span></span><br><span class="line">t.value = <span class="number">5</span> <span class="comment">#这时允许修改属性值</span></span><br><span class="line">t.show()</span><br><span class="line">&gt;&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> t.value <span class="comment">#报错，试图删除对象属性</span></span><br></pre></td></tr></table></figure><h3 id="常用的特殊方法">常用的特殊方法</h3><p>Python类中有大量的特殊方法，常见的有构造函数和析构函数，还有其他大量的特殊方法：</p><ul><li>Python类的构造函数是 <code>__init__()</code>，一般用于为数据成员设置初始值或进行其他必要的初始化工作，在创建对象时被自动调用和执行。如果用户没有设计构造函数，Python将提供一个默认的构造函数来进行必要的初始化工作。</li><li>Python类中的析构函数是<code>__del__()</code>，一般用于释放对象占用的资源，在Python删除对象和回收对象空间时被自动调用和执行。如果用户没有设计析构函数，Python将提供一个默认的析构函数来进行必要的清理工作。</li></ul><h4 id="典型的特殊方法">典型的特殊方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> accessExample <span class="keyword">import</span> Persom <span class="comment">#自己在另外一个文件写的模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    zhang = Person(<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">20</span>) <span class="comment">#执行的是__init__</span></span><br><span class="line">    zhang() <span class="comment">#执行的是__call__</span></span><br><span class="line">    <span class="built_in">print</span>(zhang.__doc__) <span class="comment">#打印描述类型</span></span><br><span class="line">    <span class="built_in">print</span>(zhang.__module__) <span class="comment">#打印在哪个模块</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(zhang.__class__) <span class="comment">#打印当前操作对象时哪个类</span></span><br><span class="line">    <span class="built_in">print</span>(Person.__dict__) <span class="comment">#用字典的方式输出该对象所在模块、doc、类属性是什么、方法名字、地址等等</span></span><br><span class="line">    <span class="built_in">print</span>(zhang) <span class="comment">#调用__str__方法，可以自定义，默认输出该方法的返回值</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】18. Tkinter视窗设计</title>
      <link href="/2023/12/17/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9118.%20Tkinter%E8%A7%86%E7%AA%97%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/12/17/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9118.%20Tkinter%E8%A7%86%E7%AA%97%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>Tkinter视窗设计</h1><h2 id="简介">简介</h2><p>Tkinter模块是Python自带的特定的可编辑的GUI界面，是Python的图形化界面开发的小工具；实际上用过pyqt的应该会发觉两者基本没有区别；</p><p>Tkinter的基本要素：</p><table><thead><tr><th>要素</th><th>描述</th></tr></thead><tbody><tr><td>Toplevel</td><td>根窗体；相当于画板</td></tr><tr><td>Frame</td><td>容器</td></tr><tr><td>Canvas</td><td>画布</td></tr><tr><td>布局管理器grid、pack、place</td><td>管理界面布局</td></tr></tbody></table><h2 id="基本操作">基本操作</h2><h3 id="创建基本窗口布局">创建基本窗口布局</h3><h4 id="主窗口">主窗口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk</span><br><span class="line">window = tk.Tk()</span><br><span class="line"><span class="comment">#常见函数</span></span><br><span class="line">window.title(<span class="string">&#x27;窗口标题&#x27;</span>)</span><br><span class="line">window.iconbitmap(<span class="string">&#x27;my_icon.ico&#x27;</span>)</span><br><span class="line">window.geometry(<span class="string">&quot;500x600&quot;</span>)</span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure><h4 id="菜单条">菜单条</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menubar = tk.Menu(window) <span class="comment">#创建一个菜单栏，此时menubar可以理解为一个容器，出现在窗口上方</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
            <tag> python、GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】17. 协程和线程——并行提速</title>
      <link href="/2023/10/25/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9117.%20%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E5%B9%B6%E8%A1%8C%E6%8F%90%E9%80%9F/"/>
      <url>/2023/10/25/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9117.%20%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E2%80%94%E2%80%94%E5%B9%B6%E8%A1%8C%E6%8F%90%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1>线程、进程、协程——并行提速</h1><p>Python的并行编程有三种方式：多线程Thread、多进程Process、多协程Coroutine</p><p>Python中可以使用多协程或者多线程来实现并行执行程序，从而加速程序的执行速度。具体选择使用协程还是线程取决于应用场景和需求。协程适用于I/O密集型任务，如网络请求、文件读写等，而线程适用于I/O密集型任务和计算密集型任务的混合场景。</p><p>在Python中，有两个主要的库用于实现协程和线程：asyncio和threading</p><h2 id="CPU密集型计算、IO密集型计算">CPU密集型计算、IO密集型计算</h2><h3 id="CPU密集型（CPU-bound）">CPU密集型（CPU-bound）</h3><p>CPU密集型也叫计算密集型，是指在IO很短的时间内可以完成，但是在这期间CPU要进行大量的运算和处理，特点是CPU占用率相当高。</p><p>比如：压缩和解压缩、加密和解密、正则表达式搜索</p><h3 id="IO密集型（IO-bound）">IO密集型（IO-bound）</h3><p>在系统运行过程中，CPU在等待IO的读写操作，CPU占用率较低。</p><p>比如：文件处理程序、网络爬虫程序、读写数据库程序</p><h3 id="多进程、多线程、多协程的对比">多进程、多线程、多协程的对比</h3><h4 id="多进程（Process-multiprocessing）">多进程（Process-multiprocessing）</h4><p>优点：可以利用多核CPU进行并行运算</p><p>缺点：占用资源多、可以启动的数目少（受到CPU个数的限制）</p><p>适用于CPU密集型计算</p><h4 id="多线程（Thread-Threading）">多线程（Thread-Threading）</h4><p>一个进程中，可以开启多个线程</p><p>优点：相比进程更轻量级，占用资源少</p><p>缺点：</p><ul><li>相比进程：多线程只能并发执行，不能用多个CPU（在计算期间，由于Python的GIL锁（全局解释器）要确保程序执行过程中只能有一个线程，所以这个期间只能使用单核CPU；当程序进行IO时，GIL锁释放，可以进行并行IO）</li><li>相比协程：启动数目有限，占用内存资源，有线程切换的开销</li></ul><p>适用于IO密集型计算、同时运行的任务数目要求不多</p><h4 id="多协程（Coroutine-asyncio）">多协程（Coroutine-asyncio）</h4><p>一个线程中，可以开启多个协程，甚至可以达到几万个协程</p><p>优点：内存开销最小、启动协程数目最多</p><p>缺点：支持的库有限制（aiohttp可以用，但是request不能用）、代码实现复杂</p><p>适用于IO密集型计算、需要运行超多任务，且现有的库支持的场景</p><h2 id="多线程demo">多线程demo</h2><p>这里演示一下多线程request</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">url = [<span class="string">f&quot;https://.....page=<span class="subst">&#123;i&#125;</span>&amp;...&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">50</span>+<span class="number">1</span>)]<span class="comment">#分析到一个url链接，通过配置page参数得到多个url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">craw</span>(<span class="params">t_url</span>):</span><br><span class="line">        resp = request.get(t_url)</span><br><span class="line">        <span class="built_in">print</span>(turl,<span class="built_in">len</span>(resp.text))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_thread</span>():</span><br><span class="line">    <span class="keyword">for</span> t_url <span class="keyword">in</span> url:</span><br><span class="line">        craw(t_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_thread</span>():</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> t_url <span class="keyword">in</span> url:</span><br><span class="line">        threads.append(threading.Thread(target=craw, args=(t_url,)))<span class="comment">#threading.Thread是threading库的一个方法，传入执行的函数名和函数参数，返回一个Thread对象，参数以元组形式传入</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()<span class="comment">#启动多线程</span></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()<span class="comment">#等待多线程执行完毕</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
            <tag> 爬虫设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown快速入门指南</title>
      <link href="/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91markdown%E8%BF%85%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91markdown%E8%BF%85%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1>markdown快速入门</h1><blockquote><p>本文旨在介绍markdown以及其使用技巧，以及typora在windows端和ubuntu端的白嫖。浅浅介绍一下typora自定义主题。</p><hr><p>下面说一些废话，如果想直接上手，可以直接<a href="##Typora%E7%9A%84%E5%AE%89%E8%A3%85">跳到这里</a></p></blockquote><h2 id="markdown简介">markdown简介</h2><p>markdown是一种轻量级标记语言(本质上是个浏览器)，你可以通过它的标记语法插入图片、视频、网站链接等等一切浏览器可表示的静态内容。具体定义见<a href="https://zh.wikipedia.org/zh-sg/Markdown">wiki关于markdown的介绍</a></p><h2 id="markdown的优点">markdown的优点</h2><p>个人来说，markdown的优点在于：</p><ul><li>没有word的繁杂的排版，可以让你专注于写内容</li><li>支持多种格式导出，可以导出成pdf、word、latex、html等多种格式的文件，实现all in one!</li><li>可自定义程度高，如果会写css的话，魔改markdown样式也是一项乐趣，可以把它写成学校实验报告、论文等格式；写一次、用一生。:joy:</li><li>基本上一些项目的readme都是markdown格式文本，最常见就是github上的了。所以是程序员必须掌握的东西；当然我认为不是程序员也应该掌握它，你会喜欢上掌握它带来的便利。</li><li>更多待解锁…</li></ul><h2 id="Typora编辑器">Typora编辑器</h2><p>就像用word写word文档一样，markdown也有很多编辑器。</p><p>其实用记事本也可以写markdown，只要会它的语法即可。不过还需要其他一些软件渲染出来。个人一直使用流行的markdown编辑器Typora。Typora的编辑方式是&quot;所见即所得&quot;，我们写好的markdown文本会马上被渲染成我们想要的样子。</p><p>那么接下来，我们按照：Typora的安装——&gt;Typora以及markdown的使用——&gt;Typora自定义主题  的逻辑上手markdown。</p><h2 id="Typora的安装">Typora的安装</h2><p>Typora目前是收费的，但是咱可以白嫖。下面分别介绍windows端typora的白嫖以及linux端的白嫖。</p><h3 id="Windows端Typora的使用">Windows端Typora的使用</h3><ol><li><p>在官网下载Typora</p><p><a href="https://typora.io/">Typora官网地址</a></p><p>选择历史版本1.6.7，下载windows64位的Typora。</p></li><li><p>下载github仓库包</p><p><a href="https://github.com/shuhongfan/TyporaCrack">仓库地址</a></p><p>下载好后，把下载下来的仓库里面的winmm.dll复制到Typora的安装目录下即可。</p><p><strong>如果不行的话，可以试试用仓库里的typora安装包安装Typora</strong></p></li></ol><h3 id="Linux端Typora的使用">Linux端Typora的使用</h3><p>这里只介绍Ubuntu端的Typora的使用，详细见我前面的博客。</p><h2 id="markdown的基本语法">markdown的基本语法</h2><p>markdown详细语法可以参考<a href="https://markdown.com.cn/basic-syntax/">markdown语法教程</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">标题</span><br><span class="line"><span class="section">#一级标题</span></span><br><span class="line"><span class="section">##二级标题</span></span><br><span class="line"><span class="section">###三级标题</span></span><br><span class="line">依此类推，最多6级</span><br><span class="line">Typora快捷键——&gt;<span class="code">`ctrl+n`</span> 这里的n代表的是第几级标题</span><br><span class="line"></span><br><span class="line">加粗</span><br><span class="line"><span class="strong">**加粗字体**</span></span><br><span class="line">Typora快捷键——&gt;<span class="code">`ctrl+B`</span></span><br><span class="line"></span><br><span class="line">倾斜</span><br><span class="line"><span class="emphasis">*倾斜字体*</span></span><br><span class="line">Typora快捷键——&gt;<span class="code">`ctrl+I`</span></span><br><span class="line"></span><br><span class="line">高亮</span><br><span class="line">==高亮字体==</span><br><span class="line"></span><br><span class="line">超链接</span><br><span class="line">[<span class="string">百度</span>](<span class="link">https://www.baidu.com</span>)  这时点击百度即可跳转</span><br><span class="line">支持插入图片</span><br><span class="line"></span><br><span class="line">内嵌HTML代码</span><br><span class="line">HTML代码可以自定义为任何样式，需要一点HTML和CSS基础</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line">&gt;引用的句子</span><br><span class="line">Typora快捷键——&gt;<span class="code">`ctrl+shift+Q`</span></span><br><span class="line"></span><br><span class="line">列表（注意.后面有空格）</span><br><span class="line"><span class="bullet">1.</span> 第一行</span><br><span class="line"><span class="bullet">2.</span> 第二行</span><br><span class="line"><span class="bullet">1.</span> 第一行</span><br><span class="line">Typora快捷键——&gt;<span class="code">`ctrl+shift+[`</span>,或者<span class="code">`ctrl+shift+]`</span>分别对应不同的样式</span><br><span class="line"></span><br><span class="line">内嵌代码</span><br><span class="line">这是一段代码<span class="code">`代码`</span></span><br><span class="line"></span><br><span class="line">代码块</span><br><span class="line">Typora快捷键<span class="code">`ctrl+shift+k`</span></span><br><span class="line"></span><br><span class="line">表格</span><br><span class="line">Typora快捷键 <span class="code">`ctrl+T`</span></span><br></pre></td></tr></table></figure><p>当然，markdown还支持数学公式的渲染，如果你会latex数学公式的语法，可以无缝衔接。markdown内<a href="https://blog.csdn.net/NSJim/article/details/109045914?spm=1001.2014.3001.5506">数学公式汇总</a></p><h2 id="Typora自定义主题">Typora自定义主题</h2><p>菜单栏的themes可以换主题样式，如果想自定义主题可以打开file-&gt;prefernces-&gt;appearance-&gt;open theme floder</p><p>把自定义的css文件放进去，重启后可以再次选择themes，选择自定义的样式。</p><p>由于本人平时比较喜欢latex论文风格，所以这里推荐一个别人写好的样式，具体教程在其仓库的readme有详细介绍。</p><ul><li><p>仓库地址：</p><p><a href="https://github.com/Keldos-Li/typora-latex-theme">typora-latex-theme</a></p></li><li><h2 id="写在最后">写在最后</h2></li></ul><p>当然，Typora的图片管理，可以用图床，这里不过多介绍，可能后续会更新，读者也可以自行搜索实现，我主要用的是github仓库+PicGo-cli+cdn域名加速。</p><p>说到底，markdown这类的都属于工具，对于工具，我们想快速掌握，最好的办法就是用上它，多用、多写就行了，想实现什么，google一下，慢慢积累，自然就熟悉了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下使用Typora</title>
      <link href="/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22.04%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8%E4%BB%98%E8%B4%B9%E7%89%88typora/"/>
      <url>/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22.04%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%85%8D%E8%B4%B9%E4%BD%BF%E7%94%A8%E4%BB%98%E8%B4%B9%E7%89%88typora/</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu22.04环境使用Typora</h1><h2 id="敬告">敬告</h2><p>**请注意：**本文仅以记录个人的学习过程，请不要从事任何违法行为。由此产生的任何问题都将由用户（您）承担。</p><h2 id="须知">须知</h2><ul><li>支持typora版本1.0.3</li><li>本人已测试平台：Ubuntu22.04</li></ul><h2 id="激活环境准备">激活环境准备</h2><ul><li><p>安装Python3、Python3-pip</p></li><li><p>安装nodejs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure></li><li><p>克隆typoraCraker项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cnvetman/typoracracker.git</span><br></pre></td></tr></table></figure></li><li><p>安装python相关依赖</p><p>切换到克隆下来的项目根目录typoracracker下执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="解包替换文件">解包替换文件</h2><blockquote><p>以下操作都是切换到<strong>typoraCracker项目根目录下</strong>执行</p><p><strong>注意，强烈建议在解包原生文件到~/Desktop中</strong></p></blockquote><ul><li><p>下载Typora1.0.3版本</p><p>项目目录下有typora_1.0.3的deb包，执行下面命令直接安装即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i typora_1.0.3_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>解包原生app.asar</p></li></ul><p>安装Typora后，原生<code>app.asar文件</code>默认路径是<code>/usr/share/typora/resources/app.asar</code>；解包原生<code>app.asar文件</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 typora.py /usr/share/typora/resources/app.asar ~/Desktop/  </span><br><span class="line"><span class="comment"># 解包后，在桌面会有一个`dec_app`目录</span></span><br></pre></td></tr></table></figure><ul><li>修改License.js</li></ul><p>修改<code>dec_app</code>目录中的License.js；在typoraCracker项目下，提供有修改好的License.js，所以直接替换即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> example/patch/License.js ~/Desktop/dec_app/</span><br></pre></td></tr></table></figure><ul><li>生成app.asar</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 typora.py -u ~/Desktop/dec_app ~/Desktop</span><br><span class="line"><span class="comment"># 在~/Desktop路径下，会生成新的的app.asar文件</span></span><br></pre></td></tr></table></figure><ul><li>替换app.asar</li></ul><p>将Typora原生的的app.asar文件替换：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份原生app.asar文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> /usr/share/typora/resources/app.asar /usr/share/typora/resources/app.asar.bak    </span><br><span class="line"><span class="comment"># 用新生成的app.asar文件替换typora自带的app.asar文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> ~/Desktop/app.asar /usr/share/typora/resources/app.asar         </span><br></pre></td></tr></table></figure><h2 id="激活Typora">激活Typora</h2><ul><li>在<strong>typoraCracker项目根路径下</strong>，执行keygen.js脚本：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成激活码</span></span><br><span class="line">node example/keygen.js</span><br></pre></td></tr></table></figure><p>得到激活码后，打开Typora软件 --&gt; Typora帮助 --&gt; 我的许可证 --&gt; 输入你的激活信息，随便一个邮箱加生成的激活码。</p><ul><li>激活成功</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801001323820.png" alt="image-20230801001323820"></p>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo初步搭建个人博客</title>
      <link href="/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Hexo%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Hexo%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>Hexo搭建个人博客</h1><blockquote><p>本文介绍hexo博客框架在Ubuntu下的搭建，只是搭建一个能用的个人博客框架，至于美化等其他的暂不介绍。</p></blockquote><h2 id="Hexo博客框架">Hexo博客框架</h2><p>优点：社区成熟，学习文档多。</p><h2 id="环境搭建">环境搭建</h2><p>环境：Ubuntu22.04 LST</p><ol><li><p>第一步，个人习惯，更新一下源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li><li><p>安装Nodejs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -<span class="comment">#添加源</span></span><br><span class="line">sudo apt-get install nodejs <span class="comment">#安装</span></span><br><span class="line">node -v<span class="comment">#检查是否安装成功</span></span><br></pre></td></tr></table></figure></li><li><p>安装npm节点包管理器（安装完nodejs自带），速度慢的话可以使用淘宝镜像，注意淘宝的域名换了，网上查的较老的教程已经无效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用淘宝镜像</span></span><br><span class="line">npm get registry <span class="comment">#查看自己的本地镜像</span></span><br><span class="line"><span class="comment">#设置本地镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br><span class="line">npm config <span class="built_in">set</span> ELECTRON_MIRROR https://npmmirror.com/mirrors/electron/</span><br></pre></td></tr></table></figure><blockquote><p>踩坑环节：</p><p>下载好使用npm下载hexo时出现<code>npm ERR! Cannot read property 'insert' of undefined </code>报错；</p><p>错误原因是我电脑已经有nodejs环境，但是版本比较旧，与新的npm不兼容，导致npm不可用；</p><p>我的解决方法：</p><p>纯净地卸载nodejs，如果nodejs还残留一些其他的东西很可能影响后续操作；</p><p>重新下nodejs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#卸载nodejs</span></span><br><span class="line">sudo apt-get --purge remove nodejs</span><br><span class="line">sudo apt-get --purge remove npm</span><br><span class="line"><span class="comment">#然后分别到/usr/local/下的lib目录、include目录、bin目录下删除所有关于node的东西</span></span><br><span class="line"><span class="comment">#安装nodejs见上面步骤2</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>安装hexo框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment">#检查是否安装成功</span></span><br><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入自己的blog目录，初始化一下</span></span><br><span class="line"><span class="built_in">mkdir</span> blog  <span class="comment">#创建一个文件夹，用于放博客</span></span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s <span class="comment">#预览一下，在本地localhost:4000可访问</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置ssh key</strong></p><blockquote><p>由于github在2021年8月停止了账号密码登录，改为token或者ssh登录。</p></blockquote><ol><li><p>新建一个github仓库，注意仓库名必须为<code>你的github用户名.github.io</code>，以后通过该地址访问你的网站。（<em>注意：仓库创建成功一半10-30分钟才生效</em>）</p></li><li><p>配置ssh key</p><p>使用ssh key连接本地与服务器，避免多次输入密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment">#检查本机是有存在ssh密钥，如果没有的话可能你是第一次使用git</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你注册github的邮箱地址&quot;</span> <span class="comment">#生成本机ssh key</span></span><br><span class="line"><span class="comment">#然后要你输入一些东西，可以不输入，三次回车即可</span></span><br><span class="line">vim /.ssh/id_rsa.pub <span class="comment">#找到.ssh/id_rsa.pub文件，复制里面的内容，就是ssh key</span></span><br></pre></td></tr></table></figure><p>上面生成并拿到key之后，打开自己的github主页：settings -&gt; SSH and GPG keys -&gt;New SSH key；将刚刚拿到的key复制到key中，title随意，保存。</p></li><li><p>测试是否配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li><p>配置git全局用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的git用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你注册github时用的邮箱&quot;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>hexo部署到github</p><p>主要是通过npm的一个hexo插件完成的，hexo-deployer-git</p><p>在自己的blog目录下安装git部署的插件</p><p>注意下面的<code>_config.yml</code>的配置<code>:</code>前面不要少了空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git </span><br><span class="line"><span class="comment">#需要对_config.yml文件进行配置修改</span></span><br><span class="line">vim _config.yml</span><br><span class="line"><span class="comment">#到文件最底部</span></span><br><span class="line"><span class="comment">#把Deployment下的配置修改成如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: <span class="comment">#这里复制粘贴你刚刚git仓库的ssh地址！</span></span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>hexo发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d <span class="comment">#hexo deploy的意思</span></span><br></pre></td></tr></table></figure></li></ol><p><em>至此，hexo博客框架搭建完毕</em></p><h2 id="hexo基本使用">hexo基本使用</h2><h3 id="常用命令汇总">常用命令汇总</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment">#hexo server，启动写好的博客，可以预览实时的笔记效果</span></span><br><span class="line">hexo n <span class="string">&quot;第一篇文章&quot;</span> <span class="comment">#new新建一篇文章，markdown文件</span></span><br><span class="line">hexo g <span class="comment">#hexo generate生成一篇文章，hexo进行渲染，注意，使用该命令需要去到自己博客的根目录进行生成</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下搭建arduino+vscode开发环境</title>
      <link href="/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22%E7%8E%AF%E5%A2%83%E4%B8%8Barduino+vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/10/18/%E6%9D%82%E8%B0%88/%E3%80%90%E6%9D%82%E8%B0%88%E3%80%91Ubuntu22%E7%8E%AF%E5%A2%83%E4%B8%8Barduino+vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1>Ubuntu22环境下arduino+vscode开发环境搭建</h1><p>本文用于记录搭建环境的过程，同时希望能帮助到有需要的人。</p><blockquote><p>背景：</p><p>本来想diy以下arduino小车，于是在linux系统上安装了arduinoIDE，发现这IDE比较丑，也没有代码提示，体验感不太好，于是想用万能vscode搭建arduino开发环境。</p></blockquote><h2 id="具体步骤">具体步骤</h2><ol><li><p>网上常见的步骤：</p><ul><li>安装vscode的arduino插件</li><li>安装arduinoIDE</li><li>在vscode的arduino插件设置中配置arduino的command路径和安装路径</li></ul><blockquote><p>大家可以按照第一种步骤试一试，我配置好后会出现can not find arduino tools的报错而不能使用；可能是我哪个环节出了问题吧。</p></blockquote></li><li><p>本人的方案</p><ul><li>安装vscode的arduino插件</li><li>下载arduino cli</li><li>清空arduino插件设置的command path和path</li></ul><blockquote><p>我这里可以正常使用</p></blockquote></li></ol><h2 id="第一种方案">第一种方案</h2><ol><li><p>打开vscode，打开扩展资源，搜索arduino，选择有微软蓝标的进行下载；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514121233087.png" alt="image-20230514121233087"></p></li><li><p>去官网下载arduinoIDE</p><p>官网链接：<a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a></p><p>（也可以谷歌arduino，进入官网，点击solfware）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514121511784.png" alt="image-20230514121511784"></p></li><li><p>根据自己的系统进行下载</p><p>我根据自己的系统，选择了Linux 64bit的下载，我下载的版本是1.8.19；</p><p>vscode的arduino插件支持arduinoIDE的版本为1.6.x以上，但是不支持2.0.0版本；（插件的detail里面有说）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514121606213.png" alt="image-20230514121606213"></p></li><li><p>下载好后，得到arduino-1.8.19-linux64.tar.xz的包，默认在Download目录下，终端cd进入Download目录对包进行解压；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在arduino-1.8.19-linux64.tar.xz所在的目录下（默认是Download）</span></span><br><span class="line">tar -xvf arduino-1.8.19-linux64.tar.xz</span><br><span class="line"><span class="comment">#解压得到文件夹arduino-1.8.19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#然后移动到你想移动的地方,我把他放在根目录下的/opt</span></span><br><span class="line">sudo <span class="built_in">mv</span> arduino-1.8.19 /opt</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后进行安装</span></span><br><span class="line"><span class="built_in">cd</span> /opt/arduino-1.8.19</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></li><li><p>回到vscode插件设置;</p><p>在输入框输入path，出现如下界面，把arduino的安装路径和可执行文件的路径写下去即可；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514123129531.png" alt="image-20230514123129531"></p><blockquote><p>如何查看arduino的安装路径和可执行文件的路径？</p><p>在终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis arduino</span><br></pre></td></tr></table></figure><p>在bin目录下的是可执行文件的路径</p></blockquote></li></ol><h2 id="第二种方案">第二种方案</h2><p>不用arduinoIDE+vscode，而用arduinoCLI+vsode。</p><p>简单来讲，arduinoCLI是基于命令行的arduino，和arduinoIDE的差别在于没有其自带的编辑器，而且arduinoCLI体量很小，只有20M不到。</p><p>而vscode正是我们要使用的编辑器，所以用vscode+arduinoCLI是十分合适的。</p><h3 id="步骤">步骤</h3><ol><li><p>在vsode插件资源中下载arduino（和第一种方案一致）</p></li><li><p>去arduinoCLI的github仓库中下载对应的版本</p><p>下载地址：<a href="https://github.com/arduino/arduino-cli/releases/">https://github.com/arduino/arduino-cli/releases/</a></p><p>选择对应版本下载，我选择的是linux64位的；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514123907364.png" alt="image-20230514123907364"></p></li><li><p>然后在对应目录下解压下载好的文件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压到指定目录，这里我把文件解压到/usr/local/bin（把目录解压到这里，arduino-cli的环境变量也顺便配置好了），并把解压后的文件放在arduino-cli里面（C要大写）</span></span><br><span class="line">sudo tar xf arduino-cli.tar.gz -C /usr/local/bin arduino-cli</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否安装成功</span></span><br><span class="line">arduino-cli version</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装成功后，可以把原来的包删掉</span></span><br><span class="line"><span class="built_in">rm</span> -rf arduino-cli-tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#至此，arduino-cli配置完毕</span></span><br></pre></td></tr></table></figure></li><li><p>然后去到vscode的arduino插件设置，command path和path什么东西都不用写，空着就行。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514123129531.png" alt="image-20230514123129531"></p></li><li><p>然后在右底角选择串口、板子型号之类的。</p></li><li><p>然后就能在vscode优雅地编写代码并烧录编译啦；</p><p>尝试简单的代码烧写，可以烧录，arduino板子也可以跑程序。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230514125244701.png" alt="image-20230514125244701"></p></li></ol><blockquote><p>本人小白一枚，本篇仅以记录学习过程和给他人提供参考；如果有错误之处，请大家指正。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】0. 机器学习概述</title>
      <link href="/2023/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%910.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%910.%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>机器学习概述</h1><h2 id="概述">概述</h2><p>机器学习（ML），专门研究计算机怎样模拟实现人类的学习行为，以获取新知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>机器学习是人工智能的核心，是使得计算机具有智能的根本途径，其应用遍及人工智能的各个领域，主要使用<strong>归纳、综合</strong>而不是演绎。</p><h2 id="机器学习场景">机器学习场景</h2><ul><li>模式识别</li><li>机器学习</li><li>深度学习：其主要研究建立、模拟人脑进行分析学习的<strong>神经网络</strong>，模仿人脑的机制来解释数据，例如图像、声音和文本。</li></ul><p>应用举例：</p><ol><li>搜索引擎： 根据你的搜索点击，优化你下次的搜索结果,是机器学习来帮助搜索引擎判断哪个结果更适合你（也判断哪个广告更适合你）。</li><li>垃圾邮件：会自动的过滤垃圾广告邮件到垃圾箱内。</li><li>超市优惠卷：在构面小孩尿布的时候，售货员会送你一份优惠卷买啤酒</li><li>邮局邮寄：手写软件自动识别寄送贺卡的地址</li><li>申请贷款：通过最近的金融活动信息进行综合评价，决定你是否合格</li></ol><h2 id="机器学习组成">机器学习组成</h2><h3 id="主要任务">主要任务</h3><p>回归和分类都是机器学习的算法，一个问题用机器学习的方式解决，需要采用回归还是分类，取决于<strong>目标变量</strong>需要的是连续的数据还是离散的数据。一般回归算法用于X到Y的映射这样的关系（连续），分类算法一般用于离散的标记数据。</p><p>分类预测的目标变量通常是有限的有限集合，回归预测的目标变量通常是无限的连续集合。</p><ul><li><p>分类（classification）：将实例数据划分到合适的类别中</p><p>应用：判断网站是否被黑客入侵（二分类：是和否），手写数字自动识别（多分类）</p></li><li><p>回归（regression）：主要用于预测数值型数据。</p><p>应用：股票价格波动的预测，房屋价格预测等</p></li></ul><h3 id="监督学习（supervised-learning）">监督学习（supervised learning）</h3><ul><li>必须确定<strong>目标变量</strong>的值，以便机器学习算法可以发现<strong>特征变量和目标变量</strong>的关系。在监督学习中，给一组数据，我们知道正确的输出结果是怎么样的，并且知道输入与输出之间存在一定的关系。</li><li>样本集：训练数据+测试数据<ol><li>训练样本=特征（feature）+目标变量（label：分类-离散值/ 回归-连续值）</li><li>特征通常样本的列，他们是独立测量得到的</li><li>目标变量：目标变量是机器学习预测算法的测试结果<ul><li>在分类算法中，目标变量的结果通常是标称变量，比如真假、是否、猫还是狗；</li><li>在回归算法中，目标变量的结果通常是连续型的，比如1-100</li></ul></li></ol></li><li>监督学习需要注意的问题：<ol><li>偏执方差权衡</li><li>功能的复杂性和数量的训练数据</li><li>输入空间的维数</li><li>噪声中的输出值</li></ol></li><li>知识表示：<ol><li>可以采用规则集的形式【例如: 数学成绩大于90分为优秀】</li><li>可以采用概率分布的形式【例如: 通过统计分布发现，90%的同学数学成绩，在70分以下，那么大于70分定为优秀】</li><li>可以使用训练样本集中的一个实例【例如: 通过样本集合，我们训练出一个模型实例，得出 年轻，数学成绩中高等，谈吐优雅，我们认为是优秀】</li></ol></li></ul><h3 id="非监督学习（unsupervised-learning）">非监督学习（unsupervised learning）</h3><ul><li>在机器学习中，无监督学习的问题是，在未加标签的数据中，试图找到隐藏的结构和关系。因为提供给学习者的示例是未标记的，因此没有错误或者报酬信号来评估潜在的解决方案。</li><li>与无监督学习密切相关的是<strong>统计数据密度估计</strong>的问题。然而无监督学习还包括寻求、总结和解释数据的主要特点等诸多技术。在无监督学习中，使用的许多方法都是基于处理数据的数据挖掘技术。</li><li>数据没有类别信息，也不给目标值</li><li>无监督学习包括的类型：<ol><li>聚类：在无监督学习中，将数据分成由类似的对象组成的多个类的过程称为聚类</li><li>密度估计：通过样本分布的紧密程度，来估计与分组的相似性</li><li>此外，无监督学习<strong>还可以减少数据特征的维度</strong>，以便我们使用二维图、三维图更加直观地展示数据信息</li></ol></li></ul><h3 id="强化学习">强化学习</h3><p>这个算法可以训练程序作出某一决定。程序在某一情况下尝试所有可能行动，记录不同行动的结果并尝试着找出最好的一次尝试来做决定。属于这一类算法的有马尔可夫决策过程。</p><h3 id="算法汇总">算法汇总</h3><p><strong>监督学习</strong></p><table><thead><tr><th>算法</th><th>用途</th></tr></thead><tbody><tr><td>K-近邻值算法</td><td>线性回归</td></tr><tr><td>朴素贝叶斯算法</td><td>局部加权线性回归</td></tr><tr><td>支持向量机</td><td>Ridge回归</td></tr><tr><td>决策树</td><td>Lasso最小回归系数估计</td></tr></tbody></table><p><strong>无监督学习</strong></p><table><thead><tr><th>算法</th><th>用途</th></tr></thead><tbody><tr><td>K-均值算法</td><td>最大期望算法</td></tr><tr><td>DBSCAN</td><td>Parzen窗设计</td></tr></tbody></table><h2 id="机器学习的使用">机器学习的使用</h2><h3 id="选择算法">选择算法</h3><p>选择算法需要考虑两个问题：</p><ol><li><p>算法场景？</p><p>主要是根据算法场景决定选择监督学习还是非监督学习</p></li><li><p>需要收集或者分析的数据是什么？</p><p>根据需要收集或分析的数据选择具体算法</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20231010183232654.png" alt="image-20231010183232654"></p></li></ol><h3 id="机器学习开发流程">机器学习开发流程</h3><ol><li>收集数据：收集样本数据</li><li>准备数据：注意数据格式</li><li>分析数据：为了确保数据集中没有垃圾数据；（数据预处理）</li><li>训练算法：[机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过此步骤</li><li>测试算法：[机器学习算法核心]评估算法效果</li><li>使用算法：将机器学习算法封装成应用程序</li></ol><h2 id="机器学习基础概念">机器学习基础概念</h2><h3 id="数据集的划分">数据集的划分</h3><ul><li><strong>训练集（Training Set）</strong>学习样本数据，通过匹配一些参数来建立模型，主要用来训练模型</li><li><strong>验证集（valudation set）</strong>     对学习出来的模型，调整模型参数，如在神经网络中选择隐藏单元数。验证集还用来确定网格结构或者控制模型的复杂程度参数</li><li><strong>测试集（test set）</strong>       测试训练好的模型的分辨能力</li></ul><h3 id="模型的拟合程度">模型的拟合程度</h3><ul><li>欠拟合（underfitting）：模型没有很好地捕捉到数据特征，不能很好地拟合数据，对样本的一般性质还未学好。</li><li>过拟合（overfitting）：模型把训练样本学习的“太好了”，可能把一些训练样本训练集仅有的特性当做了所有样本都有的一般特性，导致泛化能力下降。</li></ul><h3 id="常见的模型指标">常见的模型指标</h3><ul><li>正确率：提取出正确信息数量/提取出的信息数量</li><li>召回率：提取出正确信息数量/样本中信息数量</li><li>F值：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>2</mn><mo>×</mo><mtext>正确率</mtext><mo>×</mo><mtext>召回率</mtext></mrow><mrow><mtext>正确率</mtext><mo>+</mo><mtext>召回率</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{2\times正确率\times召回率}{正确率+召回率}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2757em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">正确率</span><span class="mbin mtight">+</span><span class="mord cjk_fallback mtight">召回率</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord cjk_fallback mtight">正确率</span><span class="mbin mtight">×</span><span class="mord cjk_fallback mtight">召回率</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>    F值即为正确率和召回率的<strong>调和平均值</strong></li></ul><h3 id="模型">模型</h3><ul><li><p>分类问题</p></li><li><p>回归问题</p></li><li><p>聚类问题：聚类是一种无监督学习任务，该算法基于数据内部结构寻找观察样本的自然簇群。<br>聚类问题的标准一般基于距离：簇内距离，簇间距离</p><p>簇内距离越小越好，簇间距离越大越好</p><p>一般地，衡量聚类问题一般会给出一个结合簇内距离和簇间距离的公式</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20231010185415558.png" alt="image-20231010185415558"></p><h2 id="特征工程">特征工程</h2><ul><li><p>特征选择：也叫特征子集选择（FFS，Feature Subset Selection）。</p><p>从已有的M个特征中选择N个特征使得系统特定指标最优化，是从原始特征中选择出一些最有效特征以降低数据集维度的过程，是提高算法效率的重要手段，也是关键的数据预处理工作。</p></li><li><p>特征提取：特征提取是计算机视觉和图像处理的一个概念，是指使用计算机提取图像信息，决定每个图像的点是否属于一个图像特征。特征提取的结果是把图像上的点分为不同的子集，这些子集往往属于孤立的点，连续的曲线或者连续的区域。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20231010190110340.png" alt="image-20231010190110340"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习】1. 代价损失函数</title>
      <link href="/2023/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%911.%20%E4%BB%A3%E4%BB%B7%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%911.%20%E4%BB%A3%E4%BB%B7%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>代价损失函数</h1><h2 id="如何判断参数选的好不好？-选择模型的最佳参数">如何判断参数选的好不好？| 选择模型的最佳参数</h2><p>代价损失函数是用于衡量我们模型训练出来的参数好不好的一个重要函数。可以根据具体问题具体定义分析，但是以下讲的平均误差平方和的形式是最常见也是最常用的代价损失函数。</p><p>我们可以使用代价成本函数，来选择模型的最佳参数。</p><h2 id="代价损失函数公式">代价损失函数公式</h2><h3 id="基本介绍">基本介绍</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mspace linebreak="newline"></mspace><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><msub><mi>f</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_{w,b}(x^{(i)})=wx^{(i)}+b \\ \hat{y}^{(i)}=f_{w,b}(x^{(i)})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2241em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0213em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.1324em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2241em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>这里是一个线性回归函数以及线性的例子，我们回归和训练、学习的目的就是得到一个参数组合w,b，使得拟合效果最好。</p><p>那么我们怎么知道我们最终选的w,b到底效果怎么样呢？</p><p>这时我们可以引入一个代价损失函数，该函数定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mo stretchy="false">(</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">J(w,b) = \frac{1}{2m}\sum_{i=1}^m(\hat{y}^{(i)}-y^{(i)})^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}-y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>我们称之为误差error，预测值与现实值的误差。为了统一得到非负数的表示，我们统一取其平方。我们对这组预测的每一个值都进行误差平方的运算并加起来，用于衡量在该参数选择下该组数据的拟合效果。</p><p>但是如果我们有许多组不同的数据，每个数据集的量级都不同，如果只计算上面的误差平方和，会导致数据量越大的数据集算出来的损失函数越大。这并不是我们希望看到的。</p><p>所以我们对误差平方和的计算取平均，平均到每一个数据元素上，抵消累加的效果。这样不同的数据集就在一个尺度进行衡量。</p><p>但是我们为了后续数据的计算方便和美观，根据经验，我们应该除以2m，当然除以m也没有任何问题。</p><p>注意：这里的m是指样本的个数，i是指某一个样本，J(w,b是参数为w.b下的代价损失函数，页脚平方误差损失函数。</p><h3 id="代价成本函数引入的目的">代价成本函数引入的目的</h3><p>我们引入代价成本函数后，为了找到最佳的模型参数，我们可以对其代价成本函数求最小值，即使得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">J_{w,b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>最小，这样意味着在该代价成本函数的衡量指标下，模型损失精确度的代价最小，也就是模型效果最好。</p><p>数学表达：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>l</mi><mo>:</mo><msub><mi>f</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo>=</mo><mi>w</mi><mi>x</mi><mo>+</mo><mi>b</mi><mspace linebreak="newline"></mspace><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>s</mi><mo>:</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mspace linebreak="newline"></mspace><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>:</mo><mi>J</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><munder><mo>∑</mo><mi>i</mi></munder><mo>=</mo><msup><mn>1</mn><mi>m</mi></msup><mo stretchy="false">(</mo><msub><mi>f</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mspace linebreak="newline"></mspace><mi>g</mi><mi>o</mi><mi>a</mi><mi>l</mi><mo>:</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>w</mi><mo separator="true">,</mo><mi>b</mi></mrow></msub><mi>J</mi><mo stretchy="false">(</mo><mi>w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">model:f_{w,b}=wx+b \\parameters: w, b \\cost function:J(w,b)=\frac{1}{2m}\sum_i=1^m(f_{w,b}(x^{(i)})-y^{(i)})^2\\goal: minimize_{w,b}J(w,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ers</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.5991em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2241em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">o</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">minimi</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20231013004359099.png" alt="image-20231013004359099"></p><h3 id="如何根据代价损失函数找到最佳参数">如何根据代价损失函数找到最佳参数</h3><p>由于代价损失函数J公式(3)，J是衡量平方误差的函数。所以我们找到的参数w，尽可能在参数w情况下的拟合曲线或者直线与其他样本点的平方误差和小即可。</p><h3 id="如何防止过拟合？——正则化惩罚">如何防止过拟合？——正则化惩罚</h3><p>正则化惩罚通过限制模型参数的大小或者复杂度，帮助模型在训练过程中更好地泛化到未见过的数据，从而提高了模型的鲁棒性和泛化能力。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】19. MPU6050传感器</title>
      <link href="/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9119.%20MPU6050%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
      <url>/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9119.%20MPU6050%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>MPU6050传感器</h1><h2 id="姿态检测">姿态检测</h2><p>抽象来说，姿态就是“载体坐标系”和“地理坐标系”之间的转换关系。</p><h3 id=""></h3><h3 id="坐标系">坐标系</h3><p><strong>常用的坐标系</strong></p><ul><li><p>地球坐标系</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230113234542491.png" alt="image-20230113234542491"></p></li><li><p>地理坐标系</p></li><li><p>载体坐标系</p><p>以运载体的质心为原点，一般根据运载体自身结构方向构成坐标系，如Z轴上由原点指向载体顶部，Y轴指向载体头部，X轴沿载体两侧方向。上面说基于飞机建立的坐标系就是一种载体坐标系，可类比到汽车、船舰、人体、动物或手机等各种物体。</p><p><strong>重要的几个角</strong></p><p>这几个角涉及到坐标转换</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230115213019160.png" alt="image-20230115213019160"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230115213152492.png" alt="image-20230115213152492"></p></li></ul><h3 id="MPU6050传感器">MPU6050传感器</h3><p>采用MEMS（微机系统）结合机械系统的方式，可以求出实时的偏航角、俯仰角、横滚角的角速度，然后通过对时间的积分可以求出偏离的角度从而确定物体的姿态。</p><h4 id="误差分析"><strong>误差分析</strong></h4><p><strong>累计误差</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230115220033292.png" alt="image-20230115220033292"></p><h4 id="减少误差、克服缺陷的方案"><strong>减少误差、克服缺陷的方案</strong></h4><ul><li>加速度传感器（无法测算出偏航角的误差、不区分重力加速度和外力加速度，当受到外部冲击时会有很大的精度误差）</li><li>磁场检测传感器（电子罗盘，在磁场环境不稳定的区域会有误差）</li><li>GPS检测（只适用于大范围移动）</li></ul><p><strong>姿态融合，滤波算法（多传感器采样，利用不同传感器在不同情况的优点使用一定的算法提高某种传感器采样数据的权重，来提高姿态检测的精确性）</strong></p><p><strong>姿态角也叫欧拉角</strong></p><p><strong>四元数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230115222808182.png" alt="image-20230115222808182"></p><p><strong>拓展：惯性导航（一般是军用设施）</strong></p><p>惯性导航不需要连接GPS等卫星导航，只需要知道起始坐标（开始时在地球的哪一个位置），每次的移动的运动都能够被累加计算出来，得到新的坐标，这样就知道物体的实时位置而不需要联网或者GPS</p><h2 id="传感器工作原理">传感器工作原理</h2><p>在电子技术中，传感器一般是指把物理量转化为电信号的装置。</p><p>传感器的原理</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230116214557779.png" alt="image-20230116214557779"></p><p>比如温度传感器，可以把温度量转化成电压信号量输出，且温度值与电压值成比例关系，我们只要使用ADC测量出电压值，并根据转换关系即可求得实际温度值。</p><h3 id="传感器参数">传感器参数</h3><p>线性误差：传感器测量值与真实物理量之间的拟合度误差</p><p>分辨率：传感器能够检测到的最小物理量的单位</p><p>采样频率：单位时间内的采样次数</p><h3 id="物理量的表示方法">物理量的表示方法</h3><p>大部分传感器的输出都是与电压成比例关系的，电压值一般采用ADC来测量，而ADC一般有固定的位数，如8位的ADC、12位的ADC等等，ADC的位数会影响测量的分辨率吧以及量程。</p><p>假设用一个2位的ADC来测量长度，2位的ADC最多可以表示4个数字，分别是0、1、2、3、4；那么假如分辨率位20cm，量程就是60cm；分辨率为10cm，量程就是30cm。</p><p><strong>所以，对于特定位数的ADC，量程和分辨率不可兼得（我们往往需要更大的量程和最小的精度，但是从上面的例子可以明显看出量程和分辨率是成正比例关系的）</strong></p><p>在实际应用钟，常常直接使用ADC<strong>每位</strong>表征的物理量的值来表示分辨率，如<strong>每位</strong>代表20cm，我们称它的分辨率为1LBS/20cm，它等效于5位表示1米：5LSB/m。<strong>其中的LSB（least significant bit），意为ADC的最低有效位</strong>。</p><p>使用采集得到的ADC数值除以分辨率，即可求得物理量。例如使用分辨率为5LBS/m，线性误差为0.1m的传感器进行长度测量，其ADC采样数据为20时，可计算得到传感器测量值为20/5=4m，而该物体长度的实际值在3.9m-4.1之m间。</p><p>例如在ADC电压采集的例程中，我们使用的STM32F103C8T6的板子是有12位的ADC，那么我们测量量程为3.3v的电压时，分辨率（也就是LSB）为3.3/4096，结果是LSB=0.0008056640625；如果哦我们ADC测到的数据为2048，那么我们就用2048*LSB=1.65；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230116222444665.png" alt="image-20230116222444665"></p><h2 id="MPU6050传感器介绍">MPU6050传感器介绍</h2><p>MPU6050是一个六轴的传感器模块，能同时检测三轴加速度、三轴陀螺仪（三轴角速度）的运动以及温 度数据。 利用MPU6050芯片内部的DMP模块（Digital Motion Processor数字运算处理器），可以对传感数据进 行滤波、融合处理，它直接通过I2C协议接口向主控制器输出姿态解算后的姿态数据，降低主控制器的运 算量。其姿态解算率最高可达200Hz，非常适合用于对姿态控制实时要求较高的领域。常见应用于手机 计步器、只能手环、四轴传感器以及计步器等的姿态检测。</p><p><strong>一般MPU6050芯片上会有方向的标注，我们在安装芯片时我们应该尽可能使得芯片与载体坐标系重合， 减少误差。</strong></p><h3 id="MPU6050的一些特性参数">MPU6050的一些特性参数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230122122002343.png" alt="image-20230122122002343"></p><h4 id="小结："><strong>小结：</strong></h4><p>从表中，我们了解到传感器的加速度以及陀螺仪的采样频率分别为1000Hz和8000Hz，它们是指加速度 以及角速度数据的采样频率，我们可以使用STM32控制器把这些数据读取出来然后进行姿态融合解算， 以求出传感器当前的姿态（俯仰角、偏航角、横滚角）。</p><p>而如果我们直接使用传感器内部的DMP单元进行解算，可以直接对采样的加速度以及角速度进行姿态解 算，解算得到的结果再输出给STM32控制器，即STM32无需自己计算，可以直接获得偏航角等姿态数 据，该DMP每秒可以输出200次姿态数据（输出频率为200Hz）。</p><p><strong>如果你是专门研究算法的话，你觉得你自己的解算姿态角的算法比官方的库的算法要好，那我们可以不 使用DMP模块而用自己的算法来进行解算。</strong></p><p><strong>小tips</strong></p><p>本传感器采用I2C协议，原本只需要GCC、GND、SCL、SDA即可进行通讯使用，那么为什么还有8个引 脚呢？</p><p>因为MPU6050是6轴传感器（三个角速度以及三个加速度），有时我们需要计算9轴的数据，需要外接 芯片对三个方向的磁场进行数据采样，多出来的几个引脚的用处就在于此，其实很少用到，仅作了解。</p><h2 id="MPU6050引脚介绍">MPU6050引脚介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230122122123683.png" alt="image-20230122122123683"></p><h2 id="MPU6050实验——获取原始数据">MPU6050实验——获取原始数据</h2><h3 id="MPU6050传感器与控制器的连接">MPU6050传感器与控制器的连接</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230123201741275.png" alt="image-20230123201741275"></p><h2 id="HAL库实操">HAL库实操</h2><h3 id="疑问：">疑问：</h3><ol><li><p>配置地址的大小的时候怎么写？</p></li><li><p>记录采样数据的时候为什么可以这样？？</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230223130253383.png" alt="image-20230223130253383"></p></li><li><p>为什么串口重定向时用</p><p>(uint8_t *)&amp;ch</p></li><li><p>出现的问题：</p><p>在写自己的函数库的时候，包含了头文件#include &quot;stm32f1xx_hal_conf.h&quot;用于调度寄存器映射，但是会报错undefine</p><p>于是改为/#include &quot;stm32f1xx_hal.h&quot;不会报错</p></li><li><p>检测不到ID，不确定ID地址是不是0x68&lt;&lt;1</p><p>(已解决，原因是设备地址是：0xD0)</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL 库开发】18. I2C</title>
      <link href="/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9118.%20IIC/"/>
      <url>/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9118.%20IIC/</url>
      
        <content type="html"><![CDATA[<h1>I2C</h1><h2 id="I2C通信协议简介">I2C通信协议简介</h2><h3 id="I2C简单介绍">I2C简单介绍</h3><p>另外，CubeMx上面也有类I2C协议，SMBus-Alert-mode，这是一种类I2C协议</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118230608357.png" alt="image-20221118230608357"></p><h3 id="I2C物理层特点">I2C物理层特点</h3><ul><li>它是一个支持多设备的总线。“总线”指的是多个设备共用的信号线。在一个I2C通讯总线中，可连接多个I2C通讯设备，支持多个通讯主机以及多个通讯从机。</li><li>一个I2C总线只使用两条总线线路，一条双向串行数据线(SDA)，一条串行时钟线(SCL).数据线即用来表示数据，<strong>时钟线用于数据收发同步。</strong></li><li>每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118231151865.png" alt="image-20221118231151865"></p><p>了解I2C<strong>物理层的电路设计</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118231654400.png" alt="image-20221118231654400"></p><h3 id="I2C的协议层">I2C的协议层</h3><p><strong>I2C的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</strong></p><p>我们的目的是了解协议的核心内容，然后学会通过STM32配置出合适的协议来实现具体的功能。</p><ol><li><h4 id="I2C的基本读写过程">I2C的基本读写过程</h4><h5 id="主机写数据到从机"><strong>主机写数据到从机</strong></h5><p><strong>注意结合下图来理解这个过程，图中阴影位表示主机发送的数据，无阴影位是从机相应的数据</strong></p><ul><li><p>首先传输一个起始信号S，然后在其实信号后面紧接着传输从机地址的信号SLAVE_ADDRESS，确定通讯数据传输目标；</p></li><li><p>在传输目标之后就是一个读写信号位：W/R，通过这个信号位指定这个传输的信号是用来读还是用来写的；（‘0’对应着写，‘1’对应着读）</p></li><li><p>如果从机接收到主机传输的数据之后（确认主机传输的地址是该从机地址），从机就会向主机发送一个响应信号：ACK(应答)/UACK(非应答)，如果从机收到了与它地址相匹配的内容的话，就会响应ACK表示“我收到了”。</p></li><li><p>如果从机没有响应主机是否收到信息，那么主机就会等待应答，直到达到最大响应时间，主机就会认为数据没有发送成功。</p></li><li><p>如果从机发出了响应并响应ACK收到信息，那么主机认为存在这样的从机，并且数据发送成功。于是主机就会开始对从机发送数据信息。于是主机和从机就开始了通信，这时主机从机就会占用总线通信。</p></li><li><p>按照这样的格式，主机和从机就可以不断通讯。</p></li><li><p>在这个协议的末尾是一个P位，停止位，表示数据传输完毕。</p><p><strong>这就是一个简单的主机写数据到从机的过程。</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118232057351.png" alt="image-20221118232057351"></p><h5 id="主机由从机中读数据"><strong>主机由从机中读数据</strong></h5><ul><li>和主机写数据到从机的过程基本一致。</li><li>区别在于：<ul><li>主机向从机发送的标志位位写（W）</li><li>当从机响应之后，从机向主机传输数据（而不是主机向从机传输数据）</li><li>数据传输完成之后，主机向从机进行响应是否收到</li><li>就这样不断地进行传输，直到主机不想再读数据了，主机就不响应从机。于是从机没有得到响应之后就会停止数据的传输。于是数据传输就结束了。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118234802031.png" alt="image-20221118234802031"></p><h5 id="通讯的复合过程"><strong>通讯的复合过程</strong></h5><p>通常，我们的通讯过程不是单向的读或者单向的写。通常是一个复合的过程。</p><p>复合的过程和前面的内容相似，只是读和写的任意交替组合。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118235055139.png" alt="image-20221118235055139"></p></li><li><h4 id="通讯的起始信号和停止信号">通讯的起始信号和停止信号</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118235151343.png" alt="image-20221118235151343"></p><p>由第一点我们可以知道，通讯的起始状态对应着时钟线高电平而数据传输线低电平。<strong>这意味着数据传输线的起始状态是高电平，当它遇到高电平的时钟线SCL时就会由高电平变低电平，于是通讯起始。</strong></p><p>停止信号原理相似。</p></li><li><h4 id="I2C数据有效性">I2C数据有效性</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221118235741952.png" alt="image-20221118235741952"></p></li><li><h4 id="地址以及数据的方向">地址以及数据的方向</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221119000043512.png" alt="image-20221119000043512"></p><p>主机会主动地产生一个起始信号以及将从机设备的地址发送到SDA信号线上。</p><p>设备地址的位数也决定了这个总线上可以挂载的设备的数量。</p></li><li><h4 id="响应位">响应位</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221119082544976.png" alt="image-20221119082544976"></p></li></ol><h3 id="如何使用STM32产生I2C协议信号？">如何使用STM32产生I2C协议信号？</h3><ul><li><h4 id="软件模拟协议：">软件模拟协议：</h4><p>使用CPU直接控制通信引脚电平，产生符合通讯协议标准的逻辑。（模拟I2C）</p></li><li><h4 id="硬件实现协议：">硬件实现协议：</h4><p>由STM32的I2C片上外设专门负责实现I2C通信协议，只要配置好该外设，它就会自动根据协议要求产生通信信号，收发数据并缓存起来，CPU只要检测这个外设的状态和访问数据寄存器，就可以完成数据的收发。</p><p>这种由硬件外设处理I2C协议的方式减轻了CPU的工作负担，并且使得软件设计更为简单。</p><p>STM32的I2C 外设可以用做通讯的主机以及从机，支持100Kbit/s和400kbit/s的速率，支持7位、10位设备地址，支持DMA数据传输，并且具有数据校验功能。</p></li></ul><p><strong>一般我们都使用硬件外设实现I2C，软件模拟协议在设计时经常会遇到时序冲突的问题，十分麻烦。一般在I2C不够用的时候才模拟I2C协议。</strong></p><h4 id="STM32的I2C框图对比">STM32的I2C框图对比</h4><p><strong>F103的框图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221119085418933.png" alt="image-20221119085418933"></p><p>对于框图的理解，我们只需要重点把握住输入和输出即可很好地理解这个逻辑。</p><p>两个关键点，时钟总线（SCL）和数据总线（SDA）</p><ul><li>时钟总线产生时钟控制，时钟控制的实现又是由各种寄存器实现的。对于时钟控制，我们只需要使能时钟和失能时钟即可，具体的时钟产生以及控制由对应的硬件完成。</li><li>数据总线与数据控制相连，数据控制由数据移位寄存器实现，数据移位寄存器通过数据寄存器来实现数据的接收和发送</li></ul><h3 id="实验工程讲解">实验工程讲解</h3><ol><li><p>配置基本的时钟、DEBUG、时钟树等等。</p></li><li><p>选择I2C1</p><ul><li><p>配置参数</p><p>参数配置中有两个配置</p><ul><li><p>主机特性</p><p>我们可以选择快速模式</p><p>时钟速率会根据I2C的速度模式进行改变</p><p>然后我们可以配置Duty Cycle，就是配置占空比，一般选择16/9</p></li><li><p>从机特性</p></li></ul></li><li><p>NVIC中断配置</p><p>将错误中断和事件中断开启，如果需要用到中断</p></li><li><p>DMA配置</p><p>和DMA章节讲解的配置一致，如果要用到，请查看之前的文章</p></li><li><p><strong>GPIO设置（重点）</strong></p><p>我们知道I2C是由两条总线的，所以它对外的接口至少也有两个，一个时钟线接口、一个数据线接口。</p><p>需要用到什么引脚，在配置I2C的时候已经会在CubeMX上面显示出来，当然，我们也可以从原理图中找到I2C器件或者从数据手册/参考手册中找到I2C的部分，查看引脚映射图找到I2C对应的引脚。</p><ul><li>我们可以看到，配置GPIO时，CubeMX已经自动帮我们把引脚模式配置好了，复用功能以及开漏模式。</li></ul></li><li><p>配置好基本设置后即可生成工程代码。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL 库开发】17. ADC</title>
      <link href="/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9117.%20ADC/"/>
      <url>/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9117.%20ADC/</url>
      
        <content type="html"><![CDATA[<h1>ADC章节</h1><h2 id="ADC简介">ADC简介</h2><h3 id="嵌入式闭环控制系统框图">嵌入式闭环控制系统框图</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116172942820.png" alt="image-20221116172942820"></p><p>数字量（D）与模拟量（A），在其中起着连接计算机系统和外部世界的桥梁作用。</p><h3 id="模拟信号的采集和处理过程">模拟信号的采集和处理过程</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116173055705.png" alt="image-20221116173055705"></p><p>传感器采集数据，经过运放放大…（<strong>主要是模拟信号的采集、AD转换、数字信号处理三部分组成</strong>）</p><h3 id="ADC原理">ADC原理</h3><p>ADC的转换主要是两个过程：采样保持、量化编码</p><p><strong>采样保持，因为采集到数据之后需要给单片机一点时间来进行转换。</strong></p><p><strong>量化编码，也有许多算法。STM32均采用逐次比较型算法。</strong></p><h3 id="ADC主要参数">ADC主要参数</h3><ul><li><p>分辨率</p><p>比如说，一个n位的AD转换器的分辨率就是n；</p><p>一般我们使用的stm32单片机都是12位的。</p><p>具体理解：假设最大输入电压是5v，那么stm32AD转换器所能分辨的最小电压量是</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>5</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mi>v</mi></mrow><annotation encoding="application/x-tex">5/2^{12}v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord">5/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span></span></p><p>ADC位数越多，所能分辨的最小电压越小，但是ADC的测量结果是经过放大的。</p></li><li><p>相对精度</p><p>AD转换器实际输出直与理论值之差</p></li><li><p>转换速度</p><p>stm32一般是微秒级别</p></li><li><p>采样间隔时间</p><p>数值上转换速率等于转换速率</p></li><li><p>采样电压范围</p></li></ul><p><strong>值得注意的是，我们的最小采样时间应该大于转换时间，这是为了让采集的数据保持到转换完成。</strong></p><p><strong>注意，采样时间至少3个周期。</strong></p><h2 id="STM32上的ADC外设">STM32上的ADC外设</h2><p>ADC通道是什么概念呢？</p><p>每个ADC指向很多个通道，但是一旦ADC开始工作，一次只能采集一个通道所指向的外设，所以我们需要一个ADC对多个通道采集信息的话，我们就需要预先设置该ADC上所使能的通道的采集顺序。</p><p>如果我们用3个ADC对同一个通道进行采集，那么采集速率就是原来的3倍！</p><h4 id="STM32的规则排序寄存器有3个，分别是SQR1、SQR2、SQR3。（针对规则通道而言）">STM32的规则排序寄存器有3个，分别是SQR1、SQR2、SQR3。（针对规则通道而言）</h4><p>SQR3控制的是1-6的转换通道。</p><p>根据下图，如果16通道想第一个转换，那么就在SQR3的SQ1取值为16；</p><p>以此类推。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116182704665.png" alt="image-20221116182704665"></p><p><strong>注意：ADC规则数据寄存器（ADC_DR）的作用，当寄存器按顺序采集完成后得到的数据值最后都会存在ADC_DR中，我们读取这一次采集的数据也是在ADC_DR中读取。三个ADC共同使用这一个ADC_DR寄存器</strong></p><h4 id="注入通道（只有一个寄存器）">注入通道（只有一个寄存器）</h4><p>​最多支持4个通道，只有一个寄存器JSQR。</p><h2 id="ADC的结构体介绍">ADC的结构体介绍</h2><h3 id="ADC的句柄结构体">ADC的句柄结构体</h3><p>ADC_HandleTypeDef</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116192750872.png" alt="image-20221116192750872"></p><h3 id="ADC初始化结构体">ADC初始化结构体</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116192910583.png" alt="image-20221116192910583"></p><p><strong>单通道AD不用设置扫描，但是两个以上的通道的话就需要设置扫描顺序，就是开启扫描模式。</strong></p><p><strong>一般我们都是选择不连续采样模式</strong></p><p><strong>外部事件触发选择一般我们都使用软件自动触发</strong></p><p><strong>如果开启DMA传输的话，就需要用到DMA连续请求转换</strong></p><h4 id="ADC通道结构体">ADC通道结构体</h4><p>ADC_ChannelConfTypeDef</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116193401566.png" alt="image-20221116193401566"></p><h2 id="例程">例程</h2><h3 id="ADC最简单的使用，用串口打印ADC的采集数据">ADC最简单的使用，用串口打印ADC的采集数据</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116200650952.png" alt="image-20221116200650952"></p><p>ADC<strong>的配置选择</strong></p><p>要选择使能连续采样模式：连续采样模式，当采样一次完成后，将数据保存在采样数据寄存器中（ADC_DR），然后外设继续下一轮采样；如果不使能，那么外设就只采样一次便停止工作。</p><h4 id="ADC的数据读取">ADC的数据读取</h4><p>有两种方式</p><ul><li><p>中断模式</p><p>定时读取ADC数据</p></li><li><p>DMA模式</p><p>只要有数据更新，就源源不断地把数据往存储器里搬运</p></li></ul><h4 id="相关参数配置讲解">相关参数配置讲解</h4><ul><li><p><strong>End Of Conversion Selection ——&gt; 这里是选择触发中断函数的条件标志选择</strong></p></li><li><p>External Trigger Conversion Source (外部触发转换源)， 这里选择软件触发。</p></li><li><p>Sampling Time (采样时间)</p><h5 id="这里涉及到计算问题"><strong>这里涉及到计算问题</strong></h5><p>首先罗列计算公式</p><ul><li><strong>转换周期</strong>， <strong>转换周期=采样时间+存储时间</strong></li><li><strong>转换速率=1/转换周期</strong></li></ul><p>我们在该例程中，选择了PCLK2=84，就是时钟2的频率为84M</p><p>分频系数=4</p><p>那么计算得到我们的ADC_Clock（ADC时钟频率）=84/4=21M</p><p>采样时间：至少3个周期</p><p><strong>那我们现在验证一下，我们这个选择是否合理，验证的标准是：</strong></p><p><strong>转换时间&lt;=采样时间+存储时间</strong></p><p>那么现在我们知道我们这个ADC分辨率为12位，每一位占一个周期时间，算上采样时间三个周期，一共是15个周期时间，我们的一个ADC周期是1/21M（频率的倒数是周期），那么算一下我们的单ADC转换时间/转换周期，数值为1/21M*（12+3）=7.5us</p><p>所以我们这里转换速率，21M/（12+3）=1.4M</p><p><strong>然后回忆，我们刚开始在CubeMX上面选择芯片的时候，有ADC参数介绍，那里介绍说单ADC最大转换速率为2.4MSPS</strong></p><p>所以我们这里的比较 1.4&lt;2.4，这样的选择理论上没有问题。</p><p><strong>但是，值得注意的是，我们现在选择的是中断触发，就是说，这里的中断频率是转换速率，1.4M；也就是说ADC以1.4M的频率不断地发出中断请求，这对于CPU来说是很快的，CPU在这里的频率为168M，近1/168的时间都被中断了，CPU的资源大大被耗费，所以这是不合理的。解决方案为延长转换时间，所以我们把采样时间选择15个周期以上</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】16. 常见的存储器介绍</title>
      <link href="/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9116.%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/10/16/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9116.%20%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1>常见的存储器介绍</h1><h2 id="常见存储器分类">常见存储器分类</h2><ul><li><p>易失性存储器</p><p>RAM</p></li><li><p>非易失性</p><p>ROM、FLASH、光盘、软盘、机械硬盘</p></li></ul><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116165907615.png" alt="image-20221116165907615" style="zoom: 67%;" /><h3 id="易失性存储器">易失性存储器</h3><p>一般把他当成RAM了</p><h4 id="分类">分类</h4><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116170140230.png" alt="image-20221116170140230" style="zoom:80%;" /><h4 id="SRAM-DRAM的存储单元结构">SRAM/DRAM的存储单元结构</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116170245777.png" alt="image-20221116170245777"></p><h4 id="SRAM-DRAM的通信方式">SRAM/DRAM的通信方式</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116170423547.png" alt="image-20221116170423547"></p><p><strong>同步和异步的主要区别是有无时钟源</strong></p><p>从图片我们可以看到，DRAM同步是要有时钟支持的。</p><p><strong>DRAM也分为DDR、DDR2（双边沿数据采集）、DDR3（和2主要区别是采样频率的变化）、SDRAM。上面的<a href="###%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB">图片</a>也有介绍到</strong></p><p><strong>DDR的意思是内存，这里的意识是，内存主要都是采用SDRAM来实现的（同步DRAM，同步动态随机存储器）</strong></p><h4 id="SEAM-DRAM的简单对比">SEAM/DRAM的简单对比</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116171206099.png" alt="image-20221116171206099"></p><h3 id="非易失性存储器">非易失性存储器</h3><ul><li>ROM，只读存储器</li><li>FLASH，闪存</li><li>磁盘、光盘</li></ul><h4 id="ROM">ROM</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116171748799.png" alt="image-20221116171748799"></p><h4 id="FLASH闪存">FLASH闪存</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221116171857358.png" alt="image-20221116171857358"></p><h4 id="哪一个闪存支持程序的执行？"><strong>哪一个闪存支持程序的执行？</strong></h4><p>答案是Nor Flash，因为Nor Flash的读写单元是字节，可以访问一条一条的指令，计算机就可以访问存放在FLASH的指令进行执行。</p><p>但是NAND FLASH的读写单元是“块/扇区”，计算机进行访问时，会读取到以指令为首地址的一大块存储空间，计算机不知道该执行哪一条，所以不能执行。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】15. DMA-直接存储器访问控制器</title>
      <link href="/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9115.%20DMA%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/10/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9115.%20DMA%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>DMA-直接存储器访问控制器</h1><h2 id="DMA的作用">DMA的作用</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110200245727.png" alt="image-20221110200245727"></p><p>在单片机上继续数据传输，大概有两种方式</p><ul><li>CPU处理数据</li><li>DMA处理数据</li></ul><p><strong>DMA实际上是一个控制器，DMA控制器的实现基于复杂的总线矩阵架构</strong></p><p><strong>DMA专注于数据转移，而CPU专注于计算处理</strong></p><h3 id="DMA的实现">DMA的实现</h3><h4 id="DMA在总线矩阵架构的位置">DMA在总线矩阵架构的位置</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110212116145.png" alt="image-20221110212116145"></p><p>结构图解读</p><ul><li>DMA是一个独立的外设，它独立于总线之外，接在总线矩阵上</li><li>它可以通过总线矩阵，访问各种与总线相连的外设</li></ul><h4 id="DMA内部的具体实现">DMA内部的具体实现</h4><p><strong>DMA框图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110213334785.png" alt="image-20221110213334785"></p><p>DMA<strong>内部实现解读</strong></p><ol><li><p>DMA请求，总线连接的外设发送DMA请求，高速DMA可以对它进行数据的搬运，于是DMA就会去对该外设里面的数据进行访问和操作；</p></li><li><p>通道选择，用于配置外设中的数据放在DMA的哪一个通道；</p><p>当外设中的数据提取到相应的通道中之后，DMA就会将数据传输到数据搬运的目标地址中</p></li></ol><h4 id="对DMA外设要点的概括">对DMA外设要点的概括</h4><p><strong>首先明白，通信实际上就是数据的传输</strong></p><p>DMA这个器件，它的功能就是建立起一个数据传输通道（不需要CPU参与这样的工作，减轻CPU的负担）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110214031119.png" alt="image-20221110214031119"></p><h4 id="如何用DMA？最贴切的应用场景（基于现有的水平）">如何用DMA？最贴切的应用场景（基于现有的水平）</h4><p>如果我们想要用串口接收数据，将数据放在内存里，我们可以不用CPU来搬运，而用DMA搬运；（传输模式：外设——&gt;存储器）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110214450651.png" alt="image-20221110214450651"></p><p>反之类似，比如想将存储器数据发送到外设里，外设发送出去；</p><p>看图注意：</p><p>空心圆点的意思是两条总线有相连的地方</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110212756092.png" alt="image-20221110212756092" style="zoom:67%;" /><h2 id="DMA的使用">DMA的使用</h2><ol><li><h3 id="建立（选取）传输通道">建立（选取）传输通道</h3><ul><li>存储器-&gt;存储器（相当于copy）</li><li>外设-&gt;存储器</li><li>存储器-&gt;外设</li><li><strong>选取通道和确定传输对象的办法：可以去参考手册查DMA请求映像</strong></li></ul></li><li><h3 id="确定传输对象">确定传输对象</h3><ul><li><p>具体的功能：</p><p>UART-内存（将串口数据传输到内存去）</p><p>内存数据-UART</p></li></ul></li><li><h3 id="敲定传输细节">敲定传输细节</h3><ul><li><p>确定谁来产生DMA请求，确定外设的DMA请求的对应的通道</p></li><li><p>确定通道优先级</p><p>注意：在DMA里，七个通道并不是同时进行传递的，而是一个通道一个通道地依次地传输的；<strong>也就是串行传输</strong></p></li><li><p>确定传输数据双方的数据格式</p><p>比如我们要将一个字节的数据传输到四个字节数据的存储器里，我们需要将数据进行怎么样的打包和拆包？(编码和解码)</p><p>参考手册中提到“源和目标地址必须按数据传输宽度对齐”</p></li><li><p>确定数据是否需要一直采集（循环模式）</p><p>循环传输模式和一般传输模式，一般传输模式就是只传输一次(比如进行ADC功能，需要进行不断地采样和传输，就需要循环传输模式)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110215556825.png" alt="image-20221110215556825"></p></li><li><p>是否需要传输标志/中断</p></li></ul></li></ol><h2 id="DMA在HAL库中的功能实现">DMA在HAL库中的功能实现</h2><p>句柄结构体：DMA_HandleTypeDef</p><p>DMA初始化结构体：DMA_InitTypeDef</p><hr><h2 id="DMA-CubeMX配置">DMA-CubeMX配置</h2><h3 id="首先在systerm-core配置DMA">首先在systerm-core配置DMA</h3><p><strong>DMA内存—&gt;内存的配置：</strong></p><ul><li>然后添加DMA请求；</li><li>地址递增功能的选择，可以配置目标地址递增与否，源地址递增与否的任意组合</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221111091932001.png" alt="image-20221111091932001"></p><p><strong>DMA外设-&gt;内存/内存-&gt;外设的配置</strong></p><p>以UART为例</p><ul><li><p>打开UART一个外设，比如UART1</p></li><li><p>然后找到DMA设置</p></li><li><p>点击Add添加DMA通道</p></li><li><p>UART1_RX    ——&gt;   外设-内存</p><p>UART1_TX    ——&gt;   内存-外设</p></li><li><p>配置请求模式：一般/循环</p></li><li><p>配置地址递增</p></li><li><p><strong>配置数据传输宽度</strong>（这里不太理解）——&gt;  一般会帮你自动选择</p></li></ul><h2 id="实例讲解">实例讲解</h2><p><strong>储存器-储存器</strong></p><h3 id="储存器-外设"><strong>储存器-外设</strong></h3><p>将DMA与外设联系起来，要使用一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221111103634242.png" alt="image-20221111103634242"></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】14. 串口通讯</title>
      <link href="/2023/10/14/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9114.%20%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"/>
      <url>/2023/10/14/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9114.%20%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h1>通讯</h1><h2 id="通讯的基本概念">通讯的基本概念</h2><h3 id="通讯的分类概览">通讯的分类概览</h3><ul><li><p>串行通讯与并行通讯</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109232726483.png" alt="image-20221109232726483" style="zoom:50%;" /></li></ul><p>​串行通讯与并行通讯的区别</p><p>​串行通讯的有点是节省数据线</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109232821901.png" alt="image-20221109232821901" style="zoom:50%;" /><ul><li><p>全双工、半双工及单工通讯（按通讯方向来分）</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109233038371.png" alt="image-20221109233038371" style="zoom:50%;" /></li><li><p>同步通讯与异步通讯（根据数据的同步方式划分）</p><p><strong>同步通讯</strong>一般会有<strong>时钟</strong>来协调，一般用于处理实时有效速率（对时钟误差要求高）</p><p>异步通讯要先约定好速率，有效数据位减少，异步通信双方的时钟允许误差较大</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109233238407.png" alt="image-20221109233238407" style="zoom:50%;" /></li><li><p>通讯速率</p><p>每秒钟传输的二进制位数</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109233501780.png" alt="image-20221109233501780" style="zoom:50%;" /></li></ul><p><strong>一个通信方式，可以是上面三种通信方式的集合</strong></p><h2 id="USART-通用同步异步收发器">USART-通用同步异步收发器</h2><p>它是STM32上的一个外设</p><h3 id="USART概览">USART概览</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109233856401.png" alt="image-20221109233856401"></p><p>协议信号主要包括物理层面这些线如何接线等等信息。</p><h3 id="STM32和PC通信模型">STM32和PC通信模型</h3><p><strong>tx是发线，rx是收线</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109234421267.png" alt="image-20221109234421267"></p><h3 id="STM32和PC通过RS-232标准通信">STM32和PC通过RS-232标准通信</h3><p>即RS-232是他们之间通信的一个协议</p><p>有了这个协议，它才能确定具体的物理层器件，比如接口，以及数据的交互方式；具体接线图如下。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109234703651.png" alt="image-20221109234703651"></p><p><strong>RS-232标准介绍</strong></p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109234811327.png" alt="image-20221109234811327" style="zoom:50%;" /><p><strong>RS-232协议电平标准对比</strong></p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109235046424.png" alt="image-20221109235046424" style="zoom:50%;" /><p><strong>RS-232标准的物理接口规定及接口标号</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109235308107.png" alt="image-20221109235308107"></p><p><strong>RS-232标准下接口标号的作用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109235356921.png" alt="image-20221109235356921"></p><p>我们目前用得到的，常用的就只有三条， <strong>即，RXD和TSD、GND</strong></p><p><strong>RS-232标准数据传输协议层</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109235624662.png" alt="image-20221109235624662"></p><p><strong>协议的概念</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221109235948123.png" alt="image-20221109235948123"></p><p><strong>数据校验</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110000027251.png" alt="image-20221110000027251"></p><p>如果数据校验出错，那么这个数据包就是个无用数据包</p><h3 id="UART收发器的外设框图">UART收发器的外设框图</h3><h4 id="链路逻辑："><strong>链路逻辑：</strong></h4><ol><li><p>接受信息端：</p><ul><li>GPIO引脚复用输入输出通信功能，GPIO引脚向TX传输电平信号；</li><li>电平信号从IrDASIR/ENDEC块传送到接收移位寄存器，电平信号一位一位地填充接收移位寄存器；</li><li>当接收移位寄存器被填满后，接收<strong>移位</strong>寄存器的数据被一位一位地传输到接收<strong>数据</strong>寄存器；</li><li>接收数据寄存器被填满后，将数据传输到总线，由CPU或者DMA处理数据；</li></ul></li><li><p>发送信息端：</p><ul><li>CPU/DMA处理好数据，传输给发送数据寄存器；</li><li>发送数据寄存器将数据传输给发送位移寄存器；</li><li>发送位移寄存器将数据传给IrDASIR/ENDEC块，然后传送给RX引脚输出；</li></ul></li><li><p>USART同步异步收发器框图</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110090923123.png" alt="image-20221110090923123" style="zoom:67%;" /></li><li><p>如何控制USART的输入输出控制呢？</p><p>它是通过各种寄存器控制的，可以根据参考手册的框图找到那些寄存器，然后自行了解。</p></li><li><p>波特率发生器以及过采样模式</p><p>波特率：用于协调数据以什么数据进行发送</p><p>过采样：用于提高采样率，提高数据的精确性</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110091542907.png" alt="image-20221110091542907" style="zoom:67%;" /></li></ol><p><strong>缩写：</strong></p><p>USART_RDR    接受数据寄存器</p><p>USART_TDR    发送数据寄存器</p><h2 id="实验工程讲解">实验工程讲解</h2><h3 id="串口收发">串口收发</h3><h4 id="硬件层必要只是准备">硬件层必要只是准备</h4><p>USB转串口（RS-232协议，PB9接口现在已经很少见到了）</p><p><strong>原理图阅读积累</strong>——&gt;<strong>跳帽</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110092821812.png" alt="image-20221110092821812"></p><h3 id="CubeMX的配置">CubeMX的配置</h3><p><strong>基本配置：RCC外部高速时钟源，在Trace和Debug选项选择单线</strong></p><ol><li>在connetivity选择串口1</li><li>选择串口模式(目前是异步模式)</li><li>使能中断NVIC</li><li>重点关注时钟域的配置（对于有不同的时钟域的板子）<ul><li>外部高速时钟，然后外部倍频，然后自动配置</li><li>具体配置可以看参考手册框图下面的文字</li></ul></li><li><strong>CubeMX只配置好初始化代码，具体使用还是要自己去敲代码</strong></li></ol><h3 id="工程代码的讲解">工程代码的讲解</h3><p>USART1普通中断回显实验</p><blockquote><p>阅读任何一份代码，都从main开始，因为他是.c文件的入口函数。</p></blockquote><p>keil快捷键：crtl+F  查看函数在哪定义，在哪个文档出现…</p><h4 id="HAL库的调用流程："><strong>HAL库的调用流程：</strong></h4><p><strong>HAL_XXX_Init ——&gt;HAL_XXX_MSPInit——&gt;在MSPinit函数中，会进行对应外设使用的GPIO引脚、特殊功能比如时钟使能之类的进行配置；</strong></p><p>所以，本次例程中的HAL_USART_Init()就会调用HAL_USART_MSPInit进行底层硬件的配置</p><h4 id="串口代码的使用">串口代码的使用</h4><h5 id="初始化USART外设（HAL库的底层逻辑）（可部分了解一下即可）">初始化USART外设（HAL库的底层逻辑）（可部分了解一下即可）</h5><ol><li>定义一个UART_HandleTypeDef结构体句柄</li><li>通过HAL_USART_MSPInit实现串口外设的底层初始化<ul><li>使能串口外设的初始化时钟</li><li>配置UART使用的引脚模式</li><li>如果要用中断就配置中断</li><li>如果要用DMA就配置DMA</li></ul></li><li>通过前面定义的结构体句柄配置串口的波特率、数据字长、停止位、奇偶校验位、硬件流控制（不常用）</li><li>通过调用HAL_USART_Init()来将串口配置为异步模式</li></ol><h5 id="发送串口数据">发送串口数据</h5><ol><li><p>调用printf函数发送数据</p></li><li><p>重新定向fputc函数，在fputc函数中调用串口发送函数HAL_UART_Transmit(…)，实现真正的串口发送（<strong>重定向C库函数printf到串口</strong>）（这一步让我们可以让单片机输出数据出来）</p><ul><li>HAL_UART_Transmit(&amp;UartHandle,  (uint8_t *)&amp;ch, 1, 1000)</li><li>参数解析：<ul><li>&amp;UartHandle  传入的串口的句柄，我们的一些初始化底层配置内容都存在句柄里；</li><li>(uint8_t *)&amp;ch  我们要发送的数据；</li><li>1   发送数据的数量；</li><li>1000  等待时间（ms）</li></ul></li></ul></li><li><p>重新定向C库函数scanf到串口，重写向后可以使用scanf，getchar等函数（这一步可以让我们输入数据到单片机）</p></li><li><p>原理：直接调用printf函数不会将内容发送到我们想要的硬件，所以我们要对printf函数中调用的fputc进行重新定义，定向向某个硬件发送数据；</p><p>具体流程：printf调用fputc，fputc调用串口发送函数</p></li><li><p>注意一点，使用fputc要在魔法棒配置中勾选Use MrcoLIB</p></li></ol><h5 id="自定义函数方式实现函数输出">自定义函数方式实现函数输出</h5><p>自定义函数发送字符串，自定义函数原型如图（自行分析理解，不懂会视频看 <em>野火第17讲第四部分第4分钟</em>）：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110123331377.png" alt="image-20221110123331377"></p><h5 id="认识串口通讯的几个常用的函数">认识串口通讯的几个常用的函数</h5><p>HAL_UART_Transmit(&amp;husart,(uint8*)&amp;ch,1,10)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110153929967.png" alt="image-20221110153929967"></p><p>等待时间是指在接收数据和发送数据时等待的时间，如果在这个时间内没有完成操作，就会返回失败的值；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110154021619.png" alt="image-20221110154021619"></p><p><strong>中断发送和接受函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110154050218.png" alt="image-20221110154050218"></p><p>这是不需要占用主程序的时间的，因为发生在中断的时候</p><hr><h4 id="如何找宏定义？">如何找宏定义？</h4><ul><li>右键，跳转到头文件</li><li>然后再头文件里面找</li></ul><h4 id="如何找到句柄结构体的定义？">如何找到句柄结构体的定义？</h4><ul><li><p>跳转搜索全部文件</p></li><li><p>一般在.h文件中</p></li><li><p>以}开头</p></li><li><p>图片</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221110121203542.png" alt="image-20221110121203542"></p></li></ul><h3 id="疑问">疑问</h3><p>中断执行完一次之后就会关闭，需要再次打开？</p><p><em>BUG熊视频第八章的11分30秒</em></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】13. 驱动蜂鸣器播放音乐</title>
      <link href="/2023/10/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9113.%20%E9%A9%B1%E5%8A%A8%E8%9C%82%E9%B8%A3%E5%99%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/"/>
      <url>/2023/10/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9113.%20%E9%A9%B1%E5%8A%A8%E8%9C%82%E9%B8%A3%E5%99%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h1>驱动蜂鸣器播放音乐</h1><h2 id="原理">原理</h2><p>利用定时器+PWM控制输出的电压频率，控制蜂鸣器的发声。</p><h3 id="乐理知识">乐理知识</h3><p>必须知道的三个参数：音符，音调，节拍</p><p>一般以C调音符为主</p><h4 id="音调">音调</h4><h5 id="C调音符与频率对照表">C调音符与频率对照表</h5><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221027175546586.png" alt="image-20221027175546586" style="zoom:50%;" /><h4 id="节拍">节拍</h4><p><code>节拍决定了音符的时间长短</code></p><h5 id="节拍的简谱图">节拍的简谱图</h5><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221027175802542.png" alt="image-20221027175802542" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221027175932606.png" alt="image-20221027175932606" style="zoom:50%;" /><h3 id="编程思路原理">编程思路原理</h3><p>采用定时器+PWM的方式，解放主循环，让程序可以做更多的事。</p><p>定时器用于把握节拍</p><p>PWM控制音调和音符</p><p>PWM的周期(Hz) = 主频(Hz) / (重装载值 + 1) / (分频系数 + 1)</p><p>每次转换音符时，动态修改重装载值即可实现PWM输出频率的变化，进而控制无源蜂鸣器的发声。定时器进行ms中断，判断节拍时间是否达到。</p><h3 id="电路原理">电路原理</h3><p>无源蜂鸣器需要输入方波驱动发声；</p><p>应注意在IO口要一个下拉电阻(使得蜂鸣器IO口不工作时保持低电平)，避免不通电时IO口处于浮空状态导致意外发声；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221028094814492.png" alt="image-20221028094814492"></p><h2 id="疑问">疑问</h2><h3 id="关于hal库的函数">关于hal库的函数</h3><p>如何找到相应的函数？只是看csdn不是治本之策。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】12. Debug功能及其方法简述</title>
      <link href="/2023/10/12/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9112.%20Debug%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/10/12/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9112.%20Debug%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1>Debug功能及其方法简述</h1><h2 id="常见的调试方法">常见的调试方法</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021155605614.png" alt="image-20221021155605614"></p><h2 id="常见的Debug工具">常见的Debug工具</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021155920484.png" alt="image-20221021155920484"></p><h2 id="MDK-Keil的DEBUG使用">MDK-Keil的DEBUG使用</h2><h3 id="硬件层面的准备">硬件层面的准备</h3><ol><li>用仿真器连接电脑与开发板</li></ol><h3 id="软件层面的准备">软件层面的准备</h3><ol><li><p>魔法棒的output选项中勾选这些(否则将无法看到现象)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021160646686.png" alt="image-20221021160646686"></p></li><li><p>Debug选项设置，重点关注右侧</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021160739705.png" alt="image-20221021160739705"></p></li><li><p>打开setting进行配置，配置好接口，其他不用管。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021161208271.png" alt="image-20221021161208271"></p></li><li><p>然后打开FlashDownload</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021161232202.png" alt="image-20221021161232202"></p><p>进行相应配置</p></li><li><p>若不小心做了失误改动，按照如下图片复原、或者重新安装</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021161428131.png" alt="image-20221021161428131"></p></li></ol><h3 id="Debug的具体使用">Debug的具体使用</h3><ol><li><p>Run按钮，点击它程序就会运行。</p></li><li><p>stop就会停止，代码也停止在相应的地方。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021162611339.png" alt="image-20221021162611339"></p><p>第一个step是步入，进入函数执行；</p><p>第二个是step over步过(它还是会执行，只不过不跟踪其代码而已)；</p><p>第三个是步出step out，即离开当前子函数，回到上一级函数；</p><p>第四个是运行到当前行</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021162544796.png" alt="image-20221021162544796"></p><p><strong>蓝色箭头：光标所处位置；    黄色箭头：程序运行到的位置</strong></p></li><li><p>回到当前程序停止位置（黄色箭头）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021162807384.png" alt="image-20221021162807384"></p></li></ol><h4 id="断点：">断点：</h4><ul><li><p>断点只能设置再小黑快里，因为在小黑块里才有实际的语句执行。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021163015870.png" alt="image-20221021163015870"></p></li><li><p>点击断点后，程序运行到断点处便会停下，但斌没有执行断点处的语句。(停在了断电处语句之前)</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021163250452.png" alt="image-20221021163250452"></p><p>两个红色圆圈的按键可以实现一键清除所有断点的作用</p></li></ul><h3 id="窗口工具">窗口工具</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021163532751.png" alt="image-20221021163532751"></p><ol><li><p>命令窗口</p><p>可以输入一些调试相关的指令(一般不怎么用)</p></li><li><p>反汇编窗口(很少使用)</p></li><li><p>标志窗口(少用)</p><p>展示程序中使用到的一些变量、参数等等</p></li><li><p>寄存器窗口</p><p>用于指示CPU工作状态</p></li><li><p>调用栈以及函数调用所在位置窗口(常用)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021164311187.png" alt="image-20221021164311187"></p></li><li><p>Watch窗口</p><p>用于监控指定的变量，具体添加方式：可以拖动至窗口，也可以如图</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021164501258.png" alt="image-20221021164501258"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021164533957.png" alt="image-20221021164533957"></p></li><li><p>Memory 窗口</p><p>和watch窗口使用方法和功能类似。</p><p>主要用于看内存的数据。如图，对i取地址后放入窗口中监控，我们i在内存中的位置以及在相应内存地址上的值。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021164849666.png" alt="image-20221021164849666"></p><p>点击右键，还可以通过不同形式来展示窗口</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021164930402.png" alt="image-20221021164930402"></p></li><li><p>UART，串口窗口</p></li><li><p>余下的窗口都需要特定的仿真器支持。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021165123208.png" alt="image-20221021165123208"></p></li></ol><pre><code>**最常用的窗口**![image-20221021165208559](https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021165208559.png)可以打开查看这些内核外设的寄存器状态![image-20221021165303930](https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021165303930.png)也可以看到其他多有外设的寄存器![image-20221021165525154](https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021165525154.png)</code></pre><h3 id="注意：">注意：</h3><p><strong>如果窗口中的数据没有实时变化，可以在veiw中选择实时更新窗口</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021165906902.png" alt="image-20221021165906902"></p><p>其次是每次debug，如果做了改动，需要重新编译和烧录。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL 库开发】11. HAL库的驱动框架</title>
      <link href="/2023/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9111.%20HAL%E5%BA%93%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9111.%20HAL%E5%BA%93%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1>HAL库驱动框架</h1><h2 id="外设初始化">外设初始化</h2><h3 id="对外设的封装">对外设的封装</h3><h4 id="xx-HandleTypeDef-xx外设句炳结构体，xx表示任何外设名，如GPIO、UART等等">xx_HandleTypeDef (xx外设句炳结构体，xx表示任何外设名，如GPIO、UART等等)</h4><ul><li>Instance成员(xx_TypeDef类型)，一般是指向外设的基地址，访问相关外设的资源</li><li>Init成员(xx_InitTypeDef类型)，用于初始化外设，配置外设如何去工作</li><li>Hdma*成员(DMA_HandleTypeDef类型，可能一个句柄结构有多个)</li><li>其他资源<ul><li>LOCK锁(HAL_LockTypeDef类型)    用于防止资源竞争，保护外设工作过程</li><li>STATUS状态(HAL_xx_StateTypeDef类型)    指示句柄结构体状态，可以用这个检查一下外设状态</li><li>…</li></ul></li></ul><h3 id="对外设初始化使用方法">对外设初始化使用方法</h3><ul><li><p>HAL_xx_Init,  参数一般为xx外设的句柄结构体</p><p>对句柄结构体下的init成员的相关参数配置到寄存器之前，它会先调用hal_xx_mspinit函数，将相关底层资源初始化完成，比如时钟、使用到的引脚、中断的使能等等。</p></li><li><p>HAL_xx_MspInit, 参数一般为xx外设的句柄结构体 (再HAL库中，这个函数是一个回调函数，用于初始化相关资源，是个弱定义，可以由用户重新定义)</p></li><li><p>其他，具体的外设初始化，我们要参考相关.c驱动文件，去参考学习“How to use this driver”</p></li></ul><h3 id="外设的使用逻辑">外设的使用逻辑</h3><h4 id="阻塞轮询-Polling">阻塞轮询(Polling)</h4><ul><li>xx_start</li><li>xx_read/write</li><li>…等等函数。==特征：传入参数需要一个Timeout参数==</li></ul><h4 id="中断-It">中断(It)</h4><ul><li>xx_start_it<ul><li>HAL_XX_IRQHandler(xx外设中断处理函数，在中断入口函数中调用，参数一般为句柄结构中的参数。在该函数中，一般会检测外设状态寄存器的标志，根据不同的状态回调不同的回调函数)  ——&gt;  各种HAL_XX_xxCallback函数</li></ul></li><li>xx_read/write_it</li><li>xx_xx_it…等等中断启动函数；==特征：函数名以IT结尾。==</li></ul><h4 id="DMA-可以再CPU不完全监控的情况下进行数据的操作">DMA(可以再CPU不完全监控的情况下进行数据的操作)</h4><ul><li>xx_start_dma<ul><li>DMA功能</li></ul></li><li>xx_read/write_dma</li><li>xx_xx_dma…等等DMA启动函数；==特征：函数名以DMA结尾==</li></ul><h4 id="其他功能">其他功能</h4><ul><li>标志查询/清除、中断功能使能/失能、时钟使能/失能<ul><li>_HAL_xx_ENABLE_IT</li><li>_HAL_xx_GET_FLAG</li><li>…等等</li></ul></li></ul><h4 id="对HAL库驱动全面了解、查看">对HAL库驱动全面了解、查看</h4><p>去HAL库的驱动包的   ##### How to use this driver ##### 了解</p><p>对于任意一个外设驱动，都会有相应的注释</p><p>==强推看注释==</p><h2 id="总结">总结</h2><ol><li><p>外设初始化</p><ul><li>定义并填充xxx外设句柄结构体</li><li>如果遵循HAL库规范，通过HAL_xxx_MspInit()函数，实现外设底层资源的初始化，包括但不限于GPIO、时钟、DMA、中断等资源的初始化</li><li>调用HAL库的对应的外设初始化函数，形如：HAL_xxx_Init()</li><li>初始化完成，开始使用外设</li></ul></li><li><p>使用外设，使用方法具体看对应外设的HAL库驱动包中的说明：</p><p><code>#####How to use this driver#####</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】10. PWM专题理解</title>
      <link href="/2023/10/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9110.%20PWM%E4%B8%93%E9%A2%98%E7%90%86%E8%A7%A3/"/>
      <url>/2023/10/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%9110.%20PWM%E4%B8%93%E9%A2%98%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>PWM专题理解</h1><h2 id="PWM-Pluase-Width-Mudulation">PWM(Pluase Width Mudulation)</h2><p><code>脉冲宽度调制 </code></p><p>利用微处理器的数字输出来对模拟电路进行控制的一种技术</p><h3 id="原理">原理</h3><p>面积等效原理</p><p><strong>相关概念：</strong></p><ul><li>脉冲：在短持续时间内突变，随后又迅速返回其初始值的物理量变化过程。(学术上的定义)</li><li>脉冲信号：瞬间突然变化、作用时间极短的电压或电流。脉冲信号是一种离散信号，具有一定的周期性。</li><li>脉冲宽度：高电平持续的时间。</li><li>脉冲冲量：脉冲信号在时间上的积累量。</li><li>周期：信号从高电平到低电平，再回到高电平所需的时间。</li><li>频率：一秒内又多少个这样的周期。</li><li>PWM占空比：一个脉冲周期内，高电平保持的时间。</li></ul><p>电压不同、时间不同的两组输入，如果他们的脉冲冲量(电压与时间的乘积)相等，那么他们输出的波形基本相同。</p><blockquote><p>如图上下两个波形钟，上下对齐且颜色相同的区域面积两两相等，所以上面的标准正弦波和下面的方波是等效的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021111337030.png" alt="image-20221021111337030"></p><p><strong>至此，我们可以理解为什么PWM可以通过数字输出来对模拟电路进行控制了，它其实就是使用数字信号(比如图中的方波)，来达到模拟信号(比如图中的正弦波)的效果</strong></p><h3 id="占空比与平均输出电压">占空比与平均输出电压</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021112035144.png" alt="image-20221021112035144"></p><p>占空比越大，所得到的平均电压也就越大，幅度值也就越大。</p><p>不断改变占空比，就可以得到我们想要的正弦波。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221021112134306.png" alt="image-20221021112134306"></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】9. STM32定时器</title>
      <link href="/2023/10/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%919.%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2023/10/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%919.%20STM32%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>定时器</h1><h2 id="SysTick定时器介绍">SysTick定时器介绍</h2><h3 id="Systick定时器特性介绍">Systick定时器特性介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020182311469.png" alt="image-20221020182311469"></p><ul><li>**计数宽度：**24bit来存储数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>=</mo><mn>16777216</mn></mrow><annotation encoding="application/x-tex">2^{24}=16777216</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">24</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">16777216</span></span></span></span></li><li>**向下递减：**计数器的工作模式</li><li><strong>计数器的工作周期：</strong> 工作周期为 1/CLKsource(时钟源)，1/72Mh z。</li><li>**计时器工作过程：**设定一个计数宽度，则计时器开始工作后，每经过1/72Mhz的时间，计数器都会向下递减一次计数宽度值。</li><li>**计时器的计时意义：**计时器完成一次工作过程所需的时间是固定的，若计数宽度和频率确定。</li><li><strong>每完成一次计时，都能触发一次中断。(详细见上面的SysTick特点图)</strong></li></ul><h3 id="计算公式-换算公式">计算公式/换算公式</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230223181225118.png" alt="image-20230223181225118"></p><h3 id="SysTick定时器功能">SysTick定时器功能</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020185745749.png" alt="image-20221020185745749"></p><h3 id="SysTick定时器寄存器介绍">SysTick定时器寄存器介绍</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020185917195.png" alt="image-20221020185917195"></p><h4 id="SysTick控制及状态寄存器-CTRL">SysTick控制及状态寄存器(CTRL)</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020190234851.png" alt="image-20221020190234851"></p><p>第0位是使能位，置1使能</p><p>第1位是中断位，若置1，则即使其倒数到0时产生SysTick异常请求，置0时误动作。</p><p>第2位是时钟源选择位</p><ul><li>置1    AHB  处理器时钟</li><li>置0   外部时钟</li></ul><p>第3到16位是计数标志位，功能描述如图。</p><h4 id="重装载数值寄存器-LOAD">重装载数值寄存器(LOAD)</h4><p>当倒数计数至零时，将被重新装载的值</p><p>例：比如我们将这个寄存器的重装载值设置位1000，则系统计时器会从1000开始递减。</p><h4 id="当前数值寄存器-VAL">当前数值寄存器(VAL)</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020191354504.png" alt="image-20221020191354504"></p><h2 id="基本定时器">基本定时器</h2><h3 id="定时器的分类">定时器的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221022142706284.png" alt="image-20221022142706284"></p><p><code>我们在Timer feature comparison 可以找到不同定时器的功能和分类</code></p><h3 id="基本定时器框架">基本定时器框架</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221023151530464.png" alt="image-20221023151530464"></p><ul><li>DMA输出是数模转换</li><li>定时器工作频率为总线频率除以预分频频率加一的和，定时器工作频率的具体解释，比如定时器工作频率为100KHz，那么定时器每一秒钟数100000个数字。</li><li>CNT，自动重装载值</li><li>定时频率为定时器工作频率除以自动重装载值加一的和，定时频率的具体解释，比如定时频率为1KHz，那么每一秒钟就会有1000次的溢出中断来标识计时完成，意味着每1ms触发一次中断，定时频率为每毫秒一次。</li></ul><h3 id="CubeMx配置定时器参数">CubeMx配置定时器参数</h3><h3 id="触发输信号">触发输信号</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221023154640655.png" alt="image-20221023154640655"></p><p>当计数完成触发一次中断后，定时器可以向其他寄存器释放信号。</p><h2 id="实例讲解">实例讲解</h2><h3 id="延时函数">延时函数</h3><p>HAL_Delay函数是基于定时器而实现的。</p><h3 id="SysTick在CubeMax中的配置">SysTick在CubeMax中的配置</h3><p>两个方面</p><p>SYS定时器来源配置</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020193544493.png" alt="image-20221020193544493"></p><p>Clock Configuration配置(配置定时器计数周期的频率)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020193923385.png" alt="image-20221020193923385"></p><p><code>to cortex systerm timer(MHz)</code></p><h3 id="如何找到内核定义的函数">如何找到内核定义的函数</h3><ul><li>路径CMSIS</li><li>systerm_stm32f1xx.c</li><li>进入该头文件(stm32f1xx.h)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020195117977.png" alt="image-20221020195117977"></p><ul><li><p>找到本芯片型号，进入头文件</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020195218083.png" alt="image-20221020195218083"></p></li><li><p>找到内核函数头文件，进入</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020195400431.png" alt="image-20221020195400431"></p></li><li><p>中断中不建议大家使用延时函数，如果Systick每配置好，很容易进入死循环。</p></li></ul><h3 id="延时函数的实现原理（定时器）">延时函数的实现原理（定时器）</h3><p>SysTick_Init()函数，跟着函数定义找</p><p>在其定义中，发现其定义了HAL_SYSTICK_CONFIG函数</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020202517551.png" alt="image-20221020202517551"></p><p>继续找其定义，发现其又调用返回了另一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020202629549.png" alt="image-20221020202629549"></p><p>继续搜索它的定义(由于这是<a href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%86%85%E6%A0%B8%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0">内核定义</a>的函数，所以按照前面的方法找)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221020203332051.png" alt="image-20221020203332051"></p><p>看懂定时器的初始化原理，然后再看Delay_us函数，进去看其定义，一层一层查找</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】8. STM32中断的使用工程</title>
      <link href="/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%918.%20STM32%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B7%A5%E7%A8%8B/"/>
      <url>/2023/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%918.%20STM32%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>STM32中断的使用(工程讲解)</h1><p><code>使用EXTI外部中断的工程实例</code></p><h2 id="CubeMax配置">CubeMax配置</h2><ol><li><h3 id="配置时钟">配置时钟</h3></li><li><p>配置SYS的debug，选择Serial Wire</p><ul><li><p>若不勾选，程序只能下载一遍</p></li><li><p>若未勾选然后已经下载了程序</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019163209562.png" alt="image-20221019163209562"></p></li></ul></li><li><p>配置GPIO引脚</p><ul><li>任意引脚，选择GPIO_EXTI</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019163358656.png" alt="image-20221019163358656"></p><p>图中的GPIO_EXTI2对应着GPIO2线的外部中断，可以在数据手册中的External interrupt/even line mapping中找到相关描述</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019163655650.png" alt="image-20221019163655650"></p><ul><li><p>配置GPIO模式，可选择上升沿触发或者下降沿触发或上下边沿都检测(rising/falling edge trigger detection)</p><p>可选择事件模式(event)或者中断模式(external interrupt)</p><p>事件模式：只产生事件</p><p>中断模式：既产生事件又产生中断</p></li></ul></li><li><p>配置NVIC(向量中断控制器)</p><ul><li>如图，如果设置了GPIO_EXTI2，那么我们要使能向量中断控制器去操纵这个引脚，所以需要在NVIC勾选相应的中断。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019164634750.png" alt="image-20221019164634750"></p><ul><li><p>然后在此界面设置优先级分组(详细请看中断概述中的NVIC章节)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019164803817.png" alt="image-20221019164803817"></p><p><code>样例中勾选了Sort by ..., 以及选择了4bits for... 意思是选择优先级分组，并且将该中断的优先级分组全部位数用于表示抢占优先级，没有子优先级</code></p></li><li><p>然后点击line2，设置其抢占优先级和子优先级</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019165049399.png" alt="image-20221019165049399"></p></li></ul></li><li><p>然后配置Project Manager(工程路径最好不要有中文)</p></li></ol><h2 id="中断触发流程">中断触发流程</h2><p>中断触发——&gt;中断向量表(在其中找对应的偏移)——&gt;找到对应的入口地址——&gt;跳转到中断服务函数(我们最终会执行的函数)</p><p><strong>这些大量的handle储存了不同的中断服务函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019170708165.png" alt="image-20221019170708165"></p><p><em><strong>如果没有定义好中断服务函数，那么触发中断后就会跳转到默认的中断服务函数(弱定义)进入死循环</strong></em></p><h3 id="注意：">注意：</h3><ol><li><p>我们在编写中断服务函数时最好先写个条件语句判断是否产生相应的中断。</p></li><li><p>判断玩之后记得清除中断标志位，否则会一直触发中断。(实际上，EXTI会将中断挂起，若不清除中断标志则会一直产生中断)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019171426885.png" alt="image-20221019171426885"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】7. STM32中断概述</title>
      <link href="/2023/10/07/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%917.%20STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/07/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%917.%20STM32%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>中断概述</h1><h2 id="中断">中断</h2><h3 id="中断的概念">中断的概念</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017150827612.png" alt="image-20221017150827612"></p><p><code>感性的理解：当你执行A任务时，出现了B任务，B任务更重要，所以你停止做A，先做完B再做A，这个过程称为中断</code></p><h3 id="中断和异常">中断和异常</h3><p>中断和异常的概念相近，异常可以说是 <strong>内核活动</strong> 产生(比如说执行指令出错)；</p><p>而中断一般是由连接到内核的外部器件(外设)产生(比如外设产生中断，提示数据传输完成)；</p><p><em>它们的触发原理或者处理方式相同，在使用中并不严格区分异常和中断</em></p><h3 id="外部中断">外部中断</h3><p><code>外部中断，目前可以理解为外设中断，英文是 External Interrupte </code></p><p>不同开发板的中断以及中断类型各不相同，因此对不不同开发板的中断使用应该具体情况具体分析，查看中断的内容，我们可以打开工程，阅读startup文件，找到其中的 <strong>External Interrupts</strong></p><h2 id="优先级">优先级</h2><h3 id="中断优先级">中断优先级</h3><ul><li>优先级有两种：可编程、不可编程</li><li>中断的优先级决定着内核优先相应谁的中断请求</li><li>小值优先原则，优先级值越小，中断会被优先相应</li><li>中断优先级按照 <strong>优先级分组</strong> 配置</li></ul><h3 id="中断的优先级分组">中断的优先级分组</h3><ul><li><p>以F103为例，STM32上使用的M3内核支持8bit优先级中的高4位bit。也就是说STM32F103支持<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>个优先级。(0~15)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017153044599.png" alt="image-20221017153044599"></p></li><li><p>在F103上，使用这4个bit，组织成五组优先级分组。这五组中，每组分为一个抢占优先级、一个子优先级组。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017153507988.png" alt="image-20221017153507988"></p><ul><li>通过优先级分组，可以更好的管理中断响应顺序。</li><li>只有 <em><strong>抢占优先级</strong></em> 才有抢占中断的权限，发生中断嵌套。(所以，<strong>抢占优先级决定中断次序</strong>) <code>A中断抢占B中断执行，执行完后B中断再执行的过程称为中断嵌套</code><ul><li>例：B中断正在执行，A中断抢占优先级数值比B中断小(A的抢占优先级比B高)，A中断则抢过B中断的使用权，响应A的中断服务函数，A中断执行完再交还给B。</li></ul></li><li>如果中断抢占优先级相同，则不发生抢占行为。</li><li>如果多个挂起的中断具有相同的抢占优先级，则子优先级高的先行，如果子优先级都相同，则IRQ编号小的先行。<strong>中断挂起：就是挂起等待</strong><ul><li>IRQ编号是中断编号，不同开发板的中断编号不同，可以通过查阅文件看到使用的开发板的中断编号。<strong>如何找？详细见视频——中断概览，21min-23min</strong></li></ul></li></ul></li><li><p>小结：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017155320648.png" alt="image-20221017155320648"></p></li></ul><hr><h2 id="嵌套向量中断控制器-NVIC">嵌套向量中断控制器(NVIC)</h2><h3 id="NVIC的功能">NVIC的功能</h3><h4 id="相关库函数">相关库函数</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017155529783.png" alt="image-20221017155529783"></p><p><code>中断等待的状态：中断挂起/中断悬起</code></p><p>NVIC, Nested Vectored Interrupt Controller.</p><h2 id="EXTI扩展中断和事件控制器">EXTI扩展中断和事件控制器</h2><p><code>EXTI, external interrupt, 外部中断</code></p><h3 id="事件的概念">事件的概念</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017181624580.png" alt="image-20221017181624580"></p><p><code>定时器是STM32的一个外设，可以实现计数的功能</code></p><h3 id="EXTI-扩展中断和事件控制器">EXTI-扩展中断和事件控制器</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017181935548.png" alt="image-20221017181935548"></p><p><strong>重点：捕获外部输入事件</strong></p><h3 id="EXTI外设框图-F1-F4-F7">EXTI外设框图(F1/F4/F7)</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017182615061.png" alt="image-20221017182615061"></p><ul><li>上升沿触发寄存器和下降沿触发寄存器可以同时配置</li><li>输入线的电平变化信号是否可以传到下一级门电路，取决于上升沿触发寄存器和下降沿触发寄存器是否捕获这个变化信号。</li></ul><p><strong>注意电路图的两个标志：</strong></p><ul><li><p>门电路</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017182940096.png" alt="image-20221017182940096"></p><p>other</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017183013894.png" alt="image-20221017183013894"></p></li><li><p>或门，输入的线其中一个输入满足条件则可通过</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017183046163.png" alt="image-20221017183046163"></p></li><li><p>与门，输入的线全都满足条件才可以通过</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221017183122537.png" alt="image-20221017183122537"></p></li><li><p>脉冲发生器，一般用于唤醒MCU，MCU为了低功耗，不工作时一般会休眠</p></li></ul><p><strong>主要的使用逻辑：捕获外部引脚电平变化——&gt;触发EXTI——&gt;申请中断</strong></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL 库开发】6. STM32第一个外设GPIO</title>
      <link href="/2023/10/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%916.%20STM32%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%96%E8%AE%BEGPIO/"/>
      <url>/2023/10/06/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%916.%20STM32%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%96%E8%AE%BEGPIO/</url>
      
        <content type="html"><![CDATA[<h1>GPIO</h1><h2 id="GPIO的输入和输出">GPIO的输入和输出</h2><h3 id="GPIO输出模式-四种">GPIO输出模式(四种)</h3><h4 id="推腕输出">推腕输出</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019195721798.png" alt="image-20221019195721798"></p><p><em>特点：驱动能力强</em>（因为MOS管电阻很小，VCC经过的电流大，驱动能力强）</p><p><em>是最常用的输出模式</em></p><h4 id="开漏输出">开漏输出</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019195809597.png" alt="image-20221019195809597"></p><p><em>只能输出低电平</em></p><p><strong>输出高电平时，可以外接一个电阻和电压（上拉电阻），电压可以根据自己的需要选择，这样IO口就可以输出你想要的电平（高于5.5v）</strong></p><p>&quot;开漏输出&quot;具有”线与“的功能，一个为低全部为低，多用于I2C或者SMBUS总线;(个人理解：就是在开漏输出的IO连接的线上，如果驱动电压是开漏输出的IO口，那么这条线上只要有一处是低电平，意味着全部都是低电平)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230124000202845.png" alt="image-20230124000202845"></p><h4 id="复用推腕输出和复用推腕输出">复用推腕输出和复用推腕输出</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019195943060.png" alt="image-20221019195943060"></p><p><strong>一般用于特殊的功能</strong></p><h3 id="GPIO输入模式-四种">GPIO输入模式(四种)</h3><h4 id="上拉输入">上拉输入</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019200122677.png" alt="image-20221019200122677"></p><p><strong>外接独立按键可以使用这个，可以有效防止其他因素的干扰</strong></p><h4 id="下拉输入">下拉输入</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019200228954.png" alt="image-20221019200228954"></p><h4 id=""></h4><h4 id="浮空输入和模拟输入">浮空输入和模拟输入</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019200338947.png" alt="image-20221019200338947"></p><p><em><strong>注意：芯片复位上电后默认为浮空输入模式。</strong></em></p><h3 id="输出速度">输出速度</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019200449504.png" alt="image-20221019200449504"></p><h3 id="GPIO初始化顺序">GPIO初始化顺序</h3><ol><li>选定具体的GPIO</li><li>配置GPIO工作模式（CRL和CRH寄存器）</li><li>控制GPIO输出高低电平（ODR、BSRR、BRR）</li></ol><h3 id="写自己的函数">写自己的函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221028104822659.png" alt="image-20221028104822659"></p><h2 id="操作寄存器点亮LED">操作寄存器点亮LED</h2><h3 id="C语言技巧">C语言技巧</h3><ul><li><p>给寄存器相应的位置位或者清0的操作</p><p>置位</p><p>|=</p><p>例子：*(unsigned int *)0x40021000 |= (1&lt;&lt;0)</p><p>表示对地址在0x40021000上的寄存器的第0位置1</p><p>清0</p><p>&amp;=</p><p>例子：*(unsigned int *)0x40021000 &amp;=  ~(1&lt;&lt;0)</p><p>表示对地址在0x40021000上的寄存器的第0位清0</p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL 库开发】5. RCC—复位和时钟控制</title>
      <link href="/2023/10/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%915.%20STM32%E7%9A%84%E5%A4%8D%E4%BD%8D%E5%92%8C%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/10/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%915.%20STM32%E7%9A%84%E5%A4%8D%E4%BD%8D%E5%92%8C%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1>RCC—复位和时钟控制</h1><p><code>RCC, Reset and clock control(是STM32的一个外设)</code></p><h2 id="STM32-RCC知识">STM32 RCC知识</h2><h3 id="STM的复位功能-三种">STM的复位功能(三种)</h3><ol><li>系统复位<ul><li>就是将系统所有寄存器都设定为默认的复位值</li><li>所有寄存器是指，除了指针控制寄存器(CSR)的复位标志和备份区域中的寄存器以外的所有寄存器</li></ul></li><li>电源复位<ul><li>除了备份区域中的寄存器，复位其他所有寄存器</li></ul></li><li>后被域复位<ul><li>只影响备份区域</li></ul></li></ol><p><strong>详细的功能查阅参考手册RCC章节</strong></p><h3 id="时钟">时钟</h3><p>对于电子器件来说，时钟就是它的心跳，STM32芯片会根据时钟的节拍来工作。</p><p><code>常说的72Mhz、480Mhz，就是指STM32的主时钟(系统时钟)的频率，芯片就以这样的频率，对各种器件做着同步的工作</code></p><h4 id="时钟来源">时钟来源</h4><ul><li><p>芯片的时钟来源有很多种，这里以STM32为例</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016103625981.png" alt="image-20221016103625981"></p><p><code>PLL时钟是我们常用的时钟，二级时钟源主要是给其他器件使用的。比如LSE常用于定时器的配置。需要注意的是，频率越高、运行速度更快、功耗越高</code></p><p><strong>这些东西也能在参考手册找到</strong></p></li></ul><h4 id="STM32时钟树的设计">STM32时钟树的设计</h4><ul><li><p>方便对各种时钟进行整合以及管理，也方便用户的使用</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016103959764.png" alt="image-20221016103959764"></p><p><code>时钟树大概长这样</code></p></li></ul><h4 id="使用CubeMax配置时钟树-这里主要针对系统时钟的设置">使用CubeMax配置时钟树(这里主要针对系统时钟的设置)</h4><ol><li><p>在Clock Confriguration中进行配置</p></li><li><p>首先，在系统核心中配置RCC外设</p><ul><li><p>在RCC外设里，我们就可以选择使用哪一个时钟了(<a href="#%E6%97%B6%E9%92%9F%E6%9D%A5%E6%BA%90">如图有HSE振荡器时钟和低速外部晶体</a>)</p></li><li><p>对于高低速时钟各有的功能和作用，可以在参考手册中找到。</p></li><li><p>我们可以根据手册来选择时钟的时钟来源：晶振/用户输入/XXX</p></li><li><p>我们常选择的方案是使用一个晶振(Crystal Resonator)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016105221536.png" alt="image-20221016105221536"></p></li><li><p>低速外部时种可选可不选(因为我们已经有一个时钟在用了)</p></li></ul><p><em>至此，配置好RCC时钟以及时钟源</em></p></li><li><p>跳转至时钟配置栏(Clock Confriguration)</p><p><code>在这里配置时钟树</code></p><ul><li><p>设置主系统时钟，找到中间的SYSCLK</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016105556992.png" alt="image-20221016105556992"></p><p><code>这里，我们可以看到我们的系统时钟是被HSI RC控制的</code></p><ul><li><p>一般，我们会用HSE作为倍频的时钟源输入，然后通过PLL对我们的输入时钟进行倍频，来实现一个较高频率的的输出，作为系统的主时钟，这样我们就可以得到一个较高的时钟频率。</p></li><li><p>根据上述逻辑，我们为了得到一个较高的时钟频率，将系统主时钟与PLL时钟相连，然后再调系统时钟的频率。</p></li><li><p>那我们应该选取什么样的系统时钟频率呢？</p><ol><li><p>参考数据手册的 <em>工作条件中的通用工作条件</em> 找到不同条件下对频率的限定范围</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016110420440.png" alt="image-20221016110420440"></p><p><code>参考手册一般会配有时钟树的图</code></p></li><li><p>先配置系统主时钟，再配置后面的分支，系统主时钟的配置，根据数据手册可以看到。(上面的工作条件图中，表明了内部AHB时钟频率的范围，以此为例调节内部HCLK的频率，然后回车，CubeMx就会有弹窗自动为你生成合适的配置方案帮你配好所有时钟)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016110955178.png" alt="image-20221016110955178"></p><p>next，这里输入72MHz，是数据手册中限制的工作频率的最大值，但是具体配置什么值，<strong>取决于我们的个人需要以及工程需要</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016111037532.png" alt="image-20221016111037532"></p><p>点击ok</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016111103108.png" alt="image-20221016111103108"></p><p><em>自动生成好了时钟方案，主要是由CubeMX检索方案自动生成合适的、不超过数据手册中的关于频率的限制的 <strong>分频因子</strong></em></p></li><li><p>看一下PLL的倍频实现</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016111218033.png" alt="image-20221016111218033"></p></li></ol></li></ul></li><li><p>对于大部分STM32外设来说，都是走这样一种主的系统时钟线路的</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016111732462.png" alt="image-20221016111732462"></p></li></ul></li></ol><p><strong>小结：</strong></p><ul><li>对于STM32上的时钟的具体配置，根据工作需求决定</li><li>时钟频率越高，一般功耗越高</li><li>另一方面，要考虑芯片的工作条件，根据芯片运行的工作条件选取时钟频率</li><li>只要满足工作条件的频率都可以配置，有一定自由度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】4. STM32程序启动过程</title>
      <link href="/2023/10/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%914.%20STM32%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/10/04/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%914.%20STM32%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>STM32启动过程</h1><h2 id="程序启动流程">程序启动流程</h2><p>STM的内核结构</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016092241070.png" alt="image-20221016092241070"></p><p>该内核就是不断接受指令，然后不断执行指令</p><p>我们所有的代码和操作都会变成相应的指令传给内核。</p><p>ARM<strong>公司设计了一套指令集</strong></p><ul><li>所有的操作最后都会变成指令集中的指令</li><li>一旦芯片上电，就会引发芯片的复位异常，并且会跳到中断向量表特定的偏移位置，获取里面的内容执行。</li><li>我们修改复位异常的内容，我们就可以让处理器去执行我们的操作</li></ul><p><em>不同的存储器差异：</em></p><ul><li>flash存储器(闪存存储器)—&gt;相对较长时间保存数据(保存时间的长短取决于芯片的性能)</li><li>SRAM存储器—&gt;静态随机存储器(断电就会数据流失)</li></ul><p><em>启动文件：</em></p><ul><li><p>一般而言，每个工程启动文件都是.s文件(汇编文件)</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221016094110055.png" alt="image-20221016094110055"></p><p><em>从启动文件的描述中，我们看到它做了这五个工作</em></p><ol><li>初始化堆栈指针</li><li>设置PC指针的值(PC指针-8的位置就是当前指针的地址)</li><li>设置中断向量表</li><li>配置系统时钟</li><li>调用C库函数_main<ol><li>完成初始化堆栈的工作</li><li>跳转到我们自己写的main函数中</li></ol></li><li>关键字：<ol><li>Stack(堆)、Heap(栈)</li><li>Vectors(中断)</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】3. 板级支持包</title>
      <link href="/2023/10/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%913.%20%E6%9D%BF%E7%BA%A7%E6%94%AF%E6%8C%81%E5%8C%85/"/>
      <url>/2023/10/03/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%913.%20%E6%9D%BF%E7%BA%A7%E6%94%AF%E6%8C%81%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1>板级支持包</h1><h2 id="什么是板级支持包">什么是板级支持包</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015212746055.png" alt="image-20221015212746055"></p><h4 id="一个软件的组织架构（简化的理解）">一个软件的组织架构（简化的理解）</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015213206288.png" alt="image-20221015213206288"></p><p>我们的目的，以及嵌入式开发的重要目标，就是构建自己的板级支持包，板级支持包在软硬件中起到承上启下的作用。</p><ul><li>板级支持包提供硬件的具体功能，实现硬件的各种作用</li><li>不同的硬件应有不同的板级支持包</li><li>主要功能：对板上的资源功能给出实现，并提供用户应用程序接口</li></ul><h4 id="本节目标："><strong>本节目标：</strong></h4><ul><li>构建开发板上的LED灯板级支持包</li><li>构建开发板上的按键板级支持包</li></ul><h2 id="构建板级支持包的操作">构建板级支持包的操作</h2><h3 id="具体操作">具体操作</h3><h4 id="打开一个工程（以LED灯为例">打开一个工程（以LED灯为例)</h4><h4 id="板级支持包是一个单独的-c-文件，我们建立一个这样的文件">板级支持包是一个单独的 .c 文件，我们建立一个这样的文件</h4><ul><li>先建立一个文件夹命名为板级支持包，用于管理</li><li>然后建立.c文件用于操控，以及建立一个头文件（就是建立一个.h文件）</li><li><a href="#%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84">然后设置相应的路径（在前文有讲）</a></li></ul><h4 id="写程序，使用相应的引脚，实现相应功能">写程序，使用相应的引脚，实现相应功能</h4><p>写程序时注意点：</p><ul><li>宏定义的对象时调用函数时，为了避免错误，使用do{}while(0)语句，这样能保证一次宏调用只执行一次。</li></ul><h4 id="板级支持包的使用">板级支持包的使用</h4><ul><li><p>在main函数中，将自己的头文件写进去(注意位置：写在USER CODE BEGIN Includes下面)</p><p><code>这样是为了在main函数中调用自己的板级支持包</code></p></li><li><p>然后在主函数进行调用，实现功能</p></li></ul><h2 id="自己移植库，并进行使用（作为补充知识）">自己移植库，并进行使用（作为补充知识）</h2><ul><li><h4 id="新建自己的移植工程目录，在目录里建好相应的文件夹便于文件的管理">新建自己的移植工程目录，在目录里建好相应的文件夹便于文件的管理</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015222425815.png" alt="image-20221015222425815"></p></li><li><h4 id="打开keil，新建一个工程，放到自己的工程目录里的Project里面去">打开keil，新建一个工程，放到自己的工程目录里的Project里面去</h4><ul><li><p>选择对应的芯片</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015222637333.png" alt="image-20221015222637333"></p></li></ul></li><li><h4 id="然后将相关的库拷到工程目录下">然后将相关的库拷到工程目录下</h4><ul><li><p>主要是CMSIS和STM32的hal库，放到libraries</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015222934209.png" alt="image-20221015222934209"></p></li></ul></li><li><p>然后在User里建立自己的第一个文件main.c</p></li><li><p>然后就可以回到keil，对自己的工程文件进行其他文件的添加（点&quot;品&quot;字型的按键）</p><ul><li><p>管理Project</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015223324126.png" alt="image-20221015223324126"></p></li><li><p>然后点击ok</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015223347266.png" alt="image-20221015223347266"></p><p>然后就可以在相应的文件夹里移植自己的库函数文件或者其他文件了</p></li><li><p>然后添加相应的文件和函数库进去</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015223701172.png" alt="image-20221015223701172"></p><ul><li><p>一般ll的.c文件不添加、带有temple字样的.c文件不添加（会导致一些错误，所以不添加）</p></li><li><p>原则：按需添加（主要是添加一些外设和必要的驱动）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015223904235.png" alt="image-20221015223904235"></p></li></ul></li><li><p>这样就将许多的必要文件放在了Project中</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015224021071.png" alt="image-20221015224021071"></p></li><li><p>但是这时我们很多.c文件是没有路径的，这就需要我们配置路径了</p></li></ul></li><li><h3 id="配置路径">配置路径</h3><ul><li><p>点击魔法棒调出窗口</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015224204184.png" alt="image-20221015224204184"></p><p>ARM compler 使用第五版本的编译器</p></li><li><p>然后点击C/C++</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015224342217.png" alt="image-20221015224342217"></p><p>然后点击include path的三个点进行路径的配置</p><ul><li><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015224453160.png" alt="image-20221015224453160"></p><p>这样找到头文件位置进行添加（主要是添加hal库的和CMSIS这种函数库的头文件）</p></li></ul></li><li><p>然后在Define中写上自己的芯片和相应的驱动，具体根据关键字写，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015224750744.png" alt="image-20221015224750744"></p><p><strong>然后点击ok就添加进了头文件</strong></p></li></ul></li></ul><p><strong>至此，我们就可以构建我们的程序，进行编写和编译</strong></p><ul><li><p>然后发现在编译过程中出现许多报错</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015225401672.png" alt="image-20221015225401672"></p><p>先解决第一个报错，如图鼠标所指向（找不到头文件XXX）</p><ul><li><p>如图这是个hal库的配置文件，通过下图的文件路径找到它</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015225523447.png" alt="image-20221015225523447"></p><p>点开这个文件，有配置说明</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015225625326.png" alt="image-20221015225625326"></p><p><strong>最后一行字说：这个文件应该被复制到应用文件夹，并且重命名为XXX</strong></p><p>（我们发现这个名字和报错名字一模一样）</p></li><li><p>按照文件提示操作，将之复制到应用目录下并重命名</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015225751127.png" alt="image-20221015225751127"></p><p>然后在keil中添加头文件路径</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015225908254.png" alt="image-20221015225908254"></p><p><strong>这样一来，就可以正常跳转到头文件了</strong></p><p>（这个config文件是必须的且重要的）</p></li></ul></li><li><p>然后我们编译，根据相应的报错，添加路径、解决错误。（一般是ex.c文件未链接）</p><p>注意，我们的main.c文件必须要有一个入口函数，不然会编译报错</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015230336400.png" alt="image-20221015230336400"></p><p><strong>至此，编译无误，工程移植建立完毕</strong>（在project中生成了.axf文件，即可进行烧录）</p></li></ul><p><strong>注意:</strong></p><ul><li>hal库定义了许多函数，一般函数的声明都集中放在文件的最后面。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】2. STM库的基本操作</title>
      <link href="/2023/10/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%912.%20STM%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%912.%20STM%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1>STM库的基本操作</h1><h2 id="如何使用函数">如何使用函数</h2><h3 id="点开各种外设的驱动文件">点开各种外设的驱动文件</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221015211502007.png" alt="image-20221015211502007"></p><ul><li>一定要看&quot;How to use this driver&quot;板块，了解如何使用</li><li>对于&quot;How to use this driver&quot;板块，带有(#)的是顶层操作，必须按步骤按顺序操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【STM32HAL库开发】1. KEIL5基本了解——新建工程模板</title>
      <link href="/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%911.%20KEIL5%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E3%80%90STM32HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%911.%20KEIL5%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1>KEIL5基本了解——新建工程模板</h1><p>本文基于新建工程模板，使用KEIL5，对KEIL的操作和一些汇编知识进行了解。</p><h2 id="工程文件必须要的几个文件">工程文件必须要的几个文件</h2><h3 id="启动文件">启动文件</h3><p>从ST官方的固件库资料里面找到启动文件</p><p><strong>启动文件是和硬件相关的一些汇编代码，是必不可少的。</strong></p><h3 id="main函数">main函数</h3><p>main函数是一个程序中的入口函数，必不可少</p><h3 id="SystemInit">SystemInit</h3><p>首先我们了解一下程序执行过程，最开始是从启动文件中的Reset_Handler（复位程序）开始执行（汇编阶段），在复位程序里面，我们调用了一个外部函数SystemInit初始化各种东西，然后调用_main函数，在这个函数的最末尾调用入口函数main，然后从汇编世界进入C语言程序的世界；</p><h3 id="包含所有寄存器定义的头文件">包含所有寄存器定义的头文件</h3><p>stm32f10x.h，这个头文件对所有的寄存器等基础的东西都做了定义，帮我们完成了很多工作；</p><h3 id="两个重要的KEIL生成的文件">两个重要的KEIL生成的文件</h3><h4 id="Listings">Listings</h4><p>存放寄存器映射、存储器映射等文件</p><h4 id="Objects">Objects</h4><p>用于存放生成的工程目标文件</p><p>比如hex文件（串口烧录可执行文件）、axf文件（烧录可执行文件）</p><h2 id="魔法棒">魔法棒</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019213030830.png" alt="image-20221019213030830"></p><p><strong>使用lab，优化我们的代码</strong></p><p>对于学习来说最好使用第五版的编译器</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20221019213113992.png" alt="image-20221019213113992"></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】预测模型-1. 统计回归预测</title>
      <link href="/2023/08/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B-1.%20%E7%BB%9F%E8%AE%A1%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B/"/>
      <url>/2023/08/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B-1.%20%E7%BB%9F%E8%AE%A1%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1>回归分析</h1><h2 id="简介">简介</h2><p>在统计学中，回归分析（regression analysis）指的是确定两种或者两种以上变量间相互依赖关系的定量关系的一种统计分析方法。回归分析根据涉及到的变量的多少，分为<strong>一元回归分析和多元回归分析</strong>；按照因变量的多少，可分为<strong>简单回归分析和多重回归分析</strong>；按照自变量和因变量的关系类型，可以分为<strong>线性回归分析和非线性回归分析</strong>。</p><p>在大数据分析中，回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于<strong>预测分析、时间序列分析以及发现变量之间的因果关系</strong>。</p><h3 id="回归分析的步骤">回归分析的步骤</h3><ol><li>确定回归方程的解释变量和被解释变量</li><li>确定回归模型，建立回归方程</li><li>对回归方程进行各种验证</li><li>利用回归方程进行预测</li></ol><h2 id="一元线性回归模型">一元线性回归模型</h2><p>如果<strong>只有一个自变量x，并且因变量Y和自变量X之间的数量变化关系呈近似线性关系</strong>，就可以建立一元线性回归方程，根据自变量X的值预测Y的值，这就是一元线性回归预测。</p><p>如果因变量Y和自变量X之间呈线性相关，那就是说，对于自变量X的某一值 xi ，因变量Y对应的取值 yi 不是唯一确定的，而是有很多的可能取值，它们分布在一条直线的上下，这是因为Y还受除自变量以外的其他因素的影响。这些因素的影响大小和方向都是不确定的，通常用一个随机变量(记为ε)来表示，也称为随机扰动项。于是，Y和X之间的依存关系可表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><mi>α</mi><mo>+</mo><mi>β</mi><msub><mi>x</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mspace linebreak="newline"></mspace><mi>α</mi><mtext> — 截距、</mtext><mi>β</mi><mtext> — 斜率、</mtext><mi>ϵ</mi><mtext> — 误差项，反映除了</mtext><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mtext>以外的随机因素对</mtext><mi>y</mi><mtext>的影响</mtext></mrow><annotation encoding="application/x-tex">y_i=\alpha+\beta x_i+\epsilon_i\\\alpha\ — \ 截距、\beta \ —\ 斜率、\epsilon \ — \ 误差项，反映除了x,y以外的随机因素对y的影响</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace"> </span><span class="mord">—</span><span class="mspace"> </span><span class="mord cjk_fallback">截距、</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace"> </span><span class="mord">—</span><span class="mspace"> </span><span class="mord cjk_fallback">斜率、</span><span class="mord mathnormal">ϵ</span><span class="mspace"> </span><span class="mord">—</span><span class="mspace"> </span><span class="mord cjk_fallback">误差项，反映除了</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">以外的随机因素对</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">的影响</span></span></span></span></span></p><h3 id="一元线性回归方程">一元线性回归方程</h3><p>描述因变量y的期望值如何依赖于自变量x的方程称为回归方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>α</mi><mo>+</mo><mi>β</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">E(y_i)=\alpha+\beta x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li>如果回归方程参数已知，对于一个给定的x的值，利用回归方程就能计算出y的期望值</li><li>用样本统计代替回归方程中的位置参数，就得得到估计回归方程，也称为回归直线</li></ul><h4 id="参数的最小二乘估计">参数的最小二乘估计</h4><p>对于回归直线，<strong>关键在于求解参数</strong>，常用高斯提出的最小二乘法，它是使得因变量的<strong>观察值y与估计值之间的离差平方和达到最小</strong>来求解。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>0</mn></msub><mo>−</mo><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>1</mn></msub><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">Q=\sum(y-\hat{y})^2=\sum(y-\hat\beta_0-\hat\beta_1x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2079em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>经过对(3)式展开，对Q求极小值点（对其求偏导数(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub><mtext>和</mtext><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0和\beta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)），最终求解得到<strong>参数的求解公式</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>1</mn></msub><mo>=</mo><mfrac><mrow><mi>n</mi><mo>∑</mo><mi>x</mi><mi>y</mi><mo>−</mo><mo>∑</mo><mi>x</mi><mo>∑</mo><mi>y</mi></mrow><mrow><mi>n</mi><mo>∑</mo><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mo stretchy="false">(</mo><mo>∑</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mspace linebreak="newline"></mspace><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>0</mn></msub><mo>=</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><mo>−</mo><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>1</mn></msub><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover></mrow><annotation encoding="application/x-tex">\hat\beta_1=\frac{n\sum xy-\sum x\sum y}{n\sum x^2-(\sum x)^2}\\\hat\beta_0=\overline y-\hat\beta_1\overline x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.825em;vertical-align:-0.1944em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1523em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span></span></span></span></span></p><h4 id="利用回归直线进行估计和预测">利用回归直线进行估计和预测</h4><ul><li>点估计：利用估计的回归方程，对于x的某个特定值求出y的一个估计值</li><li>区间估计：利用估计得到回归方程，对于x的一个特定值，求出y的一个估计值的区间</li></ul><h4 id="估计标准误差的计算">估计标准误差的计算</h4><p>为了<strong>度量回归方程的可靠性</strong>，通常计算估计的标准误差。它度量观察值回绕着回归直线的变化程度或分散程度。估计平均误差：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>S</mi><mi>y</mi></msub><mo>=</mo><msqrt><mfrac><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfrac></msqrt></mrow><annotation encoding="application/x-tex">S_y=\sqrt{\frac{\sum(y-\hat y)^2}{n-2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.44em;vertical-align:-0.7773em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6627em;"><span class="svg-align" style="top:-4.4em;"><span class="pstrut" style="height:4.4em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.6227em;"><span class="pstrut" style="height:4.4em;"></span><span class="hide-tail" style="min-width:1.02em;height:2.48em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='2.48em' viewBox='0 0 400000 2592' preserveAspectRatio='xMinYMin slice'><path d='M424,2478c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1014.6s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2z M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7773em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li>自由度为：n-2    （有两个不能改变的参数，有两个参数是用于生成估计方程的，因此不能使用）</li><li>估计标准差越大，则数据点围绕回归直线的分散程度越大，回归方程的代表性越小。</li><li>估计标准误差越小，则数据点围绕回归直线的分散程度越小，回归方程的代表性越大，即可靠性高。</li></ul><h3 id="回归直线的拟合信度">回归直线的拟合信度</h3><h4 id="置信区间估计-※">置信区间估计(※)</h4><p>置信区间估计是针对<strong>真实总体参数可能落在其中的一定范围内</strong>进行估计的过程。<strong>比如“95%的置信区间”意味着我们有95%的置信水平认为真实参数值位于该区间内。</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mn>0</mn></msub><mo>±</mo><msub><mi>t</mi><mfrac><mi>α</mi><mn>2</mn></mfrac></msub><msub><mi>s</mi><mi>e</mi></msub><msqrt><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></msqrt></mrow><annotation encoding="application/x-tex">\hat y_0\pm t_{\frac{\alpha}{2}}s_e\sqrt{\frac{1}{n}+\frac{(x_0-\overline x)^2}{\sum(x-\overline x)^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.04em;vertical-align:-1.1606em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3341em;"><span style="top:-2.85em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3908em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8794em;"><span class="svg-align" style="top:-5em;"><span class="pstrut" style="height:5em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.8394em;"><span class="pstrut" style="height:5em;"></span><span class="hide-tail" style="min-width:1.02em;height:3.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='3.08em' viewBox='0 0 400000 3240' preserveAspectRatio='xMinYMin slice'><path d='M473,2793c339.3,-1799.3,509.3,-2700,510,-2702 l0 -0c3.3,-7.3,9.3,-11,18,-11 H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606zM1001 80h400000v40H1017.7z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1606em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>在1—α置信水平下预测区间</strong></p><p>1-α置信水平下预测区间是指在回归分析中，对于给定的自变量值，预测因变量的取值范围的估计。具体来说，对于给定的自变量值，预测区间包含了我们对因变量取值的不确定性，并给出了一个区间，<strong>我们有1-α的置信水平认为真实值位于该区间内</strong>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mn>0</mn></msub><mo>±</mo><msub><mi>t</mi><mfrac><mi>α</mi><mn>2</mn></mfrac></msub><msub><mi>s</mi><mi>e</mi></msub><msqrt><mrow><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mover accent="true"><mi>x</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow></msqrt></mrow><annotation encoding="application/x-tex">\hat y_0\pm t_{\frac{\alpha}{2}}s_e\sqrt{1+\frac{1}{n}+\frac{(x_0-\overline x)^2}{\sum(x-\overline x)^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">±</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:3.04em;vertical-align:-1.1606em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3341em;"><span style="top:-2.85em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6915em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3908em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8794em;"><span class="svg-align" style="top:-5em;"><span class="pstrut" style="height:5em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.8394em;"><span class="pstrut" style="height:5em;"></span><span class="hide-tail" style="min-width:1.02em;height:3.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='3.08em' viewBox='0 0 400000 3240' preserveAspectRatio='xMinYMin slice'><path d='M473,2793c339.3,-1799.3,509.3,-2700,510,-2702 l0 -0c3.3,-7.3,9.3,-11,18,-11 H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606zM1001 80h400000v40H1017.7z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1606em;"><span></span></span></span></span></span></span></span></span></span></p><p><strong>影响区间宽度的因素</strong></p><ul><li><p>置信水平（1-α），区间宽度随着置信水平的增大而增大。</p></li><li><p>数据的离散程度Se，区间宽度随离散程度的增大而增大。</p></li><li><p>样本容量，区间宽度随样本容量的增大而减小。</p></li><li><p>X0与X均值之间的差异，随差异程度的增大而增大。</p></li></ul><h3 id="回归直线的拟合优度">回归直线的拟合优度</h3><h4 id="概念">概念</h4><ol><li>离差：每个观测值与平均值之间的差异</li><li>变差：每个观测值与回归直线的差异</li></ol><p>回归直线与各个观测点的接近程度称为回归直线对数据的拟合优度。</p><h4 id="相关指标">相关指标</h4><ul><li>总平方和（SST）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>T</mi><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">SST=\sum(y-\overline y)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">SST</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li><li>回归平方和（SSR）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>R</mi><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>−</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">SSR=\sum(\hat y-\overline y)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">SSR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li><li>残差平方和（SSE）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>S</mi><mi>E</mi><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">SSE=\sum(y-\hat y)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">SSE</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li></ul><p>总平方和可以分解为残差平方和、回归平方和两部分：SST=SSE+SSR</p><ul><li>SST反映因变量的n个观察值与其均值的<strong>总离差</strong></li><li>SSR反映了y的总变差中，由于x与y的线性关系引起的y变化的部分</li><li>SSE反映了除了x对y的线性影响以外的其他因素对y变差的作用，<strong>是不能用回归直线解释的y的变差部分</strong></li></ul><h4 id="判定系数">判定系数</h4><p><strong>回归平方和占总平方的比例</strong>，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>表示，其值在0到1之间，被称为<strong>决定系数</strong>，用于判定回归直线的拟合优度。</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">R^2=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>：说明y的变化与x无关，x完全无助于解释y的变差</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R^2=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>：说明残差平方和为0（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mtext>与</mtext><mover accent="true"><mi>y</mi><mo>^</mo></mover><mtext>相等</mtext></mrow><annotation encoding="application/x-tex">y与\hat y相等</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">与</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mord cjk_fallback">相等</span></span></span></span>），拟合是完全的，y的变化只与x有关</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mo>∑</mo><mo stretchy="false">(</mo><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>−</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mo>∑</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><mover accent="true"><mi>y</mi><mo stretchy="true">‾</mo></mover><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">R^2=\frac{\sum(\hat y-\overline y)^2}{\sum(y-\overline y)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4271em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord overline"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6306em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-3.5506em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h4 id="显著性检验">显著性检验</h4><p>显著性检验的主要目的是检验估计方程是否真实或较好地反映x和y的关系。</p><p>根据样本数据拟合回归方程时，实际上就已经假定变量x与y之间存在着线性关系，并假定误差项是一个服从正态分布的随机变量，且具有相同的方差。但这些假设是否成立需要检验，显著性检验包括两方面：</p><ul><li>线性关系检验</li><li>回归系数检验</li></ul><p><strong>线性关系检验</strong></p><p>线性关系检验是<strong>检验自变量x和因变量y之间的线性关系是否显著</strong>，或者说，它们之间能否用一个线性模型来表示。将<strong>均方回归（MSR）同均方残差（MSE）加以比较</strong>，应用F检验来分析二者之间的差别是否显著。</p><ul><li>均方回归：回归平方和SSR除以相应的自由度（自变量个数k）</li><li>均方残差：残差平方和SSE除以相应的自由度（n-k-1）</li></ul><p>H0：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\beta1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>所有回归系数与0无显著差异，y与全体x的线性关系不显著</p><p>计算检验统计量F：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>F</mi><mo>=</mo><mfrac><mrow><mi>S</mi><mi>S</mi><mi>R</mi><mi mathvariant="normal">/</mi><mn>1</mn></mrow><mrow><mi>S</mi><mi>S</mi><mi>E</mi><mi mathvariant="normal">/</mi><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>M</mi><mi>S</mi><mi>R</mi></mrow><mrow><mi>M</mi><mi>S</mi><mi>E</mi></mrow></mfrac><mo>∼</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F=\frac{SSR/1}{SSE/n-2}=\frac{MSR}{MSE}\sim F(1,n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">SSE</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">SSR</span><span class="mord">/1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">MSE</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">MSR</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><h4 id="回归系数检验">回归系数检验</h4><p>在回归分析中，我们估计了<strong>每个自变量的回归系数，表示自变量单位变化对因变量的影响</strong>。然而，这些估计值可能受到随机误差的影响，因此我们需要进行假设检验来确定这些估计值是否显著不等于零。</p><p>回归系数检验通常基于 t 检验或 F 检验。通过计算 t 统计量或 F 统计量，我们可以得出结论，<strong>判断回归系数是否显著不为零。如果回归系数显著不为零，我们可以认为自变量对因变量有显著影响；如果回归系数不显著，我们则无法得出自变量对因变量的显著影响结论。</strong></p><p>回归系数显著性检验的目的是通过检验回归系数β的值与0是否有显著性差异，来判断Y与X之间是否有显著性线性关系。若β=0，则总体回归方程中不含X项（即Y不随X变动而变动），因此变量Y与X之间不存在线性关系；若β≠0，说明变量Y与X之间存在显著的线性关系。</p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230903081413397.png" alt="image-20230903081413397" style="zoom:67%;" /><p>计算检验的统计量：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>1</mn></msub><mo>−</mo><msub><mi>β</mi><mn>1</mn></msub></mrow><msub><mi>s</mi><msub><mover accent="true"><mi>β</mi><mo>^</mo></mover><mn>1</mn></msub></msub></mfrac><mo>∼</mo><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=\frac{\hat\beta_1-\beta_1}{s_{\hat\beta_1}}\sim t(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.7827em;vertical-align:-1.1478em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6349em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3743em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord accent mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathnormal mtight" style="margin-right:0.05278em;">β</span></span><span style="top:-2.9634em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord mtight">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:-0.0528em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4618em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9579em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span><span style="top:-3.2634em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1478em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></span></p><h4 id="两个检验的区别">两个检验的区别</h4><p>线性关系的检验是检验自变量和因变量是否可以用线性来表达。</p><p>回归系数检验的作用是评估<strong>回归模型</strong>中的<strong>自变量对因变量的影响是否显著</strong>。它帮助我们确定哪些自变量对因变量有统计上显著的影响，以及它们的影响方向和大小。</p><ul><li>在一元线性回归中，自变量只有一个，线性关系检验与回归系数检验是等价的</li><li>多元回归分析中，这两种检验的意义是不同的。线性关系检验只能用来检验总体回归关系的显著性，而回归系数检验可以对各个回归系数分别进行检验</li></ul><h2 id="多元线性回归">多元线性回归</h2><p>经常遇到某一现象的发展变化取决于几个影响因素的情况，也就是一个因变量和几个自变量有依存关系的情况，这时需用多元线性回归分析。</p><ul><li>多元线性回归分析预测法：通过对两及其以上的自变量与一个因变量的相关性分析，建立预测模型进行预测和控制的方法</li></ul><p><strong>多元线性回归预测模型一般式：</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mi>A</mi><mo>+</mo><msub><mi>B</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>B</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>B</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y=A+B_1x_1+B_2x_2+...+B_nx_n+\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span></span></p><h4 id="调整的多重判定系数">调整的多重判定系数</h4><p>用样本容量n和自变量个数k去修正<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>R</mi><mi>α</mi><mn>2</mn></msubsup><mo>=</mo><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>R</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>×</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">R_{\alpha}^2=1-(1-R^2)\times\frac{n-1}{n-k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>避免增加自变量而高估<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></strong></p><blockquote><p>多元线性回归的其他分析，比如置信度区间分析、回归系数检验、显著性检验等等，都与一元线性回归类似，这里不再赘述。</p></blockquote><h2 id="曲线线性回归分析">曲线线性回归分析</h2><p>直线关系是两变量间最简单的一种关系，曲线回归分析的基本任务是通过两个相关变量x与y的实际观测数据建立曲线回归方程，以揭示x与y间的曲线联系的形式。</p><p>曲线分析最困难和首要工作时确定自变量与因变量的曲线关系的类型，曲线回归分析的基本过程：</p><ol><li>将x或y进行变量转换</li><li>对新变量进行直线回归分析、建立直线回归方程并进行显著性检验和区间估计</li><li>将新变量还原为原变量，由新变量的直线回归方程</li></ol><p>由于曲线回归模型种类繁多，所以没有通用的回归方程可直接使用。但是对于某些特殊的回归模型，可以通过变量代换、取对数等方法对其线性化，然后使用标准方程求解参数，再将参数带回原方程就是所求。</p><h4 id="多重共线性">多重共线性</h4><p>回归模型中两个或两个以上自变量彼此相关的现象。</p><p>多重共线性带来的问题：</p><ul><li>回归系数估计值不稳定性增强</li><li>回归系数假设检验结果不显著等</li></ul><h4 id="多重共线性检验的主要方法">多重共线性检验的主要方法</h4><ul><li>容忍度</li><li>方差膨胀因子（VIF）</li></ul><p><strong>容忍度</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>o</mi><msub><mi>l</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo>−</mo><msubsup><mi>R</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">Tol_i=1-R_i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1111em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-2.453em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>Ri是<strong>解释变量xi与方程中其他解释变量间的负相关系数</strong>。容忍度在0-1之间，越接近0，表示多重共线性越强。</p><p><strong>方差膨胀因子</strong></p><p>方差膨胀因子是容忍度的倒数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mi>I</mi><msub><mi>F</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msubsup><mi>R</mi><mi>i</mi><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">VIF_i=\frac{1}{1-R_i^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2843em;vertical-align:-0.9629em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7959em;"><span style="top:-2.4231em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9629em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>VIF越大，**特别是&gt;=10，**说明解释变量xi与其他解释变量有严重的多重共线性；</p><p>而VIF越接近1，表明解释变量xi和其他变量的多重共线性越弱。</p><h2 id="Python工具包介绍">Python工具包介绍</h2><h3 id="Statsmodels">Statsmodels</h3><p>用于做统计分析，提供用于提供<strong>用于估计许多不同统计模型</strong>以及<strong>进行统计测试和统计数据探索</strong>的类和函数。 每个估算器都有一个广泛的结果统计列表。 对照现有的统计数据包对结果进行测试，以确保它们是正确的。</p><h4 id="一元线性回归">一元线性回归</h4><p>statsmodels.OLS 是 statsmodels.regression.linear_model 的函数，有 4个参数 (endog, exog, missing, hasconst)。</p><p>第一个参数 endog 是回归模型中的因变量 y(t), 是1-d array 数据类型。</p><p>第二个输入 exog 是自变量 x0(t),x1(t),…,xm(t)，是(m+1)-d array 数据类型。<br>　　需要注意的是，statsmodels.OLS 的回归模型没有常数项，其形式为：<br>　　y = B<em>X + e = β0</em>x0 + β1*x1 + e, x0 = [1,…1]<br>　　而之前导入的数据 (yTest，x1) 并不包含 x0，因此需要在 x1 左侧增加一列截距列 x0=[1,…1]，将自变量矩阵转换为 X = (x0, x1)。函数 sm.add_constant() 实现的就是这个功能。<br>　　参数 missing 用于数据检查, hasconst 用于检查常量，一般情况不需要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> statsmodels.sandbox.regression.predstd <span class="keyword">import</span> wls_prediction_std</span><br><span class="line"><span class="comment"># 一元线性回归</span></span><br><span class="line"><span class="comment"># 1.产生样本测试数据</span></span><br><span class="line">nsample = <span class="number">100</span>  <span class="comment"># 样本容量</span></span><br><span class="line">x1 = np.linspace(<span class="number">0</span>, <span class="number">10</span>, nsample)  <span class="comment"># 产生步长为10的，0到100的线性随机数</span></span><br><span class="line">yTrue = <span class="number">2.36</span> + <span class="number">1.58</span> * x1  <span class="comment"># 模拟真实的直线</span></span><br><span class="line">e = np.random.normal(size=nsample)  <span class="comment"># 产生正态分布的误差</span></span><br><span class="line">ySample = yTrue + e  <span class="comment"># 产生模型数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.进行线性回归拟合</span></span><br><span class="line">X = sm.add_constant(x1)  <span class="comment"># 添加截距列</span></span><br><span class="line">model = sm.OLS(ySample, X)  <span class="comment"># 建立最小二乘模型</span></span><br><span class="line">results = model.fit()  <span class="comment"># 返回拟合结果</span></span><br><span class="line">yFit = results.fittedvalues  <span class="comment"># 获取拟合y值</span></span><br><span class="line">prstd, ivLow, ivUp = wls_prediction_std(results)  <span class="comment"># 返回标准差和置信区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.数据展示</span></span><br><span class="line"><span class="built_in">print</span>(results.summary())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOLS model: Y = b0 + b1*x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Parameters: &quot;</span>, results.params)  <span class="comment"># 输出拟合的系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.画图：原始数据点、拟合曲线、置信区间</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax.plot(x1, ySample, <span class="string">&#x27;o&#x27;</span>, label=<span class="string">&quot;data&quot;</span>)  <span class="comment"># 原始数据</span></span><br><span class="line">ax.plot(X, yFit, <span class="string">&#x27;r-&#x27;</span>, label=<span class="string">&quot;OLS&quot;</span>)  <span class="comment"># 拟合曲线</span></span><br><span class="line">ax.plot(x1, ivLow, <span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;lowConf&#x27;</span>)  <span class="comment"># 95%置信区间下限</span></span><br><span class="line">ax.plot(x1, ivUp, <span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;upConf&#x27;</span>)  <span class="comment"># 95%置信区间上限</span></span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)  <span class="comment"># 显示图例</span></span><br><span class="line">plt.title(<span class="string">&quot;OLS liner regression&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶回归</span></span><br><span class="line"><span class="comment"># y = 5 + 2X + 3X^2</span></span><br><span class="line">nsample = <span class="number">50</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, nsample)</span><br><span class="line">X = np.column_stack((x, x**<span class="number">2</span>))</span><br><span class="line">X = sm.add_constant(X)  <span class="comment"># 至此，X第一列为1，第二列为X，第三列为X^2</span></span><br><span class="line"><span class="comment"># 构造beta</span></span><br><span class="line">beta = np.array([<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 误差，正态分布</span></span><br><span class="line">e = np.random.normal(size=nsample)</span><br><span class="line"><span class="comment"># 产生y的真实值</span></span><br><span class="line">y = np.dot(X, beta)+e</span><br><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line">model = sm.OLS(y, X)</span><br><span class="line">results = model.fit()</span><br><span class="line">results.params</span><br><span class="line"><span class="built_in">print</span>(results.summary())</span><br><span class="line"><span class="comment"># 画图展示结果</span></span><br><span class="line">y_fitted = results.fittedvalues</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">ax.plot(x, y_fitted, <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&#x27;OLS&#x27;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>Statsmodels进行线性回归分析的输出结果非常丰富，results.summary()返回了回归分析的摘要。</p><p>摘要内容页非常丰富，这里着重讨论一些结果，在summary中间段落。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==============================================================================</span><br><span class="line">                 coef    std err          t      P&gt;|t|      [<span class="number">0.025</span>      <span class="number">0.975</span>]</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">const          <span class="number">2.4669</span>      <span class="number">0.186</span>     <span class="number">13.230</span>      <span class="number">0.000</span>       <span class="number">2.097</span>       <span class="number">2.837</span></span><br><span class="line">x1             <span class="number">1.5883</span>      <span class="number">0.032</span>     <span class="number">49.304</span>      <span class="number">0.000</span>       <span class="number">1.524</span>       <span class="number">1.652</span></span><br><span class="line">==============================================================================</span><br></pre></td></tr></table></figure><ul><li>coef：回归系数，即模型参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>β</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\beta_0,\beta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0528em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…的估计值</li><li>std err：标准差，方差的算数平方和，反映样本数据值与回归模型估计值之间的平均差异程度</li><li>t：t统计量，等于回归系数除以标准差，<strong>用于对每个回归系数分别进行显著性检验</strong>，如果某个自变量x的影响不明显，意味着可以从模型中剔除这个变量</li><li>P>\abs{t}：t检验的P值(Prob(t-Stastic))，反映每个自变量与因变量的<strong>相关性假设的显著性</strong>，如果 p&lt;0.05，可以理解为在0.05的显著性水平下变量xi与y存在回归关系，具有显著性</li><li><strong>[0.025,0.975]</strong>：回归系数的置信区间（Confidence interval）的下限、上限，某个回归系数的置信区间以 95%的置信度包含该回归系数 。注意并不是指样本数据落在这一区间的概率为 95%</li><li><strong>R-squared</strong>：R方判定系数（Coefficient of determination），表示所有自变量对因变量的联合的影响程度，用于度量回归方程拟合度的好坏，越接近于 1说明拟合程度越好</li><li><strong>F-statistic</strong>：F 统计量（F-Statistic），用于对整体回归方程进行显著性检验，检验所有自变量在整体上对因变量的影响是否显著</li></ul><h4 id="高阶回归-一元高阶回归，2阶以上">高阶回归(一元高阶回归，2阶以上)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高阶回归</span></span><br><span class="line"><span class="comment"># y = 5 + 2X + 3X^2</span></span><br><span class="line">nsample = <span class="number">50</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, nsample)</span><br><span class="line">X = np.column_stack((x, x**<span class="number">2</span>))</span><br><span class="line">X = sm.add_constant(X)  <span class="comment"># 至此，X第一列为1，第二列为X，第三列为X^2</span></span><br><span class="line"><span class="comment"># 构造beta</span></span><br><span class="line">beta = np.array([<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 误差。正态分布</span></span><br><span class="line">e = np.random.normal(size=nsample)</span><br><span class="line"><span class="comment"># 产生y的真实值</span></span><br><span class="line">y = np.dot(X, beta)+e</span><br><span class="line"><span class="comment"># 最小二乘法</span></span><br><span class="line">model = sm.OLS(y, X)</span><br><span class="line">results = model.fit()</span><br><span class="line">results.params</span><br><span class="line">results.summary()</span><br><span class="line"><span class="comment"># 画图展示结果</span></span><br><span class="line">y_fitted = results.fittedvalues</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;o&#x27;</span>, label=<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">ax.plot(x, y_fitted, <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&#x27;OLS&#x27;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="附录：回归结果的详细说明">附录：回归结果的详细说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Dep.Variable: y 因变量</span><br><span class="line">Model：OLS 最小二乘模型</span><br><span class="line">Method: Least Squares 最小二乘</span><br><span class="line">No. Observations: 样本数据的数量</span><br><span class="line">Df Residuals：残差自由度(degree of freedom of residuals)</span><br><span class="line">Df Model：模型自由度(degree of freedom of model)</span><br><span class="line">Covariance Type：nonrobust 协方差阵的稳健性</span><br><span class="line">R-squared：R 判定系数</span><br><span class="line">Adj. R-squared: 修正的判定系数</span><br><span class="line">F-statistic： 统计检验 F 统计量</span><br><span class="line">Prob (F-statistic): F检验的 P值</span><br><span class="line">Log likelihood: 对数似然</span><br><span class="line"></span><br><span class="line">coef：自变量和常数项的系数，b1,b2,...bm,b0</span><br><span class="line">std err：系数估计的标准误差</span><br><span class="line">t：统计检验 t 统计量</span><br><span class="line">P&gt;|t|：t 检验的 P值</span><br><span class="line">[0.025, 0.975]：估计参数的 95%置信区间的下限和上限</span><br><span class="line">Omnibus：基于峰度和偏度进行数据正态性的检验</span><br><span class="line">Prob(Omnibus)：基于峰度和偏度进行数据正态性的检验概率</span><br><span class="line">Durbin-Watson：检验残差中是否存在自相关</span><br><span class="line">Skewness：偏度，反映数据分布的非对称程度</span><br><span class="line">Kurtosis：峰度，反映数据分布陡峭或平滑程度</span><br><span class="line">Jarque-Bera(JB)：基于峰度和偏度对数据正态性的检验</span><br><span class="line">Prob(JB)：Jarque-Bera(JB)检验的 P值。</span><br><span class="line">Cond. No.：检验变量之间是否存在精确相关关系或高度相关关系。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 预测模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】通用技能-3. 数据降维</title>
      <link href="/2023/08/20/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-3.%20%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4/"/>
      <url>/2023/08/20/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-3.%20%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h1>数据降维</h1><h2 id="简介">简介</h2><p>主成分分析（Principal Components Analysis, PCA）是一种数据降维技术，通过正交变换将一组高位变量转换为较少的彼此独立、互不相关的变量，从而减少数据的维数。</p><h2 id="数据的降维">数据的降维</h2><h3 id="为什么要进行数据的降维">为什么要进行数据的降维</h3><p>数据降维的好处是以略低的精度换取问题的优化。</p><p>由于各种变量都是对同一事物的反映，<strong>变量之间经常会存在一定的相关性</strong>，这就造成大量的信息重复、重叠，有时会淹没甚至扭曲事物的真正特征与内在规律。我们希望数据分析中涉及的变量较少，而得到的信息量又较多。这就需要<strong>通过降维方法，在减少需要分析的变量数量的同时，尽可能多的保留众多原始变量所包含的有效信息</strong>。</p><p>变量之间具有一定的相关关系，意味着相关变量所反映的信息有一定程度的重叠，就有可能用较少的综合指标聚合、反映众多原始变量所包含的全部信息或主要信息。</p><p>因此，需要<strong>研究特征变量之间的相关性、相似性</strong>，以减少特征变量的数量，便于分析影响系统的主要因素。</p><p>降维方法可以从事物之间错综复杂的关系中找出一些主要因素，从而能有效利用大量统计数据进行定量分析，解释变量之间的内在关系，得到对事物特征及其发展规律的一些深层次的启发。</p><h3 id="常用的降维思想和方法">常用的降维思想和方法</h3><p>降维的数学本质是将高维的特征空间映射到低纬的特征空间，有线性映射和非线性映射两类。</p><p>线性映射方法主要有：主成分分析（PCA）和线性判别函数（LDA）</p><ul><li>主成分分析：按照均方误差损失最小化原则，将高维原始空间变换到低维特征向量空间。</li><li>线性判别函数：向线性判别超平面的法向量上投影，使得区分度最大，高内聚、低耦合</li></ul><p>非线性映射方法主要有：</p><ul><li><p>基于核的非线性降维，将高纬向量的内积抓换位低纬的核函数表示</p><ol><li>核主成分分析（KPCA）</li><li>核线性判别函数（KLDA）</li></ol></li><li><p>二维化和张量化，将数据映射到二维空间上</p><ol><li>二维主成分分析（2DPCA）</li><li>二维线性判别分析（2DLDA）</li><li>二维典型相关分析（2DCCA）</li></ol></li><li><p>流形学习方法，从高维采样数据中恢复低纬流形结构并求出相应的嵌入映射</p><ol><li>等距映射（ISOMap）</li><li>拉普拉斯特征映射（LE）</li><li>局部线性嵌入（LDD）</li></ol></li></ul><p><strong>总之，非线性映射的思想和算法与神经网络是相通的</strong></p><h3 id="SKlearn中的降维分析方法">SKlearn中的降维分析方法</h3><ul><li>主成分分析：<ol><li>decomposition.PCA　　主成分分析</li><li>decomposition.IncrementalPCA　　增量主成分分析</li><li>decomposition.KernelPCA　　核主成分分析</li><li>decomposition.SparsePCA　　稀疏主成分分析</li><li>decomposition.MiniBatchSparsePCA　　小批量稀疏主成分分析</li><li>decomposition.TruncatedSVD　　截断奇异值分解</li></ol></li><li>字典学习<ol><li>decomposition.DictionaryLearning　　字典学习</li><li>decomposition.MiniBatchDictionaryLearning　　小批量字典学习</li><li>decomposition.dict_learning　　字典学习用于矩阵分解</li><li>decomposition.dict_learning_online　　在线字典学习用于矩阵分解</li></ol></li><li>因子分析<ol><li>decomposition.FactorAnalysis　　因子分析（FA）</li></ol></li><li>独立成分分析<ol><li>decomposition.FastICA　　快速独立成分分析</li></ol></li><li>非负矩阵分解<ol><li>decomposition.NMF　　非负矩阵分解</li></ol></li><li>隐式狄利克莱分布<ol><li>decomposition.LatentDirichletAllocation　　在线变分贝叶斯算法（隐式狄利克莱分布）</li></ol></li></ul><h2 id="主成分分析方法">主成分分析方法</h2><h3 id="基本原理">基本原理</h3><p>主成分分析是最基础数据降维方法，它只需要特征值分解，就可以对数据进行压缩、去噪，应用十分广泛。</p><p>主成分分析的目的是减少数据集变量数量，同时要保留尽可能多的特征信息；方法是<strong>通过正交变换将原始变量组转换为数量较少的彼此独立的特征变量</strong>，从而减少数据集的维数。</p><p>主成分分析方法的思想是，将高维特征（n维）映射到低维空间（k维）上，新的低维特征是在原有的高维特征基础上<strong>通过线性组合而重构</strong>的，并具有相互正交的特性，即为主成分。</p><p>通过正交变换构造彼此正交的新的特征向量，这些特征向量组成了新的特征空间。将特征向量按特征值排序后，<strong>样本数据集中所包含的全部方差，大部分就包含在前几个特征向量中，其后的特征向量所含的方差很小</strong>。<strong>因此，可以只保留前 k个特征向量，而忽略其它的特征向量，实现对数据特征的降维处理</strong>。</p><h3 id="特点">特点</h3><p>主成分分析方法得到的主成分变量具有几个特点：</p><ol><li>每个主成分变量都是原始变量的线性组合</li><li>主成分的数目大大少于原始变量的数目</li><li>主成分保留了原始变量的绝大多数信息</li><li>各主成分变量之间彼此相互独立</li></ol><h3 id="算法步骤">算法步骤</h3><p>主成分分析的基本步骤是：</p><p>对原始数据归一化处理后求<strong>协方差矩阵</strong>，再<strong>对协方差矩阵求特征向量和特征值</strong>；对特征向量按特征值大小排序后，依次选取特征向量，直到选择的特征向量的方差占比满足要求为止。</p><p>算法的基本流程：</p><ul><li>（1）归一化处理，数据减去平均值；</li><li>（2）通过特征值分解，计算协方差矩阵；</li><li>（3）计算协方差矩阵的特征值和特征向量；</li><li>（4）将特征值从大到小排序；</li><li>（5）依次选取特征值最大的<em>k</em>个特征向量作为主成分，直到其累计方差贡献率达到要求；</li><li>（6）将原始数据映射到选取的主成分空间，得到降维后的数据。</li></ul><p>在算法实现的过程中，SKlearn 工具包针对实际问题的特殊性，又发展了各种改进算法，例如：</p><ul><li>增量主成分分析：针对大型数据集，为了解决内存限制问题，将数据分成多批，通过增量方式逐步调用主成分分析算法，最终完成整个数据集的降维。</li><li>核主成分分析：针对线性不可分的数据集，使用非线性的核函数把样本空间映射到线性可分的高维空间，然后在这个高维空间进行主成分分析。</li><li>稀疏主成分分析：针对主成分分析结果解释性弱的问题，通过提取最能重建数据的稀疏分量， 凸显主成分中的主要组成部分，容易解释哪些原始变量导致了样本之间的差异。</li></ul><h4 id="优点和缺点">优点和缺点</h4><p>主成分分析法的优点：</p><ol><li>仅以方差衡量信息量，不受数据集以外的因素影响；</li><li>各主成分之间正交，可消除原始数据各变量之间的相互影响；</li><li>方法简单，易于实现；</li></ol><p>缺点：</p><ol><li>各个主成分的含义具有模糊，解释性弱，通常只有信息量而无实际含义；</li><li><strong>在样本非正态分布时得到的主成分不是最优的</strong>，因此特殊情况下方差小的成分也可能含有重要信息；</li></ol><h2 id="SKlearn中的主成分分析（PCA）方法">SKlearn中的主成分分析（PCA）方法</h2><h3 id="PCA算法decomposition-PCA">PCA算法decomposition.PCA</h3><p>sklearn.decomposition.PCA类是PCA算法的具体实现。</p><p>官网介绍详见：</p><p><a href="https://scikit-learn.org/stable/modules/decomposition.html#principal-component-analysis-pca">https://scikit-learn.org/stable/modules/decomposition.html#principal-component-analysis-pca</a></p><p><em>sklearn.decomposition.PCA(n_components=None, copy=True, whiten=False)</em></p><blockquote><p>class sklearn.decomposition.PCA(n_components=None, *, copy=True, whiten=False, svd_solver=‘auto’, tol=0.0, iterated_power=‘auto’, random_state=None)</p></blockquote><h4 id="主要参数">主要参数</h4><ul><li><strong>n_components: int,float</strong>　　<strong>n 为正整数，指保留主成分的维数；n 为 (0,1] 范围的实数时，表示主成分的方差和所占的最小阈值。</strong></li><li><strong>whiten：bool, default=False</strong>　　是否对降维后的主成分变量进行归一化。默认值 False。</li><li>svd_solver：{‘auto’, ‘full’, ‘arpack’, ‘randomized’}　　指定奇异值分解SVD的算法。‘full’ 调用 scipy库的 SVD；'arpack’调用scipy库的 sparse SVD；‘randomized’ SKlearn的SVD，<strong>适用于数据量大、变量维度多、主成分维数低的场景。默认值 ‘auto’</strong>。</li></ul><h4 id="主要属性">主要属性</h4><ul><li><strong>components_：</strong> 　　方差最大的 n-components 个主成分</li><li><strong>explained_variance_：</strong>　　各个主成分的方差值</li><li><strong>explained_variance_ratio_：</strong>　　各个主成分的方差值占主成分方差和的比例</li></ul><h4 id="主要方法-函数">主要方法/函数</h4><ul><li><strong>fit(X,y=None)</strong>　　表示用数据 X 训练PCA模型<br>fit() 是scikit-learn中的通用方法，实现训练、拟合的步骤。PCA是无监督学习，y=None。</li><li><strong>fit_transform(X)</strong>　　表示用数据 X 训练PCA模型，并返回降维后的数据</li><li><strong>transform(X)</strong>　　将数据 X 转换成降维后的数据，用训练好的 PCA模型对新的数据集进行降维。</li><li><strong>inverse_transform()</strong>　　将降维后的数据转换成原始数据</li></ul><h4 id="decomposition-PCA使用例程">decomposition.PCA使用例程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA  <span class="comment"># 导入 sklearn.decomposition.PCA 类</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># Youcans， XUPT</span></span><br><span class="line"></span><br><span class="line">X = np.array([[-<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">2</span>, -<span class="number">1</span>], [-<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line">modelPCA = PCA(n_components=<span class="number">2</span>)  <span class="comment"># 建立模型，设定保留主成分数 K=2</span></span><br><span class="line">modelPCA.fit(X)  <span class="comment"># 用数据集 X 训练 模型 modelPCA</span></span><br><span class="line"><span class="built_in">print</span>(modelPCA.n_components_)  <span class="comment"># 返回 PCA 模型保留的主成份个数</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(modelPCA.explained_variance_ratio_)  <span class="comment"># 返回 PCA 模型各主成份占比</span></span><br><span class="line"><span class="comment"># [0.9924 0.0075]  # print 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(modelPCA.singular_values_) <span class="comment"># 返回 PCA 模型各主成份的奇异值</span></span><br><span class="line"><span class="comment"># [6.3006 0.5498]  # print 显示分类结果</span></span><br><span class="line"></span><br><span class="line">X = np.array([[-<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">2</span>, -<span class="number">1</span>], [-<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>]])</span><br><span class="line">modelPCA2 = PCA(n_components=<span class="number">0.9</span>) <span class="comment"># 建立模型，设定主成份方差占比 0.9</span></span><br><span class="line"><span class="comment"># 用数据集 X 训练 模型 modelPCA2，并返回降维后的数据</span></span><br><span class="line">Xtrans = modelPCA2.fit_transform(X)</span><br><span class="line"><span class="built_in">print</span>(modelPCA2.n_components_)  <span class="comment"># 返回 PCA 模型保留的主成份个数</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(modelPCA2.explained_variance_ratio_)  <span class="comment"># 返回 PCA 模型各主成份占比</span></span><br><span class="line"><span class="comment"># [0.9924]  # print 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(modelPCA2.singular_values_)  <span class="comment"># 返回 PCA 模型各主成份占比</span></span><br><span class="line"><span class="comment"># [6.3006]  # print 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(Xtrans)  <span class="comment"># 返回降维后的数据 Xtrans</span></span><br><span class="line"><span class="comment"># [[1.3834], [2.2219], [3.6053], [-1.3834], [-2.2219], [-3.6053]]</span></span><br><span class="line"><span class="comment"># = 关注 Youcans，分享原创系列 https://blog.csdn.net/youcans =</span></span><br></pre></td></tr></table></figure><p>注意：建立模型时，PCA(n_components=2) 中的 n_components为正整数，表示设定保留的主成份维数为 2；PCA(n_components=0.9) 中的 n_components 为 (0,1] 的小数，表示并不直接设定保留的主成份维数，而是设定保留的主成份应满足其方差和占比 &gt;0.9。</p><h3 id="改进算法：增量主成分分析（decomposition-IncrementalPCA）">改进算法：增量主成分分析（decomposition.IncrementalPCA）</h3><p>详细见CSDN博客：<a href="https://blog.csdn.net/youcans/article/details/116662562">https://blog.csdn.net/youcans/article/details/116662562</a></p><h3 id="改进算法：核主成分分析（decomposition-KernelPCA）">改进算法：核主成分分析（decomposition.KernelPCA）</h3><p>对于线性不可分的数据集，使用非线性的核函数可以把样本空间映射到线性可分的高维空间，然后在这个高维空间进行主成分分析。</p><p>本例程使用了SKlearn内置的数据集.datasets.oad_iris，并给出了PCA算法与三种核函数的KernelPCA算法的对比。不同算法的降维后映射到二维平面的结果有差异，进一步的讨论已经超出本文的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Demo of sklearn.decomposition.KernelPCA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  <span class="comment"># Youcans， XUPT</span></span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> KernelPCA, PCA</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">X, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(X))  <span class="comment"># &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">modelPCA = PCA(n_components=<span class="number">2</span>)  <span class="comment"># 建立模型，设定保留主成分数 K=2</span></span><br><span class="line">Xpca = modelPCA.fit_transform(X)  <span class="comment"># 用数据集 X 训练 模型 modelKPCA</span></span><br><span class="line"></span><br><span class="line">modelKpcaP = KernelPCA(n_components=<span class="number">2</span>, kernel=<span class="string">&#x27;poly&#x27;</span>) <span class="comment"># 建立模型，核函数：多项式</span></span><br><span class="line">XkpcaP = modelKpcaP.fit_transform(X)  <span class="comment"># 用数据集 X 训练 模型 modelKPCA</span></span><br><span class="line"></span><br><span class="line">modelKpcaR = KernelPCA(n_components=<span class="number">2</span>, kernel=<span class="string">&#x27;rbf&#x27;</span>) <span class="comment"># 建立模型，核函数：径向基函数</span></span><br><span class="line">XkpcaR = modelKpcaR.fit_transform(X)  <span class="comment"># 用数据集 X 训练 模型 modelKPCA</span></span><br><span class="line"></span><br><span class="line">modelKpcaS = KernelPCA(n_components=<span class="number">2</span>, kernel=<span class="string">&#x27;cosine&#x27;</span>) <span class="comment"># 建立模型，核函数：余弦函数</span></span><br><span class="line">XkpcaS = modelKpcaS.fit_transform(X)  <span class="comment"># 用数据集 X 训练 模型 modelKPCA</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">ax4 = fig.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> np.unique(y):</span><br><span class="line">    position = y == label</span><br><span class="line">    ax1.scatter(Xpca[position, <span class="number">0</span>], Xpca[position, <span class="number">1</span>], label=<span class="string">&#x27;target=%d&#x27;</span> % label)</span><br><span class="line">    ax1.set_title(<span class="string">&#x27;PCA&#x27;</span>)</span><br><span class="line">    ax2.scatter(XkpcaP[position, <span class="number">0</span>], XkpcaP[position, <span class="number">1</span>], label=<span class="string">&#x27;target=%d&#x27;</span> % label)</span><br><span class="line">    ax2.set_title(<span class="string">&#x27;kernel= Poly&#x27;</span>)</span><br><span class="line">    ax3.scatter(XkpcaR[position, <span class="number">0</span>], XkpcaR[position, <span class="number">1</span>], label=<span class="string">&#x27;target=%d&#x27;</span> % label)</span><br><span class="line">    ax3.set_title(<span class="string">&#x27;kernel= Rbf&#x27;</span>)</span><br><span class="line">    ax4.scatter(XkpcaS[position, <span class="number">0</span>], XkpcaS[position, <span class="number">1</span>], label=<span class="string">&#x27;target=%d&#x27;</span> % label)</span><br><span class="line">    ax4.set_title(<span class="string">&#x27;kernel= Cosine&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">&quot;KernalPCA (Youcans,XUPT)&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># = 关注 Youcans，分享原创系列 https://blog.csdn.net/youcans =</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 通用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】通用技能-2. 数据可视化</title>
      <link href="/2023/08/19/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-2.%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2023/08/19/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-2.%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1>数据可视化</h1><h2 id="前言">前言</h2><p>Python中数据可视化的包很多，最简单易学的就是matplotlib，而且很多库也是基于matplotlib进行二次开发的。本文会不断更新学到的可视化工具包以及相关的使用技巧。</p><h2 id="Seaborn绘图工具包">Seaborn绘图工具包</h2><p>Seaborn是在matplotlib上构建的，<strong>支持Scipy和Statamodels的统计模型</strong>可视化，可以实现：</p><ul><li>赏心悦目的内置主题以及颜色主题</li><li>展示和比较一维变量、二维变量以及各个变量的分布情况</li><li>可视化   线性回归模型中的独立变量和关联变量</li><li>可视化   时间序列，展示不确定性</li><li>复杂的可视化，如在分割区域制图</li></ul><p><strong>Seaborn 绘图工具包以数据可视化为中心来挖掘与理解数据，本身就带有一定的统计回归功能，而且简单好用，特别适合进行定性分析、初步评价。</strong></p><p>常用的Seaborn图形：</p><ul><li>带拟合直线的直方图(displot)</li><li>箱线图(boxplot)</li><li>散点图(scatterplot)</li><li>回归图(regplot)</li></ul><p>实际上，这些图形用 StatsModels Graphics、Matplotlib 也可以绘制，估计任何绘图包都可以实现。那么，为什么还要推荐 Seaborn 工具包，把这些图归入 Seaborn 的实例呢？我们来看看实现的例程就明白了：简单，便捷，舒服。不需要数据准备和变换处理，直接调用变量数据，自带回归功能；不需要复杂的参数设置，直接给出舒服的图形，自带图形风格设计。</p><h4 id="多元回归案例分析">多元回归案例分析</h4><p><strong>问题描述</strong></p><p>数据文件中收集了 30个月本公司牙膏销售量、价格、广告费用及同期的市场均价。<br>　　（1）分析牙膏销售量与价格、广告投入之间的关系，建立数学模型；<br>　　（2）估计所建立数学模型的参数，进行统计分析；<br>　　（3）利用拟合模型，预测在不同价格和广告费用下的牙膏销售量。</p><ul><li>本问题及数据来自：姜启源、谢金星，数学模型（第 3版），高等教育出版社。</li></ul><p><strong>问题的分析过程</strong></p><ol><li>找特征变量，由于本题直接给出了特征变量——销售价格、市场均价、广告费…</li><li>分析特征变量对目标变量的影响，选择能够影响目标变量的特征变量，或者对特征变量进行变换（取对数、平方等等）</li><li>根据(2)选择的特征变量进行线性回归</li></ol><p><strong>数据分析处理</strong></p><ol><li><p>观察数据分布特征</p><p>本案例的数据量比较小，数据完整规范，实际上并不需要进行数据探索和数据清洗，不过可以看一下数据的分布特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="comment">#数据探索：分布特征</span></span><br><span class="line">sns.histplot(df[<span class="string">&quot;price&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">0</span>, <span class="number">0</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;average&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">0</span>, <span class="number">1</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;advertise&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">1</span>, <span class="number">0</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;difference&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">1</span>, <span class="number">1</span>], kde=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>观察数据间的相关性</p><p>既然将所有特征变量都作为自变量直接进行线性回归不科学，就要先对每个自变量和因变量的关系进行考察。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig2, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;price&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;average&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;advertise&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;difference&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>通过相关性图发现sales-price和average的数据点很分散，与回归直线差距太大，相关性很小。</p><p>sales-advertise，sales-difference的线性度较高，因此可以把advertise和difference作为自变量进行建模。</p></li><li><p>模拟与拟合</p><ul><li>模型1：选择价格差，广告费作为自变量进行线性回归</li><li>模型2：选择价格差，广告费以及广告费的平方作为自变量进行高阶回归</li></ul></li><li><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Seaborn工具包绘图，它是在Matplotlib上构建的，支持Scipy和Statamodels的统计建模可视化</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> statsmodels.sandbox.regression.predstd <span class="keyword">import</span> wls_prediction_std</span><br><span class="line">filePath = <span class="string">&#x27;./data.txt&#x27;</span></span><br><span class="line">df = pd.read_table(filePath, sep=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 先看一下数据的分布特点，看起来都和正态分布有点差距，没看出什么特色</span></span><br><span class="line">fig1, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">sns.histplot(df[<span class="string">&quot;price&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">0</span>, <span class="number">0</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;average&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">0</span>, <span class="number">1</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;advertise&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">1</span>, <span class="number">0</span>], kde=<span class="literal">True</span>)</span><br><span class="line">sns.histplot(df[<span class="string">&quot;difference&quot;</span>].tolist(),</span><br><span class="line">             ax=axes[<span class="number">1</span>, <span class="number">1</span>], kde=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 分析各个变量与Y的相关性</span></span><br><span class="line">fig2, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;price&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;average&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;advertise&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">sns.regplot(x=df[<span class="string">&#x27;difference&#x27;</span>], y=df[<span class="string">&#x27;sales&#x27;</span>], ax=axes[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 进行回归</span></span><br><span class="line">y = df[<span class="string">&#x27;sales&#x27;</span>]</span><br><span class="line">x0 = np.ones(df.shape[<span class="number">0</span>])</span><br><span class="line">x1 = df[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">x2 = df[<span class="string">&#x27;average&#x27;</span>]</span><br><span class="line">x3 = df[<span class="string">&#x27;advertise&#x27;</span>]</span><br><span class="line">x4 = df[<span class="string">&#x27;difference&#x27;</span>]</span><br><span class="line">x5 = x3**<span class="number">2</span></span><br><span class="line">x6 = x1*x2  <span class="comment"># 考察两个变量的相互作用</span></span><br><span class="line"><span class="comment"># model1: Y = b0 + b1*x1 + b2*x2 + ... + e</span></span><br><span class="line">X1 = np.column_stack((x0, x1, x2, x3, x4))</span><br><span class="line">Model1 = sm.OLS(y, X1)</span><br><span class="line">result1 = Model1.fit()</span><br><span class="line">yFit1 = result1.fittedvalues</span><br><span class="line">prstd, ivlow, ivup = wls_prediction_std(result1)  <span class="comment"># 置信度区间</span></span><br><span class="line"><span class="built_in">print</span>(result1.summary())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nModel1: Y = b0 + b1*x1 + b2*x2 + ... + e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nParameters: &quot;</span>, result1.params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># model2: Y = b0 + b1*x1 + b2*x2 + b3*x2**2 + e</span></span><br><span class="line">X2 = np.column_stack((x0, x3, x4, x5))</span><br><span class="line">Model2 = sm.OLS(X2, y)</span><br><span class="line">result2 = Model1.fit()</span><br><span class="line">yFit2 = result2.fittedvalues</span><br><span class="line">prestd2, ivlow2, ivup2 = wls_prediction_std(result2)</span><br><span class="line"><span class="built_in">print</span>(result2.summary())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nModel2: Y = b0 + b1*x1 + b2*x2 + b3*x2**2 + e&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nParameters: &quot;</span>, result2.params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), y, <span class="string">&#x27;b-&#x27;</span>, label=<span class="string">&quot;sample&quot;</span>)  <span class="comment"># 样本数据</span></span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), yFit1, <span class="string">&#x27;r-&#x27;</span>, label=<span class="string">&quot;Fitting&quot;</span>)</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), ivup2, <span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>, label=<span class="string">&#x27;ConfR&#x27;</span>)</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), ivlow2, <span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Regression analysis with sales of toothpaste&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;period&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;sales&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 通用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】通用技能-1. 模型数据的准备</title>
      <link href="/2023/08/18/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-1.%20%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%86%E5%A4%87/"/>
      <url>/2023/08/18/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD-1.%20%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1>模型数据的准备</h1><h2 id="前言">前言</h2><p>数学建模中我们会遇到很多问题，会采用很多不同的模型，但是无论是回归分析问题还是优化类问题，我们得到的数据都是保存在文件中的，为了获取数据，我们首先就要从文件中读取数据，然后再对数据进行拆分、合并、转化等操作。</p><p>数据文件的格式很多，最常用的是.csv、.xls、.xlsx以及.txt，甚至sql数据库文件的读取。</p><h2 id="读取数据">读取数据</h2><h4 id="pandas工具包读取文件">pandas工具包读取文件</h4><ol><li><p>读取.csv文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;./example.csv&quot;</span>,engine=<span class="string">&quot;python&quot;</span>,encoding=<span class="string">&quot;utf_8_sig&quot;</span>)</span><br><span class="line"><span class="comment">#engine=&quot;python&quot;允许处理中文路径，encoding=&quot;utf_8_sig&quot;允许读取中文数据</span></span><br></pre></td></tr></table></figure></li><li><p>读取.xls文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">&quot;./example.xls&quot;</span>,sheetname=<span class="string">&quot;Sheet1&quot;</span>,header=<span class="number">0</span>,encoding=<span class="string">&quot;utf_8_sig&quot;</span>)</span><br><span class="line"><span class="comment">#header=None 表示首行为标题行，第一行是数据</span></span><br></pre></td></tr></table></figure></li><li><p>读取.txt文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_table(<span class="string">&quot;./example.txt&quot;</span>,sep=<span class="string">&quot;\t&quot;</span>,header=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#sep表示分隔符，header=None表示无标题行，第一行是数据</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数据的拆分与合并">数据的拆分与合并</h2><p>有些模型的数据量比较大，比如统计回归、神经网络等等，必要时需要对文件进行拆分或者合并。用pandas处理也比较方便。</p><ol><li><p>将Excel文件分割为多个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将Excel文件分割为多个文件</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dfData = pd.read_excel(<span class="string">&quot;./example.xls&quot;</span>,sheetname=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line">nRow,nCol = dfData.shape<span class="comment">#获取数据的行列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(nRow/<span class="number">10000</span>)+<span class="number">1</span>):</span><br><span class="line">    saveData = dfData.iloc[i*<span class="number">10000</span>+<span class="number">1</span>:(i+<span class="number">1</span>)*<span class="number">10000</span>+<span class="number">1</span>,:]<span class="comment">#每隔10000行分割一次</span></span><br><span class="line">    fileName = <span class="string">&#x27;./example_&#123;&#125;.xls&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i))</span><br><span class="line">    saveData.to_excel(fileName,sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>将多个Exel合并成一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将多个Excel文件合并成一个文件</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#多个Excel进行合并</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>):</span><br><span class="line">    fileName=<span class="string">&#x27;./example_&#123;&#125;.xls&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(i))</span><br><span class="line">    dfNew = pd.read_excel(fileName)</span><br><span class="line">    dfData = pd.concat([dfData,dfNew])</span><br><span class="line">dfData.to_excel(<span class="string">&#x27;./example&#x27;</span>,index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据预处理">数据预处理</h2><p>在实际工作中，在开始建立模型和拟合分析之前，还要对原始数据进行数据预处理（data preprocessing）。</p><p>主要包括：缺失值处理、重复数据处理、异常值处理、变量格式转换、训练集划分、数据的规范化、归一化等。</p><ol><li><p>缺失值处理</p><p>导入数据存在缺失值是经常发生的，最简单的处理方式是删除缺失数据行。使用pandas中的**.dropna()**删除含有缺失值的行或者列，也可对特定的列进行缺失值删除处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfNew = dfData.dropna(axis = <span class="number">0</span>)<span class="comment">#删除含有缺失值的行</span></span><br></pre></td></tr></table></figure><p><strong>有时也会对缺失值进行插值填充，或者替换缺失值，详细见另外的章节：插值处理</strong></p></li><li><p>重复数据处理</p><p>对于重复数据，通常会删除重复行。使用pandas中的**.duplicated()<strong>可以查询重复数据的内容，使用</strong>.drop_duplicated()**可以删除重复数据，页可以对指定的数据列进行去重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfNew = dfData.drop_duplicates(inplace=<span class="literal">True</span>)<span class="comment">#删除重复的数据行</span></span><br></pre></td></tr></table></figure></li><li><p>异常值处理</p><p>数据中可能包括异常值，是指一个样本中的数值明显偏离样本集中其他样本的观测值，也称为离群点。</p><p><strong>异常值可以通过箱线图、正态分布图进行识别，也可以通过回归、聚类建模进行识别。</strong></p><p>箱线图技术是利用数据的分位数识别其中的异常点。箱线图分析具体详情见其他章节。笼统地说，就是通过观察箱型图，查看整体的异常情况，进而发现异常值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfData.boxplot()</span><br></pre></td></tr></table></figure><p>对于异常值通常不易直接删除，需要结合具体情况进行考虑和处理。使用pandas中的**.drop()**可以直接删除异常值数据行，或者使用判断条件来判定并且删除异常值数据行。</p></li></ol><h2 id="Python例程">Python例程</h2><h3 id="问题描述">问题描述</h3><p>数据文件中收集了 30个月本公司牙膏销售量、价格、广告费用及同期的市场均价。<br>　　（1）分析牙膏销售量与价格、广告投入之间的关系，建立数学模型；<br>　　（2）估计所建立数学模型的参数，进行统计分析；<br>　　（3）利用拟合模型，预测在不同价格和广告费用下的牙膏销售量。</p><p>需要说明的是，本文例程并不是问题最佳的求解方法和结果，只是使用该问题及数据示范读取数据文件和数据处理的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 数据读取</span></span><br><span class="line">readPath = <span class="string">&#x27;./data.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> readPath[-<span class="number">4</span>:] == <span class="string">&quot;.csv&quot;</span>:</span><br><span class="line">        dfOpenFile = pd.read_csv(readPath, header=<span class="number">0</span>, sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> readPath[-<span class="number">4</span>:] == <span class="string">&quot;.xls&quot;</span> <span class="keyword">or</span> readPath[-<span class="number">5</span>:] == <span class="string">&quot;.xlsx&quot;</span>:</span><br><span class="line">        dfOpenFile = pd.read_excel(readPath, header=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> readPath[-<span class="number">4</span>:] == <span class="string">&quot;.txt&quot;</span>:</span><br><span class="line">        dfOpenFile = pd.read_table(readPath, sep=<span class="string">&quot; &quot;</span>, header=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n数据读取失败！\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">dfData = dfOpenFile.dropna()  <span class="comment"># 删除缺失值</span></span><br><span class="line"><span class="built_in">print</span>(dfData.dtypes)</span><br><span class="line"><span class="built_in">print</span>(dfData.shape)  <span class="comment"># 查看行数和列数</span></span><br><span class="line"><span class="built_in">print</span>(dfData.columns)</span><br><span class="line"><span class="comment"># 准备建模</span></span><br><span class="line">y = dfData[<span class="string">&#x27;sales&#x27;</span>]  <span class="comment"># 根据因变量列名建立因变量数据集</span></span><br><span class="line">x0 = np.ones(dfData.shape[<span class="number">0</span>])</span><br><span class="line">x1 = dfData[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">x2 = dfData[<span class="string">&#x27;average&#x27;</span>]</span><br><span class="line">x3 = dfData[<span class="string">&#x27;advertise&#x27;</span>]</span><br><span class="line">x4 = dfData[<span class="string">&#x27;difference&#x27;</span>]</span><br><span class="line">X = np.column_stack((x0, x1, x2, x3, x4))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立模型与参数估计</span></span><br><span class="line">model = sm.OLS(y, X)  <span class="comment"># 建立最小二乘模型</span></span><br><span class="line">results = model.fit()  <span class="comment"># 获取拟合模型</span></span><br><span class="line">yFit = results.fittedvalues  <span class="comment"># 返回拟合值</span></span><br><span class="line"><span class="built_in">print</span>(results.summary)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nOLS model : Y = b0x0 + b1x1 + ... + bmxm&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Parameters : &quot;</span>, results.params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(y)), y, <span class="string">&#x27;bo&#x27;</span>, label=<span class="string">&quot;sample&quot;</span>)</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="built_in">len</span>(yFit)), yFit, <span class="string">&#x27;r--&#x27;</span>, label=<span class="string">&quot;predict&quot;</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 通用技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】评价模型-5. TOPSIS优劣解距离法</title>
      <link href="/2023/08/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-5.%20TOPSIS/"/>
      <url>/2023/08/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-5.%20TOPSIS/</url>
      
        <content type="html"><![CDATA[<h1>TOPSIS优劣解距离法</h1><h2 id="引例">引例</h2><p>对大学评分，经费越多，评分排名越高。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802192308907.png" alt="image-20230802192308907"></p><p>现象：经费越高的，评分结果越小了。</p><p><strong>为了让最后结果的大小正向直观反映原数据的相对大小，可以用距离作为参考来进行评分。</strong></p><p><strong>用距离打分：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802192541972.png" alt="image-20230802192541972"></p><p>思想原理：用距离打分</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802192632702.png" alt="image-20230802192632702"></p><h2 id="TOPSIS优劣解距离法步骤">TOPSIS优劣解距离法步骤</h2><h3 id="数据预处理">数据预处理</h3><h4 id="数据正向化处理">数据正向化处理</h4><ol><li><p>对于极大型数据，无需处理</p></li><li><p><strong>极小型数据</strong>：max-x</p></li><li><p><strong>中间型数据</strong>：（把距离中间值的距离的比较归化到[0,1]区间）</p><p>M=max{|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_i-x_{best}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|}   先用每一项减去最好的一项，再取最大值</p><p>然后再令各个元素  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow><mi>M</mi></mfrac></mrow><annotation encoding="application/x-tex">\widetilde{x}=1-\frac{|x_i-x_{best}|}{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6906em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6906em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span class="svg-align" style="width:calc(100% - 0.0556em);margin-left:0.0556em;top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p><strong>区间型数据</strong>：</p><p>先计算最值到边界的最大距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>a</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo>−</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">M=max\{a-min\{x_i\},max\{x_i\}-b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">}</span></span></span></span></p><p>再令各个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true">~</mo></mover><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>a</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>M</mi></mfrac><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mo>≤</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>b</mi></mrow><mi>M</mi></mfrac><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≥</mo><mi>b</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\widetilde{x_i}=\begin{cases}1-\frac{a-x_i}{M}, x_i\le a\\ 1 ,a\le x_i \le b\\ 1-\frac{x_i-b}{M},x_i \ge b \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8406em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6906em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li></ol><h4 id="数据标准化处理">数据标准化处理</h4><p>数据标准化处理的原因：消除<strong>量纲的影响</strong>。</p><p>下面这张表的数据经过正向化处理，失业率可以反映学校层次、经费也可以反映学校层次，但横向比较后，经费和失业率根本不在一个量级，虽然都能正向反映学校排名情况。</p><p>为了方便数据的观察，我们可以将数据进行标准化处理。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802193515274.png" alt="image-20230802193515274"></p><p><strong>标准化处理的方法：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802193752951.png" alt="image-20230802193752951"></p><h3 id="数据处理——法一：距离法打分">数据处理——法一：距离法打分</h3><p>经过前面的数据预处理，得到标准化数据矩阵，这时我们可以对标准化后的结果进行距离法打分。</p><p>即在每一列对每一个数据都用这个公式进行评分：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">score=\frac{x-min}{max-min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">score</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.259em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8557em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><h3 id="数据处理——法二：用TOPSIS优劣解打分">数据处理——法二：用TOPSIS优劣解打分</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802194308003.png" alt="image-20230802194308003"></p><h3 id="将打分结果进行归一化处理">将打分结果进行归一化处理</h3><p>对所得到的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>列进行归一化，得到最终结果。</p><blockquote><p><strong>归一化、标准化和正向化的区别和联系：</strong></p><ul><li>距离法和标准化都能使结果落到[0,1]区间，但是不能让和为1</li><li>用距离法要确定最大值和最小值，可是有很多数据指标不存在理论上的最大值和最小值，比如GDP增速，所以选取给定数据中的最值即可</li><li>标准化是为了消除量纲的影响</li><li>距离法的集合意义是每个值所占的线段比例</li><li>归一化不仅能将结果化到[0,1]区间，还能使和为1</li></ul></blockquote><h2 id="TOPSIS的作用">TOPSIS的作用</h2><p>TOPSIS充分利用原始数据信息，对各个评价方案进行评估，具有客观性。</p><h2 id="TOPSIS的思想原理">TOPSIS的思想原理</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802195137789.png" alt="image-20230802195137789"></p><h2 id="小结TOPSIS">小结TOPSIS</h2><ol><li>评价矩阵正向化</li><li>评价矩阵标准化（消除量纲影响）</li><li>评价矩阵计算得分（求出未归一化的优劣解），然后归一化处理</li></ol><h2 id="基于熵权法的TOPSIS优劣解距离法">基于熵权法的TOPSIS优劣解距离法</h2><p>如果对多个指标进行打分，并且多个指标有不同的权重，那么如何打分呢？</p><h3 id="确定权重">确定权重</h3><p>客观确定权重，我们可以采用熵权法。</p><h3 id="TOPSIS优劣解距离法-权重">TOPSIS优劣解距离法*权重</h3><p>在计算最大最小距离时，分别乘上对应的权重即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230802195630409.png" alt="image-20230802195630409"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 评价模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】评价模型-4. 灰色关联分析</title>
      <link href="/2023/08/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-4.%20%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-4.%20%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>灰色关联分析（Grey Relation Analysis, GRA）</h1><h2 id="概述">概述</h2><p>灰色关联分析用于确定一个系统中，哪些因素是主要因素，那些因素是次要因素，哪些因素对系统发展影响大，哪些因素对系统发展影响小，从而进行系统分析，强化推动因素，抑制阻碍因素的一种分析方法。</p><p>它的原理可以通俗地理解为，根据序列曲线集合形状的相似程度来判断联系是否紧密。曲线越接近，相应序列之间的关联度越大，反之越小。</p><p><strong>现有的因素量化分析主要有：回归分析、方差分析、主成分分析等；这些方法都有计算量大、对数据分布规律性要求高、对数据量要求大、一致性不稳定等情况；灰色关联分析弥补了这一空白；</strong></p><h4 id="应用场景">应用场景</h4><ol><li>确定主次因素，对数据进行降维处理</li><li>解决多重共线性问题，通过对多个因素的降维选出对结果有显著影响的因素</li><li>进行综合评价（基本不用灰色相关分析做综合评价，因为不同的数据预处理方法会影响最终结果）</li><li><strong>特点：样本量的多少和样本有无规律都适用；计算量小；结果与事实一致性较好</strong></li></ol><h2 id="问题引入">问题引入</h2><p>找出对结果影响最大的因素。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801102359050.png" alt="image-20230801102359050"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801102413905.png" alt="image-20230801102413905"></p><h2 id="灰色关联分析—步骤">灰色关联分析—步骤</h2><h3 id="数据预处理">数据预处理</h3><p>通过数据预处理，可以<strong>消除量纲的影响，并将数据控制在较小的范围</strong>内。</p><p>常用方法：</p><ol><li>每个指标中的元素除以指标的均值</li><li>进行标准化处理（正向化+标准化）</li></ol><h3 id="确定分析数列">确定分析数列</h3><p>参考数列（母序列，类似于y）：能反映系统行为特征的数据序列，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">x_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>比较序列（子序列，类似于x）：影响系统行为的因素组成的数据序列，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3...</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_i(i=1,2,3...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>例如：结婚率就是参考序列</p><p>​房价、人均收入、女性失业数都是比较序列</p><h3 id="确定灰色关联系数">确定灰色关联系数</h3><p>定义两级最小差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>s</mi></msub><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>x</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">a=min_smin_t|x_0(t)-x_s(t)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">mi</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">mi</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>，两极最大差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>s</mi></msub><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>t</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>x</mi><mi>s</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">a=max_smax_t|x_0(t)-x_s(t)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">ma</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span>。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801110004849.png" alt="image-20230801110004849"></p><h3 id="确定灰色关联系数-2">确定灰色关联系数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801110201536.png" alt="image-20230801110201536"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801110349961.png" alt="image-20230801110349961"></p><p>最后通过灰色关联度的大小来判断母序列与子序列的相关性。由表可知，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">x_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的关联度最大。所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">x_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_{0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的影响最大，其次是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><h2 id="总结">总结</h2><h3 id="解题步骤">解题步骤</h3><ol><li>进行数据预处理，正向化、标准化</li><li>确定母序列和子序列，如果有多个母序列，需要分别进行灰色关联分析</li><li>将母序列与子序列两两相减，计算出两级最小差和两级最大差</li><li>对每个元素计算灰色相关系数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>，注意这里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ρ</span></span></span></span>一般取值的0.5</li><li>将各个指标的灰色相关系数求平均值作为灰色关联度</li><li>根据灰色关联度大小下结论</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 评价模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】评价模型-3. 模糊综合评价</title>
      <link href="/2023/08/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-3.%20%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/"/>
      <url>/2023/08/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-3.%20%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<h1>模糊综合评价</h1><h2 id="简介">简介</h2><p>模糊是指客观事物差异的中间过渡中的“不分明性”和“亦此亦彼性”，比如身高多高算高？温度多少合适？这些现象难以用经典的集合描述。</p><p>模糊数学开篇之作：1965年美国计算机与控制专家L.A.Zadeh提出模糊概念并发表论文《Fuzzy Sets》</p><h2 id="模糊集合">模糊集合</h2><h3 id="模糊集合的数学刻画">模糊集合的数学刻画</h3><ul><li><p>描述事物模糊性概念的集合</p></li><li><p>数学刻画——隶属函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mi>A</mi></msub><mo>:</mo><mi>X</mi><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><msub><mi>μ</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mtext>称为</mtext><mi>x</mi><mtext>对集合</mtext><mi>A</mi><mtext>的隶属度</mtext><mspace linebreak="newline"></mspace><mtext>记为</mtext><mo>:</mo><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>μ</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mo>∈</mo><mi>X</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\mu_A: X \to [0,1] \\\mu_A(x) 称为x对集合A的隶属度 \\记为: A=\{(x,\mu_A(x))|x \in X\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord cjk_fallback">称为</span><span class="mord mathnormal">x</span><span class="mord cjk_fallback">对集合</span><span class="mord mathnormal">A</span><span class="mord cjk_fallback">的隶属度</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">记为</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">}</span></span></span></span></span></p><p><strong>显然，模糊集合A完全由隶属函数来刻画，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\mu = 0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">μ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.5</span></span></span></span>最具模糊性</strong></p></li></ul><h3 id="隶属函数的确定">隶属函数的确定</h3><p>常用方法：</p><ul><li>隶属频率（问卷统计调查）</li><li>借助已有的尺度刻画（比如恩格尔系数刻画小康家庭）</li><li>指派法（指定数学函数作为隶属度函数）==常用==</li></ul><p>指派法常用函数：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20240131191832406.png" alt="image-20240131191832406"></p><h2 id="模糊综合评价问题">模糊综合评价问题</h2><h3 id="概述">概述</h3><p>当评价的结果是模糊的而不是确定的，就可以考虑进行模糊综合评价。常用于员工绩效评价，比如是优、良、中、差。</p><h3 id="模糊综合评价引入的三个集合">模糊综合评价引入的三个集合</h3><ol><li>因素集（评价指标集） U</li><li>评语集（评价结果）——&gt; 模糊集合  V</li><li>权重集（指标的权重）——&gt; 可以用TOPSIS、AHP、熵权法等找权重   A</li></ol><p>例如：评价一个学生的表现</p><p>U={专业排名，课外实践，志愿服务，竞赛成绩}</p><p>V={优，良，差}</p><p>A={0.4，0.2，0.1，0.3}</p><h3 id="模糊综合评价一般步骤">模糊综合评价一般步骤</h3><ol><li><p>确定因素集</p></li><li><p>确定评语集</p></li><li><p>确定各因素的权重</p></li><li><p>对于每个待评价对象分别确定模糊综合评价矩阵</p><p>行标签：第i次评分</p><p>列标签：评价指标</p><p>矩阵元素：根据<strong>隶属度函数确定在多大程度上属于某个评语集元素</strong></p></li><li><p>权重乘以评价矩阵得到该评价对象各指标得分</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 评价模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】评价模型-2. 熵权法</title>
      <link href="/2023/08/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-2.%20%E7%86%B5%E6%9D%83%E6%B3%95/"/>
      <url>/2023/08/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-2.%20%E7%86%B5%E6%9D%83%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>熵权法</h1><h2 id="简述">简述</h2><p>熵权法用于<strong>客观地</strong>给评价指标赋权。</p><h2 id="问题引入">问题引入</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801084000062.png" alt="image-20230801084000062"></p><p>分配权重：层次分析法</p><p>缺点：主观性强</p><p>需求：标准都很重要，想尽量避免主观赋权</p><p>解决方案：熵权法（客观赋权）</p><h2 id="熵权法—介绍">熵权法—介绍</h2><ol><li><p>概览与信息量的关系</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801084324769.png" alt="image-20230801084324769"></p></li><li><p>信息熵与信息量的关系</p><p>熵：描述系统无需程度的一个度量</p><p>信息：描述系统有序程度的一个度量</p><p><strong>可以用熵值描述某个指标的离散程度，离散程度越大，该指标对综合评价影响越大</strong></p><p>信息熵：平均而言发生一个事件我们得到的信息量的大小（得到的信息越多，已知的信息越少）</p><p>熵权法：是一种可以多对象、多指标进行综合评价的方法，其评价数据来源于数据本身，基本不受主观因素干扰</p><p><strong>基本思想：信息熵小—&gt;得到的信息少，掌握的信息多—&gt;这组信息越靠谱—&gt;权重大</strong></p></li></ol><h2 id="熵权法—定义">熵权法—定义</h2><h3 id="信息熵的定义">信息熵的定义</h3><h3 id="image-20230801085250308"><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801085250308.png" alt="image-20230801085250308"></h3><h3 id="信息熵的定性分析">信息熵的定性分析</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801085829275.png" alt="image-20230801085829275"></p><h2 id="熵权法—步骤">熵权法—步骤</h2><h3 id="正向化处理">正向化处理</h3><blockquote><p><strong>（正向化处理算法并不是唯一的，可以根据实际情况得到更优的算法）</strong></p></blockquote><p>把各种评价指标进行正向化处理，一般是都正向化为极大型指标。</p><h4 id="指标的类型">指标的类型</h4><ol><li>极大型指标</li><li>极小型指标</li><li>中间型指标</li><li>区间型指标</li></ol><h4 id="对于不同类型指标的正向化处理">对于不同类型指标的正向化处理</h4><ol><li><p>极小型指标正向化</p><p>max-x</p><p>最大的值-每一项</p></li><li><p>中间型指标</p><p>M=max{|<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_i-x_{best}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>|}   先用每一项减去最好的一项，再取最大值</p><p>然后再令各个元素  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>x</mi><mo stretchy="true">~</mo></mover><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mrow><mi>b</mi><mi>e</mi><mi>s</mi><mi>t</mi></mrow></msub><mi mathvariant="normal">∣</mi></mrow><mi>M</mi></mfrac></mrow><annotation encoding="application/x-tex">\widetilde{x}=1-\frac{|x_i-x_{best}|}{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6906em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6906em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span class="svg-align" style="width:calc(100% - 0.0556em);margin-left:0.0556em;top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mathnormal mtight">es</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span><span class="mord mtight">∣</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>区间型指标</p><p>先计算最值到边界的最大距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>a</mi><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">}</mo><mo>−</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">M=max\{a-min\{x_i\},max\{x_i\}-b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">}</span></span></span></span></p><p>再令各个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="true">~</mo></mover><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><mi>a</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>M</mi></mfrac><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mo>≤</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≤</mo><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mfrac><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>b</mi></mrow><mi>M</mi></mfrac><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>≥</mo><mi>b</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\widetilde{x_i}=\begin{cases}1-\frac{a-x_i}{M}, x_i\le a\\ 1 ,a\le x_i \le b\\ 1-\frac{x_i-b}{M},x_i \ge b \end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8406em;vertical-align:-0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6906em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="svg-align" style="top:-3.4306em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg xmlns="http://www.w3.org/2000/svg" width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:4.32em;vertical-align:-1.91em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35em;"><span style="top:-2.2em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.192em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.292em;"><span class="pstrut" style="height:3.15em;"></span><span style="height:0.316em;width:0.8889em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.8889em' height='0.316em' style='width:0.8889em' viewBox='0 0 888.89 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style="top:-4.6em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.85em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">a</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span></span></span><span style="top:-1.53em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.91em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li></ol><h3 id="标准化处理">标准化处理</h3><p>对正向化指标进行标准化处理，得到<strong>标准化矩阵X</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801094534031.png" alt="image-20230801094534031"></p><h3 id="计算各个指标下每个样本的比重">计算各个指标下每个样本的比重</h3><p>为了将不同标准放在同一个指标值范围内。</p><p>将标准化处理后得到的标准化矩阵进行处理，得到<strong>权重矩阵</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801094901069.png" alt="image-20230801094901069"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801094928634.png" alt="image-20230801094928634"></p><h3 id="计算信息熵和熵权">计算信息熵和熵权</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230801095421565.png" alt="image-20230801095421565"></p><p><strong>至此，权值确定完成</strong></p><h3 id="原理">原理</h3><p>信息熵越大，提供的信息量也越大，已经掌握的信息量就越少，信息可靠性越低，那么其对应的权值也低。</p><p>在权值确定的过程中，完全是分析已有的数据，没有引入主观敢于，具有较好的客观性。</p><h1>Version2: 熵权法</h1><h2 id="基本概念">基本概念</h2><h3 id="信息熵">信息熵</h3><p>信息：描述系统有序程度的度量</p><p>熵：描述系统混乱程度的度量</p><h3 id="熵权法">熵权法</h3><p>根据信息熵的定义，平均而言一件事发生，我们得到的信息量的大小（一件事发生代表的信息量越大，证明这件事我们已知的信息越少）；</p><p>信息熵越小，指标的离散程度越大，该指标对评价的影响越大；</p><p>指标的变异程度小，反映的信息量也相对较少其对应的权值相对应降低；</p><p><strong>人话：越离散的数据，权重应该越大</strong></p><h2 id="基本步骤">基本步骤</h2><ol><li>数据标准化</li><li>归一化，归一后的数据作为每个指标的<strong>概率</strong>，得到概率矩阵</li><li>依据概率矩阵计算每个指标的信息熵</li><li>根据信息熵计算差异系数（实际就是正向化）</li><li>得到的每个指标的差异系数即为每个指标的权重</li><li>根据权重计算得分</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 评价模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】评价模型-1. 层次分析法</title>
      <link href="/2023/08/11/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-1.%20%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2023/08/11/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B-1.%20%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>层次分析法</h1><p>层次分析法是一种主观评价方法。通过相互比较确定各个准则相对于目标的权重，以及各个方案对于每一准则的权重，这些权重在人的思维过程中通常是定性的，而在层次分析法中要给出得到权重的定量方法。</p><p>如果要使用层次分析法，类似于下面的结构图要出现在论文里。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718211648471.png" alt="image-20230718211648471"></p><h2 id="引例">引例</h2><p><strong>评价类问题</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718203834717.png" alt="image-20230718203834717"></p><h2 id="层次分析法的基本框架">层次分析法的基本框架</h2><h3 id="层次分析法的基本三要素">层次分析法的基本三要素</h3><ol><li>评价目标是什么？</li><li>评价标准是什么？</li><li>可选方案有哪些？</li></ol><h2 id="层次分析法步骤">层次分析法步骤</h2><h3 id="确定指标的重要性">确定指标的重要性</h3><p>在确定指标权重时，有时有多个指标，同时考虑可能会导致考虑不周，可以先采用两两比较，在上一组比较的基础上进而推断当前两组的权重。</p><p><strong>这里采用两两比较法确定权重</strong></p><p>奇数用于表示确切的尺度，偶数用于表示介于两个确切评价之间的评价</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718203013275.png" alt="image-20230718203013275"></p><center><a id="table1" >评价尺度表</a></center><p>通过两两比较的评价得到<strong>4*4的评价矩阵</strong></p><p>将该矩阵的第i行第j列元素记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>表示i相较于j的重要程度</li><li>当i=j时，规定<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_{ij}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>当且仅当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>×</mo><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_{ij}&gt;0,a_{ij}\times a_{ji}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9305em;vertical-align:-0.2861em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，该矩阵称为正互反矩阵</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718203705840.png" alt="image-20230718203705840"></p><h3 id="确定待选方案在某一指标下的得分">确定待选方案在某一指标下的得分</h3><p>这一环节就是对各个备选方案进行打分，打分尺度按照上面的评价指标表。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718235609596.png" alt="image-20230718235609596"></p><h3 id="层次分析法矩阵的一致性（用于检验评价矩阵是否矛盾）">层次分析法矩阵的一致性（用于检验评价矩阵是否矛盾）</h3><p>观察下面矩阵的问题</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719000711423.png" alt="image-20230719000711423"></p><h4 id="一致矩阵的性质">一致矩阵的性质</h4><ul><li>矩阵的秩为1，具有唯一的非0特征根</li><li>矩阵的任意一列向量都是对于特征根n的特征向量</li></ul><p>所以只要两两行/列满足倍数关系，就是一致矩阵（主元列只有一个）</p><p><strong>如果矩阵不满足上面的两个性质，则该矩阵是非一致性矩阵，在求权重时，非一致性矩阵和一致性矩阵有着不同的求解方法</strong></p><h4 id="一致矩阵的作用">一致矩阵的作用</h4><p>用于检查各个因素之间的比是否存在矛盾，所以在使用<strong>评价矩阵</strong>之前一定要检验其一致性</p><p>一致矩阵的判断方法：</p><ol><li>一致矩阵的性质</li><li>当评价矩阵不是一致矩阵时，算出其最大特征根x，x与n(矩阵的维数)的差越大，证明越不一致，越小则越一致。</li></ol><h4 id="一致性检验方法">一致性检验方法</h4><p>下面的<strong>随机一致性指标表</strong>可以放入论文。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718213316162.png" alt="image-20230718213316162"></p><p>这里CR&lt;0.1可以理解为<strong>比随机产生的评价矩阵好10倍</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718225739963.png" alt="image-20230718225739963"></p><h3 id="权重的计算">权重的计算</h3><h4 id="一致性矩阵求权重">一致性矩阵求权重</h4><p>直接对某一列进行归一化处理得到各个指标的权值，因为一致矩阵只有一个主元列，只需要求一列即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719001020407.png" alt="image-20230719001020407"></p><h4 id="非一致性矩阵求权重">非一致性矩阵求权重</h4><ol><li><p>算术平均法求权重</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719001339169.png" alt="image-20230719001339169"></p><p>算数平均法求权重的论文表述：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719001423779.png" alt="image-20230719001423779"></p></li><li><p><strong>特征值法求权重（更加常用，也更简单）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719001550804.png" alt="image-20230719001550804"></p></li><li><p>两种求权值方法的区别和联系</p><p>在非一致性不大的情况下，两种方法差别不大。实际生活中的数据，一致性并非很强，一般建议用特征值法求权重，特征值法方便且常用。</p><p>如果论文字数不够，也可以用这个来凑字数，两种方法都用，然后求平均值得到最终权重。</p></li></ol><h4 id="确定最终各个方案的权重得分">确定最终各个方案的权重得分</h4><ol><li><p>根据所得的各个指标下的评价矩阵求其权重，得到各个指标下各个目的地的权重得分；</p></li><li><p>根据各个指标的评价矩阵求其权重，得到各个指标的权重得分；</p></li><li><p>各个目的地的最终得分：</p><p>比如目的地1的得分=指标1下目的地1的权重*指标1的权重+指标2下目的地1的权重*指标2的权重…</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719002648044.png" alt="image-20230719002648044"></p><p><strong>上面这个表格我们也要写在论文里，最后两列CI和CR也要列出来。其中CR是常量，去找对应矩阵维数的表就行，CI是计算出来的矩阵一致性指标</strong></p></li></ol><h4 id="层次总排序的一致性检验">层次总排序的一致性检验</h4><p>得到最终的得分表后，也要对最后的得分表进行一致性检验。</p><p>方法：CR=每一行指标的权重*CI(一致性评价指标系数)求和/每一行的指标权重*RI(随机性评价指标系数)求和</p><p>​如果得到的CR&lt;0.1，则通过一致性检验。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230719003206657.png" alt="image-20230719003206657"></p><h2 id="层次分析法总结">层次分析法总结</h2><ol><li><p>层次分析法解决的是评价类问题</p></li><li><p>画出层级结构图（目标层、准则层、方案层）  （<strong>层级结构图需要放在论文里</strong>）</p></li><li><p><strong>确定评价指标</strong>，构造评价矩阵（<strong>评价尺度表需要放在论文里</strong>）</p><p>确定评价指标可以去做问卷、访问专家、学术论文上面找已经成熟的指标体系…</p></li><li><p>依照评价指标对各个方案进行打分（<strong>一致性指标系数CI求解的公式过程、随机性指标系数RI常量表、一致性比例CR求解的公式过程都需要放在论文里</strong>）</p></li><li><p>求出权重、填表、求出最后得分（<strong>最终的得分表需要放在论文里</strong>）</p></li><li><p>层次总排序一致性检验（<strong>最后的一致性检验公式也要放在论文里</strong>）</p></li><li><p>可以搜一搜相关层次分析的高引论文，看别人如何组织、如何写。</p></li></ol><h2 id="相关画图工具">相关画图工具</h2><ul><li>processon网站</li><li>亿图</li><li>wps也可以画那个结构图</li></ul><h2 id="整理">整理</h2><ol><li><p>适用情况：</p><p>较为模糊的问题</p><p>难以完全定量</p></li><li><p>基本步骤</p><ul><li><p>建立递阶层次结构（目标层、准则层、方案层）==解释说明用==</p></li><li><p>构造出各层次中的所有判断矩阵==根据重要性指标表来构造判断矩阵==</p></li><li><p>一致性检验==检验判断矩阵在一定误差范围内是否合理，不合理的话对矩阵进行调整==</p><p>计算一致性指标CI</p><p>查RI</p><p>计算一致性比例CR并判断矩阵是否合理</p></li><li><p>求权重后进行评价==根据判断矩阵求权重==</p><p>算术平均值法</p><p>几何平均值法</p><p>特征向量法（常用）</p></li><li><p>原始数据指标归一化</p></li><li><p>计算加权得分，作出决策</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 评价模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】分类模型-4. 神经网络分类</title>
      <link href="/2023/08/10/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-4.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB/"/>
      <url>/2023/08/10/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-4.%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>神经网络分类</h1><h2 id="背景">背景</h2><p>分类也有不同的种类，在机器学习中，有监督学习的分类和无监督学习的分类就是不同的两类分类方法。</p><ul><li><p>有监督学习：样本数据已经给出了正确的分类，通过对正确分类的样本数据进行学习，从中总结规律、获取知识、付诸应用。</p><p>监督学习的样本数据提供了特征值和目标值，通过回归、<strong>分类</strong>学习特征值和目标值之间的关系。</p></li><li><p>无监督学习：样本数据没有提供确定的分类属性，样本数据中只有特征值没有目标值，只能通过样本数据本身的特性进行摸索和学习，通过<strong>聚类</strong>方法来寻找和认识对象的相似性。</p></li></ul><p>所以分类和聚类是有差别的。</p><h2 id="聚类分析">聚类分析</h2><h3 id="聚类的分类">聚类的分类</h3><p>聚类是从数据分析的角度，对大量的、多维度的、无标记的样本数据集，按照样本数据自身的相似性对数据集进行分类。</p><ul><li>大量：数据数量大</li><li>多维：样本特征值多</li><li>无标记：样本数据对于每个样本没有指定的类别属性</li></ul><p>对于聚类的分类，是针对研究对象的不同来说的。把样本的行作为对象，考察样本的相似度，将样本集分成若干类，称为Q型聚类分析，属于样本分类。</p><p>把样本集的列作为对象，考察各个特征变量之间的关联程度，按照变量的相关性聚合为若干类，称为R型聚类分析，属于因子分析。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 分类模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】分类模型-3. 模糊聚类(Fuzzy C-Means)</title>
      <link href="/2023/08/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-3.%20%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB/"/>
      <url>/2023/08/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-3.%20%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>模糊聚类(Fuzzy C-Means)</h1><h2 id="学术性原理">学术性原理</h2><p>模糊聚类是将模糊理论与聚类理论结合的一种聚类方法，对于分类边界不清晰的情况较为灵活和适用。</p><p>这里介绍模糊C均值聚类(Fuzzy C-Means)方法，通过<strong>隶属度</strong>表示样本属于某一类的概率，很多情况下多个类别之间的界限并不是绝对的明确。</p><p>显然相比于K-Means的硬聚类，模糊C均值聚类得到的聚类结果更加灵活。</p><p>模糊C均值聚类通过最小化目标函数得到聚类中心：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902144549420.png" alt="image-20230902144549420"></p><p>其中，m&gt;1为模糊系数(fuzzy coefficient)，N为样本数，C为聚类中心数，Cj表示第j个聚类中心，和样本特征维数相同，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示第i个样本，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>表示样本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>对聚类中心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">c_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的隶属度(通俗地说就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>属于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">c_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>的概率)，显然满足：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902145513160.png" alt="image-20230902145513160"></p><p>||∗|| 可以是任意度量数据相似性(距离)的范数，最常见的就是欧几里得范数（又称欧氏范数，L2范数，欧氏距离）：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902145606179.png" alt="image-20230902145606179"></p><p>模糊c均值聚类通过更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">U_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>来迭代地优化目标函数Eq.(1):</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902145807631.png" alt="image-20230902145807631"></p><p>迭代的终止条件为 $max_{ij}\lbrace\abs{u_{ij}^{(t+1)}-u_{ij}^{(t)}}\rbrace&lt;\epsilon <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>，其中</mtext><mo>∗</mo><mi>t</mi><mo>∗</mo><mtext>是迭代步数，</mtext><mo>∗</mo><mi>ε</mi><mo>∗</mo><mtext>是一个很小的常数表示误差阈值。也就是说迭代地更新</mtext></mrow><annotation encoding="application/x-tex">，其中 *t* 是迭代步数，*ε* 是一个很小的常数表示误差阈值。也就是说迭代地更新</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">，其中</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">是迭代步数，</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4653em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">是一个很小的常数表示误差阈值。也就是说迭代地更新</span></span></span></span>U_{ij}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>和</mtext></mrow><annotation encoding="application/x-tex">和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">和</span></span></span></span>C_j<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>直到前后两次隶属度最大变化值不超过误差阈值。这个过程</mtext><mo>∗</mo><mo>∗</mo><mtext>最终收敛于</mtext></mrow><annotation encoding="application/x-tex">直到前后两次隶属度最大变化值不超过误差阈值。这个过程**最终收敛于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">直到前后两次隶属度最大变化值不超过误差阈值。这个过程</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">∗</span><span class="mord cjk_fallback">最终收敛于</span></span></span></span>J_m$的局部极小值点或鞍点**。</p><h2 id="原理简介">原理简介</h2><p>FCM算法是一种基于划分的聚类算法，核心思想是使得被划分到同一簇的对象之间相似度最大，而不同簇之间相似度最小。模糊C均值算法是普通C均值算法的改进，相比于普通算法对数据的硬划分，FCM是一种模糊的柔性划分。</p><h3 id="基本概念">基本概念</h3><h4 id="迭代">迭代</h4><p>迭代是数值分析中通过从一个初始估计出发寻找一系列近似解来解决问题的过程，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次”迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。在FCM聚类算法中，迭代的目的就是不断优化，使结果无限接近目标函数。</p><p><strong>注意：迭代时需要有一个条件来对迭代过程进行控制，保证迭代过程不会无休止的进行。</strong></p><h4 id="隶属度函数">隶属度函数</h4><p>隶属度函数表示一个对象x隶属于集合A的程度，通常记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>，其自变量范围是所有可能属于集合A的对象，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mu A(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">μ</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>的取值范围为[0,1]。越接近1隶属度越高。</p><h4 id="模糊集合">模糊集合</h4><p>一个定义在X={x}的隶属度函数就定义了一个模糊集合A，即这个模糊集合里的元素对某一标准的隶属度是基本相近的。聚类问题中可以把聚类生成的簇看成一个个模糊集合，因此每个样本对簇的隶属度就在[0，1]内。</p><h4 id="聚类中心">聚类中心</h4><p>就是簇的分类标准。一般有两种选取聚类中心的方法。</p><ol><li>经典做法：从所有数据点中任取c个点作为聚类中心，前提是要使得价值函数(目标函数)达到最小。</li><li>每次选簇的均值作为新的中心，迭代直到簇中的对象的分布不再发生变化。（缺点：对离群点敏感）</li></ol><h4 id="相似度算法——欧几里德距离">相似度算法——欧几里德距离</h4><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>y</mi><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt><mo>=</mo><msqrt><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">d=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+...+(x_n-y_n)^2}=\sqrt{\sum_{i=1}^{n}(x_i-y_i)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.305em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.935em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.895em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.305em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.3027em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9373em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8973em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3027em;"><span></span></span></span></span></span></span></span></span></p><p>欧几里德距离越小相似度越大。</p><h4 id="价值函数-目标函数">价值函数/目标函数</h4><p>目标函数的本质是各个点到个各类的欧式距离的和。</p><p>目标函数可以通过<strong>隶属度</strong>以及<strong>样本x到聚类中心的距离</strong>这两个量来直观衡量。（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">u_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是隶属度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是样本到聚类中心的距离）：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msubsup><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">J=\sum_{i=1}^{c}\sum_{j=1}^{n}u_{ij}^md_{ij}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2499em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span></p><p>该算法中C表示聚类数目，假设有n个样本数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x_j(1,2,3,...,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，每个数据有s个特征，将这n个数据划分为c组，算法输出一个C*N的矩阵U。</p><p>求每组的聚类中心ci，使得目标函数最小（因为目标函数与欧几里德距离有关，目标函数达到最小时，欧式距离最短，相似度最高），这保证了组内相似度最高，组间相似度最低的聚类原则。</p><p>于是我们得到最优解的表达式：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>J</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>=</mo><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>μ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msubsup><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><msub><mo fence="false" stretchy="true" minsize="2.4em" maxsize="2.4em">)</mo><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">J_{min}=\bigg( \sum_{i=1}^{c}\sum_{j=1}^{n}\mu_{ij}^md_{ij}^2 \bigg)_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0962em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4497em;vertical-align:-0.9997em;"></span><span class="mord"><span class="delimsizing size3">(</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="delimsizing size3">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.5381em;"><span style="top:-1.7003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9997em;"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><msub><mi>c</mi><mi>j</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">d_{ij}=\sqrt{(x_i-c_j)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.3231em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9169em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8769em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067l0 -0c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3231em;"><span></span></span></span></span></span></span></span></span></p><h4 id="加权指数m">加权指数m</h4><p>m实质是一个刻画模糊化程度的参数（m&gt;1），当m=1时模糊聚类就退化为HCM，研究表明最佳m的取值为[1,2.5]，一般m取2为宜。</p><h3 id="公示表">公示表</h3><ul><li>约束条件</li></ul><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></msubsup><msub><mi>μ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{c}\mu_{ij}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></p><ul><li>价值函数</li></ul><p>​<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>u</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msubsup><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">J=\sum_{i=1}^{c}\sum_{j=1}^{n}u_{ij}^md_{ij}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2499em;vertical-align:-0.4358em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4413em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li><p>聚类中心</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>μ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup><msub><mi>x</mi><mi>j</mi></msub></mrow><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mi>μ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>m</mi></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">c_i=\frac{\sum_{j=1}^n\mu_{ij}^mx_j}{\sum_{j=1}^n\mu_{ij}^m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.825em;vertical-align:-0.6678em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1572em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7047em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4603em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em;"><span style="top:-2.1777em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-2.8448em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4612em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6322em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4603em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.214em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4249em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6678em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li><li><p>隶属矩阵</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>c</mi></msubsup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mfrac><msub><mi>d</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>d</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub></mfrac><msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mfrac><mn>2</mn><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">U_{ij}=\frac{1}{\sum_{k=1}^c\big(\frac{d_{ij}}{d_{kj}}\big)^{\frac{2}{m-1}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2867em;vertical-align:-1.4416em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.19em;"><span class="pstrut" style="height:3.1187em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7047em;"><span style="top:-2.1786em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3214em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord sizing reset-size3 size6 mtight"><span class="delimsizing size1 mtight"><span class="mtight">(</span></span></span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1832em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6944em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">kj</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5441em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.6872em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6595em;"></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5092em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7326em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mtight"><span class="mord sizing reset-size3 size6 mtight"><span class="delimsizing size1 mtight"><span class="mtight">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.5982em;"><span style="top:-3.8614em;margin-right:0.0714em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size1 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0314em;"><span style="top:-2.468em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.387em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6153em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size1 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.3487em;"><span class="pstrut" style="height:3.1187em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5127em;"><span class="pstrut" style="height:3.1187em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4416em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></li></ul><h3 id="算法步骤">算法步骤</h3><ol><li>用值0，1间的值随机数初始化隶属矩阵U，使其满足约束条件。</li><li>用聚类中心公式计算出c个聚类中心<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c_i(i=1,2,...,c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></li><li>根据价值函数计算价值J，如果它小于某个特定的阈值或者它相对于上次价值函数值的改变量小于某个阈值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>，则算法停止</li><li>用隶属矩阵公式，重新计算隶属矩阵每个点的值，得到新的隶属矩阵</li></ol><h2 id="Python代码实现">Python代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">@Date    : 2019/9/11</span></span><br><span class="line"><span class="string">@Author  : Rezero</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadData</span>(<span class="params">datapath</span>):</span><br><span class="line">    data = pd.read_csv(datapath, sep=<span class="string">&#x27;,&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">    data = data.sample(frac=<span class="number">1.0</span>)   <span class="comment"># 打乱数据顺序</span></span><br><span class="line">    dataX = data.iloc[:, :-<span class="number">1</span>].values <span class="comment"># 特征</span></span><br><span class="line">    labels = data.iloc[:, -<span class="number">1</span>].values <span class="comment"># 标签</span></span><br><span class="line">    <span class="comment"># 将标签类别用 0, 1, 2表示</span></span><br><span class="line">    labels[np.where(labels == <span class="string">&quot;Iris-setosa&quot;</span>)] = <span class="number">0</span></span><br><span class="line">    labels[np.where(labels == <span class="string">&quot;Iris-versicolor&quot;</span>)] = <span class="number">1</span></span><br><span class="line">    labels[np.where(labels == <span class="string">&quot;Iris-virginica&quot;</span>)] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataX, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_U</span>(<span class="params">samples, classes</span>):</span><br><span class="line">    U = np.random.rand(samples, classes)  <span class="comment"># 先生成随机矩阵</span></span><br><span class="line">    sumU = <span class="number">1</span> / np.<span class="built_in">sum</span>(U, axis=<span class="number">1</span>)   <span class="comment"># 求每行的和</span></span><br><span class="line">    U = np.multiply(U.T, sumU)   <span class="comment"># 使隶属度矩阵每一行和为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> U.T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算样本和簇中心的距离，这里使用欧氏距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">X, centroid</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.<span class="built_in">sum</span>((X-centroid)**<span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeU</span>(<span class="params">X, centroids, m=<span class="number">2</span></span>):</span><br><span class="line">    sampleNumber = X.shape[<span class="number">0</span>]  <span class="comment"># 样本数</span></span><br><span class="line">    classes = <span class="built_in">len</span>(centroids)</span><br><span class="line">    U = np.zeros((sampleNumber, classes))</span><br><span class="line">    <span class="comment"># 更新隶属度矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(classes):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(classes):</span><br><span class="line">            U[:, i] += (distance(X, centroids[i]) / distance(X, centroids[k])) ** (<span class="number">2</span> / (m - <span class="number">1</span>))</span><br><span class="line">    U = <span class="number">1</span> / U</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> U</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ajustCentroid</span>(<span class="params">centroids, U, labels</span>):</span><br><span class="line">    newCentroids = [[], [], []]</span><br><span class="line">    curr = np.argmax(U, axis=<span class="number">1</span>)  <span class="comment"># 当前中心顺序得到的标签</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(centroids)):</span><br><span class="line">        index = np.where(curr == i)   <span class="comment"># 建立中心和类别的映射</span></span><br><span class="line">        trueLabel = <span class="built_in">list</span>(labels[index])  <span class="comment"># 获取labels[index]出现次数最多的元素，就是真实类别</span></span><br><span class="line">        trueLabel = <span class="built_in">max</span>(<span class="built_in">set</span>(trueLabel), key=trueLabel.count)</span><br><span class="line">        newCentroids[trueLabel] = centroids[i]</span><br><span class="line">    <span class="keyword">return</span> newCentroids</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cluster</span>(<span class="params">data, labels, m, classes, EPS</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param data: 数据集</span></span><br><span class="line"><span class="string">    :param m: 模糊系数(fuzziness coefficient)</span></span><br><span class="line"><span class="string">    :param classes: 类别数</span></span><br><span class="line"><span class="string">    :return: 聚类中心</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    sampleNumber = data.shape[<span class="number">0</span>]  <span class="comment"># 样本数</span></span><br><span class="line">    cNumber = data.shape[<span class="number">1</span>]       <span class="comment"># 特征数</span></span><br><span class="line">    U = initialize_U(sampleNumber, classes)   <span class="comment"># 初始化隶属度矩阵</span></span><br><span class="line">    U_old = np.zeros((sampleNumber, classes))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        centroids = []</span><br><span class="line">        <span class="comment"># 更新簇中心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(classes):</span><br><span class="line">            centroid = np.dot(U[:, i]**m, data) / (np.<span class="built_in">sum</span>(U[:, i]**m))</span><br><span class="line">            centroids.append(centroid)</span><br><span class="line"></span><br><span class="line">        U_old = U.copy()</span><br><span class="line">        U = computeU(data, centroids, m)  <span class="comment"># 计算新的隶属度矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">max</span>(np.<span class="built_in">abs</span>(U - U_old)) &lt; EPS:</span><br><span class="line">            <span class="comment"># 这里的类别和数据标签并不是一一对应的, 调整使得第i个中心表示第i类</span></span><br><span class="line">            centroids = ajustCentroid(centroids, U, labels)</span><br><span class="line">            <span class="keyword">return</span> centroids, U</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测所属的类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">X, centroids</span>):</span><br><span class="line">    labels = np.zeros(X.shape[<span class="number">0</span>])</span><br><span class="line">    U = computeU(X, centroids)  <span class="comment"># 计算隶属度矩阵</span></span><br><span class="line">    labels = np.argmax(U, axis=<span class="number">1</span>)  <span class="comment"># 找到隶属度矩阵中每行的最大值，即该样本最大可能所属类别</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    datapath = <span class="string">&quot;iris.data&quot;</span></span><br><span class="line">    dataX, labels = loadData(datapath)  <span class="comment"># 读取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分训练集和测试集</span></span><br><span class="line">    ratio = <span class="number">0.6</span>  <span class="comment"># 训练集的比例</span></span><br><span class="line">    trainLength = <span class="built_in">int</span>(dataX.shape[<span class="number">0</span>] * ratio)  <span class="comment"># 训练集长度</span></span><br><span class="line">    trainX = dataX[:trainLength, :]</span><br><span class="line">    trainLabels = labels[:trainLength]</span><br><span class="line">    testX = dataX[trainLength:, :]</span><br><span class="line">    testLabels = labels[trainLength:]</span><br><span class="line"></span><br><span class="line">    EPS = <span class="number">1e-6</span>   <span class="comment"># 停止误差条件</span></span><br><span class="line">    m = <span class="number">2</span>        <span class="comment"># 模糊因子</span></span><br><span class="line">    classes = <span class="number">3</span>  <span class="comment"># 类别数</span></span><br><span class="line">    <span class="comment"># 得到各类别的中心</span></span><br><span class="line">    centroids, U = cluster(trainX, trainLabels, m, classes, EPS)</span><br><span class="line"></span><br><span class="line">    trainLabels_prediction = predict(trainX, centroids)</span><br><span class="line">    testLabels_prediction = predict(testX, centroids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    train_error = <span class="number">1</span> - np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(trainLabels_prediction - trainLabels)) / trainLength</span><br><span class="line">    test_error = <span class="number">1</span> - np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(testLabels_prediction - testLabels)) / (dataX.shape[<span class="number">0</span>] - trainLength)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Clustering on traintset is %.2f%%&quot;</span> % (train_error*<span class="number">100</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Clustering on testset is %.2f%%&quot;</span> % (test_error*<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="单词积累">单词积累</h4><ol><li>centroid    数心，形心</li></ol><hr><h2 id="模糊聚类算法工具箱">模糊聚类算法工具箱</h2><p>github项目地址：</p><p><a href="https://github.com/ChoiNgai/FuzzyClustering">https://github.com/ChoiNgai/FuzzyClustering</a></p><p><strong>介绍：</strong></p><p>上面有常用的聚类算法提供使用，详细的使用教程，接口化操作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 分类模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】分类模型-2. 层次聚类</title>
      <link href="/2023/08/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-2.%20%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/"/>
      <url>/2023/08/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-2.%20%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>层次聚类</h1><h2 id="背景">背景</h2><p>聚类属于机器学习的无监督学习，聚类的方法有很多，比如K-means聚类、层次聚类。K-means聚类需要在聚类前确定簇数，这会因为个人的主观判断而导致分析结果的偏差。层次聚类通过对原始数据划分层次聚类，最终得出簇数，聚类结果较为客观。</p><h2 id="基本原理">基本原理</h2><p>每个数据点都是一簇，然后找到相似性最高的两个点进行聚类（看成新的一个簇参与聚类），不断迭代。</p><h2 id="具体算法">具体算法</h2><p>一般计算相似性的方法是计算距离。</p><h4 id="具体层次聚类步骤">具体层次聚类步骤</h4><ol><li><p>创建领近矩阵</p><ul><li>矩阵对角元素都为0，点与自身距离为0</li><li>使用欧几里得距离计算非对角元素的距离</li></ul></li><li><p>执行层次聚类</p><ol><li><p>将所有的点视为单个簇</p></li><li><p>找到领近矩阵中最小距离的点并且将这两个点合并</p><p>（即将这两个点视为一个簇，代替原来的两个簇）</p></li><li><p>新的簇的值可以是两个点中的最大值、最小值或者平均值或其他</p></li><li><p>重复2、3，直到只剩下一个簇</p></li></ol></li></ol><h4 id="选择聚类数">选择聚类数</h4><p>在层次聚类的过程中，每迭代一次，类别就少一层。我们应该选择多少簇的层次呢？</p><p>我们可以通过树状图方便地选出聚类的簇数。</p><p>当我们合并两个簇时，树状图会相应地记录这些簇之间的距离并以图形形式表示。下面这个是树状图的原始状态，横坐标记录了每个点的标记，纵轴记录了点和点之间的距离。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902004004674.png" alt="image-20230902004004674"></p><p>聚类完成后，我们可以绘制树状图，树状图清晰地反映出聚类的过程。然后我们设置一个阈值距离，绘制一条水平线。水平线与树状图有多少个交点就是有多少个簇。例如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902004138689.png" alt="image-20230902004138689"></p><h2 id="Python代码实现">Python代码实现</h2><h4 id="数据集和代码仓库">数据集和代码仓库</h4><blockquote><p><a href="https://github.com/xiaoyusmd/PythonDataScience">https://github.com/xiaoyusmd/PythonDataScience</a></p><p>参考文章：<a href="https://cloud.tencent.com/developer/article/2014744">https://cloud.tencent.com/developer/article/2014744</a></p></blockquote><h4 id="代码">代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> normalize</span><br><span class="line">data_scaled = normalize(data)</span><br><span class="line">data_scaled = pd.DataFrame(data_scaled, columns=data.columns)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scipy.cluster.hierarchy <span class="keyword">as</span> shc</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">7</span>))  </span><br><span class="line">plt.title(<span class="string">&quot;Dendrograms&quot;</span>)  </span><br><span class="line">dend = shc.dendrogram(shc.linkage(data_scaled, method=<span class="string">&#x27;ward&#x27;</span>))</span><br><span class="line">plt.axhline(y=<span class="number">6</span>, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)<span class="comment">#划分阈值</span></span><br><span class="line"><span class="comment">#对新的簇进行聚类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line">cluster = AgglomerativeClustering(n_clusters=<span class="number">2</span>, affinity=<span class="string">&#x27;euclidean&#x27;</span>, linkage=<span class="string">&#x27;ward&#x27;</span>)  </span><br><span class="line">cluster.fit_predict(data_scaled)</span><br><span class="line"><span class="comment">#画散点图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">7</span>))  </span><br><span class="line">plt.scatter(data_scaled[<span class="string">&#x27;Milk&#x27;</span>], data_scaled[<span class="string">&#x27;Grocery&#x27;</span>], c=cluster.labels_) </span><br></pre></td></tr></table></figure><h4 id="英文单词积累">英文单词积累</h4><ol><li><p>cluster    聚类;簇;(n/v)</p></li><li><p>hierarchy    等级、层次(n)</p></li><li><p>dendrogram     系统树图，树状图(n)</p></li><li><p>linkage    联系、联合(n)</p></li><li><p>agglomerative     凝聚的；凝结的(a)</p></li><li><p>affinity     喜好;类别;适配性;相似度(n)</p></li><li><p>euclidean     欧几里德的(a)</p></li><li><p>scatter      撒，播撒；使散开(v)</p><p>​离差；散点</p></li></ol><h4 id="可展示数据的图形">可展示数据的图形</h4><ol><li>树状图</li><li>散点图</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 分类模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】分类模型-1. K-means聚类</title>
      <link href="/2023/08/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-1.%20K-means%E8%81%9A%E7%B1%BB/"/>
      <url>/2023/08/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B-1.%20K-means%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1>K-means聚类</h1><h2 id="简介">简介</h2><p>K-Means算法是最热门最广泛的聚类算法之一，属于<strong>无监督算法</strong>，即无明确类别、label，我们把相似的东西分到一个组寻找其中的规律。</p><p><strong>优点：</strong></p><ul><li>速度快</li><li>原理简单</li><li>对大数据有较好的伸缩性</li></ul><p><strong>缺点：</strong></p><ul><li>需要指定聚类数量k</li><li>对异常值敏感</li><li>对初始值敏感</li></ul><p><strong>聚类的应用：</strong></p><ol><li>市场分割</li><li>社交网络</li><li>组织计算集群</li><li>天文数据分析</li></ol><h2 id="算法原理">算法原理</h2><p>初始给定K个簇中心，按照邻近原则把待分类的点分到各个簇。然后按照平均法重新计算各个簇的质心，确定新的簇新。一直迭代直到簇心的移动距离小于某个阈值。</p><h2 id="实现步骤">实现步骤</h2><ol><li>为待聚类的点随机寻找聚类中心</li><li>计算每个点到聚类中心的距离，将各个点归类到离该点最近的聚类中去</li><li>计算每个聚类中所有点的坐标的平均值，并将这个平均值作为新的聚类中心</li><li>重复2、3步骤，直到聚类中心不再大范围移动或者聚类次数达到要求为止</li></ol><h4 id="Python代码实现">Python代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">K_Means</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># k是分组数；tolerance‘中心点误差’；max_iter是迭代次数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k=<span class="number">2</span>, tolerance=<span class="number">0.0001</span>, max_iter=<span class="number">300</span></span>):</span><br><span class="line">        self.k_ = k</span><br><span class="line">        self.tolerance_ = tolerance</span><br><span class="line">        self.max_iter_ = max_iter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.centers_ = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k_):</span><br><span class="line">            self.centers_[i] = data[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.max_iter_):</span><br><span class="line">            self.clf_ = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.k_):</span><br><span class="line">                self.clf_[i] = []</span><br><span class="line">            <span class="comment"># print(&quot;质点:&quot;,self.centers_)</span></span><br><span class="line">            <span class="keyword">for</span> feature <span class="keyword">in</span> data:</span><br><span class="line">                <span class="comment"># distances = [np.linalg.norm(feature-self.centers[center]) for center in self.centers]</span></span><br><span class="line">                distances = []</span><br><span class="line">                <span class="keyword">for</span> center <span class="keyword">in</span> self.centers_:</span><br><span class="line">                    <span class="comment"># 欧拉距离</span></span><br><span class="line">                    <span class="comment"># np.sqrt(np.sum((features-self.centers_[center])**2))</span></span><br><span class="line">                    distances.append(np.linalg.norm(feature - self.centers_[center]))</span><br><span class="line">                classification = distances.index(<span class="built_in">min</span>(distances))</span><br><span class="line">                self.clf_[classification].append(feature)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(&quot;分组情况:&quot;,self.clf_)</span></span><br><span class="line">            prev_centers = <span class="built_in">dict</span>(self.centers_)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> self.clf_:</span><br><span class="line">                self.centers_[c] = np.average(self.clf_[c], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># &#x27;中心点&#x27;是否在误差范围</span></span><br><span class="line">            optimized = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> center <span class="keyword">in</span> self.centers_:</span><br><span class="line">                org_centers = prev_centers[center]</span><br><span class="line">                cur_centers = self.centers_[center]</span><br><span class="line">                <span class="keyword">if</span> np.<span class="built_in">sum</span>((cur_centers - org_centers) / org_centers * <span class="number">100.0</span>) &gt; self.tolerance_:</span><br><span class="line">                    optimized = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> optimized:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, p_data</span>):</span><br><span class="line">        distances = [np.linalg.norm(p_data - self.centers_[center]) <span class="keyword">for</span> center <span class="keyword">in</span> self.centers_]</span><br><span class="line">        index = distances.index(<span class="built_in">min</span>(distances))</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1.5</span>, <span class="number">1.8</span>], [<span class="number">5</span>, <span class="number">8</span>], [<span class="number">8</span>, <span class="number">8</span>], [<span class="number">1</span>, <span class="number">0.6</span>], [<span class="number">9</span>, <span class="number">11</span>]])</span><br><span class="line">    k_means = K_Means(k=<span class="number">2</span>)</span><br><span class="line">    k_means.fit(x)</span><br><span class="line">    <span class="built_in">print</span>(k_means.centers_)</span><br><span class="line">    <span class="keyword">for</span> center <span class="keyword">in</span> k_means.centers_:</span><br><span class="line">        pyplot.scatter(k_means.centers_[center][<span class="number">0</span>], k_means.centers_[center][<span class="number">1</span>], marker=<span class="string">&#x27;*&#x27;</span>, s=<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cat <span class="keyword">in</span> k_means.clf_:</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> k_means.clf_[cat]:</span><br><span class="line">            pyplot.scatter(point[<span class="number">0</span>], point[<span class="number">1</span>], c=(<span class="string">&#x27;r&#x27;</span> <span class="keyword">if</span> cat == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    predict = [[<span class="number">2</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">9</span>]]</span><br><span class="line">    <span class="keyword">for</span> feature <span class="keyword">in</span> predict:</span><br><span class="line">        cat = k_means.predict(predict)</span><br><span class="line">        pyplot.scatter(feature[<span class="number">0</span>], feature[<span class="number">1</span>], c=(<span class="string">&#x27;r&#x27;</span> <span class="keyword">if</span> cat == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;b&#x27;</span>), marker=<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    pyplot.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 分类模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】优化模型-5. 图论以及最小路径问题</title>
      <link href="/2023/08/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-5.%20%E5%9B%BE%E8%AE%BA%E4%BB%A5%E5%8F%8A%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-5.%20%E5%9B%BE%E8%AE%BA%E4%BB%A5%E5%8F%8A%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1>图论</h1><h2 id="图论基本概念">图论基本概念</h2><p>图论以图为研究对象，是离散数学的重要内容。图论不仅与拓扑学、计算机数据结构和算法密切相关，而且正在成为机器学习的关键技术。</p><p>图论中的图，不是指图形图像或者地图，而是指由定点和连接定点的边所构成的关系结构。</p><p>图提供了一种处理关系和交互等抽象概念的更好方法，它还提供了直观的视觉方式来思考这些概念。</p><h2 id="Python的NetworkX工具包">Python的NetworkX工具包</h2><p>NetworkX是基于Python语言的图论与复杂网络的工具包，用于创建、操作和研究复杂网络的结构、动力学和功能。</p><p>NetworkX可以以标准和非标准的数据格式描述图与网络，生成图与网络，分析网络结构、构建网络模型，设计网络算法，绘制网络图形。</p><p>NetworkX提供了<strong>图形的类、对象、图形生成器、网络生成器、绘图工具</strong>、内置了常用的图论的网络分析算法，可以<strong>进行图和网络的建模、分析和仿真</strong>。</p><p>NetworkX的功能非常强大和庞杂，所涉及的内容远远超出了数学建模的范畴，但可以结合数学建模谈谈如何利用这个工具包解决一些基本问题，了解其中的经典算法。</p><p><img src="https://img-blog.csdnimg.cn/20210705201642751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lvdWNhbnM=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="NetworkX的官网和文档">NetworkX的官网和文档</h4><ul><li>官方网址：<a href="https://networkx.org/">https://networkx.org/</a></li><li>官方文档：<a href="https://networkx.org/documentation/stable/">https://networkx.org/documentation/stable/</a></li><li>pdf文档：<a href="https://networkx.org/documentation/stable/_downloads/networkx_reference.pdf">https://networkx.org/documentation/stable/_downloads/networkx_reference.pdf</a></li></ul><h2 id="NetworkX基本使用">NetworkX基本使用</h2><h3 id="图、定点和边的创建与基本操作">图、定点和边的创建与基本操作</h3><p>图由顶点和连接定点的边构成，但与顶点的位置、边的曲直长短无关。NetworkX支持创建<strong>简单无向图、有向图和多重图</strong>；内置许多标准的图论算法，节点可以为任何数据；支持任意边值维度，功能丰富简单易用。</p><h3 id="图的基本概念">图的基本概念</h3><ul><li>图：若干顶点和连成顶点的边所构成的关系结构</li><li>顶点：图中的顶点，也称为节点</li><li>边：顶点之间的连线，也称为边</li><li>平行边：起点相同、终点也相同的两条边称为平行边</li><li>循环：起点和终点重合的边称为循环（自反）</li><li>有向图：图中的每条边都带有方向，成为有向图</li><li>无向图：图中的每条边都没有方向，成为无向图</li><li>赋权图：<strong>图中的每条边都有一个或多个对应的参数</strong>，称为赋权图。该参数称为这条边的权，<strong>权可以用来表示两点之间的距离、时间、费用</strong></li><li>度：与顶点项链的边的数量，称为该顶点的度</li></ul><h3 id="图、定点和边的操作">图、定点和边的操作</h3><p>Networkx很容易创建图、向图中添加顶点和边、从图中删除顶点和边，也可以查看、删除顶点和边的属性。</p><h4 id="图的创建">图的创建</h4><p>Graph() 类、DiGraph() 类、MultiGraph() 类和 MultiDiGraph() 类分别用来创建：无向图、有向图、多图和有向多图。定义和例程如下：</p><blockquote><p>class Graph(incoming_graph_data=None,**attr)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line">G1 = nx.Graph() <span class="comment">#创建无向空图</span></span><br><span class="line">G2 = nx.DiGraph()</span><br><span class="line">G3 = nx.MultiGraph()</span><br><span class="line">G4 = nx.MultiDiGraph()</span><br></pre></td></tr></table></figure><h4 id="顶点的添加、删除、查看">顶点的添加、删除、查看</h4><p>每一个顶点都有唯一的标签属性（label），可以用整数或字符类型表示，顶点还可以自定义任意属性。</p><p>顶点的常用操作：添加顶点、删除顶点、定义顶点属性，查看顶点和顶点属性。定义和例程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顶点(node)的操作</span></span><br><span class="line"><span class="comment"># 向图中添加顶点</span></span><br><span class="line">G1.add_node(<span class="number">1</span>)  <span class="comment"># 向 G1 添加顶点 1</span></span><br><span class="line">G1.add_node(<span class="number">1</span>, name=<span class="string">&#x27;n1&#x27;</span>, weight=<span class="number">1.0</span>)  <span class="comment"># 添加顶点 1，定义 name, weight 属性</span></span><br><span class="line">G1.add_node(<span class="number">2</span>, date=<span class="string">&#x27;May-16&#x27;</span>) <span class="comment"># 添加顶点 2，定义 time 属性</span></span><br><span class="line">G1.add_nodes_from([<span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>], dist=<span class="number">1</span>)  <span class="comment"># 添加多个顶点，并定义属性</span></span><br><span class="line">G1.add_nodes_from(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">15</span>))  <span class="comment"># 向图 G1 添加顶点 10～14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看顶点和顶点属性</span></span><br><span class="line"><span class="built_in">print</span>(G1.nodes())  <span class="comment"># 查看顶点列表</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 0, 6, 10, 11, 12, 13, 14]</span></span><br><span class="line"><span class="built_in">print</span>(G1._node)  <span class="comment"># 查看顶点属性</span></span><br><span class="line"><span class="comment"># &#123;1: &#123;&#x27;name&#x27;: &#x27;n1&#x27;, &#x27;weight&#x27;: 1.0&#125;, 2: &#123;&#x27;date&#x27;: &#x27;May-16&#x27;&#125;, 3: &#123;&#x27;dist&#x27;: 1&#125;, 0: &#123;&#x27;dist&#x27;: 1&#125;, 6: &#123;&#x27;dist&#x27;: 1&#125;, 10: &#123;&#125;, 11: &#123;&#125;, 12: &#123;&#125;, 13: &#123;&#125;, 14: &#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从图中删除顶点</span></span><br><span class="line">G1.remove_node(<span class="number">1</span>)  <span class="comment"># 删除顶点</span></span><br><span class="line">G1.remove_nodes_from([<span class="number">1</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>])  <span class="comment"># 通过顶点标签的 list 删除多个顶点</span></span><br><span class="line"><span class="built_in">print</span>(G1.nodes())  <span class="comment"># 查看顶点</span></span><br><span class="line"><span class="comment"># [2, 3, 0, 6, 10, 12]  # 顶点列表</span></span><br></pre></td></tr></table></figure><h4 id="边的添加、删除、查看">边的添加、删除、查看</h4><p>在NetworkX中，边是<strong>由对应顶点的名字的元组</strong>组成e=(node1,node2)。边可以设置权重、关系等属性。</p><p>边的常用操作：添加边、删除边、定义边的属性、查看边和边的属性。<strong>向图中添加边时，如果边的顶点是图中不存在的，则自动向图中添加该顶点。</strong></p><blockquote><p>Graph.add_edge(u_of_edge, v_of_edge, **attr)<br>Graph.add_edges_from(ebunch_to_add, **attr)<br>Graph.add_weighted_edges_from(ebunch_to_add, weight=‘weight’, **attr)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 边(edge)的操作</span></span><br><span class="line"><span class="comment"># 向图中添加边</span></span><br><span class="line">G1.add_edge(<span class="number">1</span>,<span class="number">5</span>)  <span class="comment"># 向 G1 添加边，并自动添加图中没有的顶点</span></span><br><span class="line">G1.add_edge(<span class="number">0</span>,<span class="number">10</span>, weight=<span class="number">2.7</span>)  <span class="comment"># 向 G1 添加边，并设置边的属性</span></span><br><span class="line">G1.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="string">&#x27;weight&#x27;</span>:<span class="number">0</span>&#125;), (<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;blue&#x27;</span>&#125;)])  <span class="comment"># 向图中添加边，并设置属性</span></span><br><span class="line">G1.add_edges_from([(<span class="number">3</span>,<span class="number">6</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">7</span>),(<span class="number">5</span>,<span class="number">10</span>),(<span class="number">0</span>,<span class="number">1</span>)])  <span class="comment"># 向图中添加多条边</span></span><br><span class="line">G1.add_weighted_edges_from([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.6</span>),[<span class="number">6</span>,<span class="number">12</span>,<span class="number">0.5</span>]])  <span class="comment"># 向图中添加多条赋权边: (node1,node2,weight)</span></span><br><span class="line"><span class="built_in">print</span>(G1.nodes())  <span class="comment"># 查看顶点</span></span><br><span class="line"><span class="comment"># [2, 3, 0, 6, 10, 12, 1, 5, 7]  # 自动添加了图中没有的顶点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从图中删除边</span></span><br><span class="line">G1.remove_edge(<span class="number">0</span>,<span class="number">1</span>)  <span class="comment"># 从图中删除边 0-1</span></span><br><span class="line">G1.remove_edges_from([(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>)])  <span class="comment"># 从图中删除多条边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 边和边的属性</span></span><br><span class="line"><span class="built_in">print</span>(G1.edges)  <span class="comment"># 查看所有的边</span></span><br><span class="line"><span class="comment">#[(2, 1), (3, 6), (0, 10), (6, 12), (10, 5)]</span></span><br><span class="line"><span class="built_in">print</span>(G1.get_edge_data(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment"># 查看指定边的属性</span></span><br><span class="line"><span class="comment"># &#123;&#x27;weight&#x27;: 3.6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment"># 查看指定边的属性</span></span><br><span class="line"><span class="comment"># &#123;&#x27;weight&#x27;: 3.6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1.edges(data=<span class="literal">True</span>))  <span class="comment"># 查看所有边的属性</span></span><br><span class="line"><span class="comment"># [(2, 1, &#123;&#x27;weight&#x27;: 3.6&#125;), (3, 6, &#123;&#125;), (0, 10, &#123;&#x27;weight&#x27;: 2.7&#125;), (6, 12, &#123;&#x27;weight&#x27;: 0.5&#125;), (10, 5, &#123;&#125;)]</span></span><br></pre></td></tr></table></figure><h4 id="查看图、顶点和边的信息">查看图、顶点和边的信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看图、顶点和边的信息</span></span><br><span class="line"><span class="built_in">print</span>(G1.nodes)  <span class="comment"># 返回所有的顶点 [node1,...]</span></span><br><span class="line"><span class="comment"># [2, 3, 0, 6, 10, 12, 1, 5, 7]</span></span><br><span class="line"><span class="built_in">print</span>(G1.edges)  <span class="comment"># 返回所有的边 [(node1,node2),...]</span></span><br><span class="line"><span class="comment"># [(2, 1), (3, 6), (0, 10), (6, 12), (10, 5)]</span></span><br><span class="line"><span class="built_in">print</span>(G1.degree)  <span class="comment"># 返回各顶点的度 [(node1,degree1),...]</span></span><br><span class="line"><span class="comment"># [(2, 1), (3, 1), (0, 1), (6, 2), (10, 2), (12, 1), (1, 1), (5, 1), (7, 0)]</span></span><br><span class="line"><span class="built_in">print</span>(G1.number_of_nodes())  <span class="comment"># 返回顶点的数量</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="built_in">print</span>(G1.number_of_edges())  <span class="comment"># 返回边的数量</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(G1[<span class="number">10</span>])  <span class="comment"># 返回与指定顶点相邻的所有顶点的属性</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;&#x27;weight&#x27;: 2.7&#125;, 5: &#123;&#125;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1.adj[<span class="number">10</span>])  <span class="comment"># 返回与指定顶点相邻的所有顶点的属性</span></span><br><span class="line"><span class="comment"># &#123;0: &#123;&#x27;weight&#x27;: 2.7&#125;, 5: &#123;&#125;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment"># 返回指定边的属性</span></span><br><span class="line"><span class="comment"># &#123;&#x27;weight&#x27;: 3.6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1.adj[<span class="number">1</span>][<span class="number">2</span>])  <span class="comment"># 返回指定边的属性</span></span><br><span class="line"><span class="comment"># &#123;&#x27;weight&#x27;: 3.6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(G1.degree(<span class="number">10</span>))  <span class="comment"># 返回指定顶点的度</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nx.info:&#x27;</span>,nx.info(G1))  <span class="comment"># 返回图的基本信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nx.degree:&#x27;</span>,nx.degree(G1))  <span class="comment"># 返回图中各顶点的度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nx.density:&#x27;</span>,nx.degree_histogram(G1))  <span class="comment"># 返回图中度的分布</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nx.pagerank:&#x27;</span>,nx.pagerank(G1))  <span class="comment"># 返回图中各顶点的频率分布</span></span><br></pre></td></tr></table></figure><h4 id="图的属性和方法">图的属性和方法</h4><p><strong>图的方法</strong></p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">G.has_node(n)</td><td style="text-align:center">当图 G 中包括顶点 n 时返回 True</td></tr><tr><td style="text-align:center">G.has_edge(u, v)</td><td style="text-align:center">当图 G 中包括边 (u,v) 时返回 True</td></tr><tr><td style="text-align:center">G.number_of_nodes()</td><td style="text-align:center">返回 图 G 中的顶点的数量</td></tr><tr><td style="text-align:center">G.number_of_edges()</td><td style="text-align:center">返回 图 G 中的边的数量</td></tr><tr><td style="text-align:center">G.number_of_selfloops()</td><td style="text-align:center">返回 图 G 中的自循环边的数量</td></tr><tr><td style="text-align:center">G.degree([nbunch, weight])</td><td style="text-align:center">返回 图 G 中的全部顶点或指定顶点的度</td></tr><tr><td style="text-align:center">G.selfloop_edges([data, default])</td><td style="text-align:center">返回 图 G 中的全部的自循环边</td></tr><tr><td style="text-align:center">G.subgraph([nodes])</td><td style="text-align:center">从图 G1中抽取顶点[nodes]及对应边构成的子图</td></tr><tr><td style="text-align:center">union(G1,G2)</td><td style="text-align:center">合并图 G1、G2</td></tr><tr><td style="text-align:center"><a href="http://nx.info">nx.info</a>(G)</td><td style="text-align:center">返回图的基本信息</td></tr><tr><td style="text-align:center">nx.degree(G)</td><td style="text-align:center">返回图中各顶点的度</td></tr><tr><td style="text-align:center">nx.degree_histogram(G)</td><td style="text-align:center">返回图中度的分布</td></tr><tr><td style="text-align:center">nx.pagerank(G)</td><td style="text-align:center">返回图中各顶点的频率分布</td></tr><tr><td style="text-align:center">nx.add_star(G,[nodes],**attr)</td><td style="text-align:center">向图 G 添加星形网络</td></tr><tr><td style="text-align:center">nx.add_path(G,[nodes],**attr)</td><td style="text-align:center">向图 G 添加一条路径</td></tr><tr><td style="text-align:center">nx.add_cycle(G,[nodes],**attr)</td><td style="text-align:center">向图 G 添加闭合路径</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p><strong>例程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">G1.clear() <span class="comment"># 清空图G1</span></span><br><span class="line">nx.add_star(G1, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], weight=<span class="number">1</span>)  <span class="comment"># 添加星形网络：以第一个顶点为中心</span></span><br><span class="line"><span class="comment"># [(1, 2), (1, 3), (1, 4), (1, 5)]</span></span><br><span class="line">nx.add_path(G1, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], weight=<span class="number">2</span>)  <span class="comment"># 添加路径：顺序连接 n个节点的 n-1条边</span></span><br><span class="line"><span class="comment"># [(5, 6), (6, 8), (8, 9), (9, 10)]</span></span><br><span class="line">nx.add_cycle(G1, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>], weight=<span class="number">3</span>)  <span class="comment"># 添加闭合回路：循环连接 n个节点的 n 条边</span></span><br><span class="line"><span class="comment"># [(7, 8), (7, 12), (8, 9), (9, 10), (10, 12)]</span></span><br><span class="line"><span class="built_in">print</span>(G1.nodes)  <span class="comment"># 返回所有的顶点 [node1,...]</span></span><br><span class="line">nx.draw_networkx(G1)</span><br><span class="line">plt.show()<span class="comment">#打印图</span></span><br><span class="line"></span><br><span class="line">G2 = G1.subgraph([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">G3 = G1.subgraph([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">G = nx.union(G2, G3)</span><br><span class="line"><span class="built_in">print</span>(G.nodes)  <span class="comment"># 返回所有的顶点 [node1,...]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 8, 9, 10, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><h4 id="图的绘制">图的绘制</h4><p>可视化是图论和网络问题中很重要的内容。NetworkX 在 Matplotlib、Graphviz 等图形工具包的基础上，提供了丰富的绘图功能。</p><p>在此简单介绍图基于Matplotlib的基本绘图函数。基本绘图函数使用字典提供的位置将节点放置在散点图上，或者使用布局函数计算位置。</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>draw(G[,pos,ax])</strong></td><td style="text-align:center">基于 Matplotlib 绘制 图 G</td></tr><tr><td style="text-align:center"><strong>draw_networkx(G[, pos, arrows, with_labels])</strong></td><td style="text-align:center">基于 Matplotlib 绘制 图 G</td></tr><tr><td style="text-align:center">draw_networkx_nodes(G, pos[, nodelist, . . . ])</td><td style="text-align:center">绘制图 G 的顶点</td></tr><tr><td style="text-align:center">draw_networkx_edges(G, pos[, edgelist, . . . ])</td><td style="text-align:center">绘制图 G 的边</td></tr><tr><td style="text-align:center">draw_networkx_labels(G, pos[, labels, . . . ])</td><td style="text-align:center">绘制顶点的标签</td></tr><tr><td style="text-align:center">draw_networkx_edge_labels(G, pos[, . . . ])</td><td style="text-align:center">绘制边的标签</td></tr></tbody></table><p>其中，nx.draw() 和 nx.draw_networkx() 是最基本的绘图函数，并可以通过自定义函数属性或其它绘图函数设置不同的绘图要求。</p><blockquote><p>draw(G, pos=None, ax=None, **kwds)</p><p>draw_networkx(G, pos=None, arrows=True, with_labels=True, **kwds)</p></blockquote><p><strong>常用的属性</strong>定义如下：</p><ul><li>‘node_size’：指定节点大小，默认为300</li><li>‘node_color’：指定节点颜色、默认红色</li><li>‘node_shape’:节点的形状，指定圆形</li><li>‘alpha’：透明度，默认1.0，不透明</li><li>‘width’：指定边的宽度，默认1.0</li><li>‘edge_color’：边的颜色、默认黑色</li><li>‘style’：边的样式，可选‘solid’、‘dashed’、‘dotted’、‘dashdot’</li><li>‘with_labels’：节点是否带标签，默认为True</li><li>‘font_size’：带标签字体大小，默认12</li><li>‘font_color’：带标签字体颜色，默认黑色</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230815191138242.png" alt="image-20230815191138242"></p><h4 id="图的分析">图的分析</h4><p>NetworkX提供了图论函数对图的结构进行分析：</p><p><strong>子图</strong></p><ul><li>子图是指顶点和边都分别是图G的顶点和子集的边的子集的图</li><li>subgraph()方法，按顶点从图G中抽出子图</li></ul><p><strong>连通子图</strong></p><ul><li>如果图G中任意两点间互通，则G是连通图</li><li>connected_components()方法，返回连通子图的集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G = nx.path_graph(<span class="number">4</span>)</span><br><span class="line">nx.add_path(G, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># 连通子图</span></span><br><span class="line">listCC = [<span class="built_in">len</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">sorted</span>(nx.connected_components(G), key=<span class="built_in">len</span>, reverse=<span class="literal">True</span>)]</span><br><span class="line">maxCC = <span class="built_in">max</span>(nx.connected_components(G), key=<span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Connected components:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(listCC))  <span class="comment"># 所有连通子图</span></span><br><span class="line"><span class="comment"># Connected components:[4, 3]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Largest connected components:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(maxCC))  <span class="comment"># 最大连通子图</span></span><br><span class="line"><span class="comment"># Largest connected components:&#123;0, 1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p><strong>强连通图</strong></p><ul><li>如果<strong>有向图G</strong>中任意两点间相互连通，则G是强连通图</li><li>strongly_connected_components()方法，返回所有强连通子图列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强连通</span></span><br><span class="line">G = nx.path_graph(<span class="number">4</span>, create_using=nx.DiGraph())</span><br><span class="line">nx.add_path(G, [<span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 找出所有的强连通子图</span></span><br><span class="line">con = nx.strongly_connected_components(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(con),<span class="built_in">list</span>(con))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt; [&#123;8, 1, 2, 3&#125;, &#123;0&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>弱连通图</strong></p><ul><li>如果一个有向图G的基图是连通图，则有向图G是弱连通图</li><li>weakly_connected_components()方法，返回所有弱连通子图的列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 弱连通</span></span><br><span class="line">G = nx.path_graph(<span class="number">4</span>, create_using=nx.DiGraph())  <span class="comment">#默认生成节点 0,1,2,3 和有向边 0-&gt;1,1-&gt;2,2-&gt;3</span></span><br><span class="line">nx.add_path(G, [<span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>])  <span class="comment">#生成有向边：7-&gt;8-&gt;3</span></span><br><span class="line">con = nx.weakly_connected_components(G)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(con),<span class="built_in">list</span>(con))</span><br><span class="line"><span class="comment"># &lt;class &#x27;generator&#x27;&gt; [&#123;0, 1, 2, 3, 7, 8&#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 优化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】优化模型-4. 0-1规划</title>
      <link href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-4.%200-1%E8%A7%84%E5%88%92/"/>
      <url>/2023/08/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-4.%200-1%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1>0-1规划</h1><h2 id="基本介绍">基本介绍</h2><p>0-1整数规划是一类特殊的整数规划，变量的取值只能是0或者1。</p><p>0-1变量的描述开关、取舍、有无等逻辑关系、顺序关系，可以处理背包问题、指派问题、选址问题、计划安排、线路设计、人员安排等各种决策规划问题。进而，任何整数都可以用二进制表达，整数变量就可以表示为多个0-1变量的组合，因此任何整数规划都可以转化为0-1规划问题来处理。0-1规划问题与运筹学中的很多经典问题也有紧密联系。</p><p>在数学建模学习中，0-1规划主要用于求解互斥的决策问题、互斥的条件约束问题、固定费用问题和分派问题。0-1规划是数模竞赛的常见题型，国赛B题经常有0-1规划问题或可以转化为0-1规划问题。</p><p>0-1规划算法都比较复杂，大规模问题一般没有精确解法。本文任然使用PuLP库进行0-1规划问题的求解。该工具包的使用都比较简单。</p><h2 id="0-1规划的分类以及建模方法">0-1规划的分类以及建模方法</h2><p>规划问题的数学模型包括决策变量、约束条件和目标函数，围绕着这三个要素都可能存在互斥的情况，从而导出不同类型的0-1规划模型，其他建模方法也有差别。</p><h3 id="互斥的决策问题">互斥的决策问题</h3>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 优化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】优化模型-3. 非线性规划</title>
      <link href="/2023/08/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-3.%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
      <url>/2023/08/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-3.%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1>非线性规划</h1><h2 id="基本概念">基本概念</h2><p>当线性问题的三要素：目标函数、限制条件、决策变量，任意一个被破坏成非线性的时候，此时线性的问题就变成了非线性的问题。</p><p>概括来说，目标函数和约束条件包含非线性函数，就是非线性规划。</p><p>非线性规划没有统一的通用方法、算法来解决，各种方法有特定的应用范围和适用条件。另一方面，非线性规划问题在实践中不能获得全局的最优解，只能得到局部最优解或者近似最优解。</p><h4 id="数学基础">数学基础</h4><ul><li><p>多元非线性函数求极值</p></li><li><p>有等式约束的多元非线性函数求极值——拉格朗日乘子法</p></li><li><p>有不等式约束的多远非线性函数求极值</p><ol><li><p>法一：引入松弛变量将不等式约束转换为等式约束；</p><p>拉格朗日乘子法；</p></li><li><p>法二：KKT条件法（拉格朗日+KKT的方法避免了引入松弛变量，是解决约束优化方法的通用方法）：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809222215539.png" alt="image-20230809222215539"></p></li></ol></li></ul><h4 id="基本形式">基本形式</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809221156523.png" alt="image-20230809221156523"></p><h4 id="二次规划的基本形式">二次规划的基本形式</h4><p>目标函数是一个二次函数那就是一个二次规划</p><p>举例：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809221305784.png" alt="image-20230809221305784"></p><h2 id="Python解非线性规划问题">Python解非线性规划问题</h2><h3 id="Scipy库求解非线性规划问题">Scipy库求解非线性规划问题</h3><h4 id="scipy库对于各种函数以及算法的详细解释和用法文档">scipy库对于各种函数以及算法的详细解释和用法文档</h4><p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize">https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize</a></p><h4 id="非线性规划问题的描述">非线性规划问题的描述</h4><p>首先，我们回顾线性规划问题的标准形式：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230810105422403.png" alt="image-20230810105422403"></p><p>类似地，可以写出非线性规划的一般形式：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230810105431587.png" alt="image-20230810105431587"></p><p>其中： <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mi>n</mi><mo stretchy="false">]</mo><mi>T</mi><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false">]</mo><mi>T</mi></msup><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mi>n</mi><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">x = [ x 1 , . . . , x n ] T x=[x_1,...,x_n]^T x=[x1,...,xn]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>为决策变量， f(x) 为目标函数， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_j(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>和 $g_i(x) $为约束条件。</p><p>由此可见，非线性规划问题，<strong>实际上就是带有约束条件的非线性函数优化问题</strong>。</p><p>按照我们的学习模式，非线性规划问题的建模和求解与线性规划问题是类似的，按照以下步骤进行：</p><pre><code>问题定义，确定决策变量、目标函数和约束条件；模型构建，由问题描述建立数学方程，并转化为标准形式的数学模型；模型求解，用标准模型的优化算法对模型求解，得到优化结果。</code></pre><h4 id="区分约束条件、边界约束、等式约束、不等式约束">区分约束条件、边界约束、等式约束、不等式约束</h4><ol><li>约束条件包括：边界约束、等式约束、不等式约束</li><li>边界约束是指决策变量的约束</li><li>等式约束和不等式约束是方程约束</li></ol><h4 id="Scipy库求解非线性规划问题的函数">Scipy库求解非线性规划问题的函数</h4><p>Scipy 是 Python 算法库和数学工具包，包括最优化、线性代数、积分、插值、特殊函数、傅里叶变换、信号和图像处理、常微分方程求解等模块。<strong>推荐使用Scipy库中的optimize模块解决非线性规划问题</strong>。</p><p>scipy.optimize模块中提供了多种用于非线性规划问题的方法函数，适用于不同类型的问题。</p><ul><li>brent() : <strong>单变量无约束</strong>优化问题，混合使用<strong>牛顿法/二分法</strong></li><li>fmin()：<strong>多变量无约束</strong>优化问题，使用单纯形法，只需要利用函数值，不需要函数的导数或者二阶导数</li><li>leatsq()：非线性最小二乘问题，用于求解<strong>非线性最小二乘拟合问题</strong></li><li>minimize()：约束优化问题，使用<strong>拉格朗日乘子法</strong>将约束优化转化为无约束优化</li></ul><h4 id="Scipy-optimize-brent-求解单变量无约束优化问题">Scipy.optimize.brent()求解单变量无约束优化问题</h4><p>非线性规划最简单的形式是一维搜索，一维搜索的常用方法是<strong>函数逼近法</strong>和<strong>区间收缩法</strong>。</p><p>brent() 函数是 SciPy.optimize 模块中求解单变量无约束优化问题最小值的首选方法。这是<strong>牛顿法和二分法的混合方法，既能保证稳定性又能快速收敛</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.optimize.brent(func,args=(),brack=<span class="literal">None</span>,tol=<span class="number">1.48e-08</span>,full_output=<span class="number">0</span>,maxiter=<span class="number">500</span>)</span><br></pre></td></tr></table></figure><p><strong>主要参数</strong></p><ol><li>*func：callable f(x,args)     目标函数f(X)，以函数形式表示，可以通过*args传参</li><li>args：tuple    可选项，以f(x,*args)的形式将可变参数p传递给目标函数f(x,p)</li><li>brack：tuple   可选项，搜索算法的开始区间</li></ol><p><strong>主要返回值</strong></p><ol><li>xmin      返回函数达到最小值时的x（注意是局部最优，不一定是全局最优）</li><li>fval        返回函数的最优值（默认不返回，仅当full_output=1时返回）</li></ol><p><strong>使用例程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> brent, fmin_ncg, minimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. Demo1：单变量无约束优化问题(Scipy.optimize.brent)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objf</span>(<span class="params">x</span>):  <span class="comment"># 目标函数</span></span><br><span class="line">    fx = x**<span class="number">2</span> - <span class="number">8</span>*np.sin(<span class="number">2</span>*x+np.pi)</span><br><span class="line">    <span class="keyword">return</span> fx</span><br><span class="line"></span><br><span class="line">xIni = -<span class="number">5.0</span></span><br><span class="line">xOpt= brent(objf, brack=(xIni,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xIni=&#123;:.4f&#125;\tfxIni=&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(xIni,objf(xIni))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xOpt=&#123;:.4f&#125;\tfxOpt=&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(xOpt,objf(xOpt)))</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xIni=-<span class="number">5.0000</span>fxIni=<span class="number">29.3522</span></span><br><span class="line">xOpt=-<span class="number">0.7391</span>fxOpt=-<span class="number">7.4195</span></span><br></pre></td></tr></table></figure><h4 id="scipy-optimiaze-fmin-求解多变量无约束优化问题">scipy.optimiaze.fmin()求解多变量无约束优化问题</h4><p>多变量无约束优化问题的算法很多，分类方式也很多。从使用者的角度来说可以分为：<strong>只使用目标函数值、使用导数（梯度下降法）、使用二阶导数</strong>。大体来说，<strong>使用导数的算法收敛较快，使用二阶导数收敛更快，但是收敛快也容易陷入局部最优</strong>。</p><p>fmin() 函数是 SciPy.optimize 模块中求解多变量无约束优化问题（最小值）的首选方法，采用<strong>下山单纯性方法</strong>。下山单纯性方法又称 <strong>Nelder-Mead 法</strong>，<strong>只使用目标函数值，不需要导数或二阶导数值</strong>，是最重要的多维无约束优化问题数值方法之一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.optimize.fmin(func, x0, args=(), xtol=<span class="number">0.0001</span>, ftol=<span class="number">0.0001</span>, maxiter=<span class="literal">None</span>, maxfun=<span class="literal">None</span>, full_output=<span class="number">0</span>, disp=<span class="number">1</span>, retall=<span class="number">0</span>, callback=<span class="literal">None</span>, initial_simplex=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>主要参数</strong></p><ol><li>*func: callable f(x,args) 　　目标函数f(x)，以函数形式表示，可以通过 *args 传递参数</li><li><strong>x0：nadarray         搜索算法的初值</strong></li><li>args：tuple             可选项，以f(x,*args)形式将参数p传递给目标函数</li></ol><p><strong>主要返回值</strong></p><ol><li>xopt             返回最小值时的x值</li><li>fopt              返回最小值时的目标函数值，fopt=func(xopt)</li></ol><p><strong>使用例程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> brent, fmin, minimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Demo2：多变量无约束优化问题(Scipy.optimize.brent)</span></span><br><span class="line"><span class="comment"># Rosenbrock 测试函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objf2</span>(<span class="params">x</span>):  <span class="comment"># Rosenbrock benchmark function</span></span><br><span class="line">    fx = <span class="built_in">sum</span>(<span class="number">100.0</span> * (x[<span class="number">1</span>:] - x[:-<span class="number">1</span>] ** <span class="number">2.0</span>) ** <span class="number">2.0</span> + (<span class="number">1</span> - x[:-<span class="number">1</span>]) ** <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">return</span> fx</span><br><span class="line"></span><br><span class="line">xIni = np.array([-<span class="number">2</span>, -<span class="number">2</span>])</span><br><span class="line">xOpt = fmin(objf2, xIni)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xIni=&#123;:.4f&#125;,&#123;:.4f&#125;\tfxIni=&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(xIni[<span class="number">0</span>],xIni[<span class="number">1</span>],objf2(xIni)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xOpt=&#123;:.4f&#125;,&#123;:.4f&#125;\tfxOpt=&#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(xOpt[<span class="number">0</span>],xOpt[<span class="number">1</span>],objf2(xOpt)))</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xIni=-<span class="number">2.0000</span>,-<span class="number">2.0000</span>fxIni=<span class="number">3609.0000</span></span><br><span class="line">xOpt=<span class="number">1.0000</span>,<span class="number">1.0000</span>fxOpt=<span class="number">0.0000</span></span><br></pre></td></tr></table></figure><h4 id="使用scipy-optimize-minimize-求解非线性规划问题">使用scipy.optimize.minimize()求解非线性规划问题</h4><p><strong>函数说明</strong></p><p>minimize() 函数是 SciPy.optimize 模块中求解多变量优化问题的通用方法，可以调用多种算法，支持约束优化和无约束优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scipy.optimize.minimize(fun, x0, args=(), method=<span class="literal">None</span>, jac=<span class="literal">None</span>, hess=<span class="literal">None</span>, hessp=<span class="literal">None</span>, bounds=<span class="literal">None</span>, constraints=(), tol=<span class="literal">None</span>, callback=<span class="literal">None</span>, options=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>主要参数</strong></p><ol><li>*func          目标函数</li><li>x0：nadarray，shape(n)        搜索算法的初值，n是决策变量的个数</li><li>args     可选项，将可变参数给目标函数fun，导数函数jac（雅可比函数，梯度函数）和二阶导数函数hess（海丝函数）</li><li>method：str     可选项，选择优化算法。默认算法为BFGS, L-BFGS-B, SLSQP（取决于问题有没有<strong>边界条件和约束条件</strong>）</li><li>jac            可选项，梯度计算方法。以函数形式表示，或选择‘2-point’，‘3-point’，‘cs’。该选项只用于Newten-CG, dogleg, trust-ncg, trust-krylov, trust-exact和trust-constr算法。</li><li>bounds         可选项，变量的边界条件（上下限）。该选项只能用于Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell和trust-constr算法。</li><li>constraints        可选项，定义约束条件f(X)&gt;=0。该选项只能用于COBYLA，SLSQP和trust-constr算法，不同算法中对于约束条件的定义是不同的。</li></ol><p><strong>主要返回值</strong></p><ol><li>res             返回优化结果，以对象的方式返回，包括是否优化成功、决策变量的优化值xOpt等等</li></ol><p><strong>minimize()的优化算法选项</strong></p><p>optimize.minimize() 的默认算法为 BFGS, L-BFGS-B, SLSQP（取决于问题有没有边界条件和约束条件），可以通过 “method=None” 选项调用多种算法。</p><ol><li><p><strong>无约束条件问题优化算法</strong></p><ul><li><strong>method=‘CG’</strong>     非线性共轭梯度算法，只能处理无约束优化问题，需要使用一阶导数</li><li><strong>method=‘BFGS’</strong>    <strong>BFGS拟牛顿法</strong>，只能处理无约束优化问题，需要使用一阶导数函数。BFGS算法性能良好，是解决无约束优化问题的默认算法。</li><li><strong>method=‘Newton-CG’</strong>     截断牛顿法，只能处理无约束优化问题，需要一阶导数，<strong>适合处理大规模问题</strong></li><li><strong>method=‘dogleg’</strong>      dog-leg信赖域算法，需要使用梯度和Hessian(必须正定)，只能处理无约束优化问题，<strong>适合处理大规模问题</strong></li><li><strong>method=‘trust-exact’</strong>     求解无约束极小化问题的信赖域算法，需要梯度和Hessian（不需要正定）</li><li><strong>method=‘trust-krylov’</strong>      使用Newton-GLTR信赖域算法，需要使用梯度和Hession(必须正定)，只能处理无约束优化问题，<strong>适合处理中大规模</strong>问题</li></ul></li><li><p><strong>边界约束条件问题优化算法</strong></p><ul><li><p><strong>method=‘Nelder-Mead’</strong>        下山单纯性法，可以处理边界约束条件（决策变量的上下限），只使用目标函数，不使用导数，<strong>鲁棒性（robust）强</strong></p><blockquote><p>roboust，在科学领域表示系统的稳定性。在数据科学领域可以理解为：算法对数据变化的容忍度有多高。</p></blockquote></li><li><p><strong>method=‘L-BFGS-B’</strong>           <strong>改进的BFGS拟牛顿法</strong>，L指有限内存，B指约束边界，可以处理边界约束条件，需要使用一阶导函数。<strong>L-BFGS-B算法性能良好，内存消耗量小，适合处理大规模问题，是边界约束优问题的默认算法</strong></p></li><li><p><strong>method=‘Powell’</strong>             <strong>改进的共轭方法</strong>，可以处理边界约束条件（决策变量上下限）</p></li><li><p><strong>method=‘TNC’</strong>               截断牛顿法，可以处理边界约束条件</p></li></ul></li><li><p><strong>带有约束条件问题优化算法</strong>（注意区别：边界约束条件和约束条件）</p><ul><li><strong>method=‘COBYLA’</strong>        <strong>线性近似约束优化算法</strong>，通过对目标函数和约束条件的线性逼近处理非线性问题。<strong>只使用目标函数</strong>，不需要导数或者二阶导数值。可以处理约束条件。</li><li><strong>method=‘SLSQP’</strong>             <strong>贯序最小二乘规划算法</strong>，可以处理<strong>边界约束、等式约束、不等式约束</strong>。SLSQP<strong>算法性能良好，是解决带有约束条件优化问题的默认算法。</strong></li><li><strong>method=‘trust-constr’</strong>       <strong>信赖域算法</strong>，通用的约束最优化方法，<strong>适合处理大规模问题</strong></li></ul></li></ol><p><strong>minimize()使用例程</strong></p><p>编程步骤：</p><ol><li>导数scipy、numpy包</li><li>定义目标函数objtf3(x)，<strong>输入变量x表示向量</strong>，返回值fx是目标函数的计算结果</li><li>定义边界约束，即优化变量的上下限：<ul><li>minimize()默认无边界约束条件，即各自变量的取值范围没有限制</li><li><strong>如果设置边界约束，要对每个自变量（决策变量）定义其上下限，注意边界约束的格式</strong></li><li>如果某个自变量没有上限，或者没有下限，则表示为None</li></ul></li><li>定义x的初值，可以随意定义</li><li><strong>求解最小化问题</strong>，resRosen，其中目标函数objf3和<strong>搜索的初始点xIni</strong>是必须的，制定优化方法和边界条件都是可选项。<strong>如果优化问题是求最大值maxFx，可以通过minFx=-maxFx转化实现</strong></li><li>通过调用最小化问题的返回值resRosen.x得到最优点xOpt</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> brent, fmin, minimize</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Demo3：多变量边界约束优化问题(Scipy.optimize.minimize)</span></span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">objf3</span>(<span class="params">x</span>):  <span class="comment"># Rosenbrock 测试函数</span></span><br><span class="line">    fx = <span class="built_in">sum</span>(<span class="number">100.0</span> * (x[<span class="number">1</span>:] - x[:-<span class="number">1</span>] ** <span class="number">2.0</span>) ** <span class="number">2.0</span> + (<span class="number">1</span> - x[:-<span class="number">1</span>]) ** <span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">return</span> fx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义边界约束（优化变量的上下限）</span></span><br><span class="line">b0 = (<span class="number">0.0</span>, <span class="literal">None</span>)  <span class="comment"># 0.0 &lt;= x[0] &lt;= Inf</span></span><br><span class="line">b1 = (<span class="number">0.0</span>, <span class="number">10.0</span>)  <span class="comment"># 0.0 &lt;= x[1] &lt;= 10.0</span></span><br><span class="line">b2 = (-<span class="number">5.0</span>, <span class="number">100.</span>)  <span class="comment"># -5.0 &lt;= x[2] &lt;= 100.0</span></span><br><span class="line">bnds = (b0, b1, b2)  <span class="comment"># 边界约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化计算</span></span><br><span class="line">xIni = np.array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>])</span><br><span class="line">resRosen = minimize(objf3, xIni, method=<span class="string">&#x27;SLSQP&#x27;</span>, bounds=bnds)</span><br><span class="line">xOpt = resRosen.x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;xOpt = &#123;:.4f&#125;, &#123;:.4f&#125;, &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(xOpt[<span class="number">0</span>],xOpt[<span class="number">1</span>],xOpt[<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;min f(x) = &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(objf3(xOpt)))</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xOpt = <span class="number">1.0000</span>, <span class="number">1.0000</span>, <span class="number">1.0000</span></span><br><span class="line"><span class="built_in">min</span> f(x) = <span class="number">0.0000</span></span><br></pre></td></tr></table></figure><h2 id="例题">例题</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230810001339296.png" alt="image-20230810001339296"></p><h3 id="代码实现一般步骤">代码实现一般步骤</h3><ol><li><p>得到非线性规划的基本形式</p><ol><li>目标函数F=F1+F2+F3，求最小值</li><li>约束条件 P1+P2+P3=700</li><li>边界约束：100&lt;=P1&lt;=200，120&lt;=P2&lt;=250，150&lt;=P3&lt;=300</li></ol></li><li><p>代码实现过程</p><ul><li><p>先将非线性规划表达为标准形式：</p><ol><li>求目标函数最小值</li><li>约束条件函数均为&gt;=形式</li></ol></li><li><p>定义目标函数funcOpt</p></li><li><p>定义边界约束</p></li><li><p>随机定义初始参数值x0向量</p></li><li><p>定义约束条件函数</p></li><li><p>定义约束条件（minimize函数以字典格式表示约束条件）</p><ol><li>{‘type’:‘ineq’, ‘fun’:functionname}格式进行定义</li><li>type键值可选：ineq、eq，分别表示等式条件约束或者不等式条件约束</li><li>fun键值为约束条件函数名</li></ol></li><li><p>调用minimize函数进行求解最优值：</p><ol><li>一般条件下选择算法（method）思路：<ul><li>解决带<strong>有边界约束、等式以及不等式条件约束</strong>的非线性规划问题：SLSQP算法</li><li>解决<strong>仅带有边界约束</strong>的非线性规划问题：L-BFGS-B算法，有限内存拟牛顿约束边界算法</li><li>解决<strong>无条件约束</strong>的优化算法：BFGS拟牛顿算法</li></ul></li><li>constraints参数接受一个元组，元组内存放的是约束条件字典</li><li>args参数，取决于代码实现需要进行给目标函数传参的方式</li></ol></li></ul></li><li><p>代码打印结果</p><ol><li>res.message，是否优化成功</li><li>res.x，自变量优化值</li><li>res.fun，目标函数优化值</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 优化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】优化模型-2. 整数规划(线性)</title>
      <link href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-2.%20%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92(%E7%BA%BF%E6%80%A7)/"/>
      <url>/2023/08/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-2.%20%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92(%E7%BA%BF%E6%80%A7)/</url>
      
        <content type="html"><![CDATA[<h1>整数规划</h1><h2 id="整数规划基本概念">整数规划基本概念</h2><h4 id="整数规划问题">整数规划问题</h4><p>线性规划问题的最优解可能是小数或者分数。整数规划是指变量的取值只能是整数的规划。这在实际问题中很常见，例如车间人数、设备台数、行驶次数，这些变量显然必须取整数解。</p><p>整数规划并不一定是线性规划问题的变量取整限制，对于二次规划、非线性规划问题也有变量取整限制而引出的整数规划。但在数学建模问题中所说的整数规划，通常是指整数线性规划。</p><p>根据变量的不同情况，整数规划又分为：</p><ul><li>完全整数规划，全部变量都要求是整数</li><li>混合整数规划，部分变量要求是整数</li><li>0-1整数规划，变量的取值只能是0或者1</li><li>混合0-1规划，部分变量的取值只能是0或1</li></ul><h2 id="整数规划的求解方法">整数规划的求解方法</h2><h4 id="分支定界法">分支定界法</h4><p>基本思想：把原问题（整数规划问题）转换为一个个线性规划问题来解决，并在求解这些线性规划问题的过程中不断追踪原问题的上界（最优可行解）和下界（最优线性松弛解）。</p><p>分支界定法把全部可行解空间反复地分割为越来越小的子集，称为<strong>分支</strong>；并且对每个子集内的解集计算一个目标的上界，称为<strong>定界</strong>，每次分支后，对于超出已知可行解集目标值的那些子集不再进一步分枝，就可以删减很多子集，这称为<strong>剪枝。</strong></p><p>具体来说：设有<strong>最大化</strong>整数规划问题A，先解与之相应的线性规划问题B，若B的最优解不符合A的整数条件，则B的最优化目标函数<strong>必是A的最优目标函数z的上界</strong>，记为z2。而<strong>A的任意可行解的目标函数值将是z的一个下界z1</strong>。分支定界法就是将B的可行域分成子区域（分支）的方法，逐步减小z2和增大z1，最终求到z。</p><p>分支定界法是一个迭代算法，随着迭代过程<strong>不断更新上界和下界，直到上界和下界非常接近时结束</strong>。<strong>通常设置 Gap &lt;  0.1%，就可把当前的最优可行解近似为问题的全局最优解了</strong>。因此，分支定界法的**“收敛”**  不是分析意义上的而是算法意义上的，优化结果是近似解而不是精确解。</p><p><strong>分支定界法不用区分完全整数规划和混合整数规划，算法便于实现，但是计算量比较大。</strong></p><h4 id="割平面法">割平面法</h4><p>基本思想：先求解普通线性规划问题的最优解，再对非整数解添加约束条件使可行域缩小，如此反复求解添加了约束条件的普通线性规划问题，直到得到整数解。</p><p>也就是说，<strong>先不考虑整数约束条件，直接求解松弛问题的最优解</strong>，如果满足整数条件就结束了，如果不满足整数条件，就在此非整数解的基础上<strong>增加新的约束条件重新求解</strong>。这个新增加的约束条件称为割平面，对松弛问题的可行域割一刀，割去松弛问题的部分非整数解。经过有限次的反复切割，必定可在缩小的可行域的一个整数极点上达到整数规划问题的最优解 。</p><p>割平面法的计算量比较小，但是对于问题的结构以及求解的要求比较高，算法比较复杂。</p><h2 id="关于Python工具包的相关问题">关于Python工具包的相关问题</h2><p>线性规划、整数规划这些模型，算法还不是很复杂，第三方软件包也很丰富。</p><p>但是，Scipy 只能求解线性规划，不能求解整数规划，如果选择 Scipy 做线性规划，那在学整数规划时就要再学另一种工具包，二者的模型描述、函数定义、参数设置肯定也是不同的。接下来遇到非线性规划问题再学一种软件包。</p><p>所以建议线性规划和整数规划都使用Python的PuLP工具包。</p><p>优势：</p><ol><li>解题过程和编程步骤方面，线性规划和整数规划完全一致</li><li>便于熟练掌握解题方法，不与其他模型搞混</li></ol><h2 id="例题">例题</h2><h3 id="问题描述">问题描述</h3><p>某厂生产甲乙两种饮料，每百箱甲饮料需用原料 6千克、工人 10名，获利 10万元；每百箱乙饮料需用原料 5千克、工人 20名，获利 9万元。<br>今工厂共有原料 60千克、工人 150名，又由于其他条件所限甲饮料产量不超过8百箱。<br>问题 1：问如何安排生产计划，即两种饮料各生产多少使获利最大？<br>问题 2：若投资0.8万元可增加原料1千克，是否应作这项投资？投资多少合理？<br>问题 3：若不允许散箱（按整百箱生产），如何安排生产计划，即两种饮料各生产多少使获利最大？<br>问题 4：若不允许散箱（按整百箱生产），若投资0.8万元可增加原料1千克，是否应作这项投资？投资多少合理？</p><h3 id="建模过程分析">建模过程分析</h3><p>线性规划和整数规划问题的建模和求解，通常可以按照问题定义、模型构建、模型求解的步骤进行。</p><h4 id="问题定义">问题定义</h4><p>问题定义，确定决策变量、目标函数和约束条件。</p><ol><li><p>决策变量</p><ul><li>对于问题一，决策变量很明确，就是甲和乙两张饮料的产量</li><li>对于问题二，决策变量应该是投资金额（成本）、甲和乙的产量；所以问题二的决策变量有3个</li></ul></li><li><p>目标函数</p><p>目标函数是决策变量的函数，我们希望通过改变决策变量的值而获得目标函数的最大值或者最小值。通常是总成本最小，总利润最大，总时间最短。</p><ol><li>对于本案例，每个问题都是希望获得最大利润，目标函数都是总利润，问题是<strong>求目标函数利润的最大值</strong>。</li></ol></li><li><p>约束条件</p><ol><li><p>不等式约束：原料60kg，工人150名，甲饮料不超过800箱。</p></li><li><p>等式约束：本题没有</p></li><li><p>决策变量的边界约束</p><p>通常，题目隐含决策变量大于0的条件，例如工人人数、原料数都大于0；另外，如果能通过分析前面的等式约束或不等式约束，得出决策变量的上限，将会极大地提高问题求解的速度和性能。</p></li></ol></li></ol><h4 id="模型构建">模型构建</h4><p>模型构建，由问题描述建立数学方程，并转化为标准形式的数学模型。</p><p>对于问题一，目标函数是生产甲、乙两种饮料的总利润，约束条件式原料总量、工人总数约束，而且原料、工人都要大于0。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230814111839950.png" alt="image-20230814111839950"></p><p>进一步分析决策变量取值范围的约束条件，由原料数量、工人数量的不等式约束可以推出（但实际上x1范围可以更小，即0~8）：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230814111856158.png" alt="image-20230814111856158"></p><p>对于问题 2，可以通过增加投资来获得更多的原料，投资额是一个新的变量。要注意的是，此时目标函数虽然也是生产两种饮料的总利润，但总利润不等于总收入，而是总收入减去总成本，在本例中就是要减去购买原料的投资。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230814111929924.png" alt="image-20230814111929924"></p><p>对于问题 3 和问题 4，区别只是不允许散箱，明确提出了决策变量 x1、x2 的取值要取整数值，所以是整数规划问题。<br>需要注意的是，问题 4 中对增加的投资额即购买的原料数量并没有整数限制，因此 x1、x2 的取值范围是正整数，但 x3 的取值范围是正数，这是一个混合整数规划问题。<br>还要说明的是，对于问题 1 和问题 2，虽然题目中没有明确要求生产甲、乙饮料的工人人数为整数，但是人数也不可能是小数的，那么这是不是也是整数规划问题呢？<br>我的理解是，这个问题怎么说都可以。<strong>如果要简化问题，使用线性规划模型，最好在问题假设中说一句，假设甲乙饮料在同一车间先后生产，只要允许甲乙饮料散箱生产，即使根据产量所求出的工人数是小数，也可以解释的通。<strong>如果你掌握了整数规划问题的求解，那就</strong>先按线性规划建模，再补充讨论工人人数也必须是整数的条件，按整数规划建模求解</strong>，这就是妥妥的获奖论文了。</p><h4 id="模型求解">模型求解</h4><p>用标准模型的优化算法对模型进行求解，得到优化结果。</p><p>（0）导入 PuLP库函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br></pre></td></tr></table></figure><p>（1）定义一个规划问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProbLP1 = pulp.LpProblem(<span class="string">&quot;ProbLP1&quot;</span>, sense=pulp.LpMaximize)    <span class="comment"># 定义问题 1，求最大值</span></span><br></pre></td></tr></table></figure><p>pulp.LpProblem 用来定义问题的构造函数。&quot;ProbLP1&quot;是用户定义的问题名。<br>参数 sense 指定问题求目标函数的最小值/最大值 。<strong>本例求最大值，选择 “pulp.LpMaximize” 。</strong></p><p>（2）定义决策变量<br>对于问题 1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">15</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x1</span></span><br><span class="line">x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7.5</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x2</span></span><br></pre></td></tr></table></figure><p>pulp.LpVariable 用来<strong>定义决策变量</strong>的函数。<strong>‘x1’、‘x2’ 是用户定义的变量名</strong>。<br><strong>参数 lowBound、upBound 用来设定决策变量的下界、上界</strong>；可以不定义下界/上界，默认的下界/上界是负无穷/正无穷。本例中 x1、x2 的取值区间分别为 [0,15]、[0,7.5]。<br><strong>参数 cat 用来设定变量类型，可选参数值：‘Continuous’ 表示连续变量（默认值）、’ Integer ’ 表示离散变量（用于整数规划问题）、’ Binary ’ 表示0/1变量（用于0/1规划问题）</strong>。</p><p>对于问题 3， 甲乙饮料产量 x1、x2 必须取整数，是整数规划问题，因此要设置变量类型为离散变量（整数变量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">15</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x1，变量类型：整数</span></span><br><span class="line">x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7.5</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x2，变量类型：整数</span></span><br></pre></td></tr></table></figure><p>（3）添加目标函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProbLP1 += (<span class="number">10</span>*x1 + <span class="number">9</span>*x2)  <span class="comment"># 设置目标函数 f(x)</span></span><br></pre></td></tr></table></figure><p><strong>添加目标函数使用 “问题名 += 目标函数式” 格式。</strong></p><p>（4）添加约束条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProbLP1 += (<span class="number">6</span>*x1 + <span class="number">5</span>*x2 &lt;= <span class="number">60</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">ProbLP1 += (<span class="number">10</span>*x1 + <span class="number">20</span>*x2 &lt;= <span class="number">150</span>)  <span class="comment"># 不等式约束</span></span><br></pre></td></tr></table></figure><p><strong>添加约束条件使用 “问题名 += 约束条件表达式” 格式。</strong><br><strong>约束条件可以是等式约束或不等式约束，不等式约束可以是 小于等于 或 大于等于，分别使用关键字&quot;&gt;=“、”&lt;=“和”==&quot;。</strong></p><p>（5）求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProbLP1.solve()</span><br><span class="line"><span class="built_in">print</span>(ProbLP1.name)  <span class="comment"># 输出求解状态</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Status:&quot;</span>, pulp.LpStatus[ProbLP1.status])  <span class="comment"># 输出求解状态</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> ProbLP1.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)  <span class="comment"># 输出每个变量的最优值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F1(x) =&quot;</span>, pulp.value(ProbLP1.objective))  <span class="comment"># 输出最优解的目标函数值</span></span><br></pre></td></tr></table></figure><p>solve() 是求解函数，可以对求解器、求解精度进行设置。<br>PuLP默认采用 CBC 求解器来求解优化问题，也可以调用其它的优化器来求解，但需要另外安装。</p><h4 id="Python例程">Python例程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mathmodel05_v1.py</span></span><br><span class="line"><span class="comment"># Demo05 of mathematical modeling algorithm</span></span><br><span class="line"><span class="comment"># Solving integer programming with PuLP.</span></span><br><span class="line"><span class="comment"># Copyright 2021 Youcans, XUPT</span></span><br><span class="line"><span class="comment"># Crated：2021-05-31</span></span><br><span class="line"><span class="comment"># Python小白的数学建模课 @ Youcans</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pulp      <span class="comment"># 导入 pulp 库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型参数设置</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题描述：</span></span><br><span class="line"><span class="string">        某厂生产甲乙两种饮料，每百箱甲饮料需用原料6千克、工人10名，获利10万元；每百箱乙饮料需用原料5千克、工人20名，获利9万元。</span></span><br><span class="line"><span class="string">        今工厂共有原料60千克、工人150名，又由于其他条件所限甲饮料产量不超过8百箱。</span></span><br><span class="line"><span class="string">        （1）问如何安排生产计划，即两种饮料各生产多少使获利最大？</span></span><br><span class="line"><span class="string">        （2）若投资0.8万元可增加原料1千克，是否应作这项投资？投资多少合理？</span></span><br><span class="line"><span class="string">        （3）若不允许散箱（按整百箱生产），如何安排生产计划，即两种饮料各生产多少使获利最大？</span></span><br><span class="line"><span class="string">        （4）若不允许散箱（按整百箱生产），若投资0.8万元可增加原料1千克，是否应作这项投资？投资多少合理？</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题 1：</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题建模：</span></span><br><span class="line"><span class="string">        决策变量：</span></span><br><span class="line"><span class="string">            x1：甲饮料产量（单位：百箱）</span></span><br><span class="line"><span class="string">            x2：乙饮料产量（单位：百箱）</span></span><br><span class="line"><span class="string">        目标函数：</span></span><br><span class="line"><span class="string">            max fx = 10*x1 + 9*x2</span></span><br><span class="line"><span class="string">        约束条件：</span></span><br><span class="line"><span class="string">            6*x1 + 5*x2 &lt;= 60</span></span><br><span class="line"><span class="string">            10*x1 + 20*x2 &lt;= 150            </span></span><br><span class="line"><span class="string">            x1, x2 &gt;= 0，x1 &lt;= 8</span></span><br><span class="line"><span class="string">    此外，由 x1,x2&gt;=0 和 10*x1+20*x2&lt;=150 可知 0&lt;=x2&lt;=7.5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ProbLP1 = pulp.LpProblem(<span class="string">&quot;ProbLP1&quot;</span>, sense=pulp.LpMaximize)    <span class="comment"># 定义问题 1，求最大值</span></span><br><span class="line">    x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">8</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x1</span></span><br><span class="line">    x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7.5</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x2</span></span><br><span class="line">    ProbLP1 += (<span class="number">10</span>*x1 + <span class="number">9</span>*x2)  <span class="comment"># 设置目标函数 f(x)</span></span><br><span class="line">    ProbLP1 += (<span class="number">6</span>*x1 + <span class="number">5</span>*x2 &lt;= <span class="number">60</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP1 += (<span class="number">10</span>*x1 + <span class="number">20</span>*x2 &lt;= <span class="number">150</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP1.solve()</span><br><span class="line">    <span class="built_in">print</span>(ProbLP1.name)  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Status youcans:&quot;</span>, pulp.LpStatus[ProbLP1.status])  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> ProbLP1.variables():</span><br><span class="line">        <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)  <span class="comment"># 输出每个变量的最优值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F1(x) =&quot;</span>, pulp.value(ProbLP1.objective))  <span class="comment"># 输出最优解的目标函数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题 2：</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题建模：</span></span><br><span class="line"><span class="string">        决策变量：</span></span><br><span class="line"><span class="string">            x1：甲饮料产量（单位：百箱）</span></span><br><span class="line"><span class="string">            x2：乙饮料产量（单位：百箱）</span></span><br><span class="line"><span class="string">            x3：增加投资（单位：万元）</span></span><br><span class="line"><span class="string">        目标函数：</span></span><br><span class="line"><span class="string">            max fx = 10*x1 + 9*x2 - x3</span></span><br><span class="line"><span class="string">        约束条件：</span></span><br><span class="line"><span class="string">            6*x1 + 5*x2 &lt;= 60 + x3/0.8</span></span><br><span class="line"><span class="string">            10*x1 + 20*x2 &lt;= 150</span></span><br><span class="line"><span class="string">            x1, x2, x3 &gt;= 0，x1 &lt;= 8</span></span><br><span class="line"><span class="string">    此外，由 x1,x2&gt;=0 和 10*x1+20*x2&lt;=150 可知 0&lt;=x2&lt;=7.5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ProbLP2 = pulp.LpProblem(<span class="string">&quot;ProbLP2&quot;</span>, sense=pulp.LpMaximize)    <span class="comment"># 定义问题 2，求最大值</span></span><br><span class="line">    x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">8</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x1</span></span><br><span class="line">    x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7.5</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x2</span></span><br><span class="line">    x3 = pulp.LpVariable(<span class="string">&#x27;x3&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x3</span></span><br><span class="line">    ProbLP2 += (<span class="number">10</span>*x1 + <span class="number">9</span>*x2 - x3)  <span class="comment"># 设置目标函数 f(x)</span></span><br><span class="line">    ProbLP2 += (<span class="number">6</span>*x1 + <span class="number">5</span>*x2 - <span class="number">1.25</span>*x3 &lt;= <span class="number">60</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP2 += (<span class="number">10</span>*x1 + <span class="number">20</span>*x2 &lt;= <span class="number">150</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP2.solve()</span><br><span class="line">    <span class="built_in">print</span>(ProbLP2.name)  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Status  youcans:&quot;</span>, pulp.LpStatus[ProbLP2.status])  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> ProbLP2.variables():</span><br><span class="line">        <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)  <span class="comment"># 输出每个变量的最优值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F2(x) =&quot;</span>, pulp.value(ProbLP2.objective))  <span class="comment"># 输出最优解的目标函数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题 3：整数规划问题</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题建模：</span></span><br><span class="line"><span class="string">        决策变量：</span></span><br><span class="line"><span class="string">            x1：甲饮料产量，正整数（单位：百箱）</span></span><br><span class="line"><span class="string">            x2：乙饮料产量，正整数（单位：百箱）</span></span><br><span class="line"><span class="string">        目标函数：</span></span><br><span class="line"><span class="string">            max fx = 10*x1 + 9*x2</span></span><br><span class="line"><span class="string">        约束条件：</span></span><br><span class="line"><span class="string">            6*x1 + 5*x2 &lt;= 60</span></span><br><span class="line"><span class="string">            10*x1 + 20*x2 &lt;= 150</span></span><br><span class="line"><span class="string">            x1, x2 &gt;= 0，x1 &lt;= 8，x1, x2 为整数</span></span><br><span class="line"><span class="string">    此外，由 x1,x2&gt;=0 和 10*x1+20*x2&lt;=150 可知 0&lt;=x2&lt;=7.5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ProbLP3 = pulp.LpProblem(<span class="string">&quot;ProbLP3&quot;</span>, sense=pulp.LpMaximize)  <span class="comment"># 定义问题 3，求最大值</span></span><br><span class="line">    <span class="built_in">print</span>(ProbLP3.name)  <span class="comment"># 输出求解状态</span></span><br><span class="line">    x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">8</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x1，变量类型：整数</span></span><br><span class="line">    x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7.5</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x2，变量类型：整数</span></span><br><span class="line">    ProbLP3 += (<span class="number">10</span> * x1 + <span class="number">9</span> * x2)  <span class="comment"># 设置目标函数 f(x)</span></span><br><span class="line">    ProbLP3 += (<span class="number">6</span> * x1 + <span class="number">5</span> * x2 &lt;= <span class="number">60</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP3 += (<span class="number">10</span> * x1 + <span class="number">20</span> * x2 &lt;= <span class="number">150</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP3.solve()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shan Status:&quot;</span>, pulp.LpStatus[ProbLP3.status])  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> ProbLP3.variables():</span><br><span class="line">        <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)  <span class="comment"># 输出每个变量的最优值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F3(x) =&quot;</span>, pulp.value(ProbLP3.objective))  <span class="comment"># 输出最优解的目标函数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 问题 4：</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题建模：</span></span><br><span class="line"><span class="string">        决策变量：</span></span><br><span class="line"><span class="string">            x1：甲饮料产量，正整数（单位：百箱）</span></span><br><span class="line"><span class="string">            x2：乙饮料产量，正整数（单位：百箱）</span></span><br><span class="line"><span class="string">            x3：增加投资（单位：万元）</span></span><br><span class="line"><span class="string">        目标函数：</span></span><br><span class="line"><span class="string">            max fx = 10*x1 + 9*x2 - x3</span></span><br><span class="line"><span class="string">        约束条件：</span></span><br><span class="line"><span class="string">            6*x1 + 5*x2 &lt;= 60 + x3/0.8</span></span><br><span class="line"><span class="string">            10*x1 + 20*x2 &lt;= 150</span></span><br><span class="line"><span class="string">            x1, x2, x3 &gt;= 0，x1 &lt;= 8，x1, x2 为整数</span></span><br><span class="line"><span class="string">    此外，由 x1,x2&gt;=0 和 10*x1+20*x2&lt;=150 可知 0&lt;=x2&lt;=7.5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    ProbLP4 = pulp.LpProblem(<span class="string">&quot;ProbLP4&quot;</span>, sense=pulp.LpMaximize)  <span class="comment"># 定义问题 4，求最大值</span></span><br><span class="line">    <span class="built_in">print</span>(ProbLP4.name)  <span class="comment"># 输出求解状态</span></span><br><span class="line">    x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">8</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x1，变量类型：整数</span></span><br><span class="line">    x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">7</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)  <span class="comment"># 定义 x2，变量类型：整数</span></span><br><span class="line">    x3 = pulp.LpVariable(<span class="string">&#x27;x3&#x27;</span>, lowBound=<span class="number">0</span>, cat=<span class="string">&#x27;Continuous&#x27;</span>)  <span class="comment"># 定义 x3</span></span><br><span class="line">    ProbLP4 += (<span class="number">10</span>*x1 + <span class="number">9</span>*x2 - x3)  <span class="comment"># 设置目标函数 f(x)</span></span><br><span class="line">    ProbLP4 += (<span class="number">6</span>*x1 + <span class="number">5</span>*x2 - <span class="number">1.25</span>*x3 &lt;= <span class="number">60</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP4 += (<span class="number">10</span>*x1 + <span class="number">20</span>*x2 &lt;= <span class="number">150</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">    ProbLP4.solve()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shan Status:&quot;</span>, pulp.LpStatus[ProbLP4.status])  <span class="comment"># 输出求解状态</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> ProbLP4.variables():</span><br><span class="line">        <span class="built_in">print</span>(v.name, <span class="string">&quot;=&quot;</span>, v.varValue)  <span class="comment"># 输出每个变量的最优值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F4(x) =&quot;</span>, pulp.value(ProbLP4.objective))  <span class="comment"># 输出最优解的目标函数值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  <span class="comment"># Copyright 2021 YouCans, XUPT</span></span><br><span class="line">    main()  <span class="comment"># Python小白的数学建模课 @ Youcans</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the CBC MILP Solver </span><br><span class="line">Version: <span class="number">2.9</span><span class="number">.0</span> </span><br><span class="line">Build Date: Feb <span class="number">12</span> <span class="number">2015</span> </span><br><span class="line"></span><br><span class="line">ProbLP1</span><br><span class="line">Status: Optimal</span><br><span class="line">x1 = <span class="number">6.4285714</span></span><br><span class="line">x2 = <span class="number">4.2857143</span></span><br><span class="line">F1(x) = <span class="number">102.8571427</span></span><br><span class="line"></span><br><span class="line">ProbLP2</span><br><span class="line">Status: Optimal</span><br><span class="line">x1 = <span class="number">8.0</span></span><br><span class="line">x2 = <span class="number">3.5</span></span><br><span class="line">x3 = <span class="number">4.4</span></span><br><span class="line">F2(x) = <span class="number">107.1</span></span><br><span class="line"></span><br><span class="line">ProbLP3</span><br><span class="line">Result - Optimal solution found</span><br><span class="line">Status Shan: Optimal</span><br><span class="line">Status: Optimal</span><br><span class="line">x1 = <span class="number">8.0</span></span><br><span class="line">x2 = <span class="number">2.0</span></span><br><span class="line">F3(x) = <span class="number">98.0</span></span><br><span class="line"></span><br><span class="line">ProbLP4</span><br><span class="line">Result - Optimal solution found</span><br><span class="line">Status: Optimal</span><br><span class="line">x1 = <span class="number">8.0</span></span><br><span class="line">x2 = <span class="number">3.0</span></span><br><span class="line">x3 = <span class="number">2.4</span></span><br><span class="line">F4(x) = <span class="number">104.6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 优化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数学建模】优化模型-1. 线性规划</title>
      <link href="/2023/08/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-1.%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
      <url>/2023/08/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E3%80%91%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B-1.%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h4 id="相关链接">相关链接</h4><p>[[【数学建模】优化模型-2-整数规划(线性)]]<br>[[【数学建模】优化模型-4-0-1规划]]<br>[[【数学建模】优化模型-3-非线性规划]]<br>[[【数学建模】优化模型-5-固定费用问题]]<br>[[【数学建模】优化模型-6-图论以及最小路径问题]]</p><h1>线性规划模型</h1><h2 id="要点">要点</h2><h4 id="线性规划的矩阵形式">线性规划的矩阵形式</h4><ul><li>不等式组条件的矩阵化</li><li>方程组条件的矩阵化</li><li>每个变量自己的取值范围</li><li>目标函数的向量化</li></ul><ol><li>决策变量</li><li>目标函数</li><li>约束条件</li></ol><h4 id="标准形式">标准形式</h4><p>只要是通过程序解决线性规划问题，一定是求最小值。如果实际问题是求最大值，那么我们加个负号即可。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809210530764.png" alt="image-20230809210530764"></p><p>如何理解线性规划的标准形式？</p><ul><li>问题是线性的最大值或者最小值</li><li>约束条件本应该是小于等于，这是通用形式。（如果要改为等于，则要用其他方式转换）</li><li>存在不等约束变换可以应用松弛变量</li><li>规划问题的核心在于决策变量，目标函数和约束条件</li></ul><h2 id="线性规划的求解的基本原理">线性规划的求解的基本原理</h2><ol><li><p>单纯形法</p><p>基本思想：固定变量，不断变换基向量求方程组带入，看看是不是最优解，如果不适合就更新迭代现阶段的解。</p><p>单纯形法实际上就是<strong>解方程组</strong>，特点是结果比较精确。</p></li><li><p>蒙特卡洛法</p><p>在可行域范围内生成大批量的随机数据点，观测这些数据在什么点位置取得最优。</p><p>基本思想：大量的重复性试验，以频率估计概率。</p><p>由于生成的点事随机的，所以必须要生成大批数据进行计算，然后求出来的也只是数值的近似最优解，更多<strong>适用于解非线性问题</strong>，因为线性问题是可以得到精确的解的。</p></li></ol><h4 id="线性规划中引入松弛变量">线性规划中引入松弛变量</h4><p>引入松弛变量可以把不等式转化为等式进行计算，我们对于等式可以有更多的更高级的处理。</p><p>此外，如果我们要用单纯形法得到最优解，那么我们最终实际上也是在解方程组，而不等式约束不是方程，我们可以通过引入松弛变量的方法将不等式变成等式约束。</p><p>基本思想和转换方法：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809220343585.png" alt="image-20230809220343585"></p><h4 id="何时引入松弛变量">何时引入松弛变量</h4><ul><li>当遇到绝对值不等式的时候</li><li>当遇到的不等式过多或者遇到了非线性的不等关系的时候</li><li>…</li></ul><h4 id="引入松弛变量以后得规划求解">引入松弛变量以后得规划求解</h4><ul><li>蒙特卡罗法</li><li>分支定界法</li><li>单纯形法</li><li>…</li></ul><h3 id="线性规划例题">线性规划例题</h3><p>例题1：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809230303492.png" alt="image-20230809230303492"></p><h3 id="Python代码实现">Python代码实现</h3><h4 id="scipy库实现">scipy库实现</h4><p>对着标准形式来</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230809210530764.png" alt="image-20230809210530764"></p><ol><li>用到的库：numpy，scipy</li><li>用到的类：scipy.optimise</li><li>用到的对象函数：调用optimise.linerprog()对象函数</li><li>我们要取的参数：<ol><li>目标函数的系数向量</li><li>不等式的约束</li><li>方程约束</li><li>变量范围</li></ol></li></ol><h4 id="PuLP库实现">PuLP库实现</h4><ol><li><p>导入PuLP库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br></pre></td></tr></table></figure></li><li><p>定义一个规划问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyProbLP = pulp.LpProblem(<span class="string">&quot;LPPrombDemo1&quot;</span>,sense=pulp.LpMaximize)</span><br></pre></td></tr></table></figure><p>pulp.LpProblem是问题定义的<strong>构造函数</strong></p><p>“LPPrombDemo1”是用户定义的<strong>问题名（用于输出信息）</strong></p><p>参数sense用于指定求最大值还是最小值，<strong>可选参数值：LpMaximize、LpMinimize</strong></p></li><li><p>定义决策变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = pulp.LpVariable(<span class="string">&#x27;x1&#x27;</span>,lowBound=<span class="number">0</span>,upBound=<span class="number">7</span>,cat=<span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x2 = pulp.LpVariable(<span class="string">&#x27;x2&#x27;</span>,lowBound=<span class="number">0</span>,upBound=<span class="number">7</span>,cat=<span class="string">&#x27;Continuous&#x27;</span>)</span><br><span class="line">x3 = pulp.LpVariable(<span class="string">&#x27;x3&#x27;</span>,lowBound=<span class="number">0</span>,upBound=<span class="number">7</span>,cat=<span class="string">&#x27;Continuous&#x27;</span>)</span><br></pre></td></tr></table></figure><p>pulp.LpVariable是定义决策变量的函数</p><p>‘x1’是用户定义的变量名</p><p>参数 lowBound、upBound 用来设定决策变量的下界、上界；可以不定义下界/上界，默认的下界/上界是负无穷/正无穷。本例中 x1,x2,x3 的取值区间为 [0,7]。<br>参数 cat 用来设定变量类型，可选参数值：‘Continuous’ 表示连续变量（默认值）、’ Integer ’ 表示离散变量（用于整数规划问题）、’ Binary ’ 表示0/1变量（用于0/1规划问题）。</p></li><li><p>添加目标函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyProbLP += <span class="number">2</span>*x1+<span class="number">3</span>*x2-<span class="number">5</span>*x3</span><br></pre></td></tr></table></figure></li><li><p>添加约束条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyProbLP += (<span class="number">2</span>*x1 - <span class="number">5</span>*x2 + x3 &gt;= <span class="number">10</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">MyProbLP += (x1 + <span class="number">3</span>*x2 + x3 &lt;= <span class="number">12</span>)  <span class="comment"># 不等式约束</span></span><br><span class="line">MyProbLP += (x1 + x2 + x3 == <span class="number">7</span>)  <span class="comment"># 等式约束</span></span><br></pre></td></tr></table></figure></li><li><p>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyProbLP.solve()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Status:&quot;</span>,pulp.LpStatus[MyProbLP.status])<span class="comment">#输出求解状态</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> MyProbLP.variables():</span><br><span class="line">    <span class="built_in">print</span>(v.name,<span class="string">&quot;=&quot;</span>,v.varValue)<span class="comment">#输出每个变量的最优值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F(x) = &quot;</span>,pulp.value(MyProbLP.objective))<span class="comment">#输出目标函数最优值</span></span><br></pre></td></tr></table></figure><p>solve()是求解函数。PuLP默认采用CBC求解器来求解优化问题，也可以调用其他优化器来求解。比如：GLPK、COIN、CLP\CBC、CPLEX以及GUROBI，但是需要另外安装。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数学建模 </category>
          
          <category> 优化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】16. 网络爬虫设计</title>
      <link href="/2023/07/16/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9116.%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/07/16/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9116.%20%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>网络爬虫设计</h1><h2 id="爬虫的基本原理">爬虫的基本原理</h2><h3 id="爬虫的用途">爬虫的用途</h3><ul><li>在网上搜集数据(比如搜索引擎)</li><li>模拟浏览器的快速操作(抢票、抢课、抢挂号…)<strong>注意：写爬虫抢票是违法的，自己用没事，卖出去就有事</strong></li><li>模拟浏览器操作，替代填表等重复操作</li></ul><h3 id="最基本的爬虫">最基本的爬虫</h3><p>数据获取型爬虫是最基本的爬虫。数据获取爬虫的本质是自动获取网页并抽取其中的内容。</p><h4 id="基本步骤">基本步骤</h4><ul><li>手工找出合适的url</li><li>用浏览器手工查看网址对于的网页，查看网页源码，找出包含想要的内容（文件名、链接）的字符串的模式</li><li>程序中获取url对应的网页</li><li>程序中用正则表达式或者BeautifulSoup库抽取网页中想要的内容</li></ul><h4 id="代码示例——获取百度图片的搜索结果">代码示例——获取百度图片的搜索结果</h4><p>实现功能：给搜索引擎一个图片，自动爬虫获取图片，把收集到的前5幅图片获取出来。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806092742758.png" alt="image-20230806092742758"></p><p><strong>代码</strong></p><p>代码以讲义为主，不要以视频为主。如果以下代码出错，可以去讲义看看。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806092925068.png" alt="image-20230806092925068"></p><ul><li>stream=True，代表获取获取的是二进制的资源</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806093521041.png" alt="image-20230806093521041"></p><h2 id="requests-get获取网页">requests.get获取网页</h2><h4 id="代码示例">代码示例</h4><ul><li><p><strong>fakeHeaders</strong>字符串的作用是伪装成一个浏览器，骗过服务器，获取网页信息。</p><p>如果服务器识别到请求方不是浏览器，可能不会把网页数据返回。</p><p>不过这里的示例代码比较幼稚，很多服务器不会上当。</p></li><li><p>r.apparent_encoding为了保证网页编码正确</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806164811393.png" alt="image-20230806164811393"></p><h4 id="关于网页获取乱码的解决办法">关于网页获取乱码的解决办法</h4><ul><li>直接按照下方代码搞定即可</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806165223637.png" alt="image-20230806165223637"></p><h4 id="用requests库获取网页的优势和局限">用requests库获取网页的优势和局限</h4><ul><li>优势：<ol><li>相对其他方法，速度快几倍</li><li>安装简单，分发容易</li></ol></li><li>局势：<ol><li>容易被反爬虫手段屏蔽</li><li>不能获取包含javascript生成的动态网页</li></ol></li><li>用上面的示例代码，不能得到百度图片搜索结果网页，得到的网页是空网页（被反爬了）</li></ul><h4 id="request-get获取网页（编码识别加强版）">request.get获取网页（编码识别加强版）</h4><ul><li>实际上是前一份代码的加强版，在fakerHeader基础上加多了一条语句（下图标红）</li><li>该爬虫可以获取百度网站图片</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806165726851.png" alt="image-20230806165726851"></p><h3 id="弥补requests不足的其他获取网页的方法">弥补requests不足的其他获取网页的方法</h3><ul><li><p>使用selenium库（慢，容易被反爬，且已经被许多网站反爬，网上对付反爬的解决办法基本不管用，不推荐）<strong>（过时了）</strong></p></li><li><p>使用pyppeteer库（快，暂时未被许多网站反爬，强烈推荐）</p><p>谷歌提供的一套爬虫工具，比较难反爬</p></li></ul><h3 id="pyppeteer库获取网站">pyppeteer库获取网站</h3><h4 id="来源">来源</h4><ul><li>puppeteer是谷歌公司推出的可以控制Chrome浏览器的一套编程工具。一个日本工程师依此为基础推出了Python版本，叫pyppeteer</li><li>官网：<a href="https://pypi.org/project/pyppeteer/">https://pypi.org/project/pyppeteer/</a></li></ul><h4 id="pyppeteer工作原理">pyppeteer工作原理</h4><ul><li><strong>启动一个浏览器Chromium，用浏览器装入网页</strong>。浏览器可以用无头模式(headless)，即隐藏式启动，也可以显式启动</li><li>从浏览器可以获取网页源代码，若网页有javascript程序，<strong>获取到的是javascript被浏览器执行后的网页源代码</strong></li><li>可以向浏览器发送命令，<strong>模拟用户在浏览器上键盘输入、鼠标点击等操作</strong>，让浏览器转到其他网页</li><li>selenium原理以及功能和pyppeteer一样</li></ul><h4 id="pyppeteer环境安装">pyppeteer环境安装</h4><ul><li>pip install pyppeteer</li><li>python版本&gt;=3.6</li><li>必须下载并且安装特殊版本的谷歌浏览器chromium（500M+）<ol><li>可以将Chromium压缩包随便解压到哪个文件夹，然后在程序指明chrome.exe或其他操作系统的可执行文件的位置</li></ol></li><li><strong>强烈推荐pyppeteer+chromium作为爬虫的首选工具</strong></li></ul><h4 id="预备知识：协程">预备知识：协程</h4><ul><li><p>协程是一种特殊的函数，多个协程可以并行</p></li><li><p>pyppeteer中所有的函数都是协程，调用时前面都要加await，并且只能在协程中使用</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806171606911.png" alt="image-20230806171606911"></p></li><li><p><strong>协程的语法：</strong></p><ol><li><p>协程就是前面加了async的函数（python3.6以后才有）:</p><p>async def f():</p><p>​return 0</p></li><li><p>调用协程时，<strong>必须在函数名前面加上await</strong></p></li><li><p>协程只能在协程里面调用，即await语句只能出现在协程里面</p></li></ol></li></ul><h4 id="用pyppeteer获取网页代码示例">用pyppeteer获取网页代码示例</h4><ul><li><p><strong>headless=False</strong>，表示不以隐藏方式启动，这样我们就看不见chromium的窗口弹出。</p><p>但是这样写很容易被反爬，强烈建议headless=False</p></li><li><p>反反爬部分：暂且照抄</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806171943439.png" alt="image-20230806171943439"></p><ul><li>获取网页信息</li><li>在非协程函数中调用协程，需要<strong>协程外启动协程、等待协程结束</strong>，照抄最后三行代码</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806172331001.png" alt="image-20230806172331001"></p><ul><li><p>启动浏览器的函数  <strong>launch</strong></p><p>其他参数：</p><p>​executablePath指定浏览器的运行位置</p><p>​userdataDir：指明用来存放浏览器工作期间存放的零时文件或者文件夹，不是必须但是可以防止莫名其妙的错误</p></li></ul><h3 id="BeautifulSoup库分析网页">BeautifulSoup库分析网页</h3><h4 id="分析并提取网页内容的三种方式">分析并提取网页内容的三种方式</h4><ol><li>正则表达式（速度最快，但适应变化性略差）</li><li>BeautifulSoup库，速度比正则表达式慢</li><li>selenium或者pyppeteer中的浏览器对象查找元素函数（速度是正则表达式的百分之一，在<strong>需要模拟网页中进行输入、点击按钮等操作的时候</strong>）</li></ol><h4 id="网页信息概览">网页信息概览</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806220421156.png" alt="image-20230806220421156"></p><h4 id="安装库和依赖">安装库和依赖</h4><ul><li><p>安装</p><p>pip install beautifulsoup4</p></li><li><p>导入</p><p>import bs4</p></li></ul><h4 id="代码示例-2">代码示例</h4><p><strong>html文档是字符串</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806221341670.png" alt="image-20230806221341670"></p><p><strong>html文档来源于文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806221418740.png" alt="image-20230806221418740"></p><p><strong>html文档来源于给定网址</strong></p><ol><li>先把网址内容爬下来，用字符串存储其内容</li><li>然后再用beautifulsoup库处理</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806221600454.png" alt="image-20230806221600454"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806221612346.png" alt="image-20230806221612346"></p><p><strong>找到想要的信息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806222225448.png" alt="image-20230806222225448"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
            <tag> 爬虫设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】15. Python的数据库编程</title>
      <link href="/2023/07/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9115.%20Python%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/07/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9115.%20Python%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1>Python的数据库编程</h1><h2 id="数据库的概念">数据库的概念</h2><ul><li>数据库可以用来存放大量数据，并且提供了方便快捷的检索手段</li><li>便于快速找出符合某种条件的数据。比如：工作年限超过三年、工资超过10000元的北京户籍员工</li><li>一个数据库可以是一个文件，比如：c:/temp/students.db</li></ul><h3 id="数据库的结构">数据库的结构</h3><ol><li><p>数据库文件，存放数据库信息</p></li><li><p>数据库表，数据库文件中有多张表，比如student.db文件包含“学生信息表”、“课程信息表”</p></li><li><p>数据库记录，数据库表由记录构成，比如“学生信息表”里每一个记录代表一个学生信息</p></li><li><p>数据库字段，数据库记录由字段构成，描述一个事物的多个属性。比如学生记录，可以由name、id、age等构成</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720094138010.png" alt="image-20230720094138010"></p></li></ol><h2 id="SQL数据库查询语句">SQL数据库查询语句</h2><p>SQL简介：structure query language，结构化查询语言。用于进行数据库操作的标准语句。数据库有很多厂家，不同的数据库内部结构不一样，但是都有统一的语言。</p><h3 id="SQL命令">SQL命令</h3><p>SQL命令：用于进行数据库操作的标准语句</p><h4 id="常用的SQL命令">常用的SQL命令</h4><ol><li>CREATE TABLE创建表</li><li>INSERT   INTO         在表中插入记录</li><li>UPDATE                   在表中更新记录</li><li>SELECT                     在表中进行查询</li><li>DELETE                     从表中删除记录</li></ol><p><strong>不区分大小写</strong></p><h3 id="代码示例">代码示例</h3><ol><li><p>CREATE</p><p>其中的primary key作为主键，不可重复</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720095051832.png" alt="image-20230720095051832"></p></li><li><p>INSERT</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720095206835.png" alt="image-20230720095206835"></p></li></ol><h2 id="创建sqlite3数据库">创建sqlite3数据库</h2><p>python中操作数据库的库也有很多种，这里推荐用小型数据库sqlite3</p><h3 id="创建数据库并写入数据">创建数据库并写入数据</h3><ul><li>操作数据库一般用光标进行</li><li>三引号扩住的字符串，因为字符串太长，换行了，所以用三引号</li><li>可以把要插入的记录用列表、元组存放起来，用循环写入数据库表里面</li><li>只要修改了数据库的内容，<strong>一定要进行db.commit()</strong>，commit之后的数据库才会真正被修改</li><li>最后要记得关闭光标和数据库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720095333122.png" alt="image-20230720095333122"></p><h3 id="数据库的查询和修改">数据库的查询和修改</h3><h4 id="SELECT相关语句">SELECT相关语句</h4><ul><li>*代表所有</li><li>DESC，表示降序排序</li><li>WHRER功能很强，可以配合检索条件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720100641897.png" alt="image-20230720100641897"></p><h3 id="检索数据库程序示例">检索数据库程序示例</h3><ul><li>fetchone，取满足条件的第一条记录</li><li>fetchall，取满足条件的所有记录</li><li>取出来的记录，在python中用列表存储</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720101921760.png" alt="image-20230720101921760"></p><h3 id="更新数据库">更新数据库</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720105422832.png" alt="image-20230720105422832"></p><h4 id="代码示例-2">代码示例</h4><ul><li>元组的三个元素分别对应三个？问号</li><li>关于数据库写入的操作，必须commit()</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720105504500.png" alt="image-20230720105504500"></p><h3 id="删除操作">删除操作</h3><p>在表内删除数据（字段、记录）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720105740370.png" alt="image-20230720105740370"></p><p>删除表的操作</p><ul><li>注意：这里不是delete，而是DROP</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720105831294.png" alt="image-20230720105831294"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720110626955.png" alt="image-20230720110626955"></p><h2 id="注意事项">注意事项</h2><ol><li>对于修改表的操作，比如插入、删除，在关闭数据库前不要忘了commit，否则可能无效。</li><li>必要时用try…except语句来避免数据库不存在，表不存在时导致runtime error</li></ol><h2 id="数据库二进制字段的处理">数据库二进制字段的处理</h2><h3 id="设置blob字段（二进制字段）的值">设置blob字段（二进制字段）的值</h3><ul><li>‘rb’的含义：r表示读取，b表示二进制</li><li>大部分文件都不是文本文件，而是二进制文件，比如音频、视频、图片…</li><li>下面代码最后一个<strong>参数(img,)</strong>，只有一个参数也要加“，”，否则不是元组，所以cur.execute函数的参数之一是元组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720111008875.png" alt="image-20230720111008875"></p><ul><li><p>Python的<strong>requests库</strong>可以用于访问网络资源</p><p>下面从网络上获取图片，进行数据库的二进制字段值的设置</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720111533694.png" alt="image-20230720111533694"></p></li></ul><h3 id="读取blob字段（二进制字段）的值">读取blob字段（二进制字段）的值</h3><ul><li>用or读取张三、李四两人的相关信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720112241884.png" alt="image-20230720112241884"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
            <tag> python数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】14. 正则表达式及其在python中的应用</title>
      <link href="/2023/07/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9114.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%9C%A8python%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9114.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%9C%A8python%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>正则表达式及其在Python中的应用</h1><h2 id="re库">re库</h2><p>python中的re库可以帮助分隔字符串，在词频统计等分析中常用到</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230718190156427.png" alt="image-20230718190156427"></p><h2 id="正则表达式">正则表达式</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720112834206.png" alt="image-20230720112834206"></p><h3 id="正则表达式的基本概念">正则表达式的基本概念</h3><p>正则表达式实际上是个字符串，是一种字符串模式（格式）。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230720121235815.png" alt="image-20230720121235815"></p><h2 id="正则表达式中的功能字符">正则表达式中的功能字符</h2><h3 id="字符">字符</h3><ol><li><p>“.”</p><p>除了‘\n’以外的任意一个字符，包括汉字</p></li><li><p>“*”</p><p>量词，表示<strong>左边</strong>的字符可以出现0次或者任意多次</p></li><li><p>“？”</p><p>量词，表示左边的字符必须出现0次或者一次</p></li><li><p>“+”</p><p>量词，表示左边的字符必须出现1次或者更多次</p></li><li><p>“{m}”</p><p>量词，m是整数。表示左边的字符必须且只能出现m次</p></li><li><p>“{m,n}”</p><p>量词，m、n都是整数。表示左边的字符必须出现至少m次，最多n次</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726083726794.png" alt="image-20230726083726794"></p><h3 id="字符组合">字符组合</h3><p>字符组合跟字符不同，字符是单个有筛选意义的字符，字符组合是多个字符结合起来表示有筛选意义的字符组合。</p><ol><li><p>“\d”</p><p>一个数字字符，等价于[0,9]</p></li><li><p>“\D”</p><p>一个非数字字符，等价于[^\d],[^0-9]</p></li><li><p>“\s”</p><p>一个空白字符，比如空格，\t\r\n等</p></li><li><p>“\S”</p><p>一个非空白字符</p></li><li><p>“\w”</p><p>一个单词字符：包括汉字或大小写英文字母、数字、下划线、或者其他语言文字</p></li><li><p>“\W”</p><p>一个非单词字符</p></li><li><p>“|”</p><p>逻辑或，A|B，表示能匹配A或能匹配B都行</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726084544738.png" alt="image-20230726084544738"></p><p><strong>注意：python字符串中，\s等不是转移字符，都是两个字符。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726084849469.png" alt="image-20230726084849469"></p><h3 id="正则表达式中的特殊字符">正则表达式中的特殊字符</h3><p>正则表达式中常见的特殊字符主要有以下几个：</p><ul><li><p>.</p></li><li><ul><li></li></ul></li><li><p>?</p></li><li><ul><li></li></ul></li><li><p>$</p></li><li><p>[ ]</p></li><li><p>( )</p></li><li><p>^</p></li><li><p>{ }</p></li><li><p>\</p><p>如果要在正则表达式中表示这些特殊字符本身，要在其前面加上‘\’。</p></li></ul><h2 id="字符的范围和量词">字符的范围和量词</h2><h3 id="XXX-的用法">[XXX]的用法</h3><p>用以表示“此处必须出现一个某某范围内的字符”，或者此处必须&quot;出现一个字符，但不可以是某某范围内的字符&quot;</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726090920227.png" alt="image-20230726090920227"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726090948027.png" alt="image-20230726090948027"></p><h3 id="“-“匹配汉字">“[]“匹配汉字</h3><p>汉字的unicode编码范围是<strong>4e00-9fa5(16进制)</strong>，因此[\u4e00-\u9fa5]即表示一个汉字。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726091202434.png" alt="image-20230726091202434"></p><h3 id="常用的正则表达式实例">常用的正则表达式实例</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726091743894.png" alt="image-20230726091743894"></p><h2 id="Python的re库关于正则表达式的函数">Python的re库关于正则表达式的函数</h2><h3 id="re-match-函数">re.match()函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726091937101.png" alt="image-20230726091937101"></p><p><strong>代码示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726092240556.png" alt="image-20230726092240556"></p><h3 id="re-search-函数">re.search()函数</h3><p>如果有多个子串匹配，则返回第一个子串。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726100904439.png" alt="image-20230726100904439"></p><p><strong>代码示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726110602900.png" alt="image-20230726110602900"></p><h3 id="re-findall-函数">re.findall()函数</h3><p>找出所有匹配的子串且不重叠，找到的子串都放在列表里面。如果没有匹配的就返回空列表。</p><p><strong>代码示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726111344036.png" alt="image-20230726111344036"></p><h3 id="re-finditer-函数">re.finditer()函数</h3><p>查找字符串中所有和模式匹配的子串（不重叠），每个子串对应于一个匹配对象，返回匹配对象的序列。（准确地说是“可用迭代器”）</p><p><strong>代码示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726111620868.png" alt="image-20230726111620868"></p><h3 id="re-sub-函数">re.sub()函数</h3><p>re.sub(模式串，替换串，母串)，用于替换匹配的子串</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726111916498.png" alt="image-20230726111916498"></p><hr><h2 id="边界符号">边界符号</h2><p>正则表达式中，边界符号有四个。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726112123956.png" alt="image-20230726112123956"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726112317565.png" alt="image-20230726112317565"></p><p><strong>注意：</strong></p><p>正则表达式的边界符号‘\b’是两个字符。但是在Python字符串中，‘\b’和’\t’、'\n’类似，表示一个字符，\b表示Backspace。</p><p>因此在正则表达式中使用边界符号\b，要写’\\b’。</p><p>如果写‘\\\\b’，则连续的两个‘\’被看做一个普通的’\'，不会和后面的’b’一起被当做字符组合。</p><p>Python字符串‘\B’是两个字符。</p><p><strong>代码示例1：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726113040305.png" alt="image-20230726113040305"></p><p><strong>代码示例2：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726113311728.png" alt="image-20230726113311728"></p><h2 id="分组（…）">分组（…）</h2><p>括号中的表达式是一个分组。多个分组按照左括号<strong>从左到右从1开始</strong>依次编号。</p><p>注意下面代码的group(0)和group(1)，<strong>groups()返回元组</strong>。</p><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726114509101.png" alt="image-20230726114509101"></p><h4 id="在分组的右边可以通过分组的编号引用该分组所匹配的字符串">在分组的右边可以通过分组的编号引用该分组所匹配的字符串</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726114949441.png" alt="image-20230726114949441"></p><h4 id="分组作为一个整体，后面可以跟量词">分组作为一个整体，后面可以跟量词</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726115931071.png" alt="image-20230726115931071"></p><h3 id="re-findall和分组">re.findall和分组</h3><p>在正则表达式中<strong>没有分组时</strong>，re.findall返回所有匹配子串构成的列表。</p><p><strong>有且只有一个分组时</strong>，re.findall返回的是一个子串的列表，每个元素是一个匹配子串中的分组对应的内容。</p><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726120503637.png" alt="image-20230726120503637"></p><p>当正则表达式中<strong>有超过一个分组时</strong>，re.findall返回的是一个<strong>元组的列表</strong>。每个元组对应于一个匹配的子串，元组里面的元素依次是1号分组、2号分组、3号分组…匹配的内容。</p><p><strong>代码示例：</strong>  <img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726121035966.png" alt="image-20230726121035966"></p><hr><h2 id="“-”的用法">“|”的用法</h2><p>表示“或”，如果没有放在“()”中，则起作用的范围是直到整个正则表达式开头或者结尾或者另一个“|”。</p><p><strong>代码示例：</strong></p><p>匹配到下面三个其中一个即可，优先级从左到右</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726121823038.png" alt="image-20230726121823038"></p><h4 id="从左到右短路匹配">从左到右短路匹配</h4><p>匹配上一个后就不计算是否还能匹配后面的</p><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726130214619.png" alt="image-20230726130214619"></p><h4 id="‘-也可以用于分组中">‘|'也可以用于分组中</h4><p>起作用的范围仅限于分组内</p><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726130950899.png" alt="image-20230726130950899"></p><hr><h2 id="量词的贪婪模式">量词的贪婪模式</h2><p>量词+、*、？、{M,N}默认匹配尽可能长的子串</p><p><strong>两个贪婪匹配造成问题的例子:</strong></p><p>下面第二个正则表达式，想要打印出所有<h3></h3>内的所有文字，但由于贪婪匹配，把最开始的<h3>和最后的</h3>括起来的内容作为截取的内容。</p><p>第三个正则表达式类似。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726132854806.png" alt="image-20230726132854806"></p><h2 id="量词的懒惰模式">量词的懒惰模式</h2><p>在量词+、*、？、{M,N}后面加‘？’则匹配尽可能短的字符串。</p><p><strong>注意最后一个例子：</strong></p><ul><li><p>/<h3>匹配第一个<h3></p></li><li><p>.*?匹配abd</p></li><li><p>[M|K]不匹配&lt;</p></li><li><p>*？匹配abc</h3><h3>bc</p></li><li><p>[M|K]匹配K</p></li><li><p>最后一个</h3>被匹配</p></li></ul><p>最终得出如例子中的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726133550102.png" alt="image-20230726133550102"></p><p><strong>例子强化：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726142501356.png" alt="image-20230726142501356"></p><hr><h2 id="匹配对象">匹配对象</h2><p>匹配对象：匹配成功时的返回结果。</p><h3 id="属性">属性</h3><ul><li><p>string：匹配时使用的母串</p></li><li><p>lastindex：最后一个被匹配的分组的编号（不是最大的编号）。如果没有被匹配的分组，将为None。</p></li></ul><h3 id="匹配对象相关函数">匹配对象相关函数</h3><ul><li><p>group([n1,n2,n3,…])</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726142850522.png" alt="image-20230726142850522"></p></li><li><p>group<strong>s</strong></p><p>以元组形式返回全部分组匹配的字符串。相当于调用group(1,2,3,…last)。</p></li><li><p>groupdict</p><p>返回以有名字的组的名字为键，以改组匹配的子串为值的字典，没有名字的组不包含在内。</p></li><li><p>start([group])</p><p>返回指定组匹配的子串在string中的起始位置。group默认为0</p></li><li><p>end([group])</p><p>返回指定的组匹配的子串在string中结束的位置（子串最后一个字符位置+1）。group默认值为0</p></li><li><p>span([group])</p><p>返回(start(group)，end(group))</p><p>group可以是组编号，也可以是组名字，缺省值为0.</p></li></ul><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726143739376.png" alt="image-20230726143739376"></p><h2 id="抽取字符串中的IP地址、邮箱、网址">抽取字符串中的IP地址、邮箱、网址</h2><p>直接精确写出来是十分麻烦且难想的，但是可以将以下代码进行记忆和备份。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726145009864.png" alt="image-20230726145009864"></p><h2 id="简化正则表达式的编写">简化正则表达式的编写</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230726145045946.png" alt="image-20230726145045946"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】13. 数据分析和展示</title>
      <link href="/2023/07/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9113.%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%B1%95%E7%A4%BA/"/>
      <url>/2023/07/13/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9113.%20%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E5%B1%95%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1>数据分析和展示</h1><h2 id="numpy库">numpy库</h2><ul><li>多维数组库，创建多维度数组很方便，可以代替多维列表</li><li>速度比多维列表快</li><li>支持向量和矩阵的各种数学运算</li><li>所有元素类型必须相同</li></ul><p>tips: pip install numpy 安装</p><h3 id="numpy创建数组的函数">numpy创建数组的函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805102754709.png" alt="image-20230805102754709"></p><h4 id="numpy创建数组示例">numpy创建数组示例</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805103058726.png" alt="image-20230805103058726"></p><h3 id="numpy数组常用的属性和函数">numpy数组常用的属性和函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805103313496.png" alt="image-20230805103313496"></p><h4 id="代码示例">代码示例</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805110520250.png" alt="image-20230805110520250"></p><h3 id="numpy元素实现增删">numpy元素实现增删</h3><p>实际上numpy数组一旦生成，元素就不能增删，而<strong>是通过返回一个新的数组来实现增删</strong>的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805110717956.png" alt="image-20230805110717956"></p><h4 id="代码示例-2">代码示例</h4><p>下面出现了<strong>axis参数</strong>，axis参数用于控制数组的拼接是发生在行上面还是发生在列上面。</p><ul><li>axis=0（缺省值），拼接使得行增加（加在列下）</li><li>axis=1，拼接使得列增加（加在行上），行不变</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805110809771.png" alt="image-20230805110809771"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805111654890.png" alt="image-20230805111654890"></p><h3 id="在numpy数组里面查找元素">在numpy数组里面查找元素</h3><ul><li>np.argwhere(a==3)，查找a数组里面等于3的元素，返回该元组的行列值，pos是numpy的<strong>二维数组</strong>，而不是列表。Python的原生列表，每个元组都需要有逗号隔开！！</li><li>a[a&gt;2]，抽取a中大于2的元素，形成一个一维数组</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805111846533.png" alt="image-20230805111846533"></p><h3 id="numpy数组的数学运算">numpy数组的数学运算</h3><h4 id="加减乘除、开方、乘方">加减乘除、开方、乘方</h4><ul><li>**特点：**可以对数组进行直接的数学运算，作用结果直接覆盖到数组内全体成员。</li><li>上述特点可以使得numpy数组很轻松的将数据进行<strong>矩阵化处理</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805112442982.png" alt="image-20230805112442982"></p><h3 id="numpy数组的切片">numpy数组的切片</h3><p>numpy数组的切片是“视图”，是原数组的一部分，而非一部分的拷贝。Python原生数组的切片实际上是一份拷贝，改了切片不会影响原来的列表，而numpy数组会影响。</p><p>下面代码示例中：</p><p>b=a[1:3,1:4]，表示从a中取1到3行、1到4列组成一个新的二维数组。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805113231605.png" alt="image-20230805113231605"></p><h2 id="pandas库">pandas库</h2><ul><li>核心功能是在二维表格上做各种操作，例如增加、修改、求一列数据的和、方差、中位数、平均数等等；</li><li>需要numpy支持</li><li>如果由openpyxl支持，还可以读写xlsx文档</li><li>最关键的类：DataFrame，<strong>表示二维表格</strong></li></ul><h3 id="pandas读写xlsx文档">pandas读写xlsx文档</h3><ul><li><p>需要openpyxl支持</p></li><li><p>读取每张工作表都是一个DataFrame类（二维表格）</p></li><li><p>如果有openpyxl或者xlrd或者xlwt支持，pandas还可以读写xlsx文档</p></li><li><p>最关键的类：<strong>DataFrame</strong>，<strong>表示二维表格</strong></p></li></ul><h3 id="重要类：Series">重要类：Series</h3><ul><li><p>Series是一维表格，每个元素都带标签且有下表，<strong>兼具列表和字典的访问形式</strong>。</p></li><li><p>参数：data，指定要存放的数据；index，指定对应的键值</p></li><li><p>代码解读：</p></li></ul><p>s[0:2][‘数学’]，表示在s的第0个到第1个元组中取标签为‘数学’的元素。（<strong>这里是用下标切片，左闭右开</strong>）</p><p>s[‘数学’：‘英语’][1]，这里是用标签来切片，闭区间。</p><ul><li><strong>注意：<strong>Series切片也是</strong>视图</strong></li></ul><h4 id="代码示例-3">代码示例</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805114404643.png" alt="image-20230805114404643"></p><p><strong>统计功能函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805115430494.png" alt="image-20230805115430494"></p><h3 id="DataFrame的构造和访问">DataFrame的构造和访问</h3><h4 id="构造">构造</h4><p>DataFrame是带行列标签的二维表格，<strong>每一列都是一个Series</strong></p><p>为了使得表格打印出来对齐并且美观，加入参数“display.unicode.east_asian_width，True”</p><p>指表参数：</p><ul><li>data，元素值</li><li>index，行标签</li><li>columns，列标签</li><li>参数可以用列表赋值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805115806066.png" alt="image-20230805115806066"></p><h4 id="访问">访问</h4><p>注意到，DataFrame的元素的数据类型是numpy数组，所以说需要numpy库支持。</p><p><strong>访问一行，记得loc</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805120203640.png" alt="image-20230805120203640"></p><h3 id="DataFrame的切片">DataFrame的切片</h3><ul><li>iloc[行选择器，列选择器]   用<strong>下标</strong>做切片，左闭右开</li><li>loc[行选择器，列选择器]   用<strong>标签</strong>做切片，包括终点</li><li>DataFrame的切片是视图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805124338508.png" alt="image-20230805124338508"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805124501824.png" alt="image-20230805124501824"></p><p><strong>注意：</strong></p><p>下面的切片用列表[1,3]，而不是[1:3]，表示取第一行和第三行</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805124649771.png" alt="image-20230805124649771"></p><h3 id="DataFrame的分析统计">DataFrame的分析统计</h3><ul><li>sort_values这个函数返回一个新的dataframe，但是如果加上参数inplace=True，那就会改变原来的dataframe</li><li>df.sum()返回的实际上是一个Series，每一列的和构成的Series</li><li>axis参数，缺省情况下为0，代表对列进行操作；反之对行进行操作。</li><li>df.T   获得<strong>转置矩阵</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805173209452.png" alt="image-20230805173209452"></p><h3 id="DataFrame的修改和增删">DataFrame的修改和增删</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805173453216.png" alt="image-20230805173453216"></p><p><strong>删除</strong></p><p>df.drop记得<strong>指定inplace=True</strong>，否则不会影响原来的表，而是会返回一个新的列表。（不是视图）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805173738487.png" alt="image-20230805173738487"></p><h3 id="pandas读写xlsx文档-2">pandas读写xlsx文档</h3><ul><li>需要openpyxl支持(对.xlsx文件)，或者xlrd或者xlwt支持。(老的.xls文件)</li><li>读取<strong>每张工作表都是一个DataFrame类（二维表格）</strong></li><li>使用pandas读取excel文档的优势：<ol><li>pandas具有很多统计功能，可以轻松做各种数据分析。</li></ol></li></ul><h4 id="代码示例-4">代码示例</h4><p><strong>读取文档</strong></p><ul><li><p>pd.read_excel返回的数据是Python中的<strong>字典</strong></p><p>字典的键为sheet_name（表的名字/索引），值为DataFrame数据结构，代表整个sheet表。</p><p><strong>index_col</strong>选择的是行标签的那一列。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230805221914583.png" alt="image-20230805221914583"></p><p><strong>写入文档</strong></p><ul><li>na_rep=‘ ’，该参数是将NAN数据替换成其他字符的参数，这里是替换成空串。</li><li>这个函数并不好用，首先会覆盖原有文件，其次只能写一个表。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806074837600.png" alt="image-20230806074837600"></p><ul><li>df.to_excel(writer,sheet_name=“s1”)，往excel表写入s1工作表</li><li>df.sort_values()函数返回一个新的dataframe，<strong>ascending参数表示降序排列</strong></li><li><strong>最终writer.save()保存文件</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806075032450.png" alt="image-20230806075032450"></p><h3 id="pandas读写csv文件">pandas读写csv文件</h3><h4 id="写文件"><strong>写文件</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/2023-08-06_07-58.png" alt="2023-08-06_07-58"></p><h4 id="读文件"><strong>读文件</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(filename,header=<span class="literal">None</span>,names=[<span class="string">&#x27;表头1&#x27;</span>,<span class="string">&#x27;表头2&#x27;</span>,<span class="string">&#x27;表头3&#x27;</span>])<span class="comment">#可以以这种方式读取文件</span></span><br></pre></td></tr></table></figure><p>该函数将csv文件以dataframe形式读取并返回给df</p><hr><h2 id="matplotlib库">matplotlib库</h2><h3 id="matplotlib画图基本步骤总结">matplotlib画图基本步骤总结</h3><ul><li>创建画布、子图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots(<span class="number">1</span>,<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment">#fig接收画布对象，ax接受子图对象；</span></span><br><span class="line"><span class="comment">#参数1，2表示该画布是一个包含1行2列子图的画布</span></span><br><span class="line"><span class="comment">#figsize=(10,8)设置画布大小</span></span><br></pre></td></tr></table></figure><ul><li>画图</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以折线图为例</span></span><br><span class="line">ax[<span class="number">0</span>].plt(x,y,<span class="string">&#x27;-or&#x27;</span>,label=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">ax[<span class="number">1</span>].plt(x,y,<span class="string">&#x27;-xb&#x27;</span>,label=<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="comment">#ax[i]表示选择第i个子图</span></span><br><span class="line"><span class="comment">#plt，plt就像是个画笔，画啥都用它</span></span><br><span class="line"><span class="comment">#x,y是序列数据，代表x轴、y轴数据；可以使列表、也可以是dataframe的一列（series）</span></span><br><span class="line"><span class="comment">#&#x27;-or&#x27;表示每个点的标记形状为o，-代表直线，r代表红色</span></span><br></pre></td></tr></table></figure><ul><li>加标题、标签、注释</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax[<span class="number">0</span>].set_xlabels(<span class="string">&#x27;xxx&#x27;</span>)<span class="comment">#y轴标签</span></span><br><span class="line">ax[<span class="number">1</span>].set_ylabels(<span class="string">&#x27;xxx&#x27;</span>)<span class="comment">#x轴标签</span></span><br><span class="line">ax[i].legend()<span class="comment">#显示图记，在旁边显示每个颜色的曲线是啥意思</span></span><br><span class="line">ax[i].set_title(<span class="string">&#x27;xxx&#x27;</span>)<span class="comment">#给子图加标题</span></span><br><span class="line">plt.suptitle(<span class="string">&#x27;xxx&#x27;</span>,fontsize=<span class="number">17</span>)<span class="comment">#记得不要17px，整数即可；这个是给整个画布加标题</span></span><br></pre></td></tr></table></figure><ul><li>保存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(filepath)</span><br><span class="line"><span class="comment">#这样就保存到filepath了</span></span><br></pre></td></tr></table></figure><p>对于其他类型的图形，在画图那一步都有一定的区别，但是其他步骤基本相同；</p><h3 id="绘制基本直方图">绘制基本直方图</h3><ul><li>rcParams这一部分是处理中文显示支持，记住即可</li><li>figure是一个plt窗口，要在窗口上创建子图subplot，然后此后所有的绘图都是在子图上进行的，没有子图，画在多也没用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806080614388.png" alt="image-20230806080614388"></p><p><strong>显示效果：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806080829111.png" alt="image-20230806080829111"></p><h4 id="绘制横向直方图">绘制横向直方图</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806080928585.png" alt="image-20230806080928585"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806081020324.png" alt="image-20230806081020324"></p><h3 id="绘制堆叠直方图">绘制堆叠直方图</h3><p><strong>效果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806081058776.png" alt="image-20230806081058776"></p><h4 id="代码示例-5">代码示例</h4><p>注意参数：bottom，指定数据从哪里开始堆叠！</p><ul><li>注意导入的库！！导入的对象！！</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806081339167.png" alt="image-20230806081339167"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806081616505.png" alt="image-20230806081616505"></p><h3 id="绘制对比直方图">绘制对比直方图</h3><p><strong>效果：</strong></p><p>多组数据进行对比</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806081731106.png" alt="image-20230806081731106"></p><h4 id="代码示例-6">代码示例</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806082029521.png" alt="image-20230806082029521"></p><ul><li><strong>ax.text在子图任意位置都可以写文字</strong></li><li><strong>rect.get获取的是柱子左侧的坐标</strong>，要获取中心点坐标还需加上柱子宽度的一半</li><li><strong>rotation参数，逆时针转动文字</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806082119458.png" alt="image-20230806082119458"></p><h3 id="绘制折线图和散点图">绘制折线图和散点图</h3><p><strong>效果图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806082748404.png" alt="image-20230806082748404"></p><h4 id="代码示例-7">代码示例</h4><ul><li>plot函数，就是给定点的序列参数，将这些点连起来并绘制出来。</li><li>scatter函数，绘制散点图，需要给出横纵坐标序列</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806082806206.png" alt="image-20230806082806206"></p><ul><li>dpi参数，代表每英寸像素的个数。<strong>越大图像越清晰。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806083358130.png" alt="image-20230806083358130"></p><h3 id="绘制饼图">绘制饼图</h3><p><strong>效果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806083519007.png" alt="image-20230806083519007"></p><h4 id="代码示例-8">代码示例</h4><ul><li>关键在于pie函数。</li><li>x参数指定份额</li><li>labels参数指定标签</li><li>expode参数指定突出程度，0.1是指半径的0.1倍</li><li>labeldistance指定标签与圆心的距离，1.1是指半径的1.1倍</li><li>pctdisatance指定显示份额的文字距离圆心的距离，0.6是指半径的0.6倍</li><li>startangle=90，从90度逆时针开始画图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806083533905.png" alt="image-20230806083533905"></p><h3 id="绘制热力图">绘制热力图</h3><p><strong>效果</strong></p><p>热力图用于展示二维数据，十分直观且对比鲜明。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806084127690.png" alt="image-20230806084127690"></p><h4 id="代码示例-9">代码示例</h4><ul><li>imshow函数，画热力图</li><li>data是二维矩阵</li><li>cmap=plt.cm.hot，画热力图，色调是暖，如果是plt.cm.cool，那么色调就变成冷色调</li><li>aspect='auto’照抄</li><li>vmin，vmax指定对小值最大值，默认是源数据的最值。最小的最暗，最大的最亮。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806084238134.png" alt="image-20230806084238134"></p><p><strong>对每一个热力图方格写入数据</strong></p><ul><li>ax.text参数ha，表示水平居中，va表示竖直居中</li><li><strong>plt.colorbar，绘制右边的颜色-数值对照柱</strong>（另外需要绘制的）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806084904141.png" alt="image-20230806084904141"></p><h3 id="绘制雷达图">绘制雷达图</h3><p><strong>效果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806085222409.png" alt="image-20230806085222409"></p><h4 id="代码示例-10">代码示例</h4><ul><li>注意，绘制雷达图的时候，子图要规定为极坐标形式。即要生成极坐标形式的子图：projection=“polar”</li><li>set_thetagrids是画一层一层的圈圈</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806085850969.png" alt="image-20230806085850969"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806085939264.png" alt="image-20230806085939264"></p><h4 id="绘制多层雷达图">绘制多层雷达图</h4><p><strong>效果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806090101762.png" alt="image-20230806090101762"></p><p><strong>代码示例</strong></p><ul><li><strong>data是一个6行3列的矩阵，每列表示一个人的数据</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806090355533.png" alt="image-20230806090355533"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806090446884.png" alt="image-20230806090446884"></p><h3 id="一个窗口绘制多幅图">一个窗口绘制多幅图</h3><p>思路：在一个窗口的不同位置创建多个子图，然后在各个子图上画图即可。</p><p><strong>效果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806090755694.png" alt="image-20230806090755694"></p><h4 id="代码示例-11">代码示例</h4><p><strong>画图基本函数</strong></p><ul><li><p>import库</p></li><li><p>汉字处理</p></li><li><p>drawRader，画雷达图；</p><p>drawPie，画饼图；</p><p>drawPlot，画折线图和散点图；</p></li><li><p>添加子图的时候加上参数</p><p>fig.add_subplot(2,2,1)表示将窗口分成两行两列，取位于第一个方格的子图</p></li><li><p>plt.subplot2grid((2,2),(1,0),colspan=2)表示将窗口分成2行两列，取第一行第0列，占两列宽。</p><p>也可以写成ax=fig.add_plotsubplot(2,1,2)</p></li><li><p>plt.figtext(0.05,0.05,‘subplot simple’)，表示显示左下角的标题，两个0.05分别表示从左边开始数占整个宽度的1/20，从底下开始数占高度的1/20</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230806090951074.png" alt="image-20230806090951074"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】12. Python数据处理生态</title>
      <link href="/2023/07/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9112.%20python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%94%9F%E6%80%81/"/>
      <url>/2023/07/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9112.%20python%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%94%9F%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1>Python数据处理生态</h1><h2 id="处理excel文档">处理excel文档</h2><h3 id="处理excel文档的相关库">处理excel文档的相关库</h3><ol><li><p>xlrd库、xlwt库</p><p>xlrd用于读取office2010以前的.xls文件</p><p>xlwt用于创建和修改.xls文件</p></li><li><p>openpyxl库</p><p>读写office2010以后的.xlsx文件</p></li></ol><h2 id="openpyxl库的使用">openpyxl库的使用</h2><p>对于excel工作表，行列号都是从1开始算的。</p><ul><li>读取xlsx表</li><li>创建xlsx表</li><li>修改xlsx表</li></ul><h3 id="读取excel文件内容">读取excel文件内容</h3><h4 id="获取excel文档book">获取excel文档book</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl <span class="keyword">as</span> pxl</span><br><span class="line">book = pxl.load_workbook(<span class="string">&quot;/home/codePath&quot;</span>) <span class="comment">#book就是整个excel文件</span></span><br></pre></td></tr></table></figure><h4 id="工作表相关操作sheet">工作表相关操作sheet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sheet=book.active <span class="comment">#取活跃的工作表</span></span><br><span class="line">sheet=book[<span class="string">&quot;price&quot;</span>]<span class="comment">#取名字为price的工作表</span></span><br><span class="line">sheetlst=book.worksheets <span class="comment">#worksheets是工作表构成的列表</span></span><br><span class="line"><span class="comment">#相关属性</span></span><br><span class="line"><span class="built_in">print</span>(sheet.title)<span class="comment">#打印出工作表的表头</span></span><br><span class="line"><span class="built_in">print</span>(sheet.min_row,sheet.max_row)<span class="comment">#输出最小、最大有效行号</span></span><br><span class="line"><span class="built_in">print</span>(sheet.min_column,sheet.max_column)<span class="comment">#输出最小、最大有效列号</span></span><br><span class="line">rows=sheet.rows<span class="comment">#工作表的每一行组成的列表</span></span><br><span class="line">column=sheet.columns<span class="comment">#工作表的每一列组成的列表</span></span><br></pre></td></tr></table></figure><h4 id="单元格的相关操作cell">单元格的相关操作cell</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#相关属性</span></span><br><span class="line"><span class="built_in">type</span>(cell.value)<span class="comment">#打印出单元格的数据类型（必须是下四种之一）：int、float、str、datetime.datetime</span></span><br><span class="line">cell.coordinat <span class="comment">#单元格的坐标，例如‘A2’，‘E2’</span></span><br><span class="line">cell.col_idx<span class="comment">#单元格列号 column_index</span></span><br><span class="line">cell.number_format<span class="comment">#数的显示格式，“General”,&quot;0.00%&quot;,&quot;0.00E+00&quot;等</span></span><br></pre></td></tr></table></figure><h4 id="读取行、列、单元格的相关操作">读取行、列、单元格的相关操作</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727214335475.png" alt="image-20230727214335475"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727214707417.png" alt="image-20230727214707417"></p><h4 id="读取公式的计算结果">读取公式的计算结果</h4><p>有时excel表格中某些单元格内容是公式，我们有可能只需要计算完公式之后的结果，或者只需要公式。</p><p>如果我们只需要计算结果，则可以在读书excel表格时加入相关参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line">book=openpyxl.load_workbook(<span class="string">&quot;/home/path&quot;</span>,data_only=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="创建excel文档">创建excel文档</h3><h4 id="创建文档及其框架的相关操作">创建文档及其框架的相关操作</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727220943747.png" alt="image-20230727220943747"></p><h4 id="excel文档内容相关操作">excel文档内容相关操作</h4><p>单元格显示格式、单元格值的类型、设置单元格宽度、新建工作表及命名、删除单元格</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727221621598.png" alt="image-20230727221621598"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727221929531.png" alt="image-20230727221929531"></p><h3 id="openpyxl指定单元格样式">openpyxl指定单元格样式</h3><p>设置单元格边线类型、粗细，为单元格填充底色，指定单元格字体、斜体，设置单元格内内容的位置（如：水平居中，垂直居中等等）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727223238087.png" alt="image-20230727223238087"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230727223307199.png" alt="image-20230727223307199"></p><hr><h2 id="jieba库">jieba库</h2><p>详细用法可以移步到github上的jieb库：<a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p><h3 id="jieba库中文分词">jieba库中文分词</h3><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230728082013503.png" alt="image-20230728082013503"></p><p>可以读取文件为jieba词典库扩充，然后再进行分词，这里为txt文件</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230728082119230.png" alt="image-20230728082119230"></p><h3 id="分词算法">分词算法</h3><h4 id="ti-dif算法">ti-dif算法</h4><p>ti-idf是一种统计方法，用以评估一个字词对于一个文件集或者一个语料库中的其中一份文件的重要程度。它是一种用于信息检索和文本挖掘的常用的加权技术。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230728091222810.png" alt="image-20230728091222810"></p><h4 id="算法原理">算法原理</h4><p>tf是词语在某篇文档中出现的评论</p><p>词语在文档中出现的频率越高越大</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230728091315816.png" alt="image-20230728091315816"></p><p>itf</p><p>词语出现的文档数越多越小</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230728091407835.png" alt="image-20230728091407835"></p><p>tf-idf的值与词语频率成正比增大，但是会随着它在更多文档中出现而下降。</p><p>效果：突出重要词语、抑制次要词语</p><p>缺点：</p><ol><li>频率小单词越重要</li><li>单词频率大越无用</li><li>不能体现上下文信息</li></ol><hr><h2 id="datatime库处理日期和时间">datatime库处理日期和时间</h2><h2 id="random随机数模块">random随机数模块</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>random.randint(1,10)</td><td>随机产生1-10的整数</td></tr><tr><td>random.random()</td><td>随机生成0-1之间的小数</td></tr><tr><td>random.uniform(min,max)</td><td>随机生成min-max之间的小数，其中min和max可以互换</td></tr><tr><td>random.randint(min,max)</td><td>随机生成min-max之间的整数</td></tr><tr><td><strong>random.choice(元组/列表/range()/字符串)</strong></td><td><strong>从给定元组/列表/range()/字符串中随机挑出一个元素</strong></td></tr><tr><td><strong>random.randrange(min,max,tap_num)</strong></td><td><strong>在min-max之间随机产生一个数，其中tap_num是间隔（可以用于取奇数、偶数）</strong></td></tr><tr><td><strong>random.sample(元组/列表/字符串/range, num)</strong></td><td><strong>从给定的对象的所有元素随机选取num个元素，返回列表</strong></td></tr></tbody></table><h2 id="Pillow库处理图像">Pillow库处理图像</h2><h3 id="图像的相关常识">图像的相关常识</h3><h4 id="图像的模式">图像的模式</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803212002871.png" alt="image-20230803212002871"></p><h4 id="图像的缩放">图像的缩放</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803212510672.png" alt="image-20230803212510672"></p><h4 id="图像的旋转、翻转以及滤镜效果">图像的旋转、翻转以及滤镜效果</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803212745727.png" alt="image-20230803212745727"></p><h4 id="图像的裁剪">图像的裁剪</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803213239349.png" alt="image-20230803213239349"></p><h4 id="图像的素描画">图像的素描画</h4><p>基本原理：把**轮廓（颜色发生剧烈变化的地方）**画出来，飞轮廓部分都变成白色。</p><p>算法思路：</p><ol><li>将彩色图片转化为黑白图片</li><li>遍历图片像素如果有相邻的像素深浅发生明显变化，那么这两个像素之间必然有一个像素是属于轮廓</li><li>深浅相差多少才算是明显变化呢？这个可以自己来调试。</li></ol><p>代码示例：</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803213912188.png" alt="image-20230803213912188"></p><h4 id="给图像添加水印">给图像添加水印</h4><p>原理：paste时可以用“掩膜”之后定img的每个像素粘贴过去的透明度。如果透明度为0则完全透明，如果透明度为255则完全掩盖原来的像素。mask参数即为掩膜，是个模式为“L”的图片对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgSrc=paste(img,(x,y),mask=msk)</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803214507273.png" alt="image-20230803214507273"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230803215513178.png" alt="image-20230803215513178"></p><h3 id="通过图片获取额外信息">通过图片获取额外信息</h3><h4 id="图片的exif信息">图片的exif信息</h4><p>当我们拍摄一张照片后，照片会有其exif信息，手机拍摄的照片以原图在网络上传播，可能会泄露个人隐私。</p><p>照片的exif信息涵盖了：照片拍摄的经纬度（地点信息）、拍照设备、曝光实践、IOS、光圈等、拍摄实践等…</p><p><strong>Python的Pillow库可以获取照片的exif信息。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】11. Python文件读写</title>
      <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9111.%20Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9111.%20Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1>文件读写</h1><h2 id="文本文件读写">文本文件读写</h2><h3 id="打开文件">打开文件</h3><p>open打开文件后，f就在程序中代表这个文件。</p><ul><li><p>f.readlines读取文件的内容，内容存放在列表里面，列表的每个元素都是一个字符串，代表文件的一行</p></li><li><p><strong>open之后返回一个可迭代的文件对象给f</strong></p></li><li><p>打开模式可选</p><table><thead><tr><th>访问模式</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>r</td><td style="text-align:center">默认，以只读方式打开</td></tr><tr><td>w</td><td style="text-align:center">打开一个文件只用于写入</td></tr><tr><td>a</td><td style="text-align:center">追加</td></tr><tr><td>rb</td><td style="text-align:center">二进制只读</td></tr><tr><td>wb</td><td style="text-align:center">二进制写</td></tr><tr><td>ab</td><td style="text-align:center">二进制追加</td></tr></tbody></table></li><li><p><strong>常用的文件读取的方法如下图：</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717222733503.png" alt="image-20230717222733503"></p><h3 id="写文件"><strong>写文件</strong></h3><p>open会在目录创建文件（如果文件不存在），但是如果目录不存在，则会报错。因为open不能创建一个文件夹。</p><ul><li><p>常见的文件写入函数</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>f.write(s)</td><td>向文件写入一个字符串或字节流</td></tr><tr><td>f.writelines(lines)</td><td>将一个元素为字符串的列表写入文件</td></tr><tr><td>f.seek(offset)</td><td>改变当前文件操作指针的位置，offset的值：<br />0：文件开头；1：当前位置；2：文件结尾</td></tr></tbody></table></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717222816467.png" alt="image-20230717222816467"></p><h3 id="读文件"><strong>读文件</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223035755.png" alt="image-20230717223035755"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223143916.png" alt="image-20230717223143916"></p><h4 id="按行读入">按行读入</h4><p>如果按行读入，读取到某一行为空串“”，则表示已经文件结束。因为即使是空行也会读取出换行符“\n”</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223342231.png" alt="image-20230717223342231"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223544719.png" alt="image-20230717223544719"></p><h3 id="添加方式打开文件"><strong>添加方式打开文件</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223657179.png" alt="image-20230717223657179"></p><h2 id="文本文件的编码">文本文件的编码</h2><h3 id="基本概念">基本概念</h3><p>二进制以什么组合方式表示文字或字母。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717223828774.png" alt="image-20230717223828774"></p><h3 id="Python程序的编码">Python程序的编码</h3><p>.py文件必须以utf-8格式才能运行。如果存成ansi格式（对应gbk编码），那么<strong>应该在文件开头写上#coding=gbk</strong></p><h3 id="指定编码打开文件">指定编码打开文件</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717224143091.png" alt="image-20230717224143091"></p><h2 id="文件的路径">文件的路径</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717224443130.png" alt="image-20230717224443130"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717224546601.png" alt="image-20230717224546601"></p><h2 id="Python的文件夹操作">Python的文件夹操作</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717224703178.png" alt="image-20230717224703178"></p><h3 id="删除文件夹的递归函数">删除文件夹的递归函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717225455738.png" alt="image-20230717225455738"></p><h3 id="获取文件夹总大小的函数">获取文件夹总大小的函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717225527614.png" alt="image-20230717225527614"></p><h2 id="命令行参数">命令行参数</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717230500558.png" alt="image-20230717230500558"></p><h2 id="文件的异常处理">文件的异常处理</h2><p>比如打开的文件不存在时，存储空间不足或其他异常；</p><p>与文件有关的异常类：FileExistsError、FileNotFoundError等</p><p>异常处理机制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常操作</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    出错提示</span><br><span class="line">    </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    无论是否出错都强制执行代码，通常用于释放资源</span><br></pre></td></tr></table></figure><h2 id="文件的上下文管理器">文件的上下文管理器</h2><p>文件常与上下文管理器结合使用</p><p>上下文管理器限定文件对象的使用范围，当对象进入或者离开范围时，进行对象分配或释放内存。</p><p>上下文管理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ... <span class="keyword">as</span> ...:</span><br><span class="line">    </span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;arr.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="built_in">print</span>([line <span class="keyword">for</span> line <span class="keyword">in</span> fp])</span><br><span class="line">    </span><br><span class="line"><span class="comment">#同时打开两个文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> src, <span class="built_in">open</span>(<span class="string">&#x27;text_new.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> dst:</span><br><span class="line">    dst.write(src.read())</span><br></pre></td></tr></table></figure><h2 id="二进制文件">二进制文件</h2><ul><li><p>数据库文件、图像文件、可执行文件、音频文件、OFFICE文档均属于二进制文件</p></li><li><p>二进制文件不能使用记事本或其他文本文件编辑软件正常读写，也无法直接通过Python进行直接解析；</p><p>必须正确理解二进制文件结构和序列化规则，才能准确理解二进制文件内容并设计正确的反序列化规则；</p></li><li><p>序列化：把内存中的数据在不丢失其类型信息的情况下转成对象的二进制形式的过程，对象序列化后的形式经过正确的反序列化可以准确无误地恢复为原有的对象；</p></li><li><p>Python中常用的序列化模块主要有：pickle，struct，marshal</p></li></ul><p>举例：用pickle模块实现内存对象的保存</p><p>步骤：</p><ul><li><p>序列化：将对象在内存中的数据直接抓取出来，转换成有序的文本</p><p>pikle包的dumps()方法可以将对象转成字符串的形式</p></li><li><p>文本存储：使用文本文件写入的方法将对象存储到文件中</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】10. 关于Python的算法时间复杂度问题</title>
      <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9110.%20%E5%85%B3%E4%BA%8EPython%E7%9A%84%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%9110.%20%E5%85%B3%E4%BA%8EPython%E7%9A%84%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Python中in的复杂度">Python中in的复杂度</h2><p>对于a  in  b这个语句</p><p>如果b是列表、字符串、元组，则时间复杂度为O(n)，与元素的个数有关。</p><p>若b是字典或者集合，时间复杂度为O(1)。</p><h2 id="Python中一些操作的时间复杂度总结">Python中一些操作的时间复杂度总结</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717221426903.png" alt="image-20230717221426903"></p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】9. 集合</title>
      <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%919.%20%E9%9B%86%E5%90%88/"/>
      <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%919.%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1>集合</h1><h2 id="集合的基本概念">集合的基本概念</h2><ul><li><p>集合元素类型可以不同</p></li><li><p>不会有重复元素，集合会==自动去重==</p><p>集合的最大特点是不包含重复元素！去重操作一般是通过集合实现</p><p>利用集合自动去重的特点，我们可以进行序列数据类型的比较；比如检查两个列表元素类型是否相同；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">list1, list2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(list1)==<span class="built_in">set</span>(list2)</span><br></pre></td></tr></table></figure></li><li><p>集合也是可变元素，可以动态增加和删除</p></li><li><p>可以增删元素</p></li><li><p>整数、小数、复数、字符串、元组等<strong>不可变的数据类型</strong>才可以作为集合的元素</p><p>列表、<strong>字典和集合</strong>等可变的不可以作为集合元素</p></li><li><p>集合的作用是快速判断某个东西是否在一堆东西里面（用in）</p><p>用in判断某个东西是否在集合里面花费的时间是固定的O(1)复杂度</p></li><li><p><strong>集合的元素没有顺序，不能用下标访问，没有索引概念，不能切片</strong></p></li><li><p>==空集的创建==，注意不能像字典、列表一样用括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aset = <span class="built_in">set</span>()</span><br><span class="line"><span class="comment">#因为直接用大括号创建的是字典类型，集合和字典都是&#123;&#125;扩住的</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="集合的构造">集合的构造</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717215646757.png" alt="image-20230717215646757"></p><h2 id="集合的常用函数">集合的常用函数</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717215913579.png" alt="image-20230717215913579"></p><h2 id="（-）集合的运算">（*）集合的运算</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717220101312.png" alt="image-20230717220101312"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717220151449.png" alt="image-20230717220151449"></p><h2 id="集合示例程序">集合示例程序</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717220418702.png" alt="image-20230717220418702"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717220543358.png" alt="image-20230717220543358"></p><h2 id="集合类型的操作符和函数">集合类型的操作符和函数</h2><p>集合运算部分</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>S-T/S.difference(T)</td><td><strong>返回一个新集合</strong>，集合中元素是S-T的元素（即在S中不在T中的元素）</td></tr><tr><td>S-=T/S.difference_update(T)</td><td>集合的差运算，并更新集合S，而不是返回一个新集合</td></tr><tr><td>S&amp;T/S.intersection(T)</td><td><strong>返回一个新集合</strong>，元素是S&amp;T</td></tr><tr><td>S&amp;=T/S.intersection_update(T)</td><td>类似</td></tr><tr><td>S^T/S.symmetric_difference(T)</td><td><strong>返回一个新集合</strong>，集合元素是S和T对称差的结果</td></tr><tr><td>S^=T/S.symmetric_difference_update(T)</td><td>类似</td></tr><tr><td>S|T/S.union(T)</td><td></td></tr><tr><td>S|=T/S.update(T)</td><td></td></tr><tr><td>S&lt;=T/S.issubset(T)</td><td>判断S是T的真子集</td></tr><tr><td>S&gt;=T/S.issuperset(T)</td><td>判断S是T的真超集</td></tr></tbody></table><p>集合操作函数部分</p><table><thead><tr><th>函数/方法</th><th>描述</th></tr></thead><tbody><tr><td>S.add(x)</td><td>如果数据项x不在集合S中，将x加到S</td></tr><tr><td>S.clear()</td><td>移除S中所有数据项</td></tr><tr><td>S.copy()</td><td>返回集合S的一个拷贝</td></tr><tr><td>S.pop()</td><td><strong>随机</strong>弹出S中一个元素，如果S为空，产生KEYERROR</td></tr><tr><td>S.discard(x)</td><td>若x在S中，则移除，如果不在不报错；</td></tr><tr><td>S.remove(x)</td><td>若x在S中，则移除，如果不在则报错KEYERROR；</td></tr><tr><td>len(S)</td><td>返回集合S元素个数</td></tr><tr><td>sum(S)</td><td>对集合数据进行求和，最后结果是数值，所以前提是集合中都是数据类型的元素</td></tr><tr><td>x in S</td><td>略</td></tr><tr><td>x not in S</td><td>略</td></tr><tr><td>S.isdisjoint(T)</td><td>如果集合S和T没有相同元素，返回True</td></tr></tbody></table><h2 id="集合、列表的区别和选择">集合、列表的区别和选择</h2><h3 id="区别">区别</h3><ol><li><p>有序性：集合是无序的</p><p>​列表式有序的</p></li><li><p>重复性：集合元素不可重复</p><p>​列表元素可以重复</p></li><li><p>可变性：集合元素可变，可以通过函数进行增、删、改</p><p>​列表元素可变，通过索引和切片操作进行修改</p></li><li><p>存储方式：集合采用哈希表存储，所以<strong>在集合中查找特定元素的速度很快</strong></p><p>​列表采用动态数组的方式存储，所以<strong>在列表中按索引访问元素的速度很快</strong></p></li></ol><h3 id="选择">选择</h3><p>集合的使用场景：元素唯一且不关心元素顺序</p><p>列表的使用场景：需要保持元素顺序且元素可以重复</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】8. 字典</title>
      <link href="/2023/07/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%918.%20%E5%AD%97%E5%85%B8/"/>
      <url>/2023/07/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%918.%20%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1>字典</h1><h2 id="字典的基本认识">字典的基本认识</h2><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717133332542.png" alt="image-20230717133332542"></p><p><strong>注意：</strong></p><ul><li>不可变的数据类型：str   int   float  tuple</li><li>可变的数据类型：list  dict  set</li><li>==只有不可变的数据类型才能作为字典元素的<strong>键</strong>==</li><li>字典用花括号扩住：d={…}</li><li>字典是键值对，没有索引的概念，不能下标访问，否则报keyerror类型错误</li><li><strong>字典的键是唯一的，如果有多个一样的键，则会自动剔除多余的，取最右边的键的值</strong></li></ul><h3 id="字典元素的访问">字典元素的访问</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717133722074.png" alt="image-20230717133722074"></p><h3 id="字典的基本操作">字典的基本操作</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717133928489.png" alt="image-20230717133928489"></p><p>涉及到<strong>in</strong>和函数<strong>get</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717134155945.png" alt="image-20230717134155945"></p><h3 id="字典的构造">字典的构造</h3><p>d={‘a’:'b}相当于d={(‘a’,‘b’)}，也就是元组生成字典的一种形式</p><h4 id="利用已有的数据创建字典">利用已有的数据创建字典!</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">dicts = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keys,values))</span><br><span class="line">dicts</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#给定键值创建值为空的字典</span></span><br><span class="line">adict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>])</span><br><span class="line">adict</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;name&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;age&#x27;</span>:<span class="literal">None</span>, <span class="string">&#x27;sex&#x27;</span>:<span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717134826007.png" alt="image-20230717134826007"></p><h2 id="lambda函数">lambda函数</h2><ul><li><p>lambda函数是一种特殊的函数——匿名函数</p></li><li><p>lambda函数是一个临时使用的函数，只包含一个表达式，表达式的计算结果可以看成函数的返回值</p></li><li><p>匿名函数并非没有名字，而是将函数名作为函数的结果返回：</p><p>fuc_name = lambda x: x</p></li><li><p>lambda函数与正常函数一样，等价于下面的表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fuc_name</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li></ul><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x,y=<span class="number">2</span>,z=<span class="number">3</span>: x+y+z</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="字典的相关函数">字典的相关函数</h2><table><thead><tr><th>函数和方法</th><th>描述</th></tr></thead><tbody><tr><td>d.keys()</td><td>返回字典中键的序列列表</td></tr><tr><td>d.values()</td><td>返回字典中值的序列列表</td></tr><tr><td>d.items()</td><td>返回字典中所有的键值对序列元组列表，键值对以元组组织</td></tr><tr><td>d.get(key,deflaut)</td><td>键存在则返回键值，否则返回默认值</td></tr><tr><td>d.pop(key,defalut)</td><td>键存在则返回键值并删除键值对，否则返回默认值</td></tr><tr><td>d.popitem()</td><td>随机从字典中取出一个键值对，以元组(k,v)的形式返回</td></tr><tr><td>d.clear()</td><td>删除所有键值对</td></tr><tr><td>del d[key]</td><td>删除字典中某个键值对</td></tr><tr><td>key in d</td><td>如果键值在字典d中返回True，否则返回False</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717135038589.png" alt="image-20230717135038589"></p><p><strong>应用</strong></p><p>关于字典打印出来的顺序问题：</p><p>在python3.5以前的版本，字典打印出来的顺序与字典本身的顺序毫无关系</p><p>在python3.5以后，字典的顺序与字典打印出来的顺序一致</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717140427561.png" alt="image-20230717140427561"></p><h3 id="字典的浅拷贝">字典的浅拷贝</h3><p><strong>键的值本质上是一个指针</strong></p><p>下面这个例子，y是x的浅拷贝，y修改了username的值不会影响到x，因为在y中，拷贝了username的指针，用另一块地址存放admin。</p><p>但是对于1978这个键的值，本身指向一块地址，y用另一块新的地址存放元组[1,2,3]的地址，实际上这时y和x的1978的键的值都指向同一块地址。所以y的变化会影响到x的变化。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717140721338.png" alt="image-20230717140721338"></p><h3 id="字典的深拷贝">字典的深拷贝</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717141121602.png" alt="image-20230717141121602"></p><h3 id="字典的遍历">字典的遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717141205168.png" alt="image-20230717141205168"></p><h2 id="字典推导式">字典推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;x:x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="string">&#x27; he&#x27;</span>,<span class="string">&#x27; she&#x27;</span>,<span class="string">&#x27; I&#x27;</span>)&#125;</span><br><span class="line">s</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27; he&#x27;</span>:<span class="string">&#x27;he&#x27;</span>,<span class="string">&#x27; she&#x27;</span>:<span class="string">&#x27;she&#x27;</span>,<span class="string">&#x27; I&#x27;</span>:<span class="string">&#x27;I&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">s = &#123;i:<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)&#125;</span><br><span class="line">s</span><br><span class="line">&gt;&gt;&#123;<span class="number">1</span>:<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>:<span class="string">&#x27;3&#x27;</span>,<span class="number">4</span>:<span class="string">&#x27;4&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">y = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">&#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x,y)&#125;</span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;B&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;C&#x27;</span>:<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;D&#x27;</span>:<span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】7. 列表</title>
      <link href="/2023/07/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%917.%20%E5%88%97%E8%A1%A8/"/>
      <url>/2023/07/07/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%917.%20%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1>列表</h1><h2 id="序列类型相关操作">序列类型相关操作</h2><p>列表、字符串、元组都是Python中的序列数据类型，元素的存储有顺序；</p><p>下面对顺序类型的数据的常见操作进行汇总；下面的表格对所有序列类型数据适用。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>x in s</td><td>x如果是s的元素，返回True，否则返回False</td></tr><tr><td>x not in s</td><td>不赘述</td></tr><tr><td>s+t</td><td>连接s和t</td></tr><tr><td><strong>s*n 或 n*s</strong></td><td><strong>将序列s复制n次</strong></td></tr><tr><td>s[i]</td><td>索引，返回序列的第i个元素</td></tr><tr><td><strong>s[i:j]</strong></td><td><strong>切片</strong>，返回包含序列s第i到j个元素的子序列（不包含j元素，==左闭右开==）</td></tr><tr><td>s[i:j:k]</td><td>按步长k切片，返回包含序列s第i到j个元素以k为步数的子序列</td></tr><tr><td><strong>len(s)</strong></td><td><strong>序列s的元素个数（长度）</strong></td></tr><tr><td><strong>min(s)</strong></td><td>序列s中的最小元素</td></tr><tr><td><strong>max(s)</strong></td><td>序列s中的最大元素</td></tr><tr><td>==s.index(x[,i[,j]])==</td><td>序列s中从i开始到j位置中第一次出现元素x的位置</td></tr><tr><td><strong>s.count(x)</strong></td><td>序列s中出现x的总次数</td></tr><tr><td><strong>sum(s)</strong></td><td>一般针对数字，对序列s中的元素求和</td></tr><tr><td><strong>sorted(s)</strong></td><td>排序函数，对列表、元组、集合等数据类型进行排序，返回列表</td></tr><tr><td>==enumerate==</td><td>枚举函数，将列表/元组/字典等其中的元素进行编号，返回其编号和元素</td></tr></tbody></table><h2 id="列表简介">列表简介</h2><ul><li><p>列表可以增删元素，列表元素可以修改，列表元素可以是任何类型；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416213710381.png" alt="image-20230416213710381"></p></li><li><p>分析说明：</p><ol><li>del   删除列表元素的函数</li><li>list.append()，括号内<strong>无论输入什么，都是作为一个元素添加在列表的尾部</strong></li></ol></li></ul><h2 id="列表的赋值">列表的赋值</h2><ul><li><p>对于列表来说，a+=b和a=a+b不同</p><ol><li>a+=b，相当于在a列表指向的地址后面添加了一块地址给a；<strong>注意：+=的右边一定是一个列表</strong></li><li>a=a+b，相当于分配一块新的空间，存储a+b，即<strong>生成一个新的列表，然后让a指向这块新的地址</strong>；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416214211391.png" alt="image-20230416214211391"></p></li></ul><h3 id="列表乘法">列表乘法</h3><p>说明：</p><p>这里的b=a*3，相当于拷贝了一份a*3，然后b作为一个新的列表存放这些内容，和a不相关；</p><p>而c=[a]*3是说，c是一个列表，<strong>它的每一个元素都指向a</strong>，有3个元素，所以a的值的改变会影响c；</p><p><strong>启示:</strong> 涉及到新列表，就是涉及到一个新地址；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416214413565.png" alt="image-20230416214413565"></p><p>深入探索：a=[0]*2+[0]*2是什么？</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716194826466.png" alt="image-20230716194826466"></p><h3 id="列表的切片">列表的切片</h3><p><strong>和字符串切片类似</strong></p><p>==列表可以同时使用正向递增序列和反向序列来切片！==</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416223322087.png" alt="image-20230416223322087"></p><h3 id="列表比大小">列表比大小</h3><p>和元组一致；</p><p>逐个比较，如果无法比较的数据类型，会runtime error</p><h3 id="列表相关函数">列表相关函数</h3><ul><li>sum   可以求列表元素的和，同时True表示1，False表示0</li></ul><h2 id="列表的排序">列表的排序</h2><h3 id="列表的朴素排序算法">列表的朴素排序算法</h3><ul><li>选择排序法</li><li>冒泡排序法</li></ul><h3 id="排序函数">排序函数</h3><p>sort是排序函数</p><p><strong>对数的排序</strong></p><p>用法：</p><ul><li>a.sort()，这样就会对a从小到大排序</li><li>b=sort<strong>ed</strong>(a)，对a排序后，生成一个新的列表b</li><li>a.sort(==reverse=True==)  从大到小排序</li></ul><h2 id="复杂列表的自义定排序">复杂列表的自义定排序</h2><p>==自定义比较函数 key，自定义排序规则，实际上是重载key函数==</p><h3 id="lambda表达式">lambda表达式</h3><p>lambda x:x[2]</p><p>lambda  参数：返回值</p><p>表示一个函数，参数是x，返回值是x[2]</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230417185113033.png" alt="image-20230417185113033"></p><h3 id="用不同的关键字排序">用不同的关键字排序</h3><p>如果关键字比较相同，则相对位置不变</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230417185223327.png" alt="image-20230417185223327"></p><h3 id="重载比较函数">重载比较函数</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716201233568.png" alt="image-20230716201233568"></p><h3 id="多级排序">多级排序</h3><p>需求：有时候不止需要比较关键词，还需要比较多种数据；如年龄、成绩、姓名。</p><p>下面是多级比较按照年龄从大到小、成绩从高到低、姓名字典序排序的例子：</p><p>​自定义的排序函数f的返回值是一个<strong>元组</strong>，我们知道，元组的比较顺序就是从第0个元素开始逐个比较，如此便实现了我们的需求。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716201951067.png" alt="image-20230716201951067"></p><h3 id="Python元组的排序">Python元组的排序</h3><p>元组不能修改，因此没有sort函数，但是可以用sorted函数。</p><p>用sorted函数后，元组变成排序后的新的列表，但元组本身不受影响。这个例子和多级排序的例子相同。</p><h2 id="列表相关函数-2">列表相关函数</h2><table><thead><tr><th>函数或方法</th><th>描述</th></tr></thead><tbody><tr><td>ls[i] = x</td><td>替换列表ls第i数据项为x</td></tr><tr><td>ls[i:j] = lt</td><td>用列表lt替换ls中第i到j项数据（不包括第j项）</td></tr><tr><td><strong>ls[i:j:k]</strong></td><td>有步长的替换，依然不包括第j项</td></tr><tr><td>del ls[i:j]</td><td>删除列表ls第i到j项数据，等价于ls[i:j]=[]</td></tr><tr><td><strong>del ls[i:j:k]</strong></td><td>删除列表ls第i到j以k为步的数据</td></tr><tr><td><strong>ls+=lt或ls.extend(lt)</strong></td><td>将列表<strong>lt的元素</strong>增加到列表ls中</td></tr><tr><td>*<em>ls <em>= n</em></em></td><td><strong>更新列表ls，其元素重复n次</strong></td></tr><tr><td>ls.append(x)</td><td>在列表ls最后增加一个元素x</td></tr><tr><td><strong>ls.clear()</strong></td><td>删除ls中所有元素</td></tr><tr><td><strong>ls.copy()</strong></td><td>返回一个新列表，复制ls中的所有元素</td></tr><tr><td><strong>ls.insert(i,x)</strong></td><td>在列表ls的第i个位置添加元素x</td></tr><tr><td><strong>ls.pop(i)</strong></td><td>将列表ls中第i项元素取出并删除该元素</td></tr><tr><td><strong>ls.remove(x)</strong></td><td>将列表中<strong>出现的第一个</strong>x元素删除</td></tr><tr><td><strong>ls.reverse()</strong></td><td>将列表中元素进行反转</td></tr><tr><td><strong>ls.sort()</strong></td><td>将列表中的数据从小到大排序</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230524221406534.png" alt="image-20230524221406534"></p><p>注意：</p><ol><li>extend和append的区别</li><li>remove(x)，只会删掉列表中第一次出现的x</li></ol><h2 id="列表映射">列表映射</h2><ul><li>map(function,sequence) ，可以用于将一个序列（列表、元组、集合…）映射到另一个序列</li><li>返回一个延时求值对象，可以转化为list、tuple、set…</li></ul><p>下面的a=map(f,[1,2,3])表示map是一个函数，将列表的各个元素作为参数，以x*x为返回值收集起来，a存放的是映射后的<strong>延时求值对象</strong>，它还没有被转换成list、set、tuple等数据类型，还不能使用。</p><p>在后面的代码操作中，通过list(a)、set(a)、tuple(a)，可以将a序列实例化，但是只能对a操作一次。</p><p><strong>下面代码第一次list(a)，已经把对象a进行了转化成list的操作，这时a对象就不存在了。后面再进行tuple(a)，输出为空。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716204447599.png" alt="image-20230716204447599"></p><h2 id="列表过滤">列表过滤</h2><ul><li>filter(function,sequence)，抽取序列中令function(x)为True的元素x</li><li>返回延时求值对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716205213583.png" alt="image-20230716205213583"></p><h2 id="嵌套元祖的复杂列表">嵌套元祖的复杂列表</h2><p>复杂列表：</p><ol><li>各个元素可以是任意类型；</li><li>列表不会预先分配空间，可以任意增加长度；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student = [(<span class="string">&#x27;201901&#x27;</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">25</span>),(<span class="string">&#x27;201902&#x27;</span>,<span class="string">&#x27;张角&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">26</span>)]</span><br></pre></td></tr></table></figure><h2 id="推导式生成列表-元组-字典-集合">推导式生成列表/元组/字典/集合</h2><h3 id="列表生成式"><strong>列表生成式</strong></h3><p>一行代码生成一个列表。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716205623299.png" alt="image-20230716205623299"></p><h3 id="元组生成式">元组生成式</h3><p>和列表生成式语法相同，不过格式为<strong>tuple(…)</strong></p><p>而元组生成式格式为**[…]**</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716205722216.png" alt="image-20230716205722216"></p><h3 id="集合推导式">集合推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aset = &#123;x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="字典推导式">字典推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adict = &#123;x:x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)&#125;</span><br></pre></td></tr></table></figure><h3 id="列表推导式复杂应用">列表推导式复杂应用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#矩阵转置</span></span><br><span class="line">matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">matrix_reverse = [[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用内置函数实现矩阵转置</span></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))  <span class="comment">#序列解包</span></span><br><span class="line">&gt;&gt;[(<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>),(<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>),(<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>),(<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>)]</span><br></pre></td></tr></table></figure><h2 id="二维列表">二维列表</h2><p>二维列表可以看作是矩阵，a[i][j]就是第i行第j列元素。</p><h3 id="二维列表的错误生成方法">二维列表的错误生成方法</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716234804057.png" alt="image-20230716234804057"></p><h3 id="二维列表的正确生成方法">二维列表的正确生成方法</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716235306898.png" alt="image-20230716235306898"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716235323595.png" alt="image-20230716235323595"></p><h2 id="二维元组">二维元组</h2><p>二维元组的定义和二维列表的定义类似</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716235406251.png" alt="image-20230716235406251"></p><h2 id="列表的拷贝-复制（重点关注）">列表的拷贝/复制（重点关注）</h2><h3 id="列表的拷贝">列表的拷贝</h3><h4 id="浅拷贝">浅拷贝</h4><p>若有两个列表a,b；则b=a意味着b指向a指向的地址，这时a和b指向同一个地址，相互影响。</p><p>若需要对列表进行拷贝：b=a[:]</p><p>也可以通过函数的方式进行拷贝：b = a.copy()</p><h4 id="深拷贝">深拷贝</h4><p>以下是浅拷贝的例子。</p><p><strong>浅拷贝</strong>：只拷贝指针，并不拷贝指针指向的内容</p><p><strong>深拷贝</strong>：不但拷贝指针，还拷贝指针指向的内容（以下面的例子来说，就是把列表[2]也另外拷贝了一份，b=[1,[2]]，虽然b中的[2]和a中的[2]看起来一样，但他们并不是指向同一块地址，不会相互影响。）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230716235751896.png" alt="image-20230716235751896"></p><h4 id="列表深拷贝的实现">列表深拷贝的实现</h4><p>深拷贝之后，a和b没有任何相互影响的关系。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717000422658.png" alt="image-20230717000422658"></p><h2 id="数据类型的互转">数据类型的互转</h2><h3 id="强制类型转换方法">强制类型转换方法</h3><h4 id="元组和列表的转换">元组和列表的转换</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717000624061.png" alt="image-20230717000624061"></p><h4 id="元组、列表和字符串的转换">元组、列表和字符串的转换</h4><p>解释一下第二行代码的&quot;&quot;.join([…])，join的功能就是把传给join的参数连在一起（一般是列表），再加上字符串尾巴，这里尾巴是“”。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230717000834759.png" alt="image-20230717000834759"></p><h4 id="数字和列表的相互转换">数字和列表的相互转换</h4><ol><li><p>把123转换成[1,2,3]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">123</span></span><br><span class="line">lst=[<span class="built_in">int</span>(digit) <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">str</span>(num)]</span><br><span class="line"><span class="comment">#先把数字转换成字符串，再使用列表推导式</span></span><br></pre></td></tr></table></figure></li><li><p>把[1,2,3]转换成123</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">lst=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,lst))<span class="comment">#先把序列转换成字符串序列，因为join函数只是对字符串的拼接</span></span><br><span class="line">num=<span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(lst))</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】6. 元组</title>
      <link href="/2023/07/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%916.%20%E5%85%83%E7%BB%84/"/>
      <url>/2023/07/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%916.%20%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1>元组</h1><ul><li>元组由数个逗号分隔的值构成，前后可以加括号；</li><li>元组不能修改，即不可增删元素，不可对元素赋值，不可修改元素顺序（比如排序）；</li><li>访问方式与列表相同，元组的访问速度比列表快。（列表式方括号，元素可修改）；</li><li>一般用于表达固定的数据项、函数多个返回值等情况；</li><li>元组中的元素可以是任意不同类型，元组中的元素如果是==列表或者集合==是可以修改的；</li><li>元组表示的是结构，列表表示的是顺序，所以元祖通常由不同的数据类型元素构成，而列表通常由相同的数据类型构成；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416205739412.png" alt="image-20230416205739412"></p><ul><li><p><strong>元组的内容由可能被修改。例如，如果元组是列表，就可以修改该列表；</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416210255845.png" alt="image-20230416210255845"></p></li></ul><h2 id="元组元素的本质">元组元素的本质</h2><p><strong>元组的每个元素都是一个指针，一旦元组建立，那么元组元素的指针指向就确定了</strong>，不能更改元组元素的指向；</p><p>可以对元组的元素进行修改，比如，元素是一个列表，可以修改该列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="string">&#x27;abc&#x27;</span>,<span class="number">123</span>,<span class="string">&quot;ios&quot;</span></span><br><span class="line">t[<span class="number">0</span>]=<span class="number">5</span> <span class="comment">#错误，元组元素不能更改指向</span></span><br><span class="line">t[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">123</span> <span class="comment">#可以修改，修改元组元素指向的内容是可以的</span></span><br></pre></td></tr></table></figure><h2 id="元组的高级用法">元组的高级用法</h2><h3 id="元组的内置函数">元组的内置函数</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(tuple)</td><td>计算元组个数</td></tr><tr><td>max(tuple)</td><td>略</td></tr><tr><td>min(tuple)</td><td>略</td></tr><tr><td>tuple(seq)</td><td>将列表转为元组</td></tr><tr><td>其他序列型函数</td><td>在列表那一章有汇总</td></tr></tbody></table><p><strong>元组使用的注意事项：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#元组中元素不能修改</span></span><br><span class="line">atuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">atuple.sort()   错误！</span><br><span class="line">atuple.pop()   错误！</span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>(atuple)   允许！</span><br></pre></td></tr></table></figure><h3 id="单元素原组">单元素原组</h3><p><strong>注意单元素原组，一定不能少了逗号，否则不是元组；</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416210633369.png" alt="image-20230416210633369"></p><h3 id="元组的切片">元组的切片</h3><p>用下标访问元组，以及元组的切片；用法和字符串一样；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416210800842.png" alt="image-20230416210800842"></p><h3 id="元组的连接和组合">元组的连接和组合</h3><ul><li><p>可以对元组进行连接组合；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416210916671.png" alt="image-20230416210916671"></p></li><li><p>和字符串连接相似；</p></li></ul><h3 id="元组的运算和迭代">元组的运算和迭代</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416211026364.png" alt="image-20230416211026364"></p><h3 id="元组的赋值">元组的赋值</h3><p>分析：<code>x+=(100,)</code>等价于<code>x=x+(100,)</code>，<strong>实际上就是在赋值符号右边新建了一个元组指向新的地址</strong>，x指向那块新的地址；但是b指向的位置不变，内容也不变；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416211130909.png" alt="image-20230416211130909"></p><h3 id="元组比大小">元组比大小</h3><ul><li><strong>逐个元素比大小</strong>，直到分出胜负；</li><li>如果由两个对应元素无法比大小（比如数据类型不同），那么会出现runtime error</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416211439176.png" alt="image-20230416211439176"></p><h4 id="元组的实用例子：">元组的实用例子：</h4><ul><li>取代复杂的分支结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】5. 字符串</title>
      <link href="/2023/07/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%915.%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/07/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%915.%20%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1>字符串</h1><h2 id="转义字符">转义字符</h2><h3 id="转义字符：">转义字符：\</h3><ul><li><p>必须在引号里面</p></li><li><p>规定’\'不转义的字符串，要在字符串引号前加上r</p><p><code>print(r'ab\ncd')#这样的\会被当作正常的字符串输出  </code></p></li></ul><h2 id="字符串切片（子串）-同样时用于元组和列表">字符串切片（子串）/同样时用于元组和列表</h2><h3 id="a-x-y-详解">a[x:y]详解</h3><ul><li>对于字符串<code> a=&quot;ABCD&quot;</code>       <code>a[1:2]</code>表示<strong>左闭右开</strong>的字符串区间，代表了字符B</li><li><strong>字符串最左边的元素序号为0，最右边的元素序号为-1</strong></li><li><code>a[2:]</code>终点省略，表示从2一直到最后；开头省略同理；</li><li>修改字符串中的子串，不能通过s[i]='x’的方式进行修改和删除</li></ul><h3 id="Python字符串的两种序号体系">Python字符串的两种序号体系</h3><p>以字符串hello world为例：</p><table><thead><tr><th>反向序列</th><th>-11</th><th>-10</th><th>-9</th><th>-8</th><th>-7</th><th>-6</th><th>-5</th><th>-4</th><th>-3</th><th>-2</th><th>-1</th></tr></thead><tbody><tr><td>字符串</td><td>H</td><td>e</td><td>l</td><td>l</td><td>o</td><td></td><td>W</td><td>o</td><td>r</td><td>l</td><td>d</td></tr><tr><td>正向序列</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td></tr></tbody></table><h3 id="a-x-y-z-详解">a[x:y:z]详解</h3><p>a[x:y:z]表示，从a[x]取到a[y]（a[y]不算），<strong>每z个字符取一次</strong>，最后拼起来；</p><p><strong>z如果为负数，表示倒着取；</strong></p><p>x，y可以省略。x，y全省略表示从头取到尾或者从尾取到头；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416090539584.png" alt="image-20230416090539584"></p><h2 id="字符串的分割">字符串的分割</h2><h3 id="split函数详解">split函数详解</h3><p><code>s.split(x)</code>用字符串x做分割符分割字符串s，得到分割后的列表<strong>两个相邻分割符号之间会被分隔出一个空串</strong>。</p><p><strong>字符串分隔后，得到各个子串包括空串的列表。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416090826652.png" alt="image-20230416090826652"></p><h3 id="字符串高级分割">字符串高级分割</h3><h4 id="用多个分隔串进行分割（引入库re）">用多个分隔串进行分割（引入库re）</h4><p><strong>re是正则表达式包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">a=<span class="string">&#x27;beautiful, is ; better*than\nugly&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(re.split(<span class="string">&#x27;;| |,|\*|\n&#x27;</span>,a))<span class="comment">#分隔符串用 | 分开</span></span><br><span class="line">两个相邻的分隔符串之间，会隔出一个空串</span><br></pre></td></tr></table></figure><h3 id="字符串相关函数">字符串相关函数</h3><ul><li><p>count   求子串出现次数</p><p><code>s='thisAAbb AA'</code></p><p><code>s.count('AA')</code>  返回2，表示AA出现2次</p></li><li><p>len   字符串长度</p><p><code>s='1234'</code></p><p><code>len(s)</code>   返回4</p></li><li><p>upper、lower函数</p><p>转大写、小写</p></li><li><p>find、rfind、index、rindex   在字符串中查找子串，返回找到的下标。找不到的话find返回-1，index引发异常</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416091854828.png" alt="image-20230416091854828"></p><ol><li><p>find还可以指定查找的起点。</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416092046109.png" alt="image-20230416092046109"></p></li></ol></li><li><p>replace  替换    返回替换后的新串</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416092132781.png" alt="image-20230416092132781"></p></li><li><p>isdigit()、islower()、isupper()，判断字符串是否是数，是否全是小写等</p></li><li><p>startswith，endswith，判断字符串是否以某个子串开头或者结尾</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416092423228.png" alt="image-20230416092423228"></p><ul><li><p>strip()  返回除去头尾空白字符(空格、‘\r’ ‘\t’ ‘\n’)后面的字符串</p></li><li><p>lstrip()  返回除去头部(左端)空白字符后的字符串</p></li><li><p>rstrip()  返回除去尾部空白字符串后的字符串</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416092729841.png" alt="image-20230416092729841"></p></li></ul><h2 id="字符串的编码">字符串的编码</h2><p>字符串在内存中的编码都是unicode，虽然写到文件的时候可能是gbk，或者utf-8</p><h2 id="字符串的格式化">字符串的格式化</h2><h3 id="format函数">format函数</h3><p>format函数，在字符串对应的参数格式。{0}…format{“nihao”,“21” }——&gt;表示format中的第0个元素替换{0}。</p><p>也可以用键值对的方式进行对应：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125;,&#123;sex&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;icserm&quot;</span>,sex=<span class="string">&#x27;male&#x27;</span>))</span><br></pre></td></tr></table></figure><p>{序号：宽度.精度  类型}</p><ul><li>&lt;  右对齐</li><li>&gt;   左对齐</li><li>^   中对齐</li><li>:b 、 :d 、 :o 、:x 分别表示二进制、十进制、八进制、十六进制输出</li></ul><p><strong>例如：如{0:&gt;10.4f}表示第0项是小数，以宽度至少是10个字符，右对齐（宽度不足时补充在左边），保留小数点后4位的方式输出。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416093121081.png" alt="image-20230416093121081"></p><h4 id="字符串格式化2image-20230416093653076">字符串格式化2<img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416093653076.png" alt="image-20230416093653076"></h4>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】4. Python数据类型</title>
      <link href="/2023/07/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%914.%20Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/07/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%914.%20Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>Python的数据类型</h1><h2 id="基本数据类型">基本数据类型</h2><ul><li>int</li><li>float</li><li>complex</li></ul><h2 id="组合数据类型">组合数据类型</h2><ul><li>字符串   str</li><li>元组       tuple</li><li>列表       list</li><li>字典       dict</li><li>集合       set</li></ul><h2 id="相关函数">相关函数</h2><ol><li><p>isinstance(x,y)   查询数据x是否时类型y</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;1233&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a,<span class="built_in">str</span>)) <span class="comment">#返回true</span></span><br></pre></td></tr></table></figure></li><li><p>len   求组合数据类型的元素个数（长度）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230415235603907.png" alt="image-20230415235603907"></p></li></ol><h2 id="关于Python中变量的理解">关于Python中变量的理解</h2><ul><li><p>Python中的变量<strong>都是指针</strong>；</p><p><strong>python中所有可以赋值的东西，也就是所有可以出现在“=”左边的东西，==都是指针==；</strong></p></li><li><p>指针即代表内存单元的地址</p></li><li><p><strong>对变量进行赋值的本质，就是让该变量的指针指向某个地址</strong>(每对变量赋值一次，就会给一个赋值一个地址，是<strong>实时动态变化</strong>的)</p></li><li><p><strong>用一个变量对另一个变量赋值，意味着让两个变量指向同一个地方</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416000022697.png" alt="image-20230416000022697"></p></li></ul><h3 id="“is-运算符和”-的区别">“is&quot;运算符和”==&quot;的区别</h3><ul><li>a is b 为true，说明a和b指向同一个地方（指针地址相同）</li><li>a == b 为true，说明a和b指向的地方放的东西相同（指针指向的地址上存储的数据相同）</li><li>a=b会使得a和b指向同一个地方</li></ul><h4 id="值的注意的问题：">值的注意的问题：</h4><ul><li>对于list、dict、set类型的变量</li></ul><p>这类变量存储时，分配一片连续的空间存储数据，如果对其中的某片数据进行改变，就是对内存上某个位值的数据进行改变，但<strong>地址不变</strong></p><p>对于赋值符号两边，其中一个变量数据的改变会影响到另一个变量，因为他们指向同一块地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b=a</span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">2</span>]) <span class="comment">#输出3</span></span><br><span class="line">a[<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">2</span>])<span class="comment">#输出10</span></span><br></pre></td></tr></table></figure><ul><li><p>对于int、float、complex、str、tuple类型的变量</p><p>他们的存储时分配一块内存地址，每次给他们的值改变，都会给他们分配一片新的内存空间，也就是说原来地址上的数据不变，但是该变量的地址改变了。</p><p>所以当a=b，a改变了并不会对b造成影响</p></li></ul><h3 id="列表元素的指针本质">列表元素的指针本质</h3><ul><li><p>列表元素也可以赋值，也是指针</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230416002538576.png" alt="image-20230416002538576"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】3. 函数</title>
      <link href="/2023/07/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%913.%20%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%913.%20%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>函数</h1><h2 id="函数的定义">函数的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法一</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二（不带返回值）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="comment">#函数体</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python的函数可以返回多个值">python的函数可以返回多个值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sumAndDiffernt</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x+y,x-y</span><br><span class="line"></span><br><span class="line">s,d=sumAndDiffernt(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(s,d)</span><br><span class="line">//输出<span class="number">15</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="参数传递">参数传递</h2><h3 id="参数传递的方式">参数传递的方式</h3><p>注意：</p><ul><li><strong>函数调用是值传递</strong></li><li><strong>对于列表这类参数，传递的时候是引用传递，函数内对列表的改变也会改变列表本身</strong></li></ul><ol><li><p>根据位置传递参数</p></li><li><p>利用键值对进行参数传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数名=值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d</span><br><span class="line"></span><br><span class="line">e = f(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li><p>参数的默认值参数：<strong>python的默认值参数必须位于形参列表的最后面</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b,c,d=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d</span><br><span class="line"><span class="comment">#如果这样定义会报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b,c=<span class="number">2</span>,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b+c+d</span><br></pre></td></tr></table></figure></li><li><p>打包传递参数</p><ul><li>定义函数时，无法确定参数个数，或者允许函数进行松散定义，形式自由</li><li>打包传递也包括两种方式：位置值，键值对</li><li>==*代表可以传递任意数量的事迹参数值==</li><li>==**代表传递任意数量的键值对==</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pakage_para</span>(<span class="params">*all_parameters</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(all_parameters))</span><br><span class="line">    <span class="built_in">print</span>(all_parameters)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#*打包传递会把传入的参数打包成元组    </span></span><br><span class="line">pakage_para(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">&lt;&lt; &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;&lt; (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">pakage_para(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line">&lt;&lt; &lt;<span class="keyword">class</span> <span class="string">&#x27;tuple&#x27;</span>&gt;</span><br><span class="line">&lt;&lt; (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pakage_parakeyword</span>(<span class="params">**all_parameters</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(all_parameters))</span><br><span class="line">    <span class="built_in">print</span>(all_parameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">#**打包传递会把传入的参数打包成字典</span></span><br><span class="line">pakage_parakeyword(a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>)</span><br><span class="line">&lt;&lt; &lt;<span class="keyword">class</span>,<span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line">&lt;&lt; &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">4</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="返回值">返回值</h2><ul><li><p>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式</p></li><li><p>不带return语句的函数返回None</p></li><li><p>可以返回多个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果多个返回值仅以逗号隔开，则返回值被打包成元组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,c,d</span>):</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">1</span>,b+<span class="number">1</span>,c+<span class="number">1</span>,d+<span class="number">1</span></span><br><span class="line">a = f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">type</span>(a)</span><br><span class="line">&lt;&lt; <span class="string">&#x27;tuple&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Python变量以及其作用范围">Python变量以及其作用范围</h2><p>变量类型：</p><ol><li><p>全局变量/外部变量</p></li><li><p>局部变量/内部变量</p></li><li><p>闭包：</p><p>闭包是介于全局变量和局部变量之间的一种特殊变量，常用语<strong>函数的嵌套定义。</strong></p><p>闭包变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">20</span> <span class="comment">#全局变量j</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    k=<span class="number">10</span> <span class="comment">#闭包变量k</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">        i = k+j <span class="comment">#局部变量i</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"><span class="keyword">return</span> f2()</span><br></pre></td></tr></table></figure></li></ol><p>局部变量和外部变量：</p><p>在局部函数中需要使用到外部变量，则需要再局部函数内部声明外部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inside_var</span>():</span><br><span class="line">    <span class="keyword">global</span> info<span class="comment">#必须要单独声明，不能global info=&quot;xxx&quot;，否则报错</span></span><br><span class="line">    info+=<span class="string">&quot;def&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(info)</span><br><span class="line"></span><br><span class="line">inside_var()</span><br><span class="line"><span class="built_in">print</span>(info)</span><br><span class="line"></span><br><span class="line">&lt;&lt; abcedf</span><br><span class="line">&lt;&lt; abcdef</span><br></pre></td></tr></table></figure><h2 id="Python函数的模块化管理">Python函数的模块化管理</h2><ul><li>模块化函数解决同名冲突问题</li></ul><p>场景：同一个.py文件定义了同名函数，多人协作的函数同名问题…</p><p>解决方式：用模块封装函数</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#model1.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfeeling</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you are right&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#model2.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">myfeeling</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes yes yes&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#main.py</span></span><br><span class="line"><span class="keyword">import</span> model1 <span class="keyword">as</span> m1</span><br><span class="line"><span class="keyword">import</span> model2 <span class="keyword">as</span> m2</span><br><span class="line"></span><br><span class="line"><span class="comment">#主调函数</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    m1.myfeeling()</span><br><span class="line">    m2.myfeeling()</span><br><span class="line"></span><br><span class="line">&lt;&lt; you are right</span><br><span class="line">&lt;&lt; yes yes yes</span><br></pre></td></tr></table></figure><ul><li><p>如果我们导入的模块除了定义函数之外还有其他可执行代码，那么Python解释器在导入这个模块的时候会执行这些代码。</p></li><li><p>如果我们在模块中的部分代码不希望在别的模块调用时执行，就写入到模块的入口地址判断下去:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#model1.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printFeeliing</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;111&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;222&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#以下内容在其他模块调用本模块的时候不会执行，所以对于每一个模块，以下部分可以作为调试、也可以作为主函数入口地址，调用其他模块在此执行系统</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我在模块1&#x27;</span>)</span><br><span class="line">    printFeeling()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数装饰器">函数装饰器</h2><h3 id="简介">简介</h3><ul><li>装饰器（decorator）是一种高级Python语法。可以对函数、方法、类进行加工、扩充；</li><li>装饰器可以从操作入手，为函数增加额外指令；</li></ul><p>场景：</p><p>在一个模块中定义好了各种函数、方法；</p><p>在调用的时候，缺少良好的交互系统；</p><p>这时可以用装饰器来解决；装饰器本质上是一个函数；</p><ol><li><p>例子：</p><p>装饰器作用：不修改原有函数的情况下扩充原有函数功能。</p><p><strong>注意：装饰器函数的定义一定要在old_function前面；</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#model1.py</span></span><br><span class="line"><span class="comment">#装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator_demo</span>(<span class="params">old_function</span>):<span class="comment">#传入旧函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_function</span>(<span class="params">x,y</span>):<span class="comment">#定义新函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;参数为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(x,y))</span><br><span class="line">        <span class="keyword">return</span> old_fuction(x,y)</span><br><span class="line">    <span class="keyword">return</span> old_function(x,y)<span class="comment">#返回的是新函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_demo  </span><span class="comment">#这句语句声明以下函数方法被装饰器调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_sum</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span>+y**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_demo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cubic_sum</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span>+y**<span class="number">3</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Python中的高阶函数">Python中的高阶函数</h2><h3 id="简介-2">简介</h3><ul><li><p>能接受<strong>函数</strong>作为其参数的函数，是高阶函数。</p></li><li><p>装饰函数就是典型的高阶函数；</p></li><li><p>常见的高阶函数：</p><ul><li>map()</li><li>filter()</li><li>reduce()</li></ul></li></ul><h4 id="map-函数">map()函数</h4><p>作用：将一个函数对象作用于多个元素</p><p><strong>注意：迭代对象迭代结束以后，元素已经结束访问！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data_list = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,data_list)</span><br><span class="line"><span class="comment">#第一个参数是函数对象（可以是匿名函数），第二个参数是可循环对象</span></span><br><span class="line"><span class="comment">#返回值类型是可迭代对象map，需要用list()直接转换成列表，也可以用列表生成式获取结果</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line">&lt;&lt; <span class="string">&#x27;map&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过list函数将map对象转换成列表输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line">&lt;&lt; [<span class="number">4</span>,<span class="number">16</span>,<span class="number">36</span>,<span class="number">64</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于可迭代对象，迭代结束后元素就已经访问结束，所以第二次访问已经无输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line">&lt;&lt; []</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过列表生成式获取结果</span></span><br><span class="line">newresult = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,data_list)</span><br><span class="line"><span class="built_in">print</span>([var <span class="keyword">for</span> var <span class="keyword">in</span> newresult])</span><br><span class="line">&gt;&gt; [<span class="number">4</span>,<span class="number">16</span>,<span class="number">36</span>,<span class="number">64</span>]</span><br></pre></td></tr></table></figure><p>map函数的典型使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quare_sum</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span>+y**<span class="number">2</span></span><br><span class="line"><span class="comment">#求平方和</span></span><br><span class="line"></span><br><span class="line">data1=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">data2=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#map传入函数</span></span><br><span class="line">result = <span class="built_in">map</span>(square_sum, data1, data2)</span><br><span class="line"></span><br><span class="line">resultlist = [var <span class="keyword">for</span> var <span class="keyword">in</span> result]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resultlist)</span><br></pre></td></tr></table></figure><h4 id="filter-函数">filter()函数</h4><p>作用：将函数作用于可循环对象的多个元素。如果函数对象返回值是True，则钙元素放回返回可迭代对象filter中。本质作用是通过调用函数筛选数据。</p><p>举例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">larger50</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">50</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">data = [<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">56</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter函数的调用：第一个参数为自定义筛选函数，第二个参数为可迭代对象</span></span><br><span class="line">result = <span class="built_in">filter</span>(larger50,data)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line">&gt;&gt; <span class="string">&#x27;filter&#x27;</span></span><br><span class="line"><span class="comment">#返回值是filter对象，filter是可迭代的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出可迭代对象的元素值</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&gt;&gt; <span class="number">60</span>,<span class="number">90</span>,<span class="number">56</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出为空，因为已经在前面用for循环迭代过一次，迭代完后改对象为空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))</span><br><span class="line">&gt;&gt; 空</span><br></pre></td></tr></table></figure><h4 id="reduce-函数">reduce()函数</h4><p>简介：</p><ul><li>reduce函数可以通过将某种形式的==<strong>二元运算</strong>==累进的作用于参数对象；</li><li>reduce库位于标准库functools，使用时需要import导入，而map，和filter是内置函数；</li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">datalist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">result = reduce(<span class="keyword">lambda</span> x,y:x*y, datalist)</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>(result)</span><br><span class="line">&gt;&gt; <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line">&gt;&gt; <span class="number">24</span></span><br><span class="line"><span class="comment">#累进执行过程：1*2 = 2， 2*3 = 6， 6*4 = 24（这里是连乘）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】2. python的基本程序逻辑结构</title>
      <link href="/2023/07/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%912.%20python%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%912.%20python%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1>python的基本逻辑结构</h1><h2 id="条件分支语句">条件分支语句</h2><p>如果要控制缩进，就需要有冒号；</p><p><strong>循环结构、分支结构等等，都得注意缩进的问题</strong></p><h2 id="输出格式控制">输出格式控制</h2><h3 id="字符串中的格式控制符：">字符串中的格式控制符：</h3><ol><li>%s表示输出字符串</li><li>%d</li><li>%f</li><li>%.nf表示要输出一个小数，保留小数点后n位，<strong>四舍六入</strong></li></ol><h2 id="循环结构">循环结构</h2><h3 id="for循环">for循环</h3><h4 id="遍历数的范围">遍历数的范围</h4><p>range(5)，左闭右开</p><p>range(0,5)</p><p>range(0,10,3)，【0,10），步长为3；</p><h4 id="遍历列表">遍历列表</h4><p>len() 可以用于求字符串长度、元组、列表、字典等等的元素个数；</p><h4 id="遍历字符串">遍历字符串</h4><p>for letter in ‘taobao’</p><h4 id="字符的编码">字符的编码</h4><p>ord输入参数必须为字符串，输出为数字；</p><p>chr输入参数必须为整数，输出为字符；</p><p>字符的编码：二进制数，在计算机中的表示标识编码；比如汉字是unicode编码，字母是ASCII编码；</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230323232430296.png" alt="image-20230323232430296"></p><h3 id="while循环">while循环</h3><h4 id="基本语法">基本语法</h4><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230323235042204.png" alt="image-20230323235042204"></p><h2 id="异常处理">异常处理</h2><h3 id="基本语法-2">基本语法</h3><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230323235938258.png" alt="image-20230323235938258"></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230324000007566.png" alt="image-20230324000007566"></p><p>下标越界也会异常；<br>下标越界也会异常；</p><h2 id="格式输出常见方法">格式输出常见方法</h2><h3 id="format方法">format方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;John&quot;</span></span><br><span class="line">age=<span class="number">25.567</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I am &#123;:.2f&#125; years old.&quot;</span>.<span class="built_in">format</span>(name,age))</span><br></pre></td></tr></table></figure><h3 id="的形式（沿用C语言）">%的形式（沿用C语言）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s and I am %.2f years old.&quot;</span>%(name,age))</span><br></pre></td></tr></table></figure><h3 id="f-string格式化方法">f-string格式化方法</h3><p>用法：</p><p>在字符串前面加上f，然后再字符串中使用花括号{}来表示变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;name&#125;</span> and I am <span class="subst">&#123;age:<span class="number">.2</span>f&#125;</span> years old.&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python基础】1. 算术运算</title>
      <link href="/2023/07/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%911.%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/"/>
      <url>/2023/07/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90Python%E5%9F%BA%E7%A1%80%E3%80%911.%20%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1>python的计算</h1><p>注意事项：</p><ul><li><strong>/  输出的结果一定是小数</strong></li><li>x 如果是小数，那么x//1也是小数</li><li>print(-9//2)，结果是-5，向负半轴取数</li></ul><h2 id="关系运算符也能比较字符串">关系运算符也能比较字符串</h2><p>a=“abc”</p><p>a==“abc”，返回true</p><h2 id="逻辑运算符">逻辑运算符</h2><ul><li>and</li><li>or</li><li>not</li></ul><h2 id="关系运算的结果True-False">关系运算的结果True   False</h2><ul><li><p>False</p><p>0、“”(空字符串)、[](空列表)    都相当于False</p></li><li><p>True</p><p>非0数、非空字符串、非空列表</p></li></ul><h2 id="各种运算符的优先级">各种运算符的优先级</h2><p>从高到底：</p><ol><li><p>算术运算符：**、*、/、//、%、+、-</p><p><strong>注意：</strong>//是整除、/是带小数点的除法</p></li><li><p>关系运算符：&lt;、&gt;、==、！=、&lt;=、&gt;=</p></li><li><p>逻辑运算符：not、and、or</p></li></ol><h2 id="Python数据类型中的浮点数">Python数据类型中的浮点数</h2><p>Python中，浮点数的数据类型使用底层表示存储数据，用底层CPU和IEEE标准来计算；所以在python表示浮点数的时候会出现误差，即使是最简单的数学运算也可能产生小的误差。</p><p>比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2.1</span></span><br><span class="line">b = <span class="number">4.2</span></span><br><span class="line">a+b  &lt;&lt;输出 <span class="number">3.000001</span></span><br></pre></td></tr></table></figure><p>在一些特殊行业，比如金融，这样的误差是不被允许的；由于Python底层就是这样实现浮点数运算的，Python本身无法避免这样的误差；</p><p>为了解决这个问题，我们可以使用decimal库来获取更高的精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">a = Decimal(<span class="string">&#x27;4.2&#x27;</span>)</span><br><span class="line">b = Decimal(<span class="string">&#x27;2.1&#x27;</span>)</span><br><span class="line">a+b</span><br><span class="line">&lt;&lt; Decimal(<span class="string">&#x27;6.3&#x27;</span>) （输出的是正常精度的数字了）</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line">&lt;&lt; <span class="number">6.3</span></span><br><span class="line">(a+b) == Decimal(<span class="string">&#x27;6.3&#x27;</span>)</span><br><span class="line">&lt;&lt; <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="二进制以及二进制位运算">二进制以及二进制位运算</h2><p>二进制在Python中用0b打头；</p><p>bin()函数可以将十进制数据以二进制的方式表示；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b11011</span></span><br><span class="line">&lt;&lt; <span class="number">27</span></span><br><span class="line"><span class="built_in">bin</span>(<span class="number">27</span>)</span><br><span class="line">&lt;&lt; <span class="number">0b11011</span></span><br></pre></td></tr></table></figure><p>二进制的位运算：</p><table><thead><tr><th>运算符</th><th>名称与作用</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>==-==</td><td><strong>==按位取非==</strong></td></tr><tr><td>&lt;&lt;</td><td>左移运算符</td></tr><tr><td>&gt;&gt;</td><td>右移运算符</td></tr></tbody></table><h2 id="数据类型转换">数据类型转换</h2><ol><li>int(x)    不支持复数</li><li>float(x)    不支持复数</li><li>complex(x,y)</li><li>str(x)</li><li>bin(x)、 oct(x)、 hex(x)</li><li><strong>chr(x)， ord(x)</strong>    ASCII码与十进制的转化</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-6. selenium的使用</title>
      <link href="/2023/06/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-6.%20selenium%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-6.%20selenium%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>模拟浏览器爬取数据</h1><h2 id="selenium简介">selenium简介</h2><p>selenium会模拟一个浏览器进行数据的获取，然后我们可以在模拟浏览器获取的页面上进行数据的获取。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-5. cookie的利用</title>
      <link href="/2023/06/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-5.%20cookie%E7%9A%84%E5%88%A9%E7%94%A8/"/>
      <url>/2023/06/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-5.%20cookie%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>cookie</h1><h2 id="简介">简介</h2><p>cookie类似于一个密钥，客户端登录之后会获取一个cookie，然后后面的访问都带着cookie对服务器进行请求。很多网站，没有cookie，就不能请求到数据。</p><h2 id="使用">使用</h2><h3 id="步骤">步骤</h3><ol><li><p>登录    得到cookie</p></li><li><p>带着cookie对服务器请求数据</p></li><li><p>注意：上面两个操作必须连起来，所以我们需要用session进行请求。</p><p>​ session请求可以认为是一连串的请求，在请求过程中cookie不会丢失。</p></li></ol><h1>防盗链</h1><h2 id="防盗链">防盗链</h2><p>request请求中的headers中的参数referer中会有一个地址，这个地址用于溯源访问当前页面的前一个页面，如果前面没有的话就会被反爬。</p>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
            <tag> 计算机网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-4. 数据解析</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-4.%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-4.%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>数据解析</h1><h2 id="前言">前言</h2><p>爬虫获取到数据后需要对数据进行解析，常用的解析方式有三种：正则解析、bs4解析、xpath解析。</p><p>其中最常用并且最搞笑的解析方式就是xpath解析，其通用性也比较强。</p><h2 id="xpath解析">xpath解析</h2><h3 id="xpath简介">xpath简介</h3><p>xpath是xml文档中搜索内容的一门语言；html是xml的一个子集，所以xpath可以用于解析html中的内容。</p><h3 id="原理">原理</h3><ol><li>file实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中</li><li>调用etree对象中的xpath方法结合xpath表达式实现标签的定位和内容的捕获</li></ol><h3 id="环境安装">环境安装</h3><ol><li>安装一个解析器：pip install lxml</li></ol><h3 id="实现过程">实现过程</h3><h4 id="实例化一个etree对象-from-lxml-import-etree">实例化一个etree对象(from lxml import etree)</h4><ol><li><p>将本地的html文档中的源码数据加载到etree对象中：</p><p>etree.parse(filePath)</p></li><li><p>或将从互联网上获取的源码数据加载到该对象中（也可以加载xml）：</p><p>etree.HTML(‘page_text’)</p></li><li><p>xpath(‘<strong>xpath表达式</strong>’)获取相关的标签定位和内容捕获</p><ul><li><p><strong>xpath表达式：</strong></p><ul><li><p>/：表达的是根节点开始定位，的表达式</p></li><li><p>//：表达的是从任意的位置定位到某个特定的标签或者是表示从多个层级下来定位到某个标签</p></li><li><p>属性定位：//div[@class=“song”]//</p></li><li><p>索引定位：//div[@class=“song”]/p[3]  <strong>索引是从1开始的</strong></p></li><li><p>取文本：//div[@class=“song”]/li**/text()**，获取直系文本内容</p><p>​                //div[@class=“song”]/li**//text()**，获取该标签下所有的文本内容(两条斜杠)</p></li><li><p>取属性：//div[@class=“tang”]/img/<strong>@src</strong></p></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-3. 网络请求模块</title>
      <link href="/2023/06/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-3.%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/06/03/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-3.%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1>网络请求模块</h1><h2 id="前言">前言</h2><p>Python中用于网络请求的模块有urllib和request，而request简洁、效率高，完全代替urllib</p><p>request模块作用：模拟浏览器发送请求</p><h2 id="使用request">使用request</h2><p>浏览器发送请求的过程（也是request模块的编码流程）</p><ol><li><p>指定url</p></li><li><p>发起请求</p><p>GET或POST请求</p><ol><li>get请求，参数：url、params(请求参数)、headers(请求头，UA伪装)</li><li>post请求，参数：url、data(请求数据/参数)、headers(UA伪装)</li></ol></li><li><p>获取响应数据</p></li><li><p>持久化存储需要的数据</p></li></ol><h2 id="爬取特定数据的方法">爬取特定数据的方法</h2><h4 id="数据解析">数据解析</h4><h4 id="阿贾克斯请求（AJAX-request）">阿贾克斯请求（AJAX request）</h4><p>阿贾克斯请求（Ajax request）是一种通过JavaScript和XMLHttpRequest对象发送HTTP请求的技术。它允许在不刷新整个页面的情况下，与服务器进行异步通信并获取数据。通过发送和接收数据，可以实现动态更新网页内容，提高用户体验。</p><p>简单来说：当发生页面信息变动时进行局部刷新页面。</p><h2 id="反爬手段">反爬手段</h2><h3 id="UA伪装">UA伪装</h3><p>User-Agent请求载体的身份标识</p><p>UA检测：</p><p>门户网站的服务器会检测对应的请求载体身份标识，如果检测搭到请求载体为某一款浏览器，那么说明这是一个正常的请求。</p><p>但是，如果检测到请求的载体不是属于某个浏览器，则表示这不是一个正常的请求（爬虫），门户网站会拒绝访问。</p><p><strong>为了不被服务器拒绝，所以我们在写爬虫时要把爬虫伪装成浏览器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;...&#x27;</span>（用抓包工具或者去浏览器开发者选项中找对应的UA放进来）</span><br><span class="line">&#125;</span><br><span class="line">response = request(url=url,params=param,headers=headers)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
            <tag> 计算机网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-2. 计算机网络基础</title>
      <link href="/2023/06/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-2.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/06/02/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-2.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络基础</h1><h2 id="IP地址">IP地址</h2><p>网络连接的核心——TCP/IP体系结构（IP和端口）</p><p><strong>IP地址是电子设备（计算机）在互联网上的唯一标识</strong></p><p>IP地址的功能是在互联网中寻找电脑</p><h3 id="DNS协议">DNS协议</h3><p>域名解析协议，把我们的IP地址转换成域名的协议，便于网址的记忆与访问</p><h3 id="内网（局域网）IP">内网（局域网）IP</h3><ul><li>内网IP：路由以内的网络，可以连接互联网，但是互联网无法直接连接内网（需要端口映射）</li><li>优点：安全、解决IPv4地址耗尽的问题</li><li>缺点：互联网无法直接连接到内网，比如在自己电脑上搭建一个网站，只有和你使用同一个路由器网络的人才能访问（在同一内网）</li></ul><h3 id="公网（互联网）IP">公网（互联网）IP</h3><ul><li>互联网IP地址</li><li>优点：直接和互联网资源互联，日常应用比如摄像头远程监控、电脑远程开机、NAS等等</li><li>缺点：安全性较低，IPv4网址资源耗尽</li></ul><p><strong>IP地址就像家庭地址一样，公网IP是小区地址，小区中又有很多住户，内网IP就是你家具体的门牌号</strong></p><h2 id="端口（TCP逻辑端口）">端口（TCP逻辑端口）</h2><ul><li>端口是应用程序（服务）在计算机中的唯一标识</li></ul><p>如何查看自己开启了哪些端口？</p><ul><li><p>linux端</p><p>netstat -anltup</p></li><li><p>windows端</p><p>netstat -ano</p></li></ul><h2 id="HTTP（Hyper-Text-Transfer-Protocol）超文本传输协议">HTTP（Hyper Text Transfer Protocol）超文本传输协议</h2><p>浏览器与服务器的数据交互协议http协议：</p><ul><li>浏览器请求服务器数据   request</li><li>服务器响应客户端请求   response</li></ul><p>http协议的特点：</p><ul><li>基于tcp/ip协议</li><li><strong>默认端口号：80</strong></li><li>请求和响应一一对应</li><li>每次请求相互独立，是无状态协议</li></ul><p>https协议，s是security或者ssl，就是更安全的超文本传输协议</p><p><strong>HTTP协议把一条信息分为三大块内容，无论是请求还是响应都分为三块内容。</strong></p><p><strong>请求：</strong></p><ul><li>请求行  ——&gt;   请求方式（get/post）   请求url地址   协议</li><li>请求头  ——&gt;   放依稀额服务器要使用的附加信息</li><li>请求体  ——&gt;   一般放请求参数</li></ul><p><strong>响应：</strong></p><ul><li>状态行  ——&gt;  协议、状态码</li><li>响应头  ——&gt;  放一些客户端要使用的一些附加信息（比如密钥ssl等）</li><li>响应体  ——&gt;  服务器返回给客户端的数据内容（html, json）</li></ul><h3 id="请求消息——request">请求消息——request</h3><p>http协议中请求消息的格式</p><ol><li><p>请求行</p><p><strong>请求方式</strong>+请求url+协议以及版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET   /pages/jointLaboratory.jsp   HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><ul><li><p>请求方式常见的有八种，get和post最为常用</p><ol><li>get请求，请求参数存放在url地址中，url有长度限制，只能传输字符数据</li><li>post请求，请求参数在请求体中，无大小限制，post请求可以传输字符或者字节数据</li></ol></li><li><p>get请求和post请求的转换</p><p><strong>get请求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902040614277.png" alt="image-20230902040614277"></p><p><strong>post请求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902040735591.png" alt="image-20230902040735591"></p><p><strong>Content-Type:服务器响应客户端的数据类型</strong></p></li></ul></li><li><p>请求头</p><ul><li><p>Host：请求主机域名/IP地址</p><p>例如：Host:www.baidu.com</p></li><li><p><strong>User-Agent</strong>：请求载体的身份标识，告诉浏览器的版本信息，供服务器解决浏览器兼容问题</p></li><li><p>Accept：传输文件类型</p></li><li><p><strong>Referer</strong>：告诉服务器从哪里来（网站服务器会检查访问者是从哪里来，决定是否允许你访问），也叫防盗链</p></li><li><p><strong>Cookie</strong>：存储在用户本地终端上的数据（客户端访问数据的“令牌”），用户登录信息、反爬token</p></li></ul><h3 id="响应消息——response">响应消息——response</h3><ol><li><p>响应行</p><p>协议以及版本+响应状态码+状态码描述</p><p>HTTP/1.1   200   OK</p><p><em>状态码200表示是正常访问网站。如果正常访问网站，状态码就是200。常见的错误状态码以及意义“”</em></p></li><li><p>响应头</p><ul><li>Server</li><li>Data</li><li>Content-Security-Policy</li></ul><p>…</p></li><li><p>响应空行</p></li><li><p>响应体</p></li></ol><h3 id="响应状态码">响应状态码</h3><p>服务器告诉浏览器本次请求和响应状态</p><p>1xx：服务器接受浏览器消息未完成，发送1xx状态码</p><p>2xx：成功，200</p><p>3xx：重定向，302，304（访问缓存）</p><p>4xx：客户端错误、404（服务器没有找到对应资源）、405（请求方法不被允许）</p><p>5xx：500、501、502、503（服务器内部出现异常）</p><h3 id="加密方式">加密方式</h3><ol><li><p>对称密钥加密</p><p>客户端发送信息到服务器会先对数据进行加密，然后把生成的密文和密钥传输给客户端</p><p>弊端：容易被拦截而导致信息泄露</p></li><li><p>非对称密钥加密</p><p>服务器端设定一种加密方式，将加密方式发送给客户端。客户端拿到加密方式之后，就把数据进行加密，加密后只把加密得到的密文发送给服务器请求数据。（不会发送秘钥）</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902043609871.png" alt="image-20230902043609871"></p><p>优点：不会把密钥和密文同时暴露</p><p>​公钥被拦截后可能会被篡改公钥加密方式然后又发送给客户端（无法保证客户端拿到的公钥是服务器创建的公钥）</p></li><li><p>证书密钥加密（https协议）</p><p>引入第三方证书认证机构；服务器创建公钥加密方式，然后发送给第三方证书认证机构，认证机构认证成功后对公钥进行数字签名（防伪），然后再发给客户端，很大程度上确保了公钥的源头正确性</p><p><img src="https://cdn.jsdelivr.net/gh/ICserD/blog_img@master/img/image-20230902043940457.png" alt="image-20230902043940457"></p></li></ol></li></ol><h2 id="web请求过程剖析">web请求过程剖析</h2><p>目前网站的web请求分为两种方式，一种是基于服务器渲染的数据请求，一种是基于客户端渲染的数据请求，不同的请求方式影响着我们抓包的url地址。</p><h3 id="基于服务器渲染的数据请求流程">基于服务器渲染的数据请求流程</h3><ol><li>客户端向服务器端发送请求（带参数，比如搜索：“周杰伦”）</li><li>服务器收到带参数的请求信息，在服务器内进行数据检索和处理，然后将数据和html整合起来，返回给客户端一个已经渲染好数据的html</li></ol><h3 id="基于客户端渲染的数据请求流程（例如阿贾克斯（XHR）请求）">基于客户端渲染的数据请求流程（例如阿贾克斯（XHR）请求）</h3><ol><li>客户端向服务器发送请求</li><li>服务器进行数据处理，返回给客户端一个网页框架，但不包含相关的数据信息</li><li>客户端收到网页框架后，在客户端进行渲染，渲染过程中执行html中的js程序，再次对服务器发送请求</li><li>服务器收到第二次请求，然后进行数据处理，将数据返回给客户端（这时返回的不是html网页，而是具体的整理好的数据，反而对于爬虫来说，这些数据正是我们需要的）</li><li>客户端根据收到的数据以及网页框架进行二次渲染，形成用户所需要浏览的网站页面</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
            <tag> 计算机网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据挖掘】爬虫系统学习-1. 前言</title>
      <link href="/2023/06/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-1.%20%E5%89%8D%E8%A8%80/"/>
      <url>/2023/06/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/%E3%80%90%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E3%80%91%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-1.%20%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1>爬虫系统学习</h1><h2 id="前言">前言</h2><p>爬虫是python的重要的实战应用之一，是一门获取信息的重要技术手段。</p><p>技术本身无罪，但爬虫如果影响到网站正常使用或者爬取涉及到商业机密等法律保护的数据时，可能会有犯罪风险。</p><h2 id="如何规避犯罪风险">如何规避犯罪风险</h2><ol><li><p>robots.txt协议</p><p>每个网站都有robots.txt协议，上面规定了哪些信息可以爬取，那些信息不可被爬取。</p><p>尽量避免爬取不被允许的信息。如果不慎爬取到了敏感信息，可以及时停止爬取和传播。</p></li></ol><h2 id="注意事项">注意事项</h2><ol><li>记得关文件</li><li>记得关resp, resp.close();</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据科学 </category>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 爬虫设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
